head	1.408;
access;
symbols;
locks
	nakashim:1.408; strict;
comment	@ * @;


1.408
date	2022.10.28.09.13.28;	author nakashim;	state Exp;
branches;
next	1.407;

1.407
date	2022.10.28.04.41.47;	author nakashim;	state Exp;
branches;
next	1.406;

1.406
date	2022.10.28.04.19.31;	author nakashim;	state Exp;
branches;
next	1.405;

1.405
date	2022.10.27.09.56.34;	author nakashim;	state Exp;
branches;
next	1.404;

1.404
date	2022.10.11.08.06.49;	author nakashim;	state Exp;
branches;
next	1.403;

1.403
date	2022.09.08.09.25.32;	author nakashim;	state Exp;
branches;
next	1.402;

1.402
date	2022.04.18.23.38.17;	author nakashim;	state Exp;
branches;
next	1.401;

1.401
date	2022.03.04.04.14.29;	author nakashim;	state Exp;
branches;
next	1.400;

1.400
date	2022.03.04.03.03.33;	author nakashim;	state Exp;
branches;
next	1.399;

1.399
date	2022.03.04.02.10.32;	author nakashim;	state Exp;
branches;
next	1.398;

1.398
date	2022.03.04.02.09.24;	author nakashim;	state Exp;
branches;
next	1.397;

1.397
date	2022.03.03.14.59.26;	author nakashim;	state Exp;
branches;
next	1.396;

1.396
date	2022.02.17.11.26.40;	author nakashim;	state Exp;
branches;
next	1.395;

1.395
date	2021.12.21.03.57.50;	author nakashim;	state Exp;
branches;
next	1.394;

1.394
date	2021.12.08.00.59.26;	author nakashim;	state Exp;
branches;
next	1.393;

1.393
date	2021.10.24.13.29.32;	author nakashim;	state Exp;
branches;
next	1.392;

1.392
date	2021.09.21.07.42.49;	author nakashim;	state Exp;
branches;
next	1.391;

1.391
date	2021.09.19.00.04.15;	author nakashim;	state Exp;
branches;
next	1.390;

1.390
date	2021.07.18.23.14.29;	author nakashim;	state Exp;
branches;
next	1.389;

1.389
date	2021.07.18.13.20.16;	author nakashim;	state Exp;
branches;
next	1.388;

1.388
date	2021.06.21.09.25.08;	author nakashim;	state Exp;
branches;
next	1.387;

1.387
date	2021.06.18.02.52.03;	author nakashim;	state Exp;
branches;
next	1.386;

1.386
date	2021.06.16.11.41.36;	author nakashim;	state Exp;
branches;
next	1.385;

1.385
date	2021.06.15.09.30.24;	author nakashim;	state Exp;
branches;
next	1.384;

1.384
date	2021.06.13.11.02.10;	author nakashim;	state Exp;
branches;
next	1.383;

1.383
date	2021.03.02.09.19.44;	author nakashim;	state Exp;
branches;
next	1.382;

1.382
date	2021.02.28.06.00.46;	author nakashim;	state Exp;
branches;
next	1.381;

1.381
date	2020.11.29.13.12.55;	author nakashim;	state Exp;
branches;
next	1.380;

1.380
date	2020.11.29.07.35.53;	author nakashim;	state Exp;
branches;
next	1.379;

1.379
date	2020.11.25.06.49.46;	author nakashim;	state Exp;
branches;
next	1.378;

1.378
date	2020.11.07.13.04.12;	author nakashim;	state Exp;
branches;
next	1.377;

1.377
date	2020.05.05.13.55.08;	author nakashim;	state Exp;
branches;
next	1.376;

1.376
date	2020.04.26.02.41.53;	author nakashim;	state Exp;
branches;
next	1.375;

1.375
date	2019.08.29.03.15.14;	author nakashim;	state Exp;
branches;
next	1.374;

1.374
date	2019.08.11.13.38.35;	author nakashim;	state Exp;
branches;
next	1.373;

1.373
date	2019.08.02.14.25.38;	author nakashim;	state Exp;
branches;
next	1.372;

1.372
date	2019.03.28.08.52.55;	author nakashim;	state Exp;
branches;
next	1.371;

1.371
date	2019.03.02.01.53.09;	author nakashim;	state Exp;
branches;
next	1.370;

1.370
date	2019.02.24.14.06.47;	author nakashim;	state Exp;
branches;
next	1.369;

1.369
date	2019.02.24.12.46.57;	author nakashim;	state Exp;
branches;
next	1.368;

1.368
date	2019.02.24.00.04.28;	author nakashim;	state Exp;
branches;
next	1.367;

1.367
date	2018.12.27.22.45.56;	author nakashim;	state Exp;
branches;
next	1.366;

1.366
date	2018.12.26.03.35.46;	author nakashim;	state Exp;
branches;
next	1.365;

1.365
date	2018.12.25.10.58.47;	author nakashim;	state Exp;
branches;
next	1.364;

1.364
date	2018.12.24.14.18.28;	author nakashim;	state Exp;
branches;
next	1.363;

1.363
date	2018.12.24.13.20.44;	author nakashim;	state Exp;
branches;
next	1.362;

1.362
date	2018.12.24.13.09.58;	author nakashim;	state Exp;
branches;
next	1.361;

1.361
date	2018.12.24.10.35.41;	author nakashim;	state Exp;
branches;
next	1.360;

1.360
date	2018.12.24.08.24.58;	author nakashim;	state Exp;
branches;
next	1.359;

1.359
date	2018.12.24.06.20.35;	author nakashim;	state Exp;
branches;
next	1.358;

1.358
date	2018.12.23.13.57.02;	author nakashim;	state Exp;
branches;
next	1.357;

1.357
date	2018.12.23.12.12.02;	author nakashim;	state Exp;
branches;
next	1.356;

1.356
date	2018.12.23.09.53.51;	author nakashim;	state Exp;
branches;
next	1.355;

1.355
date	2018.12.23.03.41.14;	author nakashim;	state Exp;
branches;
next	1.354;

1.354
date	2018.12.23.00.11.30;	author nakashim;	state Exp;
branches;
next	1.353;

1.353
date	2018.12.22.13.54.51;	author nakashim;	state Exp;
branches;
next	1.352;

1.352
date	2018.12.21.11.17.09;	author nakashim;	state Exp;
branches;
next	1.351;

1.351
date	2018.12.21.10.35.05;	author nakashim;	state Exp;
branches;
next	1.350;

1.350
date	2018.12.21.10.07.22;	author nakashim;	state Exp;
branches;
next	1.349;

1.349
date	2018.12.07.02.52.04;	author nakashim;	state Exp;
branches;
next	1.348;

1.348
date	2018.12.02.07.03.41;	author nakashim;	state Exp;
branches;
next	1.347;

1.347
date	2018.12.02.06.38.04;	author nakashim;	state Exp;
branches;
next	1.346;

1.346
date	2018.12.02.02.47.14;	author nakashim;	state Exp;
branches;
next	1.345;

1.345
date	2018.11.23.09.16.44;	author nakashim;	state Exp;
branches;
next	1.344;

1.344
date	2018.11.22.14.53.29;	author nakashim;	state Exp;
branches;
next	1.343;

1.343
date	2018.11.21.06.13.45;	author nakashim;	state Exp;
branches;
next	1.342;

1.342
date	2018.11.20.07.59.09;	author nakashim;	state Exp;
branches;
next	1.341;

1.341
date	2018.11.15.15.22.44;	author nakashim;	state Exp;
branches;
next	1.340;

1.340
date	2018.11.03.13.40.21;	author nakashim;	state Exp;
branches;
next	1.339;

1.339
date	2018.10.23.10.42.49;	author nakashim;	state Exp;
branches;
next	1.338;

1.338
date	2018.10.23.07.08.45;	author nakashim;	state Exp;
branches;
next	1.337;

1.337
date	2018.10.18.12.42.18;	author nakashim;	state Exp;
branches;
next	1.336;

1.336
date	2018.09.18.02.02.52;	author nakashim;	state Exp;
branches;
next	1.335;

1.335
date	2018.09.17.08.24.47;	author nakashim;	state Exp;
branches;
next	1.334;

1.334
date	2018.09.17.05.41.34;	author nakashim;	state Exp;
branches;
next	1.333;

1.333
date	2018.09.17.02.15.11;	author nakashim;	state Exp;
branches;
next	1.332;

1.332
date	2018.09.16.08.58.18;	author nakashim;	state Exp;
branches;
next	1.331;

1.331
date	2018.09.15.23.26.42;	author nakashim;	state Exp;
branches;
next	1.330;

1.330
date	2018.09.15.14.44.46;	author nakashim;	state Exp;
branches;
next	1.329;

1.329
date	2018.09.12.15.25.59;	author nakashim;	state Exp;
branches;
next	1.328;

1.328
date	2018.09.12.08.57.43;	author nakashim;	state Exp;
branches;
next	1.327;

1.327
date	2018.07.29.10.25.56;	author nakashim;	state Exp;
branches;
next	1.326;

1.326
date	2018.07.29.09.44.25;	author nakashim;	state Exp;
branches;
next	1.325;

1.325
date	2018.07.29.09.38.08;	author nakashim;	state Exp;
branches;
next	1.324;

1.324
date	2018.07.29.05.09.14;	author nakashim;	state Exp;
branches;
next	1.323;

1.323
date	2018.07.29.03.02.49;	author nakashim;	state Exp;
branches;
next	1.322;

1.322
date	2018.07.24.14.08.00;	author nakashim;	state Exp;
branches;
next	1.321;

1.321
date	2018.02.16.16.26.03;	author nakashim;	state Exp;
branches;
next	1.320;

1.320
date	2018.02.16.10.48.02;	author nakashim;	state Exp;
branches;
next	1.319;

1.319
date	2018.02.13.01.59.50;	author nakashim;	state Exp;
branches;
next	1.318;

1.318
date	2017.12.24.14.13.32;	author nakashim;	state Exp;
branches;
next	1.317;

1.317
date	2017.12.01.02.44.25;	author nakashim;	state Exp;
branches;
next	1.316;

1.316
date	2017.12.01.02.10.58;	author nakashim;	state Exp;
branches;
next	1.315;

1.315
date	2017.11.28.07.53.57;	author nakashim;	state Exp;
branches;
next	1.314;

1.314
date	2017.09.13.14.33.19;	author nakashim;	state Exp;
branches;
next	1.313;

1.313
date	2017.09.11.15.40.41;	author nakashim;	state Exp;
branches;
next	1.312;

1.312
date	2017.09.11.09.16.03;	author nakashim;	state Exp;
branches;
next	1.311;

1.311
date	2017.09.11.00.01.18;	author nakashim;	state Exp;
branches;
next	1.310;

1.310
date	2017.09.10.14.58.51;	author nakashim;	state Exp;
branches;
next	1.309;

1.309
date	2017.09.10.12.23.41;	author nakashim;	state Exp;
branches;
next	1.308;

1.308
date	2017.09.10.10.33.25;	author nakashim;	state Exp;
branches;
next	1.307;

1.307
date	2017.09.10.08.17.55;	author nakashim;	state Exp;
branches;
next	1.306;

1.306
date	2017.09.10.00.12.07;	author nakashim;	state Exp;
branches;
next	1.305;

1.305
date	2017.09.09.12.11.26;	author nakashim;	state Exp;
branches;
next	1.304;

1.304
date	2017.09.09.11.55.41;	author nakashim;	state Exp;
branches;
next	1.303;

1.303
date	2017.09.09.11.50.41;	author nakashim;	state Exp;
branches;
next	1.302;

1.302
date	2017.09.09.03.11.04;	author nakashim;	state Exp;
branches;
next	1.301;

1.301
date	2017.09.08.14.25.18;	author nakashim;	state Exp;
branches;
next	1.300;

1.300
date	2017.09.08.08.06.57;	author nakashim;	state Exp;
branches;
next	1.299;

1.299
date	2017.09.08.07.43.13;	author nakashim;	state Exp;
branches;
next	1.298;

1.298
date	2017.09.08.03.49.33;	author nakashim;	state Exp;
branches;
next	1.297;

1.297
date	2017.09.07.14.51.30;	author nakashim;	state Exp;
branches;
next	1.296;

1.296
date	2017.09.07.04.18.46;	author nakashim;	state Exp;
branches;
next	1.295;

1.295
date	2017.09.06.09.45.43;	author nakashim;	state Exp;
branches;
next	1.294;

1.294
date	2017.09.05.12.11.25;	author nakashim;	state Exp;
branches;
next	1.293;

1.293
date	2017.09.03.11.47.06;	author nakashim;	state Exp;
branches;
next	1.292;

1.292
date	2017.09.03.05.57.14;	author nakashim;	state Exp;
branches;
next	1.291;

1.291
date	2017.09.02.12.37.46;	author nakashim;	state Exp;
branches;
next	1.290;

1.290
date	2017.09.01.15.45.46;	author nakashim;	state Exp;
branches;
next	1.289;

1.289
date	2017.09.01.14.52.51;	author nakashim;	state Exp;
branches;
next	1.288;

1.288
date	2017.09.01.13.31.52;	author nakashim;	state Exp;
branches;
next	1.287;

1.287
date	2017.09.01.00.02.39;	author nakashim;	state Exp;
branches;
next	1.286;

1.286
date	2017.08.31.12.27.19;	author nakashim;	state Exp;
branches;
next	1.285;

1.285
date	2017.08.31.08.21.09;	author nakashim;	state Exp;
branches;
next	1.284;

1.284
date	2017.08.31.07.37.58;	author nakashim;	state Exp;
branches;
next	1.283;

1.283
date	2017.08.31.05.35.07;	author nakashim;	state Exp;
branches;
next	1.282;

1.282
date	2017.08.30.23.39.45;	author nakashim;	state Exp;
branches;
next	1.281;

1.281
date	2017.08.30.05.34.00;	author nakashim;	state Exp;
branches;
next	1.280;

1.280
date	2017.08.29.12.51.09;	author nakashim;	state Exp;
branches;
next	1.279;

1.279
date	2017.08.29.08.22.49;	author nakashim;	state Exp;
branches;
next	1.278;

1.278
date	2017.08.27.02.39.22;	author nakashim;	state Exp;
branches;
next	1.277;

1.277
date	2017.08.25.08.38.21;	author nakashim;	state Exp;
branches;
next	1.276;

1.276
date	2017.08.25.00.06.02;	author nakashim;	state Exp;
branches;
next	1.275;

1.275
date	2017.08.24.02.30.20;	author nakashim;	state Exp;
branches;
next	1.274;

1.274
date	2017.08.24.00.00.07;	author nakashim;	state Exp;
branches;
next	1.273;

1.273
date	2017.08.23.23.02.51;	author nakashim;	state Exp;
branches;
next	1.272;

1.272
date	2017.08.23.15.27.39;	author nakashim;	state Exp;
branches;
next	1.271;

1.271
date	2017.08.18.12.23.14;	author nakashim;	state Exp;
branches;
next	1.270;

1.270
date	2017.08.17.12.18.45;	author nakashim;	state Exp;
branches;
next	1.269;

1.269
date	2017.08.17.01.30.42;	author nakashim;	state Exp;
branches;
next	1.268;

1.268
date	2017.08.16.15.33.54;	author nakashim;	state Exp;
branches;
next	1.267;

1.267
date	2017.08.16.08.44.11;	author nakashim;	state Exp;
branches;
next	1.266;

1.266
date	2017.08.15.07.12.20;	author nakashim;	state Exp;
branches;
next	1.265;

1.265
date	2017.08.14.13.37.31;	author nakashim;	state Exp;
branches;
next	1.264;

1.264
date	2017.08.14.13.19.29;	author nakashim;	state Exp;
branches;
next	1.263;

1.263
date	2017.08.14.07.55.27;	author nakashim;	state Exp;
branches;
next	1.262;

1.262
date	2017.08.13.13.32.33;	author nakashim;	state Exp;
branches;
next	1.261;

1.261
date	2017.08.13.08.24.57;	author nakashim;	state Exp;
branches;
next	1.260;

1.260
date	2017.08.13.06.34.43;	author nakashim;	state Exp;
branches;
next	1.259;

1.259
date	2017.08.13.06.05.32;	author nakashim;	state Exp;
branches;
next	1.258;

1.258
date	2017.08.12.08.53.30;	author nakashim;	state Exp;
branches;
next	1.257;

1.257
date	2017.08.12.02.24.57;	author nakashim;	state Exp;
branches;
next	1.256;

1.256
date	2017.08.09.14.02.37;	author nakashim;	state Exp;
branches;
next	1.255;

1.255
date	2017.08.08.22.39.25;	author nakashim;	state Exp;
branches;
next	1.254;

1.254
date	2017.08.04.09.30.02;	author nakashim;	state Exp;
branches;
next	1.253;

1.253
date	2017.08.03.07.06.38;	author nakashim;	state Exp;
branches;
next	1.252;

1.252
date	2017.07.30.06.25.34;	author nakashim;	state Exp;
branches;
next	1.251;

1.251
date	2017.07.30.06.21.58;	author nakashim;	state Exp;
branches;
next	1.250;

1.250
date	2017.07.26.01.28.30;	author nakashim;	state Exp;
branches;
next	1.249;

1.249
date	2017.07.25.07.19.12;	author nakashim;	state Exp;
branches;
next	1.248;

1.248
date	2017.07.24.05.00.36;	author nakashim;	state Exp;
branches;
next	1.247;

1.247
date	2017.07.17.11.44.50;	author nakashim;	state Exp;
branches;
next	1.246;

1.246
date	2017.07.16.23.00.03;	author nakashim;	state Exp;
branches;
next	1.245;

1.245
date	2017.07.10.23.52.17;	author nakashim;	state Exp;
branches;
next	1.244;

1.244
date	2017.07.10.10.05.13;	author nakashim;	state Exp;
branches;
next	1.243;

1.243
date	2017.07.09.12.49.42;	author nakashim;	state Exp;
branches;
next	1.242;

1.242
date	2017.07.08.14.13.46;	author nakashim;	state Exp;
branches;
next	1.241;

1.241
date	2017.07.08.11.43.28;	author nakashim;	state Exp;
branches;
next	1.240;

1.240
date	2017.07.08.05.07.07;	author nakashim;	state Exp;
branches;
next	1.239;

1.239
date	2017.07.08.03.36.55;	author nakashim;	state Exp;
branches;
next	1.238;

1.238
date	2017.07.07.14.10.41;	author nakashim;	state Exp;
branches;
next	1.237;

1.237
date	2017.07.07.09.54.39;	author nakashim;	state Exp;
branches;
next	1.236;

1.236
date	2017.07.07.01.06.37;	author nakashim;	state Exp;
branches;
next	1.235;

1.235
date	2017.07.06.22.56.32;	author nakashim;	state Exp;
branches;
next	1.234;

1.234
date	2017.07.06.00.11.20;	author nakashim;	state Exp;
branches;
next	1.233;

1.233
date	2017.07.05.23.19.13;	author nakashim;	state Exp;
branches;
next	1.232;

1.232
date	2017.07.05.14.28.54;	author nakashim;	state Exp;
branches;
next	1.231;

1.231
date	2017.07.05.02.36.45;	author nakashim;	state Exp;
branches;
next	1.230;

1.230
date	2017.07.04.15.41.06;	author nakashim;	state Exp;
branches;
next	1.229;

1.229
date	2017.07.04.07.56.04;	author nakashim;	state Exp;
branches;
next	1.228;

1.228
date	2017.07.02.15.08.02;	author nakashim;	state Exp;
branches;
next	1.227;

1.227
date	2017.06.30.13.32.19;	author nakashim;	state Exp;
branches;
next	1.226;

1.226
date	2017.06.29.10.35.27;	author nakashim;	state Exp;
branches;
next	1.225;

1.225
date	2017.06.26.05.00.40;	author nakashim;	state Exp;
branches;
next	1.224;

1.224
date	2017.06.26.05.00.14;	author nakashim;	state Exp;
branches;
next	1.223;

1.223
date	2017.06.19.09.25.50;	author nakashim;	state Exp;
branches;
next	1.222;

1.222
date	2017.06.18.09.52.25;	author nakashim;	state Exp;
branches;
next	1.221;

1.221
date	2017.06.18.00.17.24;	author nakashim;	state Exp;
branches;
next	1.220;

1.220
date	2017.06.14.23.49.02;	author nakashim;	state Exp;
branches;
next	1.219;

1.219
date	2017.06.10.12.51.55;	author nakashim;	state Exp;
branches;
next	1.218;

1.218
date	2017.06.05.15.07.59;	author nakashim;	state Exp;
branches;
next	1.217;

1.217
date	2017.04.28.04.09.45;	author nakashim;	state Exp;
branches;
next	1.216;

1.216
date	2017.04.21.03.29.27;	author nakashim;	state Exp;
branches;
next	1.215;

1.215
date	2017.03.09.10.30.22;	author nakashim;	state Exp;
branches;
next	1.214;

1.214
date	2017.02.28.07.54.27;	author nakashim;	state Exp;
branches;
next	1.213;

1.213
date	2017.02.24.13.50.25;	author nakashim;	state Exp;
branches;
next	1.212;

1.212
date	2017.02.24.08.18.55;	author nakashim;	state Exp;
branches;
next	1.211;

1.211
date	2017.02.21.07.58.03;	author nakashim;	state Exp;
branches;
next	1.210;

1.210
date	2017.02.14.03.56.45;	author nakashim;	state Exp;
branches;
next	1.209;

1.209
date	2017.02.13.02.27.21;	author nakashim;	state Exp;
branches;
next	1.208;

1.208
date	2017.02.12.23.18.31;	author nakashim;	state Exp;
branches;
next	1.207;

1.207
date	2017.02.12.22.07.40;	author nakashim;	state Exp;
branches;
next	1.206;

1.206
date	2017.02.12.22.07.13;	author nakashim;	state Exp;
branches;
next	1.205;

1.205
date	2017.02.12.08.41.49;	author nakashim;	state Exp;
branches;
next	1.204;

1.204
date	2017.02.11.14.58.39;	author nakashim;	state Exp;
branches;
next	1.203;

1.203
date	2017.02.11.09.04.33;	author nakashim;	state Exp;
branches;
next	1.202;

1.202
date	2017.02.08.05.39.39;	author nakashim;	state Exp;
branches;
next	1.201;

1.201
date	2017.02.04.16.06.34;	author nakashim;	state Exp;
branches;
next	1.200;

1.200
date	2017.02.04.15.56.30;	author nakashim;	state Exp;
branches;
next	1.199;

1.199
date	2017.02.04.07.34.14;	author nakashim;	state Exp;
branches;
next	1.198;

1.198
date	2017.02.04.05.00.41;	author nakashim;	state Exp;
branches;
next	1.197;

1.197
date	2017.02.02.22.45.49;	author nakashim;	state Exp;
branches;
next	1.196;

1.196
date	2017.02.02.03.16.43;	author nakashim;	state Exp;
branches;
next	1.195;

1.195
date	2017.02.01.23.24.46;	author nakashim;	state Exp;
branches;
next	1.194;

1.194
date	2017.02.01.23.16.07;	author nakashim;	state Exp;
branches;
next	1.193;

1.193
date	2017.02.01.12.13.53;	author nakashim;	state Exp;
branches;
next	1.192;

1.192
date	2017.02.01.10.23.02;	author nakashim;	state Exp;
branches;
next	1.191;

1.191
date	2017.02.01.09.38.15;	author nakashim;	state Exp;
branches;
next	1.190;

1.190
date	2017.01.31.23.15.54;	author nakashim;	state Exp;
branches;
next	1.189;

1.189
date	2017.01.31.13.26.01;	author nakashim;	state Exp;
branches;
next	1.188;

1.188
date	2017.01.31.12.10.58;	author nakashim;	state Exp;
branches;
next	1.187;

1.187
date	2017.01.31.10.09.52;	author nakashim;	state Exp;
branches;
next	1.186;

1.186
date	2017.01.31.04.35.43;	author nakashim;	state Exp;
branches;
next	1.185;

1.185
date	2017.01.30.23.44.08;	author nakashim;	state Exp;
branches;
next	1.184;

1.184
date	2017.01.30.05.35.28;	author nakashim;	state Exp;
branches;
next	1.183;

1.183
date	2017.01.30.01.42.30;	author nakashim;	state Exp;
branches;
next	1.182;

1.182
date	2017.01.29.16.24.11;	author nakashim;	state Exp;
branches;
next	1.181;

1.181
date	2017.01.29.14.23.53;	author nakashim;	state Exp;
branches;
next	1.180;

1.180
date	2017.01.29.14.00.23;	author nakashim;	state Exp;
branches;
next	1.179;

1.179
date	2017.01.29.11.50.50;	author nakashim;	state Exp;
branches;
next	1.178;

1.178
date	2017.01.28.02.00.22;	author nakashim;	state Exp;
branches;
next	1.177;

1.177
date	2017.01.26.23.10.37;	author nakashim;	state Exp;
branches;
next	1.176;

1.176
date	2017.01.26.22.47.46;	author nakashim;	state Exp;
branches;
next	1.175;

1.175
date	2017.01.26.07.49.58;	author nakashim;	state Exp;
branches;
next	1.174;

1.174
date	2017.01.26.05.48.35;	author nakashim;	state Exp;
branches;
next	1.173;

1.173
date	2017.01.25.23.00.29;	author nakashim;	state Exp;
branches;
next	1.172;

1.172
date	2017.01.25.15.07.58;	author nakashim;	state Exp;
branches;
next	1.171;

1.171
date	2017.01.24.08.44.44;	author nakashim;	state Exp;
branches;
next	1.170;

1.170
date	2017.01.23.21.43.13;	author nakashim;	state Exp;
branches;
next	1.169;

1.169
date	2017.01.23.06.57.35;	author nakashim;	state Exp;
branches;
next	1.168;

1.168
date	2017.01.23.01.34.57;	author nakashim;	state Exp;
branches;
next	1.167;

1.167
date	2017.01.22.12.40.29;	author nakashim;	state Exp;
branches;
next	1.166;

1.166
date	2017.01.22.11.25.43;	author nakashim;	state Exp;
branches;
next	1.165;

1.165
date	2017.01.22.09.30.22;	author nakashim;	state Exp;
branches;
next	1.164;

1.164
date	2017.01.22.08.11.07;	author nakashim;	state Exp;
branches;
next	1.163;

1.163
date	2017.01.22.07.09.59;	author nakashim;	state Exp;
branches;
next	1.162;

1.162
date	2017.01.22.06.18.36;	author nakashim;	state Exp;
branches;
next	1.161;

1.161
date	2017.01.22.02.34.45;	author nakashim;	state Exp;
branches;
next	1.160;

1.160
date	2017.01.21.13.55.14;	author nakashim;	state Exp;
branches;
next	1.159;

1.159
date	2017.01.21.13.49.04;	author nakashim;	state Exp;
branches;
next	1.158;

1.158
date	2017.01.21.09.56.16;	author nakashim;	state Exp;
branches;
next	1.157;

1.157
date	2017.01.21.09.53.09;	author nakashim;	state Exp;
branches;
next	1.156;

1.156
date	2017.01.21.09.30.09;	author nakashim;	state Exp;
branches;
next	1.155;

1.155
date	2017.01.21.06.24.51;	author nakashim;	state Exp;
branches;
next	1.154;

1.154
date	2017.01.20.04.32.03;	author nakashim;	state Exp;
branches;
next	1.153;

1.153
date	2017.01.19.15.50.07;	author nakashim;	state Exp;
branches;
next	1.152;

1.152
date	2017.01.19.05.06.52;	author nakashim;	state Exp;
branches;
next	1.151;

1.151
date	2017.01.07.02.53.39;	author nakashim;	state Exp;
branches;
next	1.150;

1.150
date	2016.12.26.13.54.57;	author nakashim;	state Exp;
branches;
next	1.149;

1.149
date	2016.12.26.10.44.19;	author nakashim;	state Exp;
branches;
next	1.148;

1.148
date	2016.12.25.06.18.10;	author nakashim;	state Exp;
branches;
next	1.147;

1.147
date	2016.12.25.06.17.26;	author nakashim;	state Exp;
branches;
next	1.146;

1.146
date	2016.12.23.08.02.35;	author nakashim;	state Exp;
branches;
next	1.145;

1.145
date	2016.12.22.09.47.51;	author nakashim;	state Exp;
branches;
next	1.144;

1.144
date	2016.12.21.03.12.42;	author nakashim;	state Exp;
branches;
next	1.143;

1.143
date	2016.12.21.02.49.30;	author nakashim;	state Exp;
branches;
next	1.142;

1.142
date	2016.12.21.00.09.13;	author nakashim;	state Exp;
branches;
next	1.141;

1.141
date	2016.12.18.21.28.13;	author nakashim;	state Exp;
branches;
next	1.140;

1.140
date	2016.12.18.12.14.22;	author nakashim;	state Exp;
branches;
next	1.139;

1.139
date	2016.12.18.07.41.16;	author nakashim;	state Exp;
branches;
next	1.138;

1.138
date	2016.12.17.02.38.42;	author nakashim;	state Exp;
branches;
next	1.137;

1.137
date	2016.12.16.03.18.07;	author nakashim;	state Exp;
branches;
next	1.136;

1.136
date	2016.12.15.01.51.56;	author nakashim;	state Exp;
branches;
next	1.135;

1.135
date	2016.12.11.00.43.07;	author nakashim;	state Exp;
branches;
next	1.134;

1.134
date	2016.12.10.10.20.49;	author nakashim;	state Exp;
branches;
next	1.133;

1.133
date	2016.12.10.08.49.40;	author nakashim;	state Exp;
branches;
next	1.132;

1.132
date	2016.12.08.13.47.44;	author nakashim;	state Exp;
branches;
next	1.131;

1.131
date	2016.11.17.04.02.35;	author nakashim;	state Exp;
branches;
next	1.130;

1.130
date	2016.11.15.15.51.44;	author nakashim;	state Exp;
branches;
next	1.129;

1.129
date	2016.11.15.12.57.23;	author nakashim;	state Exp;
branches;
next	1.128;

1.128
date	2016.11.10.23.49.02;	author nakashim;	state Exp;
branches;
next	1.127;

1.127
date	2016.11.10.16.02.10;	author nakashim;	state Exp;
branches;
next	1.126;

1.126
date	2016.11.10.08.07.01;	author nakashim;	state Exp;
branches;
next	1.125;

1.125
date	2016.11.10.04.37.52;	author nakashim;	state Exp;
branches;
next	1.124;

1.124
date	2016.11.09.09.41.29;	author nakashim;	state Exp;
branches;
next	1.123;

1.123
date	2016.11.03.14.51.09;	author nakashim;	state Exp;
branches;
next	1.122;

1.122
date	2016.11.01.04.58.57;	author nakashim;	state Exp;
branches;
next	1.121;

1.121
date	2016.10.23.09.13.39;	author nakashim;	state Exp;
branches;
next	1.120;

1.120
date	2016.08.24.13.57.19;	author nakashim;	state Exp;
branches;
next	1.119;

1.119
date	2016.08.16.03.09.22;	author nakashim;	state Exp;
branches;
next	1.118;

1.118
date	2016.08.04.15.36.00;	author nakashim;	state Exp;
branches;
next	1.117;

1.117
date	2016.07.28.23.59.50;	author nakashim;	state Exp;
branches;
next	1.116;

1.116
date	2016.07.28.06.40.11;	author nakashim;	state Exp;
branches;
next	1.115;

1.115
date	2016.07.01.08.03.37;	author nakashim;	state Exp;
branches;
next	1.114;

1.114
date	2016.06.21.10.19.21;	author nakashim;	state Exp;
branches;
next	1.113;

1.113
date	2016.06.19.09.33.39;	author nakashim;	state Exp;
branches;
next	1.112;

1.112
date	2016.06.02.06.44.21;	author nakashim;	state Exp;
branches;
next	1.111;

1.111
date	2016.06.01.02.19.47;	author nakashim;	state Exp;
branches;
next	1.110;

1.110
date	2016.05.21.09.51.13;	author nakashim;	state Exp;
branches;
next	1.109;

1.109
date	2016.05.19.08.21.08;	author nakashim;	state Exp;
branches;
next	1.108;

1.108
date	2016.05.19.06.18.57;	author nakashim;	state Exp;
branches;
next	1.107;

1.107
date	2016.05.18.23.59.16;	author nakashim;	state Exp;
branches;
next	1.106;

1.106
date	2016.05.16.05.18.06;	author nakashim;	state Exp;
branches;
next	1.105;

1.105
date	2016.05.16.03.32.15;	author nakashim;	state Exp;
branches;
next	1.104;

1.104
date	2016.05.15.15.44.19;	author nakashim;	state Exp;
branches;
next	1.103;

1.103
date	2016.05.15.11.31.18;	author nakashim;	state Exp;
branches;
next	1.102;

1.102
date	2016.05.15.10.13.33;	author nakashim;	state Exp;
branches;
next	1.101;

1.101
date	2016.05.15.07.02.27;	author nakashim;	state Exp;
branches;
next	1.100;

1.100
date	2016.05.14.05.02.19;	author nakashim;	state Exp;
branches;
next	1.99;

1.99
date	2016.05.13.23.47.44;	author nakashim;	state Exp;
branches;
next	1.98;

1.98
date	2016.05.10.23.15.28;	author nakashim;	state Exp;
branches;
next	1.97;

1.97
date	2016.05.08.05.30.40;	author nakashim;	state Exp;
branches;
next	1.96;

1.96
date	2016.05.07.13.52.53;	author nakashim;	state Exp;
branches;
next	1.95;

1.95
date	2016.05.07.11.31.57;	author nakashim;	state Exp;
branches;
next	1.94;

1.94
date	2016.05.07.11.26.09;	author nakashim;	state Exp;
branches;
next	1.93;

1.93
date	2016.05.03.05.39.54;	author nakashim;	state Exp;
branches;
next	1.92;

1.92
date	2016.05.01.23.03.23;	author nakashim;	state Exp;
branches;
next	1.91;

1.91
date	2016.05.01.16.01.08;	author nakashim;	state Exp;
branches;
next	1.90;

1.90
date	2016.05.01.15.01.23;	author nakashim;	state Exp;
branches;
next	1.89;

1.89
date	2016.05.01.13.52.28;	author nakashim;	state Exp;
branches;
next	1.88;

1.88
date	2016.05.01.13.17.23;	author nakashim;	state Exp;
branches;
next	1.87;

1.87
date	2016.05.01.12.20.44;	author nakashim;	state Exp;
branches;
next	1.86;

1.86
date	2016.05.01.09.52.28;	author nakashim;	state Exp;
branches;
next	1.85;

1.85
date	2016.05.01.07.56.28;	author nakashim;	state Exp;
branches;
next	1.84;

1.84
date	2016.04.30.00.20.19;	author nakashim;	state Exp;
branches;
next	1.83;

1.83
date	2016.04.29.11.52.18;	author nakashim;	state Exp;
branches;
next	1.82;

1.82
date	2016.04.29.11.48.27;	author nakashim;	state Exp;
branches;
next	1.81;

1.81
date	2016.04.29.10.10.35;	author nakashim;	state Exp;
branches;
next	1.80;

1.80
date	2016.04.29.10.08.49;	author nakashim;	state Exp;
branches;
next	1.79;

1.79
date	2016.04.29.09.48.30;	author nakashim;	state Exp;
branches;
next	1.78;

1.78
date	2016.04.29.08.48.36;	author nakashim;	state Exp;
branches;
next	1.77;

1.77
date	2016.04.28.23.49.32;	author nakashim;	state Exp;
branches;
next	1.76;

1.76
date	2016.04.28.23.43.47;	author nakashim;	state Exp;
branches;
next	1.75;

1.75
date	2016.04.28.23.28.05;	author nakashim;	state Exp;
branches;
next	1.74;

1.74
date	2016.04.28.15.59.21;	author nakashim;	state Exp;
branches;
next	1.73;

1.73
date	2016.04.28.15.47.29;	author nakashim;	state Exp;
branches;
next	1.72;

1.72
date	2016.04.28.12.58.43;	author nakashim;	state Exp;
branches;
next	1.71;

1.71
date	2016.04.28.00.05.10;	author nakashim;	state Exp;
branches;
next	1.70;

1.70
date	2016.04.27.15.19.05;	author nakashim;	state Exp;
branches;
next	1.69;

1.69
date	2016.04.26.14.18.18;	author nakashim;	state Exp;
branches;
next	1.68;

1.68
date	2016.04.26.12.13.01;	author nakashim;	state Exp;
branches;
next	1.67;

1.67
date	2016.04.26.11.53.21;	author nakashim;	state Exp;
branches;
next	1.66;

1.66
date	2016.04.26.11.20.57;	author nakashim;	state Exp;
branches;
next	1.65;

1.65
date	2016.04.26.09.53.08;	author nakashim;	state Exp;
branches;
next	1.64;

1.64
date	2016.04.26.08.01.34;	author nakashim;	state Exp;
branches;
next	1.63;

1.63
date	2016.04.25.22.54.03;	author nakashim;	state Exp;
branches;
next	1.62;

1.62
date	2016.04.25.13.52.33;	author nakashim;	state Exp;
branches;
next	1.61;

1.61
date	2016.04.24.13.17.02;	author nakashim;	state Exp;
branches;
next	1.60;

1.60
date	2016.04.24.12.20.00;	author nakashim;	state Exp;
branches;
next	1.59;

1.59
date	2016.04.20.23.29.29;	author nakashim;	state Exp;
branches;
next	1.58;

1.58
date	2016.04.20.23.00.24;	author nakashim;	state Exp;
branches;
next	1.57;

1.57
date	2016.04.20.12.05.07;	author nakashim;	state Exp;
branches;
next	1.56;

1.56
date	2016.04.19.23.02.41;	author nakashim;	state Exp;
branches;
next	1.55;

1.55
date	2016.04.19.10.19.32;	author nakashim;	state Exp;
branches;
next	1.54;

1.54
date	2016.04.19.04.38.47;	author nakashim;	state Exp;
branches;
next	1.53;

1.53
date	2016.04.18.13.11.19;	author nakashim;	state Exp;
branches;
next	1.52;

1.52
date	2016.04.17.23.56.19;	author nakashim;	state Exp;
branches;
next	1.51;

1.51
date	2016.04.17.13.55.17;	author nakashim;	state Exp;
branches;
next	1.50;

1.50
date	2016.04.17.00.53.44;	author nakashim;	state Exp;
branches;
next	1.49;

1.49
date	2016.04.15.00.04.25;	author nakashim;	state Exp;
branches;
next	1.48;

1.48
date	2016.04.14.14.36.55;	author nakashim;	state Exp;
branches;
next	1.47;

1.47
date	2016.04.12.01.58.54;	author nakashim;	state Exp;
branches;
next	1.46;

1.46
date	2016.04.11.15.36.07;	author nakashim;	state Exp;
branches;
next	1.45;

1.45
date	2016.04.11.14.32.57;	author nakashim;	state Exp;
branches;
next	1.44;

1.44
date	2016.04.11.14.08.36;	author nakashim;	state Exp;
branches;
next	1.43;

1.43
date	2016.04.11.12.05.21;	author nakashim;	state Exp;
branches;
next	1.42;

1.42
date	2016.04.11.12.00.01;	author nakashim;	state Exp;
branches;
next	1.41;

1.41
date	2016.04.11.08.50.58;	author nakashim;	state Exp;
branches;
next	1.40;

1.40
date	2016.04.11.07.51.41;	author nakashim;	state Exp;
branches;
next	1.39;

1.39
date	2016.04.11.03.46.19;	author nakashim;	state Exp;
branches;
next	1.38;

1.38
date	2016.04.10.14.10.46;	author nakashim;	state Exp;
branches;
next	1.37;

1.37
date	2016.04.10.12.16.15;	author nakashim;	state Exp;
branches;
next	1.36;

1.36
date	2016.04.10.12.02.03;	author nakashim;	state Exp;
branches;
next	1.35;

1.35
date	2016.04.10.04.01.07;	author nakashim;	state Exp;
branches;
next	1.34;

1.34
date	2016.04.08.08.03.13;	author nakashim;	state Exp;
branches;
next	1.33;

1.33
date	2016.04.07.15.00.28;	author nakashim;	state Exp;
branches;
next	1.32;

1.32
date	2016.04.07.09.02.32;	author nakashim;	state Exp;
branches;
next	1.31;

1.31
date	2016.04.07.03.49.56;	author nakashim;	state Exp;
branches;
next	1.30;

1.30
date	2016.04.06.09.49.38;	author nakashim;	state Exp;
branches;
next	1.29;

1.29
date	2016.04.04.08.51.32;	author nakashim;	state Exp;
branches;
next	1.28;

1.28
date	2016.04.03.23.25.35;	author nakashim;	state Exp;
branches;
next	1.27;

1.27
date	2016.04.03.14.43.16;	author nakashim;	state Exp;
branches;
next	1.26;

1.26
date	2016.04.02.14.04.00;	author nakashim;	state Exp;
branches;
next	1.25;

1.25
date	2016.04.02.08.52.36;	author nakashim;	state Exp;
branches;
next	1.24;

1.24
date	2016.03.29.13.20.25;	author nakashim;	state Exp;
branches;
next	1.23;

1.23
date	2016.03.28.15.02.56;	author nakashim;	state Exp;
branches;
next	1.22;

1.22
date	2016.03.27.15.54.31;	author nakashim;	state Exp;
branches;
next	1.21;

1.21
date	2016.03.20.04.16.40;	author nakashim;	state Exp;
branches;
next	1.20;

1.20
date	2016.03.17.10.58.33;	author nakashim;	state Exp;
branches;
next	1.19;

1.19
date	2016.03.15.00.03.11;	author nakashim;	state Exp;
branches;
next	1.18;

1.18
date	2016.03.12.22.53.10;	author nakashim;	state Exp;
branches;
next	1.17;

1.17
date	2016.03.10.00.50.38;	author nakashim;	state Exp;
branches;
next	1.16;

1.16
date	2016.03.09.13.30.16;	author nakashim;	state Exp;
branches;
next	1.15;

1.15
date	2016.03.04.03.31.13;	author nakashim;	state Exp;
branches;
next	1.14;

1.14
date	2016.03.02.15.32.27;	author nakashim;	state Exp;
branches;
next	1.13;

1.13
date	2016.02.28.23.51.58;	author nakashim;	state Exp;
branches;
next	1.12;

1.12
date	2016.02.28.15.07.26;	author nakashim;	state Exp;
branches;
next	1.11;

1.11
date	2016.02.16.14.53.21;	author nakashim;	state Exp;
branches;
next	1.10;

1.10
date	2016.02.16.12.28.11;	author nakashim;	state Exp;
branches;
next	1.9;

1.9
date	2016.02.16.09.49.14;	author nakashim;	state Exp;
branches;
next	1.8;

1.8
date	2016.02.15.14.56.52;	author nakashim;	state Exp;
branches;
next	1.7;

1.7
date	2016.02.08.14.28.27;	author nakashim;	state Exp;
branches;
next	1.6;

1.6
date	2016.02.07.15.36.50;	author nakashim;	state Exp;
branches;
next	1.5;

1.5
date	2016.02.07.14.37.16;	author nakashim;	state Exp;
branches;
next	1.4;

1.4
date	2016.02.07.12.15.17;	author nakashim;	state Exp;
branches;
next	1.3;

1.3
date	2016.02.04.07.53.34;	author nakashim;	state Exp;
branches;
next	1.2;

1.2
date	2016.02.03.10.00.09;	author nakashim;	state Exp;
branches;
next	1.1;

1.1
date	2016.02.02.15.07.18;	author nakashim;	state Exp;
branches;
next	;


desc
@@


1.408
log
@*** empty log message ***
@
text
@
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.407 2022/10/28 04:41:47 nakashim Exp nakashim $";

/* EMAX6 Simulator                     */
/*         Copyright (C) 2012 by NAIST */
/*         Primary writer: Y.Nakashima */
/*                nakashim@@is.naist.jp */

/* emax6.c 2012/9/22 */

#include <stdio.h>
#include "csim.h"
#include "../conv-c2c/emax6.h"
#include "../conv-c2c/emax6lib.c"

/* CGRA hardware */

struct axiif { /* axi status of EMAX6 */
  /* physical interface of AXI/ZYNQ */
  Ull   axi_awaddr            ; /* aligned-address of mm                    v                         */
  Ull   axi_awlen          :16; /* aligned-length  of mm                    v                         */
  Ull   axi_awvalid        : 1; /* axi <- fsm                                                         */
  Ull   axi_awready        : 1; /* axi -> fsm                                                         */
  Ull   axi_wstrb          :32; /* axi byte-enable for 32B                                            */
  Ull   axi_wdata[UNIT_WIDTH] ; /* axi -> write-data                        v                         */
  Ull   axi_wvalid         : 1; /* axi -> fsm write-valid                                             */
  Ull   axi_wlast          : 1; /* axi -> fsm write-last                                              */
  Ull   axi_wready         : 1; /* axi <- fsm write-ready                                             */
  Ull   axi_araddr            ; /* aligned-address of mm    v   v   v   v           v                 */
  Ull   axi_arlen          :16; /* aligned-length  of mm    v   v   v   v           1                 */
  Ull   axi_arvalid        : 1; /* axi <- fsm                                                         */
  Ull   axi_arready        : 1; /* axi -> fsm                                                         */
  Ull   axi_rdata[UNIT_WIDTH] ; /* axi read-data            v   v   v   v           v                 */
  Ull   axi_rvalid         : 1; /* axi <- fsm read-valid                                              */
  Ull   axi_rlast          : 1; /* axi <- fsm read-last                                               */
  Ull   axi_rready         : 1; /* axi -> fsm read-ready                                              */

  /* work for axi-side */
  Ull   dma_stat           : 2; /* 0:none, 2:dma_lmmread, 3:dma_lmmwrite */
  Ull   wadr_sent          : 1; /* 0:none, 1:sent for write */
  Ull   radr_sent          : 1; /* 0:none, 1:sent for read */
  Ull   dadr               :31; /* ddr-adr (internal) */
  Ull   madr               :31; /* lmm-adr (internal) */
  Ull   mlen               :16; /* len (internal) */
  Ull   mreq               :16; /* counter (internal) */
  Ull   fmask              : 8; /* mask for first 32B-chunk                                           */
  Ull   lmask              : 8; /* mask for last  32B-chunk                                           */

  /* work for emax-side */
  Ull   wadr_recv          : 1; /* 0:none, 1:recv for write */
  Ull   radr_recv          : 1; /* 0:none, 1:recv for read */
  Ull   reqn               :16; /* AXIから送出されたon-the-fly req数 */
  Ull   creg               : 1; /* 0:RD unit regs, 1:RD control regs */
  Ull   srw                : 1; /* 0:read, 1:write */
  Ull   sadr               :31; /* adr (internal) */
  Ull   slen               :16; /* len (internal) */
  Ull   sreq               :16; /* counter (internal) */

  /* physical interface (pipelined) to EMAX6-body */
  Ull   axring_ful2   : 2; /* 0:empty, 2:full */
  Ull   axring_b_top  : 2; /* to be enqueued next */
  Ull   axring_b_bot  : 2; /* to be dequeued next */
  Ull   exring_deq_wait : 1; /* synchronize exring deq */
#define AXRING_BR_BUF 2
  struct axring_br {
    Ull   rw          : 1; /* 0:read, 1:write */
    Ull   ty          : 3; /* 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
    Ull   col         : 2; /* logical col# for target lmm */
    Ull   sq          :16; /* sequential # for pipelined DMA 0:last, init by awlen/arlen and decremented */
    Ull   av          : 1; /* address valid */
    Ull   a           :31; /* logical addr reg/lmm */
    Ull   dm          :32; /* <- lmm wdata       */
    Ull   d[UNIT_WIDTH]  ; /* <- lmm wdata/rdata */
  } axring_br[AXRING_BR_BUF]; /* reg */
  Ull   deq_wait      : 1; /* AXI->unit[EMAX_DEPTH/LMRING_MUX-1, EMAX_DEPTH/LMRING_MUX*2-1,...] */
} axiif[MAXCORE]; /* used as EMAX_NCHIP */

struct exring { /* ex status of EMAX6 */
  Ull   cmd_busy        : 1; /* reg_ctrl.statに直接反映 */
  Ull   unit_busy       : 1; /* reg_ctrl.statに直接反映 */
  Ull   cycle           : 3;

  struct unit { /* hardware status of EMAX6 units */
    Ull   cmd           : 2; /* internal copy of reg_ctrl.cmd */
    Ull   cycle         : 3; /* previous unit1_exec/stop is reffered every 4 cycles */
                             /* previous br[0/1] is switched every 4 cycles */
                             /* brout[cycle-4] is updated */
    Ull   l_row         : 6; /* 0..63 *//* 0の物理行が起動の起点 */
    Ull   scon_count    : 7; /* conf.mapdist*2 */
    Ull   one_shot      : 1; /* reg  *//* self_loop_control 0:init 1:self_loop, keep 0 in first 4 cycles */
    Ull   one_shot2     : 1; /* one_shot for stage2 */
    Ull   one_shot_fold : 1; /* folding用にone_shotから4τ遅延 */
    Ull   one_shot_fold2: 1; /* folding用にone_shotから5τ遅延 */
    Ull   one_shot_fold3: 1; /* folding用にone_shotから6τ遅延 */
    Ull   one_shot_fold4: 1; /* folding用にone_shotから7τ遅延 */
    Ull   unit1_exec    : 1; /* 次の動作を指示 (cex,exe,eag), 0:wait 1:exec *//* reg_ctrl.statに直接反映 */
    Ull   unit1_fold    : 1; /* folding用にunit1_execから4τ遅延 */
    Ull   stage_forstat : 2; /* from for()for(), bit0:LOOP0=zero, bit1:LOOP1=zero stage2において毎サイクル生成 */
    Ull   unit1_forstat : 2; /* from for()for(), bit0:LOOP0=zero, bit1:LOOP1=zero 4τ毎に生成 */
    Ull   unit1_forstat2: 2; /* unit1_forstat for stage2 */
    Ull   unit1_forstat_fold:  2; /* forstat+folding for stage1 */
    Ull   unit1_forstat_fold2: 2; /* forstat+folding for stage2 */
    Ull   unit1_forstat_fold3: 2; /* forstat+folding for stage3 */
    Ull   unit1_forstat_fold4: 2; /* forstat+folding for stage4 */
    Ull   unit1_arbrk   : 1; /* loop最終命令の実行完了を表示 */
    Ull   unit1_stop    : 1; /* 次の動作を指示 (cex,exe,eag), 0:wait 1:stop */
    Ull   tr_valid      : 1; /* TRの状態を表示 */
    Ull   unit2_exec    : 1; /* 次の動作を指示 (lmm),         0:wait 1:exec *//* reg_ctrl.statに直接反映 */
    Ull   unit2_fold    : 1; /* folding用にunit2_execから4τ遅延 */
    Ull   unit2_forstat : 2; /* from for()for(), bit0:LOOP0=zero, bit1:LOOP1=zero */
    Ull   unit2_stop    : 1; /* 次の動作を指示 (lmm),         0:wait 1:stop */
    Ull   brout_valid   : 1; /* BRの状態を表示 常時tr_validを1τ後に伝搬 */

    Ull   stage2_exec   : 1; /* unit1_exec  -> stage2_exec */
    Ull   stage2_fold   : 1; /* folding用にstage2_execから4τ遅延 */
    Ull   stage3_exec   : 1; /* stage2_exec -> stage3_exec */
    Ull   stage3_fold   : 1; /* folding用にstage3_execから4τ遅延 */
    Ull   stage4_exec   : 1; /* stage3_exec -> stage4_exec */
    Ull   stage4_fold   : 1; /* folding用にstage4_execから4τ遅延 */
    Ull   cx[EMAX_WIDTH]   ; /* reg  */
    Ull   cx2dr         : 2; /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
    Ull   cx3dr         : 2; /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
    Ull   ex1              ; /* reg  *//* in for ALU */
    Ull   ex2              ; /* reg  *//* in for ALU */
    Ull   ex3              ; /* reg  *//* in for ALU */
    Ull   ex2passr1     : 8; /* reg  *//* pass r1 for OP_SFMA */
    Ull   ex2passr2        ; /* reg  *//* pass r4 for OP_SFMA/x11_softu64_dist */
    Ull   ex2passr3        ; /* reg  *//* pass r4 for OP_SFMA/x11_softu64_dist */
    Ull   ex2passr4     : 8; /* reg  *//* pass r4 for OP_SFMA */
    Ull   ex2dr            ; /* reg  *//* out from first-stage */
    Ull   ex2dr_sfma0      ; /* reg  *//* out from first-stage/softu64 */
    Ull   ex2dr_sfma1      ; /* reg  *//* out from first-stage/softu64 */
    Ull   ex2dr_sfma2      ; /* reg  *//* out from first-stage/softu64 */
    Ull   ex2dr_sfma3      ; /* reg  *//* out from first-stage/softu64 */
    Ull   ex2dr_sfma4      ; /* reg  *//* out from first-stage/softu64 */
    Ull   ex2dr_sfma5      ; /* reg  *//* out from first-stage/softu64 */
    Ull   ex2dr_sfma6      ; /* reg  *//* out from first-stage/softu64 */
    Ull   ex2dr_sfma7      ; /* reg  *//* out from first-stage/softu64 */
    Ull   ex3passr1     : 8; /* reg  *//* pass r1 for OP_SFMA */
    Ull   ex3passr2        ; /* reg  *//* pass r4 for OP_SFMA/x11_softu64_dist */
    Ull   ex3passr3        ; /* reg  *//* pass r4 for OP_SFMA/x11_softu64_dist */
    Ull   ex3dr            ; /* reg  *//* out from second-stage */
    Ull   ex4dr_prev       ; /* reg  *//* for siml-loop only */
    Ull   ex4dr            ; /* reg  *//* out from third-stage */
    Ull   eab           :18; /* wire *//* in for ALU */
    Ull   eao           :64; /* wire *//* in for ALU */
    Ull   ea0b          :18; /* reg  *//* in for EA0 */
    Ull   ea0o          :64; /* reg  *//* in for EA0 */
    Ull   ea1b          :18; /* reg  *//* in for EA1 */
    Ull   ea1o          :64; /* reg  *//* in for EA1 */
    Ull   ea02dofs         ; /* reg  *//* ★for passing eag offset */
    Ull   ea02dr           ; /* reg  *//* for mex(&addr) pointer */
    Ull   ea12dofs         ; /* reg  *//* ★for passing eag offset */
    Ull   ea12dr           ; /* reg  *//* for mex(&addr) pointer */
    Ull   ea03woofs     :18; /* reg  *//* ★for mex(&addr) feedback */
    Ull   ea03dr           ; /* reg  *//* for eag(&addr) pointer */
    Ull   ea13woofs     :18; /* reg  *//* ★for mex(&addr) feedback */
    Ull   ea13dr           ; /* reg  *//* for eag(&addr) pointer */
    Ull   ea04_lmask    :18; /* wire *//* offset */
    Ull   ea04_umask    : 2; /* wire *//* partition */
    Ull   ea04woofs_prev:18; /* reg  *//* ★for siml-loop only */
    Ull   ea04woofs     :18; /* reg  *//* ★for mex(&addr) feedback */
    Ull   ea04dr        :18; /* reg  *//* base+mex+ofs */
    Ull   ea14_lmask    :18; /* wire *//* offset */
    Ull   ea14_umask    : 2; /* wire *//* partition */
    Ull   ea14woofs_prev:18; /* reg  *//* ★for siml-loop only */
    Ull   ea14woofs     :18; /* reg  *//* ★for mex(&addr) feedback */
    Ull   ea14dr        :18; /* reg  *//* base+mex+ofs */
    Ull   tx[UNIT_WIDTH]   ; /* reg  */
    Ull   tx2dr[UNIT_WIDTH]; /* reg  */
    Ull   tx3dr[UNIT_WIDTH]; /* reg  */
    Ull   tx4dr[UNIT_WIDTH]; /* reg  */

    Ull   ranger_ok     : 8; /* wire *//* lmring要求がread &ty==4&adr[col]<>lmm_range内 */
    Ull   rangew_ok     : 8; /* wire *//* lmring要求がwrite&ty==4&adr[col]<>lmm_range内 */
    Ull   lmranger_ok   : 8; /* wire *//* lmring要求がread &ty==4&adr[col]<>lmm_range内 */
    Ull   lmrangew_ok   : 8; /* wire *//* lmring要求がwrite&ty==4&adr[col]<>lmm_range内 */
    Ull   lmlddmqw_ok   : 1; /* wire *//* lmring要求がwrite&ty==3&op1[col]==LDDMQ */
    Ull   lmea0sfma     : 1; /* wire *//* sfma+ea0.stbr存在 4サイクルに分けて実行 */
    Ull   lmea0strq     : 1; /* wire *//* ea0.strq存在      4サイクルに分けて実行 */
    Ull   lmea0strqcol  : 2; /* wire *//* ea0.strq_col番号  4サイクルに分けて実行 */
    Ull   lmring_ea0bsy : 1; /* wire *//* ea0有効 */
    Ull   lmring_ea1bsy : 1; /* wire *//* ea1有効 */
    Ull   lmring_ful    : 1; /* wire *//* (ful2==3)|(ful1 & (ful2==2)) */
    Ull   deq_wait      : 1; /* wire *//* lmring_ful|(ranger_ok&ea1)|(rangew_ok&ea0)|(lddmqw_ok&col!=j) */
    Ull   lmring_ful1   : 1; /* 0:rw/ty/co/sq/a/di/dm無効, 1:rw/ty/co/sq/a/di/dm有効 */
    struct lmring_tr {
      Ull   rw          : 1; /* 0:read, 1:write */
      Ull   ty          : 3; /* 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
      Ull   col         : 2; /* logical col# for target lmm */
      Ull   sq          :16; /* sequential # for pipelined DMA */
      Ull   av          : 1; /* address valid */
      Ull   a           :31; /* logical addr reg/lmm */
      Ull   dm          :32; /* <- lmm wdata       */
      Ull   d[UNIT_WIDTH]  ; /* <- lmm wdata/rdata */
      Ull   merge       : 8; /* wordwise 0:merge_lmm, 1:pass_lmm */
    } lmring_tr;             /* reg */

    Ull   lmco          : 2; /* wire *//* -> col# */
    Ull   lmca          :18; /* wire *//* -> ea01dr *//* col#による2bit補正前addr */
    Ull   lmwm          :32; /* wire *//* <- axi   */
    Ull   lmwd[UNIT_WIDTH] ; /* wire *//* <- axi   */
    Ull   lmrd[UNIT_WIDTH] ; /* wire *//* -> axi   */
    Ull   mwmux[UNIT_WIDTH]; /* wire for mw0[] */
    struct lmm {
      Ull   en0         : 1; /* internal reg       */
      Ull   en1         : 1; /* internal reg       */
      Ull   rw0         : 1; /* 0:read, 1:write    */
      Ull   rw1         : 1; /* 0:read,(1:write)   */
      Ull   ma0         :18; /* internal reg  addr(32B aligned)      */
      Ull   ma1         :18; /* internal reg  addr(32B aligned)      */
      Ull   mm0         :32; /* internal reg  mask */
      Ull   mw0[UNIT_WIDTH]; /* internal reg  data */
      Ull   mr0[UNIT_WIDTH]; /* internal wire data */
      Ull   mr1[UNIT_WIDTH]; /* internal wire data */
      Uchar m[LMEM_SIZE]   ; /* local memory       */
    } lmm;

    Ull   mr0mux        : 2; /* mr0[3-0] -> brs0     */
    Ull   mr1mux        : 2; /* mr1[3-0] -> brs1     */
    Ull   mr0d             ; /* muxed data for BR[0] */
    Ull   mr1d             ; /* muxed data for BR[1] */
    Ull   mexmr0d_prev     ; /* ★for mex */
    Ull   mexmr0d          ; /* ★for mex */
    Ull   mexmr1d_prev     ; /* ★for mex */
    Ull   mexmr1d          ; /* ★for mex */
    struct {Ull r[UNIT_WIDTH];} b[2][EMAX_WIDTH]; /* shadow_breg *//* constantは両方にセット */

    Ull   lmring_ful2   : 2; /* 0:empty, 3:full */
    Ull   lmring_b_top  : 2; /* to be enqueued next */
    Ull   lmring_b_bot  : 2; /* to be dequeued next */
#define LMRING_MUX    8
#define LMRING_BR_BUF 3
    struct lmring_br {
      Ull   rw          : 1; /* 0:read, 1:write */
      Ull   ty          : 3; /* 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
      Ull   col         : 2; /* logical col# for target lmm */
      Ull   sq          :16; /* sequential # for pipelined DMA */
      Ull   av          : 1; /* address valid */
      Ull   a           :31; /* logical addr reg/lmm */
      Ull   dm          :32; /* <- lmm wdata       */
      Ull   d[UNIT_WIDTH]  ; /* <- lmm wdata/rdata */
    } lmring_br[LMRING_BR_BUF]; /* reg */
  } unit[AMAP_DEPTH];
} exring[MAXCORE];

Ull get_tcureg_valid(cid, col) int cid, col;
{
#ifndef IGNORE_LDDMQ_HANDSHAKE
  return (emax5[cid].fsm[col].tcureg_valid);
#else
  return (0);
#endif
}

put_tcureg_ready(cid, col) int cid, col;
{
#ifndef IGNORE_LDDMQ_HANDSHAKE
  emax5[cid].fsm[col].tcureg_ready = 1;
#endif
}

Ull get_tcureg_last(cid, col) int cid, col;
{
#ifndef IGNORE_LDDMQ_HANDSHAKE
  return (emax5[cid].fsm[col].tcureg_last);
#else
  return (0);
#endif
}

put_tcureg_term(cid, col) int cid, col;
{
#ifndef IGNORE_LDDMQ_HANDSHAKE
  emax5[cid].fsm[col].tcureg_term = 1;
#endif
}

Ull get_tcureg(cid, col, n) int cid, col, n;
{
#ifndef IGNORE_LDDMQ_HANDSHAKE
  return (emax5[cid].fsm[col].tcureg[n]);
#else
  return (0);
#endif
}

emax_lmm_init()
{
  int i, j, k;

  for (i=0; i<MAXCORE; i++) {
    for (j=0; j<EMAX_DEPTH; j++) {
      for (k=0; k<LMEM_SIZE; k++)
	exring[i].unit[j].lmm.m[k] = 0xff;
    }
  }
}

/* EMAX6 control */
struct dma_ctrl dma_ctrl; /* body of dma_ctrl */
struct reg_ctrl reg_ctrl; /* body of reg_ctrl */

//application -> emax6_start((Ull*)emax6_conf_x1, (Ull*)emax6_lmmi_x1, (Ull*)emax6_regv_x1);
//            -> svc 0xf1
siml_emax6(cid, trace, trace_pipe)
     /* core毎にemaxは1つなので,t[cid]を使用 */
     /* ただしEMAX6のカスケード接続版IMAXでは，core[0]に全EMAX6を接続. simlの都合上,EMAX_NCHIP <= MAXCORE */
     Uint cid; Uint trace, trace_pipe;
{
  /*┌─┐  ┌───────────────────┐┌─┐┌───────────────────┐   */
  /*│ A│  │awaddr        $1 WR/RD-req      awaddr││ A││awaddr        $1 WR/RD-req      awaddr│   */
  /*│ R│  │awdata  ┌──────────┐awdata││ R││awdata  ┌──────────┐awdata│   */
  /*│ M│  │araddr  │  ┌exring─←─┐  │araddr││ M││araddr  │  ┌exring─←─┐  │araddr│   */
  /*│─┤$1├─┐  $3│$3│┌┐┌┐┌┐│  │  ┌─┤│  │├─┐  $3│$3│┌┐┌┐┌┐│  │  ┌─┤   */
  /*│ I├─┤PD├→─◆─□□□□□□□□┐└→┤PD├─→─┤PD├→─◆─□□□□□□□□┐└→┤PD├→ */
  /*│ /│  │IM│SL l├─□□□□□□□□┤  MA│IM││  ││IM│SL l├─□□□□□□□□┤  MA│IM│   */
  /*│ O├─┤OA├┐ m├─□□□□□□□□┤  ┌┤OA├─←─┤OA├┐ m├─□□□□□□□□┤  ┌┤OA├← */
  /*│─┤$2├─┘│ r├─□□□□□□□□┤  │└─┤│  │├─┘│ r├─□□□□□□□□┤  │└─┤   */
  /*│#0│  │　  │ i├─□□□□□□□□┤  │    ││#1││    │ i├─□□□□□□□□┤  │    │   */
  /*│　│  │  　│ n├─□□□□□□□□┤  │　  ││  ││  　│ n├─□□□□□□□□┤  │　  │   */
  /*│　│  │    │ g├─□□□□□□□□┤  │    ││  ││    │ g├─□□□□□□□□┤  │    │   */
  /*│　│  │    │  └─□□□□□□□□┤  │    ││  ││    │  └─□□□□□□□□┤  │    │   */
  /*│ L│  │ 　 │      └┘└┘└┘└┘↓$4│ 　 ││ L││ 　 │      └┘└┘└┘└┘↓$4│ 　 │   */
  /*│ 1│  │ 　 └────────←──◆─┘ 　 ││ 1││ 　 └────────←──◆─┘ 　 │   */
  /*│ $│  │ardata               $4 RD-wait ardata││ $││ardata               $4 RD-wait ardata│   */
  /*└─┘  └───────────────────┘└─┘└───────────────────┘   */
  /*                               chip#0                             | #1             #2                */
  /* siml_axi_iorq(cid, trace)     c[0].iorq <- axiif[0]       $2     | -              -                 */
  /* siml_iorq_axi(cid, trace)     c[0].iorq -> axiif[0]       $1     | -              -                 */
  /* for (row) {                   */
  /*   siml_unit_lmm(cid, row)     */
  /*   siml_unit_stage5(cid, i)    */
  /* }                             */
  /* for (row)                     */
  /*   siml_unit_stage4_pre(cid, row)*/
  /* siml_exring_deq_wait(cid)     axiif.exring_deq_wait(axi->lmring) |                                  */
  /* for (row) {                   */
  /*   siml_unit_stage4(cid, row)  bri: axring/lmring切替え                                              */
  /*   siml_unit_stage3(cid, row)  */
  /*   siml_unit_stage2(cid, row)  */
  /*   siml_unit_stage1(cid, row)  */
  /* }                             */
  /* siml_lmring_axi(cid, trace)   axiif[0] <- lmring[0.term]  $4     | lm[1.term]     lm[2.term]        */
  /* siml_axi_lmring(cid, trace)   axiif[0] -> axiif[0].axring $3     |                                  */

  int i, j, k, row0, prev_stat[EMAX_NCHIP], emax_stat, busy;
  Ull a;
  Ull steps = t[cid].total_steps;
  Ull cycle = t[cid].total_cycle;

#if 1
  if (cycle % ARM_EMAX6_RATIO) /* ARM:2.0GHz EMAX6:1.0GHz */
    return (0);
#endif

  if (cid>=EMAX_NCHIP) { /* EMAX6 is attached on cid=0:EMAX_NCHIP-1 */
    if (EMAX_NCHIP > MAXCORE)
      printf("EMAX_NCHIP(%d) should be <= MAXCORE(%d)\n", EMAX_NCHIP, MAXCORE);
    return (0);
  }

  /* update LMRING/EXRING */
  prev_stat[cid] =  c[0].iorq.v_stat || (reg_ctrl.i[cid].stat & 0xffff00ff);
  /* ソフトからのstat検査時に(c[cid].iorq.v_stat)を含めると常にbusy */
  reg_ctrl.i[cid].stat = ((LMEM_SIZE==131072)?2:(LMEM_SIZE==65536)?1:0)<<12
                       | ((EMAX_DEPTH==64)?3:(EMAX_DEPTH==32)?2:(EMAX_DEPTH==16)?1:0)<<8
                       | (!(axiif[cid].axi_arvalid||axiif[cid].axi_awvalid||axiif[cid].axi_wvalid||axiif[cid].reqn)?LMRING_IDLE:LMRING_BUSY)<<4
                       | (!(exring[cid].cmd_busy||exring[cid].unit_busy)?EXRING_IDLE:EXRING_BUSY);
  if (prev_stat[cid] && !c[0].iorq.v_stat && !(reg_ctrl.i[cid].stat & 0xffff00ff))
    printf("%03.3d:EE %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 IO/CMD-END----\n", cid, (Uint)(steps>>32), (Uint)steps, (Uint)(cycle>>32), (Uint)cycle);

#if 1
  emax_stat = 0;
  for (i=0; i<EMAX_NCHIP; i++) emax_stat |= (reg_ctrl.i[i].stat & 0xffff00ff);
  if (!c[0].iorq.v_stat && !emax_stat) return (0);
#endif

  if (cid == 0) { /* cid#0のみ */
    siml_axi_iorq(cid, trace);   /* AXI->IORQ */
    siml_iorq_axi(cid, trace);   /* IORQ->AXI */
  }

  /* find top_row */
  for (row0=0; row0<EMAX_DEPTH; row0++)           /* EXRINGは論理row0からsimlする必要があり,LMRINGも合わせる */
    if (exring[cid].unit[row0].l_row == 0) break; /* LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */

  /********************************************************/
  siml_lmring_axi(cid, trace); /* LMRING->AXI */

  /* siml_unit_stage4()の前にLMRING_MUX個のdeq_waitを集約 */
  /* なお,全stage5と全stage4を交互にsimlすると,毎サイクルlmringが2stage進むことになる */
  /* しかし.lmring_axiは1stageしか処理しないので,性能見積り上の弊害はない 20190828 */
  for (i=(row0+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
    siml_unit_lmm(cid, i);
    siml_unit_stage5(cid, i); /* stage-5 (4DR->BROUT)(LMRING_TR->LMRING_BROUT) */
    if (i==row0)
      break;
  }

  for (i=(row0+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
    siml_unit_stage4_pre(cid, i);
    if (i==row0)
      break;
  }
  siml_exring_deq_wait(cid, trace);

  /* siml unit */
  for (i=(row0+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
    siml_unit_stage4(cid, i); /* stage-4 (3DR->4DR)  (LMRING_BRIN->LMRING_TR) */
    siml_unit_stage3(cid, i); /* stage-3 (2DR->3DR) */
    siml_unit_stage2(cid, i); /* stage-2 (EX/TX->2DR) */
    siml_unit_stage1(cid, i); /* stage-1 (BRIN->EX/TX) */
    if (i==row0)
      break;
  }

  siml_axi_lmring(cid, trace); /* AXI->LMRING */
  /********************************************************/

  busy = 0;
  for (i=0; i<EMAX_DEPTH; i++) { /* for each unit */
    if (exring[cid].unit[i].unit1_exec || exring[cid].unit[i].unit1_fold || exring[cid].unit[i].unit1_stop || exring[cid].unit[i].unit2_exec || exring[cid].unit[i].unit2_fold || exring[cid].unit[i].unit2_stop)
      busy = 1;
  }
  exring[cid].unit_busy = busy;

  if (trace && trace_pipe)
    show_emax6_status(cid);

#if 0
printf("@@@@@@@@ cid=%d c[0].iorq.v_stat=%d arvalid=%d, awvalid=%d, wvalid=%d, reqn=%d, cmd_busy=%d, unit_busy=%d axring_ful2=%d", cid, c[0].iorq.v_stat,
axiif[cid].axi_arvalid, axiif[cid].axi_awvalid, axiif[cid].axi_wvalid, axiif[cid].reqn, exring[cid].cmd_busy, exring[cid].unit_busy, axiif[cid].axring_ful2);

for (i=0; i<EMAX_DEPTH; i++) {
if (i%8==0) printf(" ");
printf("%d%d", exring[cid].unit[i].lmring_ful1, exring[cid].unit[i].lmring_ful2);
}
printf("\n");
#endif

  return (0);
}

siml_axi_iorq(cid, trace) Uint cid, trace;
{
  /* LMMのcolumnマルチスレッデイングは,EXRINGを優先し,LMRINGは隙間で動作させる */
  /* LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */

  /*                                                                                                 *//* axi_write_busy axi_read_busy */
  /* 論理番号           物理番号                     V<--------ENQ (siml_axiifが先にENQ)             *//* awaddr+awlen+awvalid ^> awready *//* wdata[]+wstrb+wvalid+wlast -> wready->next */
  /*                              axiif.axring_br =======bri_ful2 物理#0のpiはaxringに差し替え       *//* araddr+arlen+arvalid -> arready */
  /* row0+DEPTH-2              0        |            V^--------waiti(unit[0].deq_wait)               */
  /*                             unit[].lmring_br -------  下からsiml.deq_waitが同一τにドミノ倒し.  */
  /*                                    |                  実機と違うがoutputの出方は同じ            */
  /* row0+DEPTH-1              1        |            V        ↑                                     */
  /*     siml起点(broutは定数)   unit[].lmring_br -------  SIML起点(1τ前の次段deq_waitを使う.正常)  */
  /* row0                     62        |            V     SIML最後(前段brの値が1τ未来になる)       */
  /*                             unit[].lmring_br -------     ↑                                     */
  /* row0+1                   63        |            V                                               */
  /*                             unit[].lmring_br -------bro_ful2                                    */
  /*                                                 |^--------waito(axiif.deq_wait)                 */
  /*                                                 +-------->DEQ (siml_axiifが先にDEQ)             *//* rdata[]+rvalid+rlast -> rready->next  */

  /* iorq.v_stat      : 4; v 0:empty 1:reserve 3:inuse | stat 0:empty 1:busy 3:RD-ok */
  /* iorq.tid         :12;                         */
  /* iorq.type        : 4; type                    */
  /* iorq.opcd        : 6; opcd                    */
  /* iorq.ADR            ; 以前のADDRに対応        */
  /* iorq.BUF[2]         ; for load/store          */
  /* iorq.rob            ; for DATA                */

  /* exring.deq_wait  : 1; 0:deq,1:wait            */
  /* axring_ful2      : 2; 0:empty, 2:ful          */
  /* axring_br.rw     : 1; 0:read, 1:write         */
  /* axring_br.ty     : 3; 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
  /* axring_br.col    : 2; logical col# for target lmm */
  /* axring_br.sq     :16; sequential # for pipelined DMA */
  /* axring_br.a      :31; logical addr reg/lmm    */
  /* axring_br.dm     :32; <- lmm wdata            */
  /* axring_br.d[4]      ; <- lmm wdata/rdata      */

  /* read: LMRING終端からの回収 bro->axiif->iorq */
  /*       HOST:AXIIF->IORQ (ARM-restartにより,iorqに該当エントリがない場合がある) */
  /************************************************************************************************************************************************************************************************************/
  /*                        |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk                   _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* iorq.v_stat : 4 *1101===X=0000==========X========1101===========================X=1111                                                                                                                   */
  /* iorq.tid    :12                                                                 A                                                                                                                        */
  /* iorq.type   : 4  4:write                         3:read                         |                                                                                                                        */
  /* iorq.opcd   : 6  2:LD/STRW 3:LD/STR 12:VLD/VSTRQ                                |                                                                                                                        */
  /* iorq.ADR                                           ===A======                   |                                                                                                                        */
  /* iorq.BUF[2]                                                                -----<=D=====>---                                                                                                             */
  /* iorq.rob                                                                                                                                                                                                 */
  /* rdata[]    SLAVE                                                   -----<=D=====>---                                                                                                                     */
  /* rvalid     SLAVE                                                   _____/~~~~~~~\___                                                                                                                     */
  /* rlast      SLAVE                                                   _____/~~~~~~~\___                                                                                                                     */
  /* rready    MASTER*                                                  _____/~~~~~~~\___                                                                                                                     */
  /************************************************************************************************************************************************************************************************************/

  axiif[cid].axi_rready = 1; /* always 1 */

  if (axiif[cid].dma_stat == 2) { /* DMA RD active */
    if (axiif[cid].mreq <= axiif[cid].mlen) { /* write active */
      if (axiif[cid].axi_rvalid && axiif[cid].axi_rready) { /* new read_req starts */
        printf("%03.3d:DMA RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
               cid, axiif[cid].madr+axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH,
               (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
               (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
               (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
               (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
        if (axiif[cid].mreq == 0) {
          if (axiif[cid].fmask&0x01) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0x00000000ffffffffLL, axiif[cid].axi_rdata[0]);
          if (axiif[cid].fmask&0x02) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffff00000000LL, axiif[cid].axi_rdata[0]);
          if (axiif[cid].fmask&0x04) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0x00000000ffffffffLL, axiif[cid].axi_rdata[1]);
          if (axiif[cid].fmask&0x08) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffff00000000LL, axiif[cid].axi_rdata[1]);
          if (axiif[cid].fmask&0x10) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0x00000000ffffffffLL, axiif[cid].axi_rdata[2]);
          if (axiif[cid].fmask&0x20) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffff00000000LL, axiif[cid].axi_rdata[2]);
          if (axiif[cid].fmask&0x40) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0x00000000ffffffffLL, axiif[cid].axi_rdata[3]);
          if (axiif[cid].fmask&0x80) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffff00000000LL, axiif[cid].axi_rdata[3]);
        }
        else if (axiif[cid].mreq == axiif[cid].mlen) {
          if (axiif[cid].lmask&0x01) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0x00000000ffffffffLL, axiif[cid].axi_rdata[0]);
          if (axiif[cid].lmask&0x02) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffff00000000LL, axiif[cid].axi_rdata[0]);
          if (axiif[cid].lmask&0x04) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0x00000000ffffffffLL, axiif[cid].axi_rdata[1]);
          if (axiif[cid].lmask&0x08) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffff00000000LL, axiif[cid].axi_rdata[1]);
          if (axiif[cid].lmask&0x10) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0x00000000ffffffffLL, axiif[cid].axi_rdata[2]);
          if (axiif[cid].lmask&0x20) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffff00000000LL, axiif[cid].axi_rdata[2]);
          if (axiif[cid].lmask&0x40) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0x00000000ffffffffLL, axiif[cid].axi_rdata[3]);
          if (axiif[cid].lmask&0x80) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffff00000000LL, axiif[cid].axi_rdata[3]);
        }
        else {
          mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
          mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
          mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
          mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
        }
        axiif[cid].mreq++;
      }
    }
    else { /* data完了 */
      dma_ctrl.ZDMA_CH_STATUS = (dma_ctrl.ZDMA_CH_STATUS & ~3); /* free */
      dma_ctrl.ZDMA_CH_CTRL2  = (dma_ctrl.ZDMA_CH_CTRL2  & ~1); /* free */
      axiif[cid].dma_stat   = 0; /* reset */
      axiif[cid].radr_sent  = 0; /* reset */
    }
  }

  if (c[cid].iorq.v_stat == ((3<<2)|1) && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
    /*emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);*/
    if (c[cid].iorq.ADR < REG_BASE2_PHYS) { /* dma space ... 固定位置 (DMA_BASE2_PHYS-REG_BASE2_PHYS) */
      switch (c[cid].iorq.opcd) {
      case 2:if (c[cid].iorq.ADR & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x adr=%08.8x (should be aligned to Uint)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    c[cid].iorq.BUF[0] = *(Uint*)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)); break;
      case 3:if (c[cid].iorq.ADR & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x adr=%08.8x (should be aligned to Ull)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    c[cid].iorq.BUF[0] = *(Ull *)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)); break;
      default:                                       printf("%03.3d:emax6_ctl: dma_space load: opcd=%x adr=%08.8x (should be LDRW/LDR)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR); break; }
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|3; /* return to sim-core.c */
      if (trace)
        printf("%03.3d:PIO->IORQ RD opcd=%d adr=%08.8x data=%08.8x_%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
    }
    else if (axiif[cid].axi_rvalid && axiif[cid].axi_rready) { /* new read_req starts */
      printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
             cid, axiif[cid].sadr,
             (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
             (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
             (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
             (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
      switch (c[cid].iorq.opcd) { /* 2:LD/STRW 3:LD/STR 12:VLD/VSTRQ */
      case 2: /* 32bit */
        switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
        case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
        case  8: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[1]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
        case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
        case 24: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[3]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
        }
        break;
      case 3: /* 64bit */
        switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
        case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0]; break;
        case  8: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[1]; break;
        case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2]; break;
        case 24: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[3]; break;
        }
        break;
      case 12: /* 128bit */
        switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
        case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0];
                 c[cid].iorq.BUF[1] = axiif[cid].axi_rdata[1]; break;
        case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2];
                 c[cid].iorq.BUF[1] = axiif[cid].axi_rdata[3]; break;
        }
        break;
      }
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|3; /* return to sim-core.c */
      axiif[cid].radr_sent = 0;
      if (trace)
        printf("%03.3d:AXIIF->IORQ RD opcd=%d adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR,
               (Uint)(c[cid].iorq.BUF[1]>>32), (Uint)c[cid].iorq.BUF[1],
               (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
    }
  }

  return (0);
}

siml_iorq_axi(cid, trace) Uint cid, trace;
{
  int    i, k;

  /* read/write LMRING先端への投入   iorq->axiif->bri */
  /*       HOST:IORQ->AXIIF (ARM-restartにより,iorqに該当エントリがない場合がある) */
  /************************************************************************************************************************************************************************************************************/
  /*                        |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk                   _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* iorq.v_stat : 4 *1101===X=0000==========X========1101===========================X=1111                                                                                                                   */
  /* iorq.tid    :12                                                                                                                                                                                          */
  /* iorq.type   : 4  4:write                         3:read                                                                                                                                                  */
  /* iorq.opcd   : 6  2:LD/STRW 3:LD/STR 12:VLD/VSTRQ                                                                                                                                                         */
  /* iorq.ADR           ===A======                      ===A======                                                                                                                                            */
  /* iorq.BUF[2]        ===D======                                                                                                                                                                            */
  /* iorq.rob                                                                                                                                                                                                 */
  /* awaddr    MASTER*  -----<=A=====>---                                                                                                                                                                     */
  /* awlen     MASTER*  -----<=0=====>---                                                                                                                                                                     */
  /* awvalid   MASTER*  _____/~~~~~~~\___ valid=1                                                                                                                                                             */
  /* awready    SLAVE   ~~~~~~~~~~~~~\___ ready=1時に授受                                                                                                                                                     */
  /* wstrb     MASTER*  -----<=M=====>---                                                                                                                                                                     */
  /* wdata[]   MASTER*  -----<=D=====>---                                                                                                                                                                     */
  /* wvalid    MASTER*  _____/~~~~~~~\___                                                                                                                                                                     */
  /* wlast     MASTER*  _____/~~~~~~~\___ PIOの場合,常に1                                                                                                                                                     */
  /* wready     SLAVE   ~~~~~~~~~~~~~\___                                                                                                                                                                     */
  /* araddr    MASTER*                                  -----<=A=====>---                                                                                                                                     */
  /* arlen     MASTER*                                  -----<=0=====>---                                                                                                                                     */
  /* arvalid   MASTER*                                  _____/~~~~~~~\___                                                                                                                                     */
  /* arready    SLAVE                                   ~~~~~~~~~~~~~\___                                                                                                                                     */
  /************************************************************************************************************************************************************************************************************/

  if ((exring[cid].cycle&3) == 3 && (reg_ctrl.i[cid].cmd&3) == CMD_RESET) {
    axiif[cid].dma_stat   = 0;
    axiif[cid].wadr_sent  = 0;
    axiif[cid].radr_sent  = 0;
    axiif[cid].dadr       = 0;
    axiif[cid].madr       = 0;
    axiif[cid].mlen       = 0;
    axiif[cid].mreq       = 0;
    axiif[cid].fmask      = 0;
    axiif[cid].lmask      = 0;
  }

  if (axiif[cid].dma_stat == 3) { /* DMA WR active */
    if (!axiif[cid].wadr_sent) {
      if (!axiif[cid].axi_awvalid) {
        axiif[cid].axi_awaddr   = axiif[cid].madr;
        axiif[cid].axi_awlen    = axiif[cid].mlen;
        axiif[cid].axi_awvalid  = 1; /* on */
        printf("%03.3d:DMA WR start ddradr=%08.8x lmmadr=%08.8x len=%04.4x\n",
               cid, axiif[cid].dadr, axiif[cid].madr, axiif[cid].mlen);
      }
      else if (axiif[cid].axi_awready) { /* adr完了 */
        axiif[cid].wadr_sent    = 1; /* fin */
        /*axiif[cid].mreq       = 0; *//* length */
        axiif[cid].axi_awvalid  = 0; /* off */
      }
    }
    else if (axiif[cid].mreq <= axiif[cid].mlen) { /* write active */
      if (axiif[cid].mreq == 0)
        axiif[cid].axi_wstrb = ((axiif[cid].fmask&0x80)?0xf0000000:0)
                             | ((axiif[cid].fmask&0x40)?0x0f000000:0)
                             | ((axiif[cid].fmask&0x20)?0x00f00000:0)
                             | ((axiif[cid].fmask&0x10)?0x000f0000:0)
                             | ((axiif[cid].fmask&0x08)?0x0000f000:0)
                             | ((axiif[cid].fmask&0x04)?0x00000f00:0)
                             | ((axiif[cid].fmask&0x02)?0x000000f0:0)
                             | ((axiif[cid].fmask&0x01)?0x0000000f:0);
      else if (axiif[cid].mreq == axiif[cid].mlen)
        axiif[cid].axi_wstrb = ((axiif[cid].lmask&0x80)?0xf0000000:0)
                             | ((axiif[cid].lmask&0x40)?0x0f000000:0)
                             | ((axiif[cid].lmask&0x20)?0x00f00000:0)
                             | ((axiif[cid].lmask&0x10)?0x000f0000:0)
                             | ((axiif[cid].lmask&0x08)?0x0000f000:0)
                             | ((axiif[cid].lmask&0x04)?0x00000f00:0)
                             | ((axiif[cid].lmask&0x02)?0x000000f0:0)
                             | ((axiif[cid].lmask&0x01)?0x0000000f:0);
      else
        axiif[cid].axi_wstrb = 0xffffffff;
      axiif[cid].axi_wdata[0] = mmr(axiif[cid].dadr                );
      axiif[cid].axi_wdata[1] = mmr(axiif[cid].dadr|(sizeof(Ull)*1));
      axiif[cid].axi_wdata[2] = mmr(axiif[cid].dadr|(sizeof(Ull)*2));
      axiif[cid].axi_wdata[3] = mmr(axiif[cid].dadr|(sizeof(Ull)*3));
      axiif[cid].axi_wvalid   = 1; /* on */
      if (axiif[cid].mreq == axiif[cid].mlen)
        axiif[cid].axi_wlast  = 1; /* on */
      else
        axiif[cid].axi_wlast  = 0; /* off */
      if (axiif[cid].axi_wready) { /* prepare next write */
	printf("%03.3d:DMA WR mreq=%d last=%x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, axiif[cid].mreq, axiif[cid].axi_wlast, axiif[cid].axi_wstrb,
	       (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
	       (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
	       (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
	       (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
        axiif[cid].dadr+=sizeof(Ull)*UNIT_WIDTH;
        axiif[cid].mreq++;
      }
    }
    else { /* data完了 */
      printf("%03.3d:DMA WR FIN\n", cid);
      dma_ctrl.ZDMA_CH_STATUS = (dma_ctrl.ZDMA_CH_STATUS & ~3); /* free */
      dma_ctrl.ZDMA_CH_CTRL2  = (dma_ctrl.ZDMA_CH_CTRL2  & ~1); /* free */
      axiif[cid].dma_stat   = 0; /* reset */
      axiif[cid].wadr_sent  = 0; /* reset */
      axiif[cid].axi_wvalid = 0; /* off */
      axiif[cid].axi_wlast  = 0; /* off */
    }
  }

  if (axiif[cid].dma_stat == 2) { /* DMA RD active */
    if (!axiif[cid].radr_sent) {
      if (!axiif[cid].axi_arvalid) {
        axiif[cid].axi_araddr   = axiif[cid].madr;
        axiif[cid].axi_arlen    = axiif[cid].mlen;
        axiif[cid].axi_arvalid  = 1; /* on */
        printf("%03.3d:DMA RD start lmmadr=%08.8x ddradr=%08.8x len=%04.4x\n",
               cid, axiif[cid].madr, axiif[cid].dadr, axiif[cid].mlen);
      }
      else if (axiif[cid].axi_arready) { /* adr完了 */
        axiif[cid].radr_sent    = 1; /* fin */
        /*axiif[cid].mreq       = 0; *//* length */
        axiif[cid].axi_arvalid  = 0; /* off */
      }
    }
  }

  if (c[cid].iorq.v_stat == ((3<<2)|1) && c[cid].iorq.type == 4) { /* store *//* emax6_reg()機能は最終的には各担当stageに配置 */
    /*emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);*/
    if (c[cid].iorq.ADR < REG_BASE2_PHYS) { /* dma space ... 固定位置 (DMA_BASE2_PHYS-REG_BASE2_PHYS) */
      switch (c[cid].iorq.opcd) {
      case 2:if (c[cid].iorq.ADR & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%x adr=%08.8x (should be aligned to Uint)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    *(Uint*)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)) = c[cid].iorq.BUF[0]; break;
      case 3:if (c[cid].iorq.ADR & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%x adr=%08.8x (should be aligned to Ull)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    *(Ull *)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)) = c[cid].iorq.BUF[0]; break;
      default:                                       printf("%03.3d:emax6_ctl: dma_space store: opcd=%x adr=%08.8x (should be STRW/STR)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR); break; }
      c[cid].iorq.v_stat = 0; /* immediately finished */
      if (trace)
        printf("%03.3d:IORQ->PIO WR opcd=%d adr=%08.8x data=%08.8x_%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
      if ((dma_ctrl.ZDMA_CH_STATUS&3) != 2 && (dma_ctrl.ZDMA_CH_CTRL2 & 1)) {
        dma_ctrl.ZDMA_CH_STATUS = (dma_ctrl.ZDMA_CH_STATUS & ~3) | 2; /* busy */
        if (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 < LMM_BASE2_PHYS) { /* mem->lmm */
          axiif[cid].dma_stat = 3; /* write */
          axiif[cid].dadr     = dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* mem addr */
          axiif[cid].madr     = dma_ctrl.ZDMA_CH_DST_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* lmm addr */
          axiif[cid].mlen     = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Uint)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Uint)-1)/(UNIT_WIDTH*2))
                              - ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Uint)                                               )/(UNIT_WIDTH*2)); /* 0:1cycle, 1:2cycle */
          axiif[cid].mreq     = 0;
          axiif[cid].fmask    = 0xff << ( (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Uint)                                               ) & (UNIT_WIDTH*2-1));
          axiif[cid].lmask    = 0xff >> (~(dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Uint)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Uint)-1) & (UNIT_WIDTH*2-1));
          if (axiif[cid].mlen==0) {
            axiif[cid].fmask &= axiif[cid].lmask;
            axiif[cid].lmask &= axiif[cid].fmask;
          }
          printf("%03.3d:DMA WR src=%08.8x dst=%08.8x len=%04.4x\n", cid,
                 axiif[cid].dadr, axiif[cid].madr, axiif[cid].mlen);
        }
        else { /* lmm->mem */
          axiif[cid].dma_stat = 2; /* read */
          axiif[cid].dadr     = dma_ctrl.ZDMA_CH_DST_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* mem addr */
          axiif[cid].madr     = dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* lmm addr */
          axiif[cid].mlen     = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Uint)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Uint)-1)/(UNIT_WIDTH*2))
                              - ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Uint)                                               )/(UNIT_WIDTH*2)); /* 0:1cycle, 1:2cycle */
          axiif[cid].mreq     = 0;
          axiif[cid].fmask    = 0xff << ( (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Uint)                                               ) & (UNIT_WIDTH*2-1));
          axiif[cid].lmask    = 0xff >> (~(dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Uint)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Uint)-1) & (UNIT_WIDTH*2-1));
          if (axiif[cid].mlen==0) {
            axiif[cid].fmask &= axiif[cid].lmask;
            axiif[cid].lmask &= axiif[cid].fmask;
          }
          printf("%03.3d:DMA RD src=%08.8x dst=%08.8x len=%04.4x\n", cid,
                 axiif[cid].madr, axiif[cid].dadr, axiif[cid].mlen);
        }
      }
    }
    else if (!axiif[cid].dma_stat) { /* DMA is inactive */
      if (!axiif[cid].wadr_sent) {
        if (!axiif[cid].axi_awvalid) {
          axiif[cid].axi_awaddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1);
          axiif[cid].axi_awlen    = 0;
          axiif[cid].axi_awvalid  = 1; /* on */
          if (trace)
            printf("%03.3d:IORQ->AXIIF WR opcd=%x adr=%08.8x\n",
                   cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_awaddr);
        }
        else if (axiif[cid].axi_awready) { /* adr完了 */
          axiif[cid].wadr_sent    = 1; /* fin */
          axiif[cid].mreq         = 0; /* length */
          axiif[cid].axi_awvalid  = 0; /* off */
        }
      }
      else if (axiif[cid].mreq <= 0) { /* write active */
        switch (c[cid].iorq.opcd) { /* 2:LD/STRW 3:LD/STR 12:VLD/VSTRQ */
        case 2: /* 32bit */
          axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x0000000f<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 8 ? 0x00000f00<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==16 ? 0x000f0000<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==24 ? 0x0f000000<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000);
          axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
          axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
          axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
          axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
          break;
        case 3: /* 64bit */
          axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x000000ff : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 8 ? 0x0000ff00 : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==16 ? 0x00ff0000 : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==24 ? 0xff000000 : 0x00000000);
          axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0];
          axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[0];
          axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0];
          axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[0];
          break;
        case 12: /* 128bit */
          axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x0000ffff : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==16 ? 0xffff0000 : 0x00000000);
          axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0];
          axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[1];
          axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0];
          axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[1];
          break;
        }
        axiif[cid].axi_wvalid   = 1; /* on */
        if (axiif[cid].mreq == 0)
          axiif[cid].axi_wlast  = 1; /* on */
        else
          axiif[cid].axi_wlast  = 0; /* off */
	printf("%03.3d:PIO WR adr=%08.8x msk=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb,
	       (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
	       (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
	       (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
	       (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
        if (axiif[cid].axi_wready) { /* data完了 */
          axiif[cid].mreq++;
        }
      }
      else {
        c[cid].iorq.v_stat      = 0; /* immediately finished */
        axiif[cid].wadr_sent    = 0; /* reset */
        axiif[cid].axi_wvalid   = 0; /* off */
        axiif[cid].axi_wlast    = 0; /* off */
      }
    }
  }

  if (c[cid].iorq.v_stat == ((3<<2)|1) && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
    /*emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);*/
    if (c[cid].iorq.ADR < REG_BASE2_PHYS) { /* dma space ... 固定位置 (DMA_BASE2_PHYS-REG_BASE2_PHYS) */
    }
    else if (!axiif[cid].dma_stat) { /* DMA is inactive */
      if (!axiif[cid].radr_sent) {
        if (!axiif[cid].axi_arvalid) {
          axiif[cid].axi_araddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1); /* 全dword読み出し */
          axiif[cid].axi_arlen    = 0;
          axiif[cid].axi_arvalid  = 1; /* on */
          if (trace)
            printf("%03.3d:IORQ->AXIIF AR opcd=%x adr=%08.8x\n",
                   cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_araddr);
        }
        else if (axiif[cid].axi_arready) { /* adr完了 */
          axiif[cid].radr_sent    = 1;
          axiif[cid].mreq         = 0; /* length */
          axiif[cid].axi_arvalid  = 0; /* off */
        }
      }
    }
  }

  return (0);
}

siml_exring_deq_wait(cid, trace) Uint cid, trace;
{
  int i;

  /* axiifw側の準備 */
  /* 先頭のexring.deq_waitを集めておき,siml_stage4()の前にaxiif[cid].exring_deq_waitを確定 */
  axiif[cid].exring_deq_wait=0;
  for (i=0; i<LMRING_MUX; i++)
    axiif[cid].exring_deq_wait |= exring[cid].unit[EMAX_DEPTH/LMRING_MUX*i].deq_wait;/* top deq_wait */
}

siml_lmring_axi(cid, trace) Uint cid, trace;
{
  /* LMMのcolumnマルチスレッデイングは,EXRINGを優先し,LMRINGは隙間で動作させる */
  /* LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */

  /*                                                                                                 *//* axi_write_busy axi_read_busy */
  /* 論理番号           物理番号                     V<--------ENQ (siml_axiifが先にENQ)             *//* awaddr+awlen+awvalid ^> awready *//* wdata[]+wstrb+wvalid+wlast -> wready->next */
  /*                              axiif.axring_br =======bri_ful2 物理#0のpiはaxringに差し替え       *//* araddr+arlen+arvalid -> arready */
  /* row0+DEPTH-2              0        |            V^--------waiti(unit[0].deq_wait)               */
  /*                             unit[].lmring_br -------  下からsiml.deq_waitが同一τにドミノ倒し.  */
  /*                                    |                  実機と違うがoutputの出方は同じ            */
  /* row0+DEPTH-1              1        |            V        ↑                                     */
  /*     siml起点(broutは定数)   unit[].lmring_br -------  SIML起点(1τ前の次段deq_waitを使う.正常)  */
  /* row0                     62        |            V     SIML最後(前段brの値が1τ未来になる)       */
  /*                             unit[].lmring_br -------     ↑                                     */
  /* row0+1                   63        |            V                                               */
  /*                             unit[].lmring_br -------bro_ful2                                    */
  /*                                                 |^--------waito(axiif.deq_wait)                 */
  /*                                                 +-------->DEQ (siml_axiifが先にDEQ)             *//* rdata[]+rvalid+rlast -> rready->next  */

  /* exring.deq_wait  : 1; 0:deq,1:wait            */
  /* axring_ful2      : 2; 0:empty, 2:ful          */
  /* axring_br.rw     : 1; 0:read, 1:write         */
  /* axring_br.ty     : 3; 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
  /* axring_br.col    : 2; logical col# for target lmm */
  /* axring_br.sq     :16; sequential # for pipelined DMA */
  /* axring_br.a      :31; logical addr reg/lmm    */
  /* axring_br.dm     :32; <- lmm wdata            */
  /* axring_br.d[4]      ; <- lmm wdata/rdata      */

  /* axiif.deq_wait   : 1; 0:deq,1:wait            */
  /* lmring_ful2      : 2; 0:empty, 3:ful          */
  /* lmring_br.rw     : 1; 0:read, 1:write         */
  /* lmring_br.ty     : 3; 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
  /* lmring_br.col    : 2; logical col# for target lmm */
  /* lmring_br.sq     :16; sequential # for pipelined DMA */
  /* lmring_br.a      :31; logical addr reg/lmm    */
  /* lmring_br.dm     :32; <- lmm wdata            */
  /* lmring_br.d[4]      ; <- lmm wdata/rdata      */

  int    i, k;
  int    bro_ful2, bro_av;
  struct lmring_br *bro[LMRING_MUX]; /* wire */

  for (i=0, bro_ful2=1, bro_av=0; i<LMRING_MUX; i++) {
    bro_ful2 &= (exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2 > 0);
    bro[i]    = &exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_br[exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot]; /* AXI<-EMAX側 */
    bro_av   |= bro[i]->av;
  }

  /* read: LMRING終端からの回収 bro->axiif->iorq */
  /*       EMAX:BRO->AXIIF  */
  /************************************************************************************************************************************************************************************************************/
  /*                        |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk                   _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* bro_ful2  0:emp,3:ful 0_/~1~~~~~\                                                                                                                                                                        */
  /* bro.rw    0:rd.1:wr   --<=0=====>-                                                                                                                                                                       */
  /* bro.ty    0:reg,4:lmm --<=*=====>-                                                                                                                                                                       */
  /* bro.col   :  2        reg_ctrl.csel                                                                                                                                                                      */
  /* bro.sq    : 16        --<=0=====>-                                                                                                                                                                       */
  /* bro.av    :  1        --<=0=====>-                                                                                                                                                                       */
  /* bro.a     : 31        --<=A=====>-                                                                                                                                                                       */
  /* bro.dm    : 32        ------------                                                                                                                                                                       */
  /* bro.d[4]  :256        --<=D=====>-                                                                                                                                                                       */
  /* axiif_reqn                                                         _____/~~~~~~~~~~~                                                                                                                     */
  /* axiif_srw                  -----<=1=====>---                       -----<=0=====>---                                                                                                                     */
  /* axiif_sadr                 -----<=A=====>---                       -----<=A=====>---                                                                                                                     */
  /* axiif_sreq                 -----<=0=====>---                       -----<=0=====>---                                                                                                                     */
  /* rdata[]    SLAVE*                                                  -----<=D=====>---                                                                                                                     */
  /* rvalid     SLAVE*                                                  _____/~~~~~~~\___                                                                                                                     */
  /* rlast      SLAVE*                                                  _____/~~~~~~~\___                                                                                                                     */
  /* rready    MASTER                                                   ~~~~~~~~~~~~~~~~~                                                                                                                     */
  /************************************************************************************************************************************************************************************************************/

  /* 以下,cid<(EMAX_NCHIP-1)の場合,次段IMAXが存在 */
  /*┌─┐  ┌───────────────────┐┌─┐┌───────────────────┐   */
  /*│  │  │        ┌──────────┐      ││  ││        ┌──────────┐      │   */
  /*│─┤$1├─┐  $3│$3　            　  │  ┌─┤│  │├─┐  $3│$3　            　  │  ┌─┤   */
  /*│ I├─┤PD├→─◇─┌──────┐┐└→┤PD├─→─┤PD├→─◇─┌──────┐┐└→┤PD├→ */
  /*│ O├─┤OA├┐  ├─│            │┤  ┌┤OA├─←─┤OA├┐  ├─│            │┤  ┌┤OA├← */
  /*│─┤$2├─┘│  ├─│            │┤  │└─┤│  │├─┘│  ├─│            │┤  │└─┤   */
  /*│　│  │    │  └─└──────┘┤  │    ││  ││    │  └─└──────┘┤  │    │   */
  /*│  │  │ 　 │                      ↓$4│ 　 ││  ││ 　 │                      ↓$4│ 　 │   */
  /*│  │  │ 　 └────────←──◆─┘ 　 ││  ││ 　 └────────←──◆─┘ 　 │   */
  /*└─┘  └───────────────────┘└─┘└───────────────────┘   */
  /*               |  IMAX[cid]                       |  IMAX[cid+1]                                     */
  /*       rready> | <rvalid <deq_wait bro+rw rready> | <rvalid <deq_wait                                */
  /*          x    |    <0       <1      0x     0>    |     x    ... do  nothing           */
  /*          x    |    <0       <0      11     0>    |     x    ... deq bro               */
  /*          0    |    <0       <1      10     0>    |     x    ... wait for left-rready  */
  /*               |                                  |                                    */
  /*          1    |    <0       <1      10     0>    |     0    ... ↓へ遷移              */
  /*          1    |    <0       <1      10     1>    |     0    ... wait for right-rready */
  /*          1    |    <1       <0      10     1>    |     1    ... deq bro               */

  if (bro_ful2 && bro[0]->rw==1) { /* WRは無条件にdequeue */
    /* writeの場合,UNIT毎にreqn復帰.後段を待たない */
    axiif[cid].deq_wait = 0; /* 上流axiによるdeq-OK */
    axiif[cid].reqn--;
    axiif[cid].axi_rvalid = 0; /* 上流axiはread不可 */
    if (cid < EMAX_NCHIP-1)
      axiif[cid+1].axi_rready = 0; /* 下流axiからの受取不可 */
    if (!bro_av)
      printf("%03.3d:BRO WR no unit covers ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro[0]->ty, bro[0]->a, bro[0]->a-reg_ctrl.i[cid].adtr);
    if (trace)
      printf("%03.3d:BRO->AXIIF WR reqn--=%d ty=%x adr=%08.8x dm=%08.8x\n",
             cid, axiif[cid].reqn, bro[0]->ty, bro[0]->a, bro[0]->dm);
  }
  else if (bro_ful2 && bro[0]->rw==0) { /* lmringにRD要求有り */
    /* readの場合,後段を待ち,結果merge axiif[cid+1].axi_rdata[UNIT_WIDTH] */
    /*                                 axiif[cid+1].axi_rvalid            */
    /*                                 axiif[cid+1].axi_rlast             */
    /*                                 axiif[cid+1].axi_rready            */
    if (!axiif[cid].axi_rready) { /* 上流が空いていない */
      axiif[cid].deq_wait = 1; /* 上流axiによるdeq-不可 */
      axiif[cid].axi_rvalid = 0; /* 上流axiはread不可 */
      if (cid < EMAX_NCHIP-1)
	axiif[cid+1].axi_rready = 0; /* 下流axiからの受取不可 */
    }
    else if (cid < reg_ctrl.i[cid].mcid && !axiif[cid+1].axi_rvalid) { /* 下流から何もなし */
      printf("%03.3d:BRO waiting for next IMAX[%d]\n", cid, cid+1);
      axiif[cid].deq_wait = 1; /* 上流axiによるdeq-不可 */
      axiif[cid].axi_rvalid = 0; /* 上流axiはread不可 */
      axiif[cid+1].axi_rready = 1; /* 受信可能に変更 */
    }
    else { /* 下流から受取 */
      for (k=0; k<UNIT_WIDTH; k++) {
	if (cid < reg_ctrl.i[cid].mcid)
	  axiif[cid].axi_rdata[k] = axiif[cid+1].axi_rdata[k];
	else
	  axiif[cid].axi_rdata[k] = 0LL;
	for (i=0; i<LMRING_MUX; i++) {
	  if (bro[i]->av)
	    axiif[cid].axi_rdata[k] |= bro[i]->d[k];
	}
      }
      axiif[cid].deq_wait = 0; /* 上流axiによるdeq-OK */
      axiif[cid].reqn--;
      axiif[cid].axi_rvalid = 1; /* 上流axiはread-OK */
      if (cid < EMAX_NCHIP-1)
	axiif[cid+1].axi_rready = 1;
      if (!bro_av)
	printf("%03.3d:BRO RD no unit covers ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro[0]->ty, bro[0]->a, bro[0]->a-reg_ctrl.i[cid].adtr);
      else
	printf("%03.3d:AXI RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, axiif[cid].sadr,
	       (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	       (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	       (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	       (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
    }
  }
  else if (axiif[cid].creg) { /* RD control regs */
    /* CREGは後段IMAXに送信しない．先頭のみ応答 */
    for (k=0; k<UNIT_WIDTH; k++)
      axiif[cid].axi_rdata[k] = *((Ull*)((Uchar*)&reg_ctrl.i[cid]+(axiif[cid].sadr-REG_BASE2_PHYS))+k);
    axiif[cid].axi_rvalid = 1; /* 上流axiはread-OK */
    axiif[cid].creg = 0; /* reset RD control regs */
    printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
           cid, axiif[cid].sadr,
           (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
           (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
           (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
           (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
  }
  else {
    axiif[cid].deq_wait = 1; /* 上流axiによるdeq-不可 */
    axiif[cid].axi_rvalid = 0; /* 上流axiはread不可 */
    if (cid < EMAX_NCHIP-1)
      axiif[cid+1].axi_rready = 0; /* 下流axiからの受取不可 */
  }

  return (0);
}

siml_axi_lmring(cid, trace) Uint cid, trace;
{
  int    i, k, mask;
  int    bri_ful2 = axiif[cid].axring_ful2;
  struct axring_br *bri = &axiif[cid].axring_br[axiif[cid].axring_b_top]; /* AXI->EMAX側 */

  /* read/write LMRING先端への投入   iorq->axiif->bri */
  /*       EMAX:AXIIF->BRI  */
  /************************************************************************************************************************************************************************************************************/
  /*                        |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk                   _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* awaddr    MASTER   -----<=A=====>---                                                                                                                                                                     */
  /* awlen     MASTER   -----<=0=====>---                                                                                                                                                                     */
  /* awvalid   MASTER   _____/~~~~~~~\___ valid=1                                                                                                                                                             */
  /* awready    SLAVE*  ~~~~~~~~~~~~~\___ ready=1の時に授受                                                                                                                                                   */
  /* wstrb     MASTER   -----<=M=====>---                                                                                                                                                                     */
  /* wdata[]   MASTER   -----<=D=====>---                                                                                                                                                                     */
  /* wvalid    MASTER   _____/~~~~~~~\___                                                                                                                                                                     */
  /* wlast     MASTER   _____/~~~~~~~\___ PIOの場合,常に1                                                                                                                                                     */
  /* wready     SLAVE*  ~~~~~~~~~~~^~\___                                                                                                                                                                     */
  /* araddr    MASTER                A                          -----<=A=====>---                                                                                                                             */
  /* arlen     MASTER                |                          -----<=0=====>---                                                                                                                             */
  /* arvalid   MASTER                |                          _____/~~~~~~~\___                                                                                                                             */
  /* arready    SLAVE*               |                          ~~~~~~~~~~~~~\___                                                                                                                             */
  /* axiif_busy           *                                             _____/~~~~~~~~~~~                                                                                                                     */
  /* axiif_srw            *     -----<=1=====>---                       -----<=0=====>---                                                                                                                     */
  /* axiif_sadr           *     -----<=A=====>---                       -----<=A=====>---                                                                                                                     */
  /* axiif_sreq           *     -----<=0=====>---                       -----<=0=====>---                                                                                                                     */
  /* bri_ful2  0:emp,2:ful      __1__/~2~ update axring_b_top           __1__/~2~ update axring_b_top                                                                                                         */
  /* bri.rw    0:rd.1:wr  *     -----<=1=====>---                       -----<=0=====>---                                                                                                                     */
  /* bri.ty    0:reg,4:lmm*     -----<=*=====>---                       -----<=*=====>---                                                                                                                     */
  /* bri.col   :  2       *     reg_ctrl.csel                           reg_ctrl.csel                                                                                                                         */
  /* bri.sq    : 16       *     -----<=0=====>---                       -----<=0=====>---                                                                                                                     */
  /* bri.av    :  1       *     sadr <=0=====>---                       sadr <=0=====>---                                                                                                                     */
  /* bri.a     : 31       *     sadr <=A=====>---                       sadr <=A=====>---                                                                                                                     */
  /* bri.dm    : 32       *     wstrb<=M=====>---                       -----------------                                                                                                                     */
  /* bri.d[4]  :256       *     wdata<=0=====>---                       -----------------                                                                                                                     */
  /* deq_waiti 0:dq,1:wait      update axring_b_bot                     update axring_b_bot                                                                                                                   */
  /************************************************************************************************************************************************************************************************************/

  /* 以下,cid<(EMAX_NCHIP-1)の場合,次段IMAXが存在 */
  /*┌─┐  ┌───────────────────┐┌─┐┌───────────────────┐   */
  /*│  │  │        ┌──────────┐      ││  ││        ┌──────────┐      │   */
  /*│─┤$1├─┐  $3│$3　            　  │  ┌─┤│  │├─┐  $3│$3　            　  │  ┌─┤   */
  /*│ I├─┤PD├→─◆─┌──────┐┐└→┤PD├─→─┤PD├→─◆─┌──────┐┐└→┤PD├→ */
  /*│ O├─┤OA├┐  ├─│            │┤  ┌┤OA├─←─┤OA├┐  ├─│            │┤  ┌┤OA├← */
  /*│─┤$2├─┘│  ├─│            │┤  │└─┤│  │├─┘│  ├─│            │┤  │└─┤   */
  /*│　│  │    │  └─└──────┘┤  │    ││  ││    │  └─└──────┘┤  │    │   */
  /*│  │  │ 　 │                      ↓$4│ 　 ││  ││ 　 │                      ↓$4│ 　 │   */
  /*│  │  │ 　 └────────←──◇─┘ 　 ││  ││ 　 └────────←──◇─┘ 　 │   */
  /*└─┘  └───────────────────┘└─┘└───────────────────┘   */
  /* 前段へのarready/awreadyは，自axringに空き+後段がarready/awreadyの場合に1                            */
  axiif[cid].axi_arready = (bri_ful2 < AXRING_BR_BUF && !axiif[cid].radr_recv && (cid<EMAX_NCHIP-1?axiif[cid+1].axi_arready:1));
  axiif[cid].axi_awready = (bri_ful2 < AXRING_BR_BUF && !axiif[cid].wadr_recv && (cid<EMAX_NCHIP-1?axiif[cid+1].axi_awready:1));
  axiif[cid].axi_wready  = (bri_ful2 < AXRING_BR_BUF                          && (cid<EMAX_NCHIP-1?axiif[cid+1].axi_wready :1));

  if (axiif[cid].axi_arvalid && axiif[cid].axi_arready) { /* new read_req starts */
    axiif[cid].radr_recv = 1; /* fin */
    axiif[cid].srw  = 0; /* read */
    axiif[cid].sadr = axiif[cid].axi_araddr;
    axiif[cid].slen = axiif[cid].axi_arlen;
    axiif[cid].sreq = 0;
    if (cid < reg_ctrl.i[cid].mcid) {
      axiif[cid+1].axi_araddr   = axiif[cid].axi_araddr;
      axiif[cid+1].axi_arlen    = axiif[cid].axi_arlen;
      axiif[cid+1].axi_arvalid  = 1; /* on */
    }
  }
  else if (axiif[cid].radr_recv) {
    Uint a;
    if (cid < EMAX_NCHIP-1 && axiif[cid+1].axi_arvalid && axiif[cid+1].axi_arready)
      axiif[cid+1].axi_arvalid = 0; /* off */
    a = axiif[cid].sadr;
    if (a < REG_BASE2_PHYS+REG_CONF_OFFS) { /* control space ... 固定位置 *//* 本来はbri_ful2の影響を受けないが,統一管理のためにbri_ful2を使用 */
      axiif[cid].radr_recv = 0; /* reset */
      axiif[cid].creg = 1; /* set RD control regs */
      if (trace)
        printf("%03.3d:AXIIF->REG AR adr=%08.8x\n", cid, a);
    }
    else if (axiif[cid].sreq <= axiif[cid].slen) { /* (burst 256bit_LMM -> 256bit_AXI_read (256bit*256count = 8KB)) */
      if (bri_ful2 < AXRING_BR_BUF) {
	if (axiif[cid].sreq == axiif[cid].slen)
	  axiif[cid].radr_recv = 0; /* reset */
	bri->rw   = 0; /* read */
	bri->ty   = ( a              >=LMM_BASE2_PHYS) ? 4 : /* lmm  */
                    ((a&REG_AREA_MASK)>=REG_LDDM_OFFS) ? 3 : /* lddm */
                    ((a&REG_AREA_MASK)>=REG_ADDR_OFFS) ? 2 : /* addr */
                    ((a&REG_AREA_MASK)>=REG_BREG_OFFS) ? 1 : /* breg */
                                                       0 ; /* conf */
	bri->col  = reg_ctrl.i[cid].csel; /* logical col# for target lmm */
	bri->sq   = axiif[cid].sreq; /* from axiif[cid].axi_awlen to 0 */
	bri->av   = 0; /* initial */
	bri->a    = a + ((bri->ty==4)?reg_ctrl.i[cid].adtr:0) + axiif[cid].sreq*sizeof(Ull)*UNIT_WIDTH;
	bri->d[0] = 0;
	bri->d[1] = 0;
	bri->d[2] = 0;
	bri->d[3] = 0;
	axiif[cid].reqn++;
	axiif[cid].sreq++;
	axiif[cid].axring_ful2++;
	axiif[cid].axring_b_top = (axiif[cid].axring_b_top + 1)%AXRING_BR_BUF;
	if (trace)
	  printf("%03.3d:AXIIF->BRI AR reqn++=%d axring_ful2=%x adr=%08.8x\n", cid, axiif[cid].reqn, axiif[cid].axring_ful2, bri->a);
      }
    }
  }
  else if (axiif[cid].axi_awvalid && axiif[cid].axi_awready) {
    axiif[cid].wadr_recv = 1; /* fin */
    axiif[cid].srw  = 1; /* write */
    axiif[cid].sadr = axiif[cid].axi_awaddr;
    axiif[cid].slen = axiif[cid].axi_awlen;
    axiif[cid].sreq = 0;
    if ((axiif[cid].axi_awaddr < REG_BASE2_PHYS+REG_CONF_OFFS || cid < reg_ctrl.i[cid].mcid) && cid < EMAX_NCHIP-1) {
      axiif[cid+1].axi_awaddr   = axiif[cid].axi_awaddr;
      axiif[cid+1].axi_awlen    = axiif[cid].axi_awlen;
      axiif[cid+1].axi_awvalid  = 1; /* on */
    }
  }
  else if (axiif[cid].wadr_recv) {
    Uint a;
    if (cid < EMAX_NCHIP-1 && axiif[cid+1].axi_awvalid && axiif[cid+1].axi_awready)
      axiif[cid+1].axi_awvalid = 0; /* off */
    a = axiif[cid].sadr;
    if (a < REG_BASE2_PHYS+REG_CONF_OFFS) { /* control space ... 固定位置 *//* 本来はbri_ful2の影響を受けないが,統一管理のためにbri_ful2を使用 */
      if (axiif[cid].axi_wvalid && axiif[cid].axi_wready) {
        axiif[cid].wadr_recv = 0; /* reset */
        if      (axiif[cid].axi_wstrb & 0x000000ff) { k=0; mask=axiif[cid].axi_wstrb     & 0xff; }
        else if (axiif[cid].axi_wstrb & 0x0000ff00) { k=1; mask=axiif[cid].axi_wstrb>> 8 & 0xff; }
        else if (axiif[cid].axi_wstrb & 0x00ff0000) { k=2; mask=axiif[cid].axi_wstrb>>16 & 0xff; }
        else if (axiif[cid].axi_wstrb & 0xff000000) { k=3; mask=axiif[cid].axi_wstrb>>24 & 0xff; }
        if (mask & 0x0f)
          *((Uint*)((Ull*)((Uchar*)&reg_ctrl.i[cid]+(a-REG_BASE2_PHYS))+k)  ) = axiif[cid].axi_wdata[k];
        if (mask & 0xf0)
          *((Uint*)((Ull*)((Uchar*)&reg_ctrl.i[cid]+(a-REG_BASE2_PHYS))+k)+1) = axiif[cid].axi_wdata[k]>>32;
        if (trace)
          printf("%03.3d:AXIIF->REG WR adr=%08.8x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
                 cid, a, axiif[cid].axi_wstrb,
                 (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
                 (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
                 (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
                 (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
        if (cid < EMAX_NCHIP-1) {
          axiif[cid+1].axi_wstrb    = axiif[cid].axi_wstrb; /* set cid=0,1,2,3 */;
          axiif[cid+1].axi_wdata[0] = axiif[cid].axi_wdata[0];
          axiif[cid+1].axi_wdata[1] = axiif[cid].axi_wdata[1];
          axiif[cid+1].axi_wdata[2] = axiif[cid].axi_wdata[2] + (a==REG_BASE2_PHYS?0x000010000LL:0x000000000LL); /* set cid=0,1,2,3 */
          axiif[cid+1].axi_wdata[3] = axiif[cid].axi_wdata[3];
          axiif[cid+1].axi_wvalid   = 1; /* on */
          axiif[cid+1].axi_wlast    = 1; /* on */
        }
        switch (reg_ctrl.i[cid].cmd&3) {
        case CMD_RESET:
	  if (!exring[cid].cmd_busy) {
	    printf("%03.3d:ES %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 CMD(%x) START---\n", cid,
		   (Uint)(t[cid].total_steps>>32), (Uint)t[cid].total_steps,
		   (Uint)(t[cid].total_cycle>>32), (Uint)t[cid].total_cycle, reg_ctrl.i[cid].cmd&3);
	    exring[cid].cmd_busy = 1;
          }
          break;
        case CMD_SCON:  /* scon */
        case CMD_EXEC:  /* exec */
	  if (cid <= reg_ctrl.i[cid].mcid) {
	    if (!exring[cid].cmd_busy) {
	      printf("%03.3d:ES %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 CMD(%x) START---\n", cid,
		     (Uint)(t[cid].total_steps>>32), (Uint)t[cid].total_steps,
		     (Uint)(t[cid].total_cycle>>32), (Uint)t[cid].total_cycle, reg_ctrl.i[cid].cmd&3);
	      exring[cid].cmd_busy = 1;
	    }
          }
          break;
        }
      }
      else {
        if (cid < EMAX_NCHIP-1)
          axiif[cid+1].axi_wvalid   = 0; /* off */
      }
    }
    else if (axiif[cid].sreq <= axiif[cid].slen) { /* 0-3:conf/breg/addr/lddm, 4:lmm (burst 256bit_AXI_write -> 256bit_LMM (256bit*256count = 8KB)) */
      if (axiif[cid].axi_wvalid && axiif[cid].axi_wready) {
        if (axiif[cid].sreq == axiif[cid].slen)
          axiif[cid].wadr_recv = 0; /* reset */
        bri->rw   = 1; /* write */
        bri->ty   = ( a              >=LMM_BASE2_PHYS) ? 4 : /* lmm  */
                    ((a&REG_AREA_MASK)>=REG_LDDM_OFFS) ? 3 : /* lddm */
                    ((a&REG_AREA_MASK)>=REG_ADDR_OFFS) ? 2 : /* addr */
                    ((a&REG_AREA_MASK)>=REG_BREG_OFFS) ? 1 : /* breg */
                                                         0 ; /* conf */
        bri->col  = reg_ctrl.i[cid].csel;   /* logical col# for target lmm */
        bri->sq   = axiif[cid].sreq; /* from 0 to axiif[cid].axi_awlen */
        bri->av   = 0; /* initial */
        bri->a    = a + ((bri->ty==4)?reg_ctrl.i[cid].adtr:0) + axiif[cid].sreq*sizeof(Ull)*UNIT_WIDTH;
        bri->dm   = axiif[cid].axi_wstrb;
        bri->d[0] = axiif[cid].axi_wdata[0];
        bri->d[1] = axiif[cid].axi_wdata[1];
        bri->d[2] = axiif[cid].axi_wdata[2];
        bri->d[3] = axiif[cid].axi_wdata[3];
        axiif[cid].reqn++;
        axiif[cid].sreq++;
        axiif[cid].axring_ful2++;
        axiif[cid].axring_b_top = (axiif[cid].axring_b_top + 1)%AXRING_BR_BUF;
        if (trace)
          printf("%03.3d:AXIIF->BRI WR reqn++=%x axring_ful2=%x adr=%08.8x dm=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
                 cid, axiif[cid].reqn, axiif[cid].axring_ful2, bri->a, bri->dm,
                 (Uint)(bri->d[3]>>32), (Uint)bri->d[3],
                 (Uint)(bri->d[2]>>32), (Uint)bri->d[2],
                 (Uint)(bri->d[1]>>32), (Uint)bri->d[1],
                 (Uint)(bri->d[0]>>32), (Uint)bri->d[0]);
	if (cid < reg_ctrl.i[cid].mcid) {
          axiif[cid+1].axi_wstrb    = axiif[cid].axi_wstrb;
          axiif[cid+1].axi_wdata[0] = axiif[cid].axi_wdata[0];
          axiif[cid+1].axi_wdata[1] = axiif[cid].axi_wdata[1];
          axiif[cid+1].axi_wdata[2] = axiif[cid].axi_wdata[2];
          axiif[cid+1].axi_wdata[3] = axiif[cid].axi_wdata[3];
          axiif[cid+1].axi_wvalid   = 1; /* on */
          if (axiif[cid].sreq == axiif[cid].slen)
            axiif[cid+1].axi_wlast  = 1; /* on */
          else
            axiif[cid+1].axi_wlast  = 0; /* off */
        }
      }
      else {
        if (cid < EMAX_NCHIP-1)
          axiif[cid+1].axi_wvalid   = 0; /* off */
      }
    }
  }
  else {
    if (cid < EMAX_NCHIP-1)
      axiif[cid+1].axi_wvalid   = 0; /* off */
    if ((reg_ctrl.i[cid].cmd&3) == CMD_RESET) {
      axiif[cid].wadr_recv      = 0;
      axiif[cid].radr_recv      = 0;
      axiif[cid].reqn           = 0;
      axiif[cid].creg           = 0;
      axiif[cid].srw            = 0;
      axiif[cid].sadr           = 0;
      axiif[cid].slen           = 0;
      axiif[cid].sreq           = 0;
      axiif[cid].axring_ful2    = 0;
      axiif[cid].axring_b_top   = 0;
      axiif[cid].axring_b_bot   = 0;
      axiif[cid].exring_deq_wait= 0;
    }
    if ((exring[cid].cycle&3) == 3) {
      reg_ctrl.i[cid].cmd = (reg_ctrl.i[cid].cmd&~3) | CMD_NOP;
      exring[cid].cmd_busy = 0;
    }
  }

  if (bri_ful2 && !axiif[cid].exring_deq_wait) { /* dequeued for next cycle */
    axiif[cid].axring_ful2--;
    axiif[cid].axring_b_bot = (axiif[cid].axring_b_bot + 1)%AXRING_BR_BUF;
  }

  if ((exring[cid].cycle&3) == 3 && (reg_ctrl.i[cid].cmd&3) == CMD_RESET)
    exring[cid].cycle = 0;
  else
    exring[cid].cycle++;

  return (0);
}

siml_unit_stage1(Uint cid, Uint i) /* stage-1 (BRIN->EX/TX) */
{
  /******************************************************************************************************************************************************************************************/
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /* reg_ctrl.cmd -----------------<==EXEC=========X==NOP>================================================================================================================================= */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         ----------------------------------<==EXEC=========================================================================================================================>------- */
  /* one_shot    __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* unit1_exec  __________________________________/~~(l_row==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* reg_ctrl.stat---------------------------------<==EXRING_BUSY==================================================================================>--------------------------------------- */

  /* reg_ctrl.cmd -----------------<==SCON=========X==NOP>================================================================================================================================= */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         ----------------------------------<==SCON=========================================================================================>--------------------------------------- */
  /* scon_count  ----------------------------------<==conf.mapdist*2===============X==conf.mapdist*2-1=============X==0============================>======================================= */
  /*                                                      Ascon2  Ascon2  Ascon2  Ascon2  Ascon1  Ascon1  Ascon1  Ascon1                                                                    */
  /*                                                      ->br0   ->br1   ->br2   ->br3   br0->   br1->   br2->   br3->                                                                     */
  /* unit1_exec  __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* stage1out** --------------------------------------------------------------------------<== 0===X== 1===X== 2===X== 3===>--------------------------------------------------------------- */
  /* stage4out** ------------------------------------------<== 0===X== 1===X== 2===X== 3===>----------------------------------------------------------------------------------------------- */
  /* reg_ctrl.stat---------------------------------<==EXRING_BUSY==================================================>----------------------------------------------------------------------- */

  /******************************************************************************************************************************************************************************************/
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* brout_valid __/~~(l_row==row0-1)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- row[i]--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         --<==EXEC=========================================================================================================================================================>------- */
  /* one_shot    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* unit1_exec  __/~~(l_row==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* stage_forstat.0(stage2)_______________________________________________________________________________________________/L0=0~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* stage_forstat.1(stage2)_______________________________________________________________________________________________________/L1=0~~~~~~~~~~~\_______________________________________ */
  /* unit1_forstat(stage2)_________________________________________________________________________________________________________________________/L1=0~~~\_______________________________ */
  /* unit1_arbrk(stage2)___________________________________________________________________________________________________________/~forstat=3~~~~~\_______________________________________ */
  /*                                                                                                                                           A確定                                        */
  /* st2ex       __________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________ */
  /* st3ex       __________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________ */
  /* st4ex       __________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________ */
  /* unit1_stop  __________________________________________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* stage1out** ----------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==>-------------------------------- */
  /* stage2out   ----------<-------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==>------------------------ */
  /* stage3out   ----------<---------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==>---------------- */
  /* stage4out   ----tx4dr-<-----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==>-------- */
  /* tr_valid    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* stage5out   -------brout------------------------------<==p0===X==p1===X==p2===X==p3===X==q0===X==q1===X==q2===X==q3===X==q0===X==q1===X==q2===X==q3===X==q0===X==q1===X==q2===X==q3==> */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- row[i+1]------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         --<==EXEC=========================================================================================================================================================>------- */
  /* one_shot    __________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* stage1out   --------------------------------------------------------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */

  /***folding****************************************************************************************************************/
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /*              V-update                        V-update                        V-update                        V-update  */
  /* brout_valid __/~~(l_row==row0-1)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- row[i]----------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                        V-update  */
  /* cmd         --<==EXEC=========================================================================================>------- */
  /* one_shot    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* unit1_exec  __/~~(l_row==0)~~~~~~~~~~~~~~~~~~~\_______________________________________________________________________ */
  /* stage_forstat.0(stage2)/L0=0~~~~~~~~~~~~~~~~~~\_______________________________________________________________________ */
  /* stage_forstat.1(stage2)_______/L1=0~~~~~~~~~~~\_______________________________________________________________________ */
  /* unit1_forstat(stage2)_________________________/L1=0~~~\_______________________________________________________________ */
  /* unit1_arbrk(stage2)___________/~forstat=3~~~~~\_______________________________________________________________________ */
  /*                                           A確定                                                                        */
  /* one_shot2   __________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________ */
  /* st2ex       __________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________________________________ */
  /* st3ex       __________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________________________ */
  /* st4ex       __________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________________ */
  /* unit1_stop  __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* stage1out** ----------<== 0===X== 1===X== 2===X== 3==>---------------------------------------------------------------- */
  /* stage2out   ----------<-------<== 0===X== 1===X== 2===X== 3==>-------------------------------------------------------- */
  /* stage3out   ----------<---------------<== 0===X== 1===X== 2===X== 3==>------------------------------------------------ */
  /* stage4out   ----tx4dr-<-----------------------<== 0===X== 1===X== 2===X== 3==>---------------------------------------- */
  /* tr_valid    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* stage5out   -------brout------------------------------<==p0===X==p1===X==p2===X==p3===X==q0===X==q1===X==q2===X==q3==> */
  /*              V-update                        V-update                        V-update                        V-update  */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- row[i+1]--------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                        V-update  */
  /* cmd         --<==EXEC=========================================================================================>------- */
  /* one_shot    __________________________________________________________________________________________________/~~~~~~~ */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* stage1out   --------------------------------------------------------------------------<== 0===X== 1===X== 2===X== 3==> */

  int pi = (i+EMAX_DEPTH-1)%EMAX_DEPTH;
  int xi; /* EXE-in: select i/pi by folding or not */
  int bi; /* EAB-in: select i/pi by folding or not */
  int oi; /* EAO-in: select i/pi by folding or not */
  int b  = (exring[cid].unit[i].cycle / EMAX_WIDTH)&1; /* 0,0,0,0,1,1,1,1 */
  int j  =  exring[cid].unit[i].cycle % EMAX_WIDTH;    /* 0,1,2,3,0,1,2,3 */
  int k;   /* tmp, and for STRQ/SFMA+STBR(lmea0strqcol) */
  int ofs; /*          for STRQ/SFMA+STBR(lmea0strqcol) */
  int s, sb, so;
  int unit1_exec_next, unit1_fold_next, unit1_forstat_next, unit1_forstat_fold_next, unit1_stop_next, unit2_exec_next, unit2_fold_next, unit2_forstat_next, unit2_stop_next;

  switch (exring[cid].unit[i].cmd) {
  case CMD_NOP:   /* nop */
    if ((exring[cid].unit[i].cycle&3) == 3) {
      switch (reg_ctrl.i[cid].cmd&3) {
      case CMD_RESET: /* reset */
        exring[cid].unit[i].l_row         = i; /* reset to default */
        exring[cid].unit[i].scon_count    = 0; /* reset to default */
        exring[cid].unit[i].one_shot      = 0; /* reset to default */
        exring[cid].unit[i].one_shot2     = 0; /* reset to default */
        exring[cid].unit[i].one_shot_fold = 0; /* reset to default */
        exring[cid].unit[i].one_shot_fold2= 0; /* reset to default */
        exring[cid].unit[i].unit1_exec    = 0; /* reset to default */
        exring[cid].unit[i].unit1_fold    = 0; /* reset to default */
        exring[cid].unit[i].unit1_forstat = 0; /* reset to default */
        exring[cid].unit[i].unit1_forstat2 = 0;/* reset to default */
        exring[cid].unit[i].unit1_forstat_fold  = 0;/* reset to default */
        exring[cid].unit[i].unit1_forstat_fold2 = 0;/* reset to default */
        exring[cid].unit[i].unit1_stop    = 0; /* reset to default */
        exring[cid].unit[i].unit2_exec    = 0; /* reset to default */
        exring[cid].unit[i].unit2_fold    = 0; /* reset to default */
        exring[cid].unit[i].unit2_forstat = 0; /* reset to default */
        exring[cid].unit[i].unit2_stop    = 0; /* reset to default */
        exring[cid].unit[i].stage2_exec   = 0; /* reset to default */
        exring[cid].unit[i].stage2_fold   = 0; /* reset to default */
        for (k=0; k<EMAX_WIDTH; k++)
          exring[cid].unit[i].cx[k]       = 0;
        exring[cid].unit[i].ex1           = 0LL;
        exring[cid].unit[i].ex2           = 0LL;
        exring[cid].unit[i].ex3           = 0LL;
        exring[cid].unit[i].ea0b          = 0;
        exring[cid].unit[i].ea0o          = 0LL;
        exring[cid].unit[i].ea1b          = 0;
        exring[cid].unit[i].ea1o          = 0LL;
        for (k=0; k<EMAX_WIDTH; k++)
          exring[cid].unit[i].tx[k]       = 0LL;
        break;
      case CMD_SCON:  /* scon */
	if (cid <= reg_ctrl.i[cid].mcid) {
	  exring[cid].unit[i].cmd = CMD_SCON;
	  exring[cid].unit[i].scon_count = reg_ctrl.i[cid].conf[i][0].cdw2.mapdist<<1;
	  exring[cid].unit[i].unit1_exec = 1;
	}
        break;
      case CMD_EXEC:  /* exec */
	if (cid <= reg_ctrl.i[cid].mcid) {
	  if (!reg_ctrl.i[cid].conf[i][0].cdw0.v)
	    exring[cid].unit[i].cmd = CMD_NOP;
	  else {
	    exring[cid].unit[i].cmd = CMD_EXEC;
	    if (exring[cid].unit[i].l_row == 0)
	      exring[cid].unit[i].unit1_exec = 1;
	  }
        }
        break;
      }
    }
    break;
  case CMD_SCON:  /* scon */
    if (exring[cid].unit[i].unit1_exec && (exring[cid].unit[i].scon_count & 1)) {
      *((Ull*)(&reg_ctrl.i[cid].conf[i][j])+0) = exring[cid].unit[pi].b[0][j].r[0];
      *((Ull*)(&reg_ctrl.i[cid].conf[i][j])+1) = exring[cid].unit[pi].b[0][j].r[1];
      *((Ull*)(&reg_ctrl.i[cid].conf[i][j])+2) = exring[cid].unit[pi].b[0][j].r[2];
      *((Ull*)(&reg_ctrl.i[cid].conf[i][j])+3) = exring[cid].unit[pi].b[0][j].r[3];
    }

    if ((exring[cid].unit[i].cycle&3) == 3) {
      if (exring[cid].unit[i].unit1_stop)
        exring[cid].unit[i].cmd = CMD_NOP;
      unit1_exec_next = (exring[cid].unit[i].scon_count <= 1) ? 0 : 1;
      unit1_stop_next = (exring[cid].unit[i].scon_count == 1) ? 1 : 0;
      if (exring[cid].unit[i].unit1_exec) {
        if (exring[cid].unit[i].scon_count & 1)
          exring[cid].unit[i].l_row = (exring[cid].unit[i].l_row+EMAX_DEPTH-1)%EMAX_DEPTH; /* adjust l_row */
        exring[cid].unit[i].scon_count--;
      }
      exring[cid].unit[i].unit1_exec = unit1_exec_next & ~unit1_stop_next;
      exring[cid].unit[i].unit1_stop =                    unit1_stop_next;
    }
    break;
  case CMD_EXEC:  /* exec */
    if ((exring[cid].unit[i].unit1_exec && (exring[cid].unit[i].l_row==0 || exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid))   /* unit1   active */
      ||(exring[cid].unit[i].unit1_fold &&                                  exring[cid].unit[ i                         ].brout_valid)) { /* folding active */

      k   = (exring[cid].unit[i].lmea0sfma || exring[cid].unit[i].lmea0strq) ? exring[cid].unit[i].lmea0strqcol : j;

      if (reg_ctrl.i[cid].conf[i][j].cdw0.fold) {
        xi = i;  /* refer current br */
        bi = (reg_ctrl.i[cid].conf[i][k].cdw1.ea0bs&2)? i : pi; /* if ea0 takes eabbrs, shuold be i (else ea1(load) from pi) */
        oi = (reg_ctrl.i[cid].conf[i][j].cdw1.ea0os&1)? i : pi; /* if ea0 takes eaobrs, shuold be i (else ea1(load) from pi) */
      }
      else {
        xi = pi; /* normal */
        bi = pi; /* normal */
        oi = pi; /* normal */
      }
      s = reg_ctrl.i[cid].conf[i][j].cdw1.cs0;    exring[cid].unit[i].cx[0] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.i[cid].conf[i][j].cdw1.cs1;    exring[cid].unit[i].cx[1] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.i[cid].conf[i][j].cdw1.cs2;    exring[cid].unit[i].cx[2] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.i[cid].conf[i][j].cdw1.cs3;    exring[cid].unit[i].cx[3] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];

      s = reg_ctrl.i[cid].conf[i][j].cdw2.ts0;    exring[cid].unit[i].tx[0] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.i[cid].conf[i][j].cdw2.ts1;    exring[cid].unit[i].tx[1] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.i[cid].conf[i][j].cdw2.ts2;    exring[cid].unit[i].tx[2] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.i[cid].conf[i][j].cdw2.ts3;    exring[cid].unit[i].tx[3] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];

      s = reg_ctrl.i[cid].conf[i][j].cdw0.ex1brs; exring[cid].unit[i].ex1   = (j == 0 && reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_FOR && (exring[cid].unit[i].stage_forstat & (1<<j)))
                                                                            ||(j == 1 && reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_FOR && (exring[cid].unit[i].stage_forstat & (1<<j)))
                                                                            ||( reg_ctrl.i[cid].conf[i][j].cdw0.ex1s!=1)
						                            ||(!reg_ctrl.i[cid].conf[i][j].cdw0.fold && !exring[cid].unit[i].one_shot)
						                            ||( reg_ctrl.i[cid].conf[i][j].cdw0.fold && !exring[cid].unit[i].one_shot_fold)
						                            ||(!reg_ctrl.i[cid].conf[i][j].cdw0.fold && (reg_ctrl.i[cid].conf[i][j].cdw0.init&1)&&(exring[cid].unit[i].unit1_forstat&1))
						                            ||( reg_ctrl.i[cid].conf[i][j].cdw0.fold && (reg_ctrl.i[cid].conf[i][j].cdw0.init&1)&&(exring[cid].unit[i].unit1_forstat_fold&1))
                                                                            ? exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH] : exring[cid].unit[i].ex4dr_prev; /* self_loop */
      s = reg_ctrl.i[cid].conf[i][j].cdw0.ex2brs; exring[cid].unit[i].ex2   = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.i[cid].conf[i][j].cdw0.ex3brs; exring[cid].unit[i].ex3   = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
#if 0
      //test016.c init 00000000 00000010 00000020 00000030 00000100 00000110 00000120 00000130 00000200 00000210 00000220 00000230 00000300 00000310 00000320 00000330
      //test016.c out  00000004 00000010 00000020 00000030 00000104 00000110 00000120 00000130 00000204 00000210 00000220 00000230 00000304 00000310 00000320 00000330
      if (i==2 && j==0) {
	s = reg_ctrl.i[cid].conf[i][j].cdw0.ex1brs;
	printf("%d: [%d][%d].cdw0.fold=%d one_shot=%d one_shot_fold=%d init=%d forstat=%d forstatfold=%d ex1=%08.8x mem=%08.8x exo=%08.8x ex2=%08.8x\n",
	       exring[cid].unit[i].cycle, i, j, reg_ctrl.i[cid].conf[i][j].cdw0.fold, exring[cid].unit[i].one_shot, exring[cid].unit[i].one_shot_fold,
	       reg_ctrl.i[cid].conf[i][j].cdw0.init, exring[cid].unit[i].unit1_forstat, exring[cid].unit[i].unit1_forstat_fold, (Uint)exring[cid].unit[i].ex1,
	       (Uint)exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH], (Uint)exring[cid].unit[i].ex4dr_prev, (Uint)exring[cid].unit[i].ex2);
      }
#endif
#if 0
//if (`conf_fold) begin
//  wire [`EXRING_ADDR_BITS-1:0]    ea0bs   = (!ea0loop||first) ? (kea0bfromBR ? bi eabout              : regvk_ea0b)|ofs : ea0out;
//  wire [`REG_DATA_BITS-1:0]       ea0os   = (!ea0loop||second)? (kea0ofromBR ? oi eaoout              : regvk_ea0o) : 0;
//  wire [`EXRING_ADDR_BITS-1:0]    ea1bs   = (!ea1loop||first) ? ( ea1bfromBR ? bi(eab0BR?eabout:eabin):  regv_ea1b) : ea1out;
//  wire [`REG_DATA_BITS-1:0]       ea1os   = (!ea1loop||second)? ( ea1ofromBR ? oi(eao0BR?eaoout:eaoin):  regv_ea1o) : 0;
//end
//else begin
//  wire [`EXRING_ADDR_BITS-1:0]    ea0bs   = (!ea0loop||first) ? (kea0bfromBR ? bi eabin               : regvk_ea0b)|ofs : ea0out;
//  wire [`REG_DATA_BITS-1:0]       ea0os   = (!ea0loop||second)? (kea0ofromBR ? oi eaoin               : regvk_ea0o) : 0;
//  wire [`EXRING_ADDR_BITS-1:0]    ea1bs   = (!ea1loop||first) ? ( ea1bfromBR ? bi eabin               :  regv_ea1b) : ea1out;
//  wire [`REG_DATA_BITS-1:0]       ea1os   = (!ea1loop||second)? ( ea1ofromBR ? oi eaoin               :  regv_ea1o) : 0;
//end
#endif
      /* eab/eaoが上か下かは,foldとea0bs/ea0osのみによって決まる */
      s = reg_ctrl.i[cid].conf[i][k].cdw1.eabbrs; exring[cid].unit[i].eab   = exring[cid].unit[bi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]; //ここがSFMA+STBRの起源
      s = reg_ctrl.i[cid].conf[i][j].cdw1.eaobrs; exring[cid].unit[i].eao   = exring[cid].unit[oi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];

#if 0
//    sb = reg_ctrl.i[cid].conf[i][k].cdw1.ea0bs;
//    if (sb & 1) { /* same as if (mex0op) */
//	if (!exring[cid].unit[i].one_shot||(reg_ctrl.i[cid].conf[i][j].cdw0.mex0init && (exring[cid].unit[i].unit1_forstat&1)))
//	  base = pi;
//	else
//	  base = ea04woofs_prev;
//    }
//    else
//	base = pi;
//
//    offs = pi;
#endif
      /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
      /* STRQ/SFMA+STBRはSTRを4サイクル分割実行 */
      /* exring[cid].unit[i].lmea0strq と exring[cid].unit[i].lmea0strqcol は siml_unit_stage4()にて先行セット */
      ofs = exring[cid].unit[i].lmea0strq ? (j<<3) : 0;
      sb = reg_ctrl.i[cid].conf[i][k].cdw1.ea0bs; exring[cid].unit[i].ea0b = (!(sb&1)||(!exring[cid].unit[i].one_shot||(reg_ctrl.i[cid].conf[i][j].cdw0.mex0init && (exring[cid].unit[i].unit1_forstat&1))))
						    ? (((sb&2)?exring[cid].unit[i].eab:reg_ctrl.i[cid].addr[i][k].ea0b)|ofs)
						    : exring[cid].unit[i].ea04woofs_prev; /* ★ */
      so = reg_ctrl.i[cid].conf[i][k].cdw1.ea0os; exring[cid].unit[i].ea0o = so
						    ? exring[cid].unit[i].eao
						    : reg_ctrl.i[cid].addr[i][k].ea0o;    /* ★ */
      sb = reg_ctrl.i[cid].conf[i][j].cdw1.ea1bs; exring[cid].unit[i].ea1b = (!(sb&1)||(!exring[cid].unit[i].one_shot||(reg_ctrl.i[cid].conf[i][j].cdw0.mex1init && (exring[cid].unit[i].unit1_forstat&1))))
						    ? ( (sb&2)?exring[cid].unit[i].eab:reg_ctrl.i[cid].addr[i][j].ea1b     )
						    : exring[cid].unit[i].ea14woofs_prev; /* ★ */
      so = reg_ctrl.i[cid].conf[i][j].cdw1.ea1os; exring[cid].unit[i].ea1o = so
						    ? exring[cid].unit[i].eao
						    : reg_ctrl.i[cid].addr[i][j].ea1o;    /* ★ */
    }

    if (exring[cid].unit[i].unit1_exec && (exring[cid].unit[i].l_row==0 || exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid)) /* unit1   active */
      exring[cid].unit[i].stage2_exec = 1;
    else
      exring[cid].unit[i].stage2_exec = 0;

    if (exring[cid].unit[i].unit1_fold &&                                  exring[cid].unit[ i                         ].brout_valid) /* folding active */
      exring[cid].unit[i].stage2_fold = 1;
    else
      exring[cid].unit[i].stage2_fold = 0;

    exring[cid].unit[i].one_shot2           = exring[cid].unit[i].one_shot;
    exring[cid].unit[i].one_shot_fold2      = exring[cid].unit[i].one_shot_fold;
    exring[cid].unit[i].unit1_forstat2      = exring[cid].unit[i].unit1_forstat;
    exring[cid].unit[i].unit1_forstat_fold2 = exring[cid].unit[i].unit1_forstat_fold;

    if ((exring[cid].unit[i].cycle&3) == 3) {
      if ((!reg_ctrl.i[cid].conf[i][0].cdw0.fold && exring[cid].unit[i].unit2_stop)||(reg_ctrl.i[cid].conf[i][0].cdw0.fold && exring[cid].unit[i].unit2_fold && !exring[cid].unit[i].stage4_fold))
        exring[cid].unit[i].cmd = CMD_NOP;
      if (exring[cid].unit[i].unit1_exec && (exring[cid].unit[i].l_row==0 || exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid)) /* active */
        exring[cid].unit[i].one_shot = 1;
      else
        exring[cid].unit[i].one_shot = 0;
      if (exring[cid].unit[i].unit1_fold) /* active */
        exring[cid].unit[i].one_shot_fold = 1;
      else
        exring[cid].unit[i].one_shot_fold = 0;
      unit1_exec_next    = exring[cid].unit[i].unit1_exec     | (reg_ctrl.i[cid].conf[i][0].cdw0.v && exring[cid].unit[i].l_row>0 && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_exec);
      unit1_fold_next    = exring[cid].unit[i].unit2_exec     &  reg_ctrl.i[cid].conf[i][0].cdw0.fold;
      unit1_forstat_next = exring[cid].unit[i].l_row==0       ?  exring[cid].unit[i].stage_forstat                          : exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_forstat;
      unit1_forstat_fold_next = exring[cid].unit[i].unit2_forstat;
      unit1_stop_next    = exring[cid].unit[i].unit1_arbrk    | (reg_ctrl.i[cid].conf[i][0].cdw0.v && exring[cid].unit[i].l_row>0 && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_stop);
      unit2_exec_next    = exring[cid].unit[i].unit1_exec;
      unit2_fold_next    = exring[cid].unit[i].unit1_fold     &  reg_ctrl.i[cid].conf[i][0].cdw0.fold;
      unit2_forstat_next = exring[cid].unit[i].unit1_forstat;
      unit2_stop_next    = exring[cid].unit[i].unit1_stop;
      exring[cid].unit[i].unit1_exec    = unit1_exec_next & ~unit1_stop_next;
      exring[cid].unit[i].unit1_fold    = unit1_fold_next;
      exring[cid].unit[i].unit1_forstat = unit1_forstat_next;
      exring[cid].unit[i].unit1_forstat_fold = unit1_forstat_fold_next;
      exring[cid].unit[i].unit1_stop    =                    unit1_stop_next;
      exring[cid].unit[i].unit2_exec    = unit2_exec_next & ~unit2_stop_next;
      exring[cid].unit[i].unit2_fold    = unit2_fold_next;
      exring[cid].unit[i].unit2_forstat = unit2_forstat_next;
      exring[cid].unit[i].unit2_stop    =                    unit2_stop_next;
    }
    break;
  }

  if ((exring[cid].unit[i].cycle&3) == 3 && (reg_ctrl.i[cid].cmd&3) == CMD_RESET)
    exring[cid].unit[i].cycle = 0;
  else
    exring[cid].unit[i].cycle++;

  return (0);
}

siml_unit_stage2(Uint cid, Uint i) /* stage-2 (EX/TX->1DR) */
{
  /******************************************************************************************************************************************************************************************/
  /* sample/test021.c #define spike01_core1(r, s)                                                                                                                                           */
  /* mo4(OP_LDRQ,  1,  BR[r][2], (Ull)b0,                  (Ull)bofs,        MSK_W1,    (Ull)b,          L*RMGRP,   0,      0,    (Ull)NULL,   L*RMGRP);                                    */
  /* mo4(OP_LDRQ,  1,  BR[r][1], (Ull)a[s][CHIP],          (Ull)cofs,        MSK_W1,    (Ull)a[s][CHIP], L,         0,      0,    (Ull)NULL,   L);                                          */
  /* exe(OP_NOP,      &AR[r][0], 0LL,           EXP_H3210, 0LL,              EXP_H3210, 0LL,             EXP_H3210, OP_NOP, 0LL,  OP_NOP,      0LL);                                        */
  /* mop(OP_LDBR,  1, &b00,      (Ull)c0[s][CHIP],         (Ull)oofs,        MSK_W0,    (Ull)c[s][CHIP], RMGRP/4,   0,      1,    (Ull)NULL,   RMGRP/4);                                    */
  /* ex4(OP_SFMA,     &b00,      INIT0?b00:b00, EXP_H3210, BR[r][1],         EXP_H3210, BR[r][2],        EXP_H3210, OP_NOP, 32LL, OP_NOP,      0LL);                                        */
  /* mop(OP_STBR,  1, &b00,      (Ull)oofs,                (Ull)c0[s][CHIP], MSK_D0,    (Ull)c[s][CHIP], RMGRP/4,   0,      1,    (Ull)NULL,   RMGRP/4)                                     */
  /******************************************************************************************************************************************************************************************/
  /*     SFMA Timing                       LD-B4               LD-A4               LD-C                                                                                                     */
  /*                  −−〓〓 t=3        −−〓〓 t=2        −−〓〓 t=1        −−〓〓   t=0                                                                                            */
  /*                  ＼／▽▽            ＼／▼▽            ＼／▼▽            ＼／▼▽                                                                                                  */
  /*                  □□□□ t=4        □□■□ t=3        □□■□ t=2        □□■□   t=1                                                                                            */
  /*                  −−     t=5        −−B4   t=4        −−A4   t=3        −−C      t=2                                                                                            */
  /*                  |▽|▽▽            |▽|▼▽            |▽|▼▽            |▽|▼▽                                                                                                  */
  /*                  □□□□ t=6        □□■□ t=5        □□■□ t=4        □□■□   t=3                                                                                            */
  /*                  −−                −−B4              −−A4              −−C                                                                                                     */
  /*                  |▽|▽▽            |▽|▼▽            |▽|▼▽            |▽|▼▽                                                                                                  */
  /*              ┌─□□□□ t=7    ┌─■■■■ t=6    ┌─■■■■ t=5    ┌─□□■□   t=4                                                                                            */
  /*              │  −−−−        │  B3B2B1B0        │  A3A2A1A0        │  −−C −                                                                                                  */
  /*              │B3A3C             │B2A2C             │B1A1C             │B0A0C                                                                                                       */
  /******************************************************************************************************************************************************************************************/
  /*              │  SFMA            │  SFMA            │  SFMA            │  SFMA  STBR                                                                                                */
  /*              └→−−〓〓 t=11   └→−−〓〓 t=10   └→−−〓〓 t=9    └→−−〓〓   t=8                                                                                            */
  /*                  ＼／▽▼            ＼／▽▼            ＼／▽▼            ＼／□▼                                                                                                  */
  /*                  ■■□■ t=12       ■■□■ t=11       ■■□■ t=10       ■■□■   t=9                                                                                            */
  /*                  −−     t=13       −−     t=12       −−     t=11       −−  C(st)t=10                                                                                           */
  /*              ┌→|▼|▽▼      ←┬→|▼|▽▼      ←┬→|▼|▽▼      ←┬→|▼|▽▼                                                                                                  */
  /*              └─□■□■ t=14   └─□■□■ t=13   └─□■□■ t=12   └─□■□■   t=11                                                                                           */
  /*                  −−−C(st)         −−−C(st)         −−−C(st)         −−−C(st)                                                                                               */
  /*                  |▽|▽▽            |▽|▽▽            |▽|▽▽            |▽|▽▽                                                                                                  */
  /*                  □□□□ t=15       □□□□ t=14       □□□□ t=13       □□□□   t=12                                                                                           */
  /*                  −−−−            −−−−            −−−−            −−−−                                                                                                  */
  /******************************************************************************************************************************************************************************************/

  int    j = (exring[cid].unit[i].cycle+(EMAX_WIDTH-1)) % EMAX_WIDTH; /* 3,0,1,2,3,0,1,2 */
  int    k;
  Ull    c3, c2, c1, c0;
  Ushort pattern;
  Ull    cxd;
  Uint   op_nf1, op_ex1, op_ex2, op_ex3;
  Uint   init, one_shot2, forstat2;
  Ull    r1, r2, r3, r4, r5;
  Uint   exp1, exp2, exp3;
  Uint   ex1_retval;
  Ull    base0, offs0;
  Ull    base1, offs1;
  Uint   mex0op,   mex1op;   /* ★ */
  Uint   mex0init, mex1init; /* ★ */
  Uint   mex0dist, mex1dist; /* ★ */
  Uint   mex0ofs,  mex1ofs;  /* ★ */
  Uint   mexlimit;           /* ★ */
  Uint   mexblock;           /* ★ */

  switch (exring[cid].unit[i].cmd) {
  case CMD_NOP:   /* nop */
    if ((exring[cid].unit[i].cycle&3) == 3) {
      switch (reg_ctrl.i[cid].cmd&3) {
      case CMD_RESET: /* reset */
        exring[cid].unit[i].stage_forstat = 0;
        exring[cid].unit[i].unit1_arbrk = 0;
        exring[cid].unit[i].stage3_exec = 0;
        exring[cid].unit[i].stage3_fold = 0;
        exring[cid].unit[i].cx2dr       = 0;
        exring[cid].unit[i].ex2passr1   = 0;
        exring[cid].unit[i].ex2passr2   = 0;
        exring[cid].unit[i].ex2passr3   = 0;
        exring[cid].unit[i].ex2passr4   = 0;
        exring[cid].unit[i].ex2dr       = 0LL;
        exring[cid].unit[i].ex2dr_sfma0 = 0LL;
        exring[cid].unit[i].ex2dr_sfma1 = 0LL;
        exring[cid].unit[i].ex2dr_sfma2 = 0LL;
        exring[cid].unit[i].ex2dr_sfma3 = 0LL;
        exring[cid].unit[i].ex2dr_sfma4 = 0LL;
        exring[cid].unit[i].ex2dr_sfma5 = 0LL;
        exring[cid].unit[i].ex2dr_sfma6 = 0LL;
        exring[cid].unit[i].ex2dr_sfma7 = 0LL;
        exring[cid].unit[i].ea02dofs    = 0; /* ★ */
        exring[cid].unit[i].ea02dr      = 0;
        exring[cid].unit[i].ea12dofs    = 0; /* ★ */
        exring[cid].unit[i].ea12dr      = 0;
        exring[cid].unit[i].tx2dr[0]    = 0LL;
        exring[cid].unit[i].tx2dr[1]    = 0LL;
        exring[cid].unit[i].tx2dr[2]    = 0LL;
        exring[cid].unit[i].tx2dr[3]    = 0LL;
        break;
      }
    }
    break;
  case CMD_SCON:  /* scon */
    break;
  case CMD_EXEC:  /* exec */
    if (exring[cid].unit[i].stage2_exec || exring[cid].unit[i].stage2_fold) { /* active */
      /* cx -> cx2dr */
      c0      = exring[cid].unit[i].cx[0];
      c1      = exring[cid].unit[i].cx[1];
      c2      = exring[cid].unit[i].cx[2];
      c3      = exring[cid].unit[i].cx[3];
      pattern = reg_ctrl.i[cid].conf[i][j].cdw1.cex_tab;
      cex(OP_CEXE, &cxd, c3, c2, c1, c0, pattern);
      exring[cid].unit[i].cx2dr = cxd;

      /* ex -> ex2dr */
      op_nf1 = reg_ctrl.i[cid].conf[i][1].cdw0.op1 != OP_FOR;
      op_ex1 = reg_ctrl.i[cid].conf[i][j].cdw0.op1;
      op_ex2 = reg_ctrl.i[cid].conf[i][j].cdw0.op2;
      op_ex3 = reg_ctrl.i[cid].conf[i][j].cdw0.op3;
      init   = reg_ctrl.i[cid].conf[i][j].cdw0.init;
      one_shot2 = exring[cid].unit[i].one_shot2;
      forstat2 = exring[cid].unit[i].unit1_forstat2;
      r1     = exring[cid].unit[i].ex1;
      r2     = (op_ex1 == OP_FOR && j == 1 && !(exring[cid].unit[i].stage_forstat & 1)) /* LOOP1は，LOOP0==0の時のみ更新 */
             ||((init & 2) && one_shot2 && !(forstat2 & 1)) ? 0LL /* init0 specified && LOOP0-not_end */ : exring[cid].unit[i].ex2;
      r3     = exring[cid].unit[i].ex3;
      r4     = reg_ctrl.i[cid].conf[i][j].cdw0.e2is==0 ? reg_ctrl.i[cid].conf[i][j].cdw3.e2imm
             : reg_ctrl.i[cid].conf[i][j].cdw0.e2is==1 ? exring[cid].unit[i].ex2
             :                                           exring[cid].unit[i].ex3;
      r5     = reg_ctrl.i[cid].conf[i][j].cdw0.e3is==0 ? reg_ctrl.i[cid].conf[i][j].cdw0.e3imm
             :                                           exring[cid].unit[i].ex3;
      exp1   = reg_ctrl.i[cid].conf[i][j].cdw0.ex1exp;
      exp2   = reg_ctrl.i[cid].conf[i][j].cdw0.ex2exp;
      exp3   = reg_ctrl.i[cid].conf[i][j].cdw0.ex3exp;

      if (reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_SFMA) {
	exring[cid].unit[i].ex2passr1 = (Uchar)r1; /* OP_FSMA */
	exring[cid].unit[i].ex2passr2 = r2; /* OP_FSMA/x11_softu64_dist */
	exring[cid].unit[i].ex2passr3 = r3; /* OP_FSMA/x11_softu64_dist */
	exring[cid].unit[i].ex2passr4 = (Uchar)r4; /* OP_FSMA */
	ex1_retval = softu64(1, &exring[cid].unit[i].ex2dr_sfma0, NULL, NULL, r1, r2, r3, r4);
      }
      else
	ex1_retval = exe(op_ex1, &exring[cid].unit[i].ex2dr, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5);

      if ((exring[cid].unit[i].cycle&3) == 0)
        exring[cid].unit[i].unit1_arbrk = 0;
      else if (op_ex1 == OP_WHILE) {
        exring[cid].unit[i].unit1_arbrk = ex1_retval;
        /*printf("%d WHILE dst=%d arbrk=%d\n", j, (Uint)exring[cid].unit[i].ex2dr, exring[cid].unit[i].unit1_arbrk);*/
      }
      else if (op_ex1 == OP_FOR) {
        if (j == 0) { /* LOOP0 */
          exring[cid].unit[i].unit1_arbrk    = (op_nf1<<1 | ex1_retval)==3;
          exring[cid].unit[i].stage_forstat  =  op_nf1<<1 | ex1_retval;
        }
        else if (j == 1) { /* LOOP1 */
          exring[cid].unit[i].unit1_arbrk    = (ex1_retval<<1 | exring[cid].unit[i].stage_forstat)==3;
          exring[cid].unit[i].stage_forstat  =  ex1_retval<<1 | exring[cid].unit[i].stage_forstat;
        }
        /*printf("%d FOR stage_forstat=%d dst=%d arbrk=%d\n", j, exring[cid].unit[i].stage_forstat, (Uint)exring[cid].unit[i].ex2dr, exring[cid].unit[i].unit1_arbrk);*/
      }

      /* ea -> ea2dr */
      base0 = exring[cid].unit[i].ea0b;
      offs0 = exring[cid].unit[i].ea0o;
      base1 = exring[cid].unit[i].ea1b;
      offs1 = exring[cid].unit[i].ea1o;
      mex0op   = reg_ctrl.i[cid].conf[i][j].cdw0.mex0op;   /* ★ */
      mex1op   = reg_ctrl.i[cid].conf[i][j].cdw0.mex1op;   /* ★ */
      mex0init = reg_ctrl.i[cid].conf[i][j].cdw0.mex0init; /* ★ */
      mex1init = reg_ctrl.i[cid].conf[i][j].cdw0.mex1init; /* ★ */
      mex0dist = reg_ctrl.i[cid].conf[i][j].cdw0.mex0dist; /* ★ */
      mex1dist = reg_ctrl.i[cid].conf[i][j].cdw0.mex1dist; /* ★ */
      mexlimit = reg_ctrl.i[cid].conf[i][j].cdw0.mexlimit; /* ★ */

//    eag(&exring[cid].unit[i].ea02dr, base0, offs0, reg_ctrl.i[cid].conf[i][k].cdw1.ea0msk);
//    eag(&exring[cid].unit[i].ea12dr, base1, offs1, reg_ctrl.i[cid].conf[i][j].cdw1.ea1msk);

      if (mex0op) {  /* ★ */
	if ((!one_shot2)||(mex0init && (forstat2 & 1))) /* ★ */
	  mex0ofs = 0;        /* ★ */
	else {                /* ★ */
	  switch (mex0dist) { /* ★ */
	  case  0: mex0ofs =  0; break; /* ★ */
	  case  1: mex0ofs =  1; break; /* ★ */
	  case  2: mex0ofs =  2; break; /* ★ */
	  case  3: mex0ofs =  4; break; /* ★ */
	  case  4: mex0ofs =  8; break; /* ★ */
	  case  5: mex0ofs = 16; break; /* ★ */
	  case  6: mex0ofs = 32; break; /* ★ */
	  default: mex0ofs = 64; break; /* ★ */
	  }
	}
      }
      else           /* ★ */
	mex0ofs = 0; /* ★ */
      if (mex1op) {  /* ★ */
	if ((!one_shot2)||(mex1init && (forstat2 & 1))) /* ★ */
	  mex1ofs = 0;        /* ★ */
	else {                /* ★ */
	  switch (mex1dist) { /* ★ */
	  case  0: mex1ofs =  0; break; /* ★ */
	  case  1: mex1ofs =  1; break; /* ★ */
	  case  2: mex1ofs =  2; break; /* ★ */
	  case  3: mex1ofs =  4; break; /* ★ */
	  case  4: mex1ofs =  8; break; /* ★ */
	  case  5: mex1ofs = 16; break; /* ★ */
	  case  6: mex1ofs = 32; break; /* ★ */
	  default: mex1ofs = 64; break; /* ★ */
	  }
	}
      }
      else           /* ★ */
	mex1ofs = 0; /* ★ */
      switch (mexlimit) { /* ★ */
      case  0: mexblock =      0; break; /* ★ */
      case  1: mexblock =      8; break; /* ★ */
      case  2: mexblock =     16; break; /* ★ */
      case  3: mexblock =     32; break; /* ★ */
      case  4: mexblock =     64; break; /* ★ */
      case  5: mexblock =    128; break; /* ★ */
      case  6: mexblock =    256; break; /* ★ */
      case  7: mexblock =    512; break; /* ★ */
      case  8: mexblock =   1024; break; /* ★ */
      case  9: mexblock =   2048; break; /* ★ */
      case 10: mexblock =   4096; break; /* ★ */
      case 11: mexblock =   8192; break; /* ★ */
      case 12: mexblock =  16384; break; /* ★ */
      case 13: mexblock =  32768; break; /* ★ */
      case 14: mexblock =  65536; break; /* ★ */
      default: mexblock = 131072; break; /* ★ */
      }

//    mex(mex0op, &exring[cid].unit[i].ea02dr, base0, mex0ofs, exring[cid].unit[i].mexmr1d_prev, exring[cid].unit[i].mexmr0d_prev); /* ★ */
//    mex(mex1op, &exring[cid].unit[i].ea12dr, base1, mex1ofs, exring[cid].unit[i].mexmr1d_prev, exring[cid].unit[i].mexmr0d_prev); /* ★ */
      mex(mex1op, &exring[cid].unit[i].ea12dr, base1, mex1ofs, mex0op, &exring[cid].unit[i].ea02dr, base0, mex0ofs, mexblock, exring[cid].unit[i].mexmr1d_prev, exring[cid].unit[i].mexmr0d_prev); /* ★ */

      k = (exring[cid].unit[i].lmea0sfma || exring[cid].unit[i].lmea0strq) ? exring[cid].unit[i].lmea0strqcol : j;
      exring[cid].unit[i].ea02dofs = eam(offs0, reg_ctrl.i[cid].conf[i][k].cdw1.ea0msk); /* ★ */
      exring[cid].unit[i].ea12dofs = eam(offs1, reg_ctrl.i[cid].conf[i][j].cdw1.ea1msk); /* ★ */

      /* tx -> tx2dr */
      exring[cid].unit[i].tx2dr[0] = exring[cid].unit[i].tx[0];
      exring[cid].unit[i].tx2dr[1] = exring[cid].unit[i].tx[1];
      exring[cid].unit[i].tx2dr[2] = exring[cid].unit[i].tx[2];
      exring[cid].unit[i].tx2dr[3] = exring[cid].unit[i].tx[3];
    }

    if (exring[cid].unit[i].stage2_exec)
      exring[cid].unit[i].stage3_exec = 1;
    else
      exring[cid].unit[i].stage3_exec = 0;

    if (exring[cid].unit[i].stage2_fold)
      exring[cid].unit[i].stage3_fold = 1;
    else
      exring[cid].unit[i].stage3_fold = 0;

    exring[cid].unit[i].one_shot_fold3      = exring[cid].unit[i].one_shot_fold2;
    exring[cid].unit[i].unit1_forstat_fold3 = exring[cid].unit[i].unit1_forstat_fold2;

    break;
  }

  return (0);
}

siml_unit_stage3(Uint cid, Uint i) /* stage-3 (1DR->2DR) */
{
  int    j = (exring[cid].unit[i].cycle+(EMAX_WIDTH-2)) % EMAX_WIDTH; /* 2,3,0,1,2,3,0,1 */
  int    k;            /* ★ */
  Ull    base0, offs0; /* ★ */
  Ull    base1, offs1; /* ★ */

  switch (exring[cid].unit[i].cmd) {
  case CMD_NOP:   /* nop */
    if ((exring[cid].unit[i].cycle&3) == 3) {
      switch (reg_ctrl.i[cid].cmd&3) {
      case CMD_RESET: /* reset */
        exring[cid].unit[i].stage4_exec = 0;
        exring[cid].unit[i].stage4_fold = 0;
        exring[cid].unit[i].cx3dr     = 0;
        exring[cid].unit[i].ex3passr1 = 0;
        exring[cid].unit[i].ex3passr2 = 0;
        exring[cid].unit[i].ex3passr3 = 0;
        exring[cid].unit[i].ex3dr     = 0LL;
	exring[cid].unit[i].ea03woofs = 0; /* ★ */
        exring[cid].unit[i].ea03dr    = 0;
	exring[cid].unit[i].ea13woofs = 0; /* ★ */
        exring[cid].unit[i].ea13dr    = 0;
        exring[cid].unit[i].tx3dr[0]  = 0LL;
        exring[cid].unit[i].tx3dr[1]  = 0LL;
        exring[cid].unit[i].tx3dr[2]  = 0LL;
        exring[cid].unit[i].tx3dr[3]  = 0LL;
        break;
      }
    }
    break;
  case CMD_SCON:  /* scon */
    break;
  case CMD_EXEC:  /* exec */
    if (exring[cid].unit[i].stage3_exec || exring[cid].unit[i].stage3_fold) { /* active */
      /* cx2dr -> cx3dr */
      exring[cid].unit[i].cx3dr = exring[cid].unit[i].cx2dr;

      /* ex2dr -> ex3dr */
      if (reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_SFMA) { /* stage3で乗算結果のMAGNI調整 */
	exring[cid].unit[i].ex3passr1 = exring[cid].unit[i].ex2passr1; /* OP_FSMA */
	exring[cid].unit[i].ex3passr2 = exring[cid].unit[i].ex2passr2; /* OP_FSMA/x11_softu64_dist */
	exring[cid].unit[i].ex3passr3 = exring[cid].unit[i].ex2passr3; /* OP_FSMA/x11_softu64_dist */
	softu64(2, &exring[cid].unit[i].ex2dr_sfma0, &exring[cid].unit[i].ex3dr, NULL, exring[cid].unit[i].ex2passr1, exring[cid].unit[i].ex2passr2, exring[cid].unit[i].ex2passr3, exring[cid].unit[i].ex2passr4);
      }
      else
	exring[cid].unit[i].ex3dr   = exring[cid].unit[i].ex2dr;

      /* ea2dr -> ea3dr */
//    exring[cid].unit[i].ea03dr = exring[cid].unit[i].ea02dr;
//    exring[cid].unit[i].ea13dr = exring[cid].unit[i].ea12dr;
      exring[cid].unit[i].ea03woofs = exring[cid].unit[i].ea02dr;   /* ★ */
      base0                         = exring[cid].unit[i].ea02dr;   /* ★ */
      offs0                         = exring[cid].unit[i].ea02dofs; /* ★ */
      exring[cid].unit[i].ea13woofs = exring[cid].unit[i].ea12dr;   /* ★ */
      base1                         = exring[cid].unit[i].ea12dr;   /* ★ */
      offs1                         = exring[cid].unit[i].ea12dofs; /* ★ */
      eag(&exring[cid].unit[i].ea03dr, base0, offs0);               /* ★ */
      eag(&exring[cid].unit[i].ea13dr, base1, offs1);               /* ★ */

      /* tx2dr -> tx3dr */
      exring[cid].unit[i].tx3dr[0] = exring[cid].unit[i].tx2dr[0];
      exring[cid].unit[i].tx3dr[1] = exring[cid].unit[i].tx2dr[1];
      exring[cid].unit[i].tx3dr[2] = exring[cid].unit[i].tx2dr[2];
      exring[cid].unit[i].tx3dr[3] = exring[cid].unit[i].tx2dr[3];
    }

    if (exring[cid].unit[i].stage3_exec)
      exring[cid].unit[i].stage4_exec = 1;
    else
      exring[cid].unit[i].stage4_exec = 0;

    if (exring[cid].unit[i].stage3_fold)
      exring[cid].unit[i].stage4_fold = 1;
    else
      exring[cid].unit[i].stage4_fold = 0;

    exring[cid].unit[i].one_shot_fold4      = exring[cid].unit[i].one_shot_fold3;
    exring[cid].unit[i].unit1_forstat_fold4 = exring[cid].unit[i].unit1_forstat_fold3;

    break;
  }

  return (0);
}

siml_unit_stage4_pre(Uint cid, Uint i) /* stage-4 (2DR->3DR)  (LMRING_BRIN->LMRING_TR) */
{
  int    pi = (i+EMAX_DEPTH-1)%EMAX_DEPTH;
  int    j  = (exring[cid].unit[i].cycle+(EMAX_WIDTH-3)) % EMAX_WIDTH; /* 1,2,3,0,1,2,3,0 */
  struct lmring_br *br = ((i%(EMAX_DEPTH/LMRING_MUX))==0)?(struct lmring_br*)&axiif[cid].axring_br[axiif[cid].axring_b_bot]
                                                         :(struct lmring_br*)&exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot];
  Uint   ftag, ltag, fmask, lmask, aximask;

  ftag  = (reg_ctrl.i[cid].addr[i][br->col].top&~(sizeof(Ull)*UNIT_WIDTH-1)); /* & 0xffffffe0 */
  ltag  = (reg_ctrl.i[cid].addr[i][br->col].bot&~(sizeof(Ull)*UNIT_WIDTH-1)); /* & 0xffffffe0 */
  switch ((reg_ctrl.i[cid].addr[i][br->col].top/sizeof(Uint)) & (UNIT_WIDTH*2-1)) {
  case 0: fmask = 0xff; break;
  case 1: fmask = 0xfe; break;
  case 2: fmask = 0xfc; break;
  case 3: fmask = 0xf8; break;
  case 4: fmask = 0xf0; break;
  case 5: fmask = 0xe0; break;
  case 6: fmask = 0xc0; break;
  case 7: fmask = 0x80; break;
  }
  switch (~(reg_ctrl.i[cid].addr[i][br->col].bot/sizeof(Uint)) & (UNIT_WIDTH*2-1)) {
  case 0: lmask = 0xff; break;
  case 1: lmask = 0x7f; break;
  case 2: lmask = 0x3f; break;
  case 3: lmask = 0x1f; break;
  case 4: lmask = 0x0f; break;
  case 5: lmask = 0x07; break;
  case 6: lmask = 0x03; break;
  case 7: lmask = 0x01; break;
  }
  aximask = ((br->dm & 0xf0000000)?0x80:0) | ((br->dm & 0x0f000000)?0x40:0) | ((br->dm & 0x00f00000)?0x20:0) | ((br->dm & 0x000f0000)?0x10:0)
          | ((br->dm & 0x0000f000)?0x08:0) | ((br->dm & 0x00000f00)?0x04:0) | ((br->dm & 0x000000f0)?0x02:0) | ((br->dm & 0x0000000f)?0x01:0);
  exring[cid].unit[i].ranger_ok = (ftag< br->a && br->a< ltag) ? 0xff :
                                  (ftag==br->a && br->a< ltag) ? (fmask) :
                                  (ftag< br->a && br->a==ltag) ? (lmask) :
                                  (ftag==br->a && br->a==ltag) ? (fmask & lmask) : 0;
  exring[cid].unit[i].rangew_ok = (ftag< br->a && br->a< ltag) ? 0xff :
                                  (ftag==br->a && br->a< ltag) ? (fmask & aximask) :
                                  (ftag< br->a && br->a==ltag) ? (lmask & aximask) :
                                  (ftag==br->a && br->a==ltag) ? (fmask & lmask & aximask) : 0;

  exring[cid].unit[i].lmranger_ok    = (reg_ctrl.i[cid].conf[i][br->col].cdw2.lmm_axir && br->rw==0 && br->ty==4) ? exring[cid].unit[i].ranger_ok : 0; /* 8bits */
  exring[cid].unit[i].lmrangew_ok    = (reg_ctrl.i[cid].conf[i][br->col].cdw2.lmm_axiw && br->rw==1 && br->ty==4) ? exring[cid].unit[i].rangew_ok : 0; /* 8bits */
  exring[cid].unit[i].lmlddmqw_ok    = br->rw==1 && br->ty==3 && reg_ctrl.i[cid].conf[i][br->col].cdw1.ea1op == OP_LDDMQ; /* lmwd[0]->tr *//* LDDMQは同一slotに高々1が前提 */
  exring[cid].unit[i].lmea0sfma      = reg_ctrl.i[cid].conf[i][0].cdw1.ea0op == OP_STBR && reg_ctrl.i[cid].conf[i][0].cdw0.op1 == OP_SFMA; /* SFMA+STBR */
  exring[cid].unit[i].lmea0strq      = reg_ctrl.i[cid].conf[i][0].cdw1.ea0op == OP_STRQ;                                                   /* STRQ */
  exring[cid].unit[i].lmea0strqcol   = 0; /* default (fixed to 0) */
                                     /* MEX追加前: 行全体のea0       は[i][0].fold=0ならstage4_exec, fold=1ならstage4_foldに従う */
                                     /* MEX追加後: 行全体のea0(load) はstage4_execに従う                                         */
                                     /*            行全体のea0(store)は[i][0].fold=0ならstage4_exec, fold=1ならstage4_foldに従う */
  exring[cid].unit[i].lmring_ea0bsy  = ((reg_ctrl.i[cid].conf[i][j].cdw1.ea0op && reg_ctrl.i[cid].conf[i][j].cdw1.ea0op <= OP_IM_BUFRD) /* ★ */
                                     && exring[cid].unit[i].stage4_exec)/* op0 LD */                                                    /* ★ */
                                   || (((reg_ctrl.i[cid].conf[i][j].cdw1.ea0op && reg_ctrl.i[cid].conf[i][j].cdw1.ea0op <= OP_IM_BUFWR)||(exring[cid].unit[i].lmea0sfma||exring[cid].unit[i].lmea0strq))
                                     &&((!reg_ctrl.i[cid].conf[i][0].cdw0.fold && exring[cid].unit[i].stage4_exec) || (reg_ctrl.i[cid].conf[i][0].cdw0.fold && exring[cid].unit[i].stage4_fold)));/*op0 ST */
                                     /*            行全体のea1(load) はstage4_execに従う */
  exring[cid].unit[i].lmring_ea1bsy  =  (reg_ctrl.i[cid].conf[i][j].cdw1.ea1op && reg_ctrl.i[cid].conf[i][j].cdw1.ea1op <= OP_IM_BUFRD) /* ★ */
                                     && exring[cid].unit[i].stage4_exec;/* op1 LD */                                                    /* ★ */
  exring[cid].unit[i].lmring_ful     =(exring[cid].unit[i].lmring_ful2==LMRING_BR_BUF) || (exring[cid].unit[i].lmring_ful1 && exring[cid].unit[i].lmring_ful2==LMRING_BR_BUF-1); /* assign */
  exring[cid].unit[i].deq_wait       = exring[cid].unit[i].lmring_ful                  || (exring[cid].unit[i].lmranger_ok && exring[cid].unit[i].lmring_ea1bsy)
                                                                                       || (exring[cid].unit[i].lmrangew_ok && exring[cid].unit[i].lmring_ea0bsy)
                                                                                       || (exring[cid].unit[i].lmlddmqw_ok && br->col!=j                       );
  return (0);
}

siml_unit_stage4(Uint cid, Uint i) /* stage-4 (2DR->3DR)  (LMRING_BRIN->LMRING_TR) */
{
  /* LMMのcolumnマルチスレッデイングは,EXRINGを優先し,LMRINGは隙間で動作させる */
  /* 例えばSTRQが存在する場合,EXRINGは全cycleを使ってしまうので,隙間がなくなる */
  /* 隙間がない場合のPLOADは,EXRING完了後に動作開始することになる              */
  /* この点,TRも同様だが,TRは直前のLDDMQに隙間が出るので,PLOADと同時動作可能   */

  /*                        EXEC   NOP               */
  /* lmring_brin                       -> lmring_tr  */
  /* cx3dr                             -> cx4dr      */
  /* ex3dr                             -> ex4dr      */
  /* lmwa/ea03dr,mwsa                  -> ea04dr/ma0 */
  /* lmra/ea13dr,mrsa                  -> ea14dr/ma1 */
  /* lmwd/ex3dr/tx3dr,trs              -> tx4dr      */
  /* lmwd/ex3dr/tx3dr,mws              -> mw         */

  /******************************************************************************************************************************************************************************************/
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* brout_valid __/~~(l_row==row0-1)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- row[i]--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         --<==EXEC=========================================================================================================================================================>------- */
  /* one_shot    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* unit1_exec  __/~~(l_row==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* stage1out** ----------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */
  /* stage2out   ------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2==> */
  /* stage3out   --------------------------<== 0===X== 1===X==*2*==X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1==> */

  /* ful0(prev)  ___________________________1_______2______/3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~~3~~~~~~ */
  /* dv/sq       __________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* ia          --------------------------<==a0===X==a1===X==a2===>-----------------------<==a3===>-------<==a4===X==a5===X==a6===>---------------<==a7===>------------------------------- */
  /* di          --------------------------<==d0===X==d1===X==d2===>-----------------------<==d3===>-------<==d4===X==d5===X==d6===>---------------<==d7===>------------------------------- */
  /*                                                              A enq_en deq_en=~wait & ~ful                                                                                              */
  /*                                                                                        ful = (ful2==3)|(ful1&(ful2==2))                                                                */
  /* wait        __________________________________________/~~~~~~~\_______________________/~~~~~~~\_______________________/~~~~~~~\_______________________/~~~~~~~\_______________________ */
  /* ful1        ___________________________0_______0_______0_______0______/1~~~~~~\0______/1~~~~~~\0______/1~~~~~~~1~~~~~~~1~~~~~~\0_______0______/1~~~~~~\0_______0_______0_______0______ */
  /* ful2                                   3       3       2       2       2       2       1       1       1       1       2       3       2       2       3       2       2       2       */
  /* ful         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______/~~~~~~~~~~~~~~~\_______________________________________/~~~~~~~~~~~~~~~\_______/~~~~~~~~~~~~~~~\_______________________ */
  /* ful1        __________________________________________________________/~~~~~~~\_______/~~~~~~~\_______/~~~~~~~~~~~~~~~~~~~~~~~\_______________/~~~~~~~\_______________________________ */
  /*                                                                                        dv <= deq_en                                                                                    */
  /* ea04dr      --------------------------------------------------<== 2===X==a0===>-------<==a1===X== 2===X==a2===X==a3===X==a4===X== 2===>-------<==a5===>-------<== 2===>--------------- */
  /* ia          ----------------------------------------------------------<==a0===>-------<==a1===>-------<==a2===X==a3===X==a4===>---------------<==a5===>------------------------------- */
  /* di          ----------------------------------------------------------<==d0===>-------<==d1===>-------<==d2===X==d3===X==d4===>---------------<==d5===>------------------------------- */

  /* stage4out   -------tx4dr----------------------<== 0===X== 1===X==*2*==X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0=== */
  /* tr_valid    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */

  /* ful2                                   3       3       2       2       2       2       1       1       1       1       2       3       2       2       3       2       2       2       */
  /* stage5out   -------brout------------------------------<==p0===X==p1===X=*p2*==X==p3===X==q0===X==q1===X==q2===X==q3===X==q0===X==q1===X==q2===X==q3===X==q0===X==q1===X==q2===X==q3==> */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- row[i+1]------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         --<==EXEC=========================================================================================================================================================>------- */
  /* one_shot    __________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* stage1out   --------------------------------------------------------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */

  /******************************************************************************************************************************************************************************************/
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* one_shot    __________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\________________________________________ */
  /* stage1_r1   --<==s1==>--------------------------------------------------------<==s1==>------------------------------------------------------------------------------------------------ */
  /* stage1_r2/3 --<=s2/s3><=s2/s3><=s2/s3><=s2/s3>--------------------------------<=s2/s3><=s2/s3><=s2/s3><=s2/s3>------------------------------------------------------------------------ */
  /* stage2_sfma ----------<=MULT=><=MULT=><=MULT=><=MULT=>--------------------------------<=MULT=><=MULT=><=MULT=><=MULT=>---------------------------------------------------------------- */
  /* stage3_sfma ------------------<=MULT=><=MULT=><=MULT=><=MULT=>--------------------------------<=MULT=><=MULT=><=MULT=><=MULT=>-------------------------------------------------------- */
  /* one_shot4   __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\________________ */
  /* stage4_s1   --------------------------<=s1===><=s1===><=s1===><=s1===><=s1===><=s1===><=s1===><=s1===><=s1===><=s1===><=s1===><=s1===><=s1===><=s1===><=s1===><=s1===>---------------- */
  /* stage4_sfma --------------------------<=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==><=ACC==>---------------- */
  /* stage5_st   ----------------------------------<=LMMW=>--------------------------------------------------------<=LMMW=>---------------------------------------------------------------- */

  int    pi = (i+EMAX_DEPTH-1)%EMAX_DEPTH;
  int    j  = (exring[cid].unit[i].cycle+(EMAX_WIDTH-3)) % EMAX_WIDTH; /* 1,2,3,0,1,2,3,0 */
  int    k; /* for STRQ(lmea0strqcol) */
  struct lmring_br *br = ((i%(EMAX_DEPTH/LMRING_MUX))==0)?(struct lmring_br*)&axiif[cid].axring_br[axiif[cid].axring_b_bot]
                                                         :(struct lmring_br*)&exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot];
  int             ful2 = ((i%(EMAX_DEPTH/LMRING_MUX))==0)?axiif[cid].axring_ful2           /* axi      ful2 */
                                                         :exring[cid].unit[pi].lmring_ful2;/* previous ful2 */
  struct lmring_tr *tr = &exring[cid].unit[i].lmring_tr;
  int cdx = br->a / (REG_AREA_MASK+1) & (EMAX_NCHIP-1);               /* for registers */
  int idx = br->a & (sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH*EMAX_DEPTH-1); /* for registers */
  int row = idx/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K/128B=0........63 *//* 64 rows */
  int deq_wait = (((i%(EMAX_DEPTH/LMRING_MUX)==0)&&axiif[cid].exring_deq_wait)||((i%(EMAX_DEPTH/LMRING_MUX)>0)&&exring[cid].unit[i].deq_wait));

  /* LMRING_TR */
#if 0
  Ull   lmranger_ok   : 4; /* wire *//* lmring要求がread &ty==4&adr[col]<>lmm_range内 */
  Ull   lmrangew_ok   : 4; /* wire *//* lmring要求がwrite&ty==4&adr[col]<>lmm_range内 */
  Ull   lmlddmqw_ok   : 1; /* wire *//* lmring要求がwrite&ty==3&op1[col]==LDDMQ */
  Ull   lmea0sfma     : 1; /* wire *//* sfma+ea0.stbr存在 4サイクルに分けて実行 */
  Ull   lmea0strq     : 1; /* wire *//* ea0.strq存在      4サイクルに分けて実行 */
  Ull   lmea0strqcol  : 2; /* wire *//* ea0.strq_col番号  4サイクルに分けて実行 */
  Ull   lmring_ea0bsy : 1; /* wire *//* ea0有効 */
  Ull   lmring_ea1bsy : 1; /* wire *//* ea1有効 */
  Ull   lmring_ful    : 1; /* wire *//* (ful2==3)|(ful1 & (ful2==2)) */
  Ull   deq_wait      : 1; /* wire *//* lmring_ful|(ranger_ok&ea1)|(rangew_ok&ea0)|(lddmqw_ok&col!=j) */
  Ull   lmring_ful1   : 1; /* 0:rw/ty/co/sq/a/di/dm無効, 1:rw/ty/co/sq/a/di/dm有効 */
  struct lmring_tr {
    Ull   rw          : 1; /* 0:read, 1:write */
    Ull   ty          : 3; /* 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
    Ull   col         : 2; /* logical col# for target lmm */
    Ull   sq          :16; /* sequential # for pipelined DMA */
    Ull   av          : 1; /* address valid */
    Ull   a           :31; /* logical addr reg/lmm */
    Ull   dm          :32; /* <- lmm wdata       */
    Ull   d[UNIT_WIDTH]  ; /* <- lmm wdata/rdata */
    Ull   merge       : 4; /* wordwise 0:merge_lmm, 1:pass_lmm */
  } lmring_tr;
  Ull   lmco          : 2; /* wire *//* -> col# */
  Ull   lmca          :18; /* wire *//* -> ea01dr *//* col#による2bit補正前addr */
  Ull   lmwm          :32; /* wire *//* <- axi   */
  Ull   lmwd[UNIT_WIDTH] ; /* wire *//* <- axi   */
#endif

  /* op0                      */
  /* OP_LDR          0x01 ... */
  /* OP_STR          0x11 ... */
  /* OP_LDDMQ        0x18     */
  /* OP_TR           0x19     */
  /* OP_IM_BUFWR     0x1e ----ここまでeagと干渉 */
  /* OP_IM_PREF      0x1f lmring-write動作 自身なので干渉しない */

  /* op1                      */
  /* OP_LDR          0x01 ... */
  /* OP_IM_BUFRD     0x0e ----ここまでeagと干渉 */
  /* OP_IM_DRAIN     0x0f lmring-read動作  自身なので干渉しない */
  /* OP_LDDMQ        0x18 lmring-read動作  自身なので干渉しない */
  /* OP_TR           0x19 lmring-read動作  自身なので干渉しない */

  /* lmmi[][]はmerge(copy=1)のみでsplit無.DMA対象はv=1,copy=0のみだがEXECがblockしていない限りLMM参照可 */
  /* conf.lmm_modeはmerge/split有.EXEC時にEA->LMMの際のアドレスマスクを制御 */

  /*  以下のようにtop/botが32Byteアラインされていない場合,stage#2にもstage#3用データが取り込まれないためには,axi_adrに加えてmaskの考慮が必要 */
  /*  for stage#2            mask=0000000000000000 0000000000000000 FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF  axi_adr=00020    */
  /*   bot=0002f,top=00000   data=0003000300030002 0003000100030000 0002000700020006 0002000500020004                   */
  /*  for stage#3            mask=FFFFFFFFFFFFFFFF FFFFFFFFFFFFFFFF 0000000000000000 0000000000000000  axi_adr=00020    */
  /*   bot=0005f,top=00030   data=0003000300030002 0003000100030000 0002000700020006 0002000500020004                   */

  /* 全有効lmmi[i][j]に対し, conf.lmm_modeは, exringからのLD/STが参照すべきLMM範囲をcycle%4毎に指示 */
  /* 全有効lmmi[i][j]に対し, lmmi.bcas/copyは，ARMが当該LMMIをDMA対象とするかを指示 */
  /* lmm_modeとbcas/copyは連動する */
  /* 全有効lmmi[i][j]に対し, lmm_mode/bcas/copyとは独立に, reg_ctrl.addr[i][j].top/botがlmring向けに範囲を提示 */
  /* top/botはcycle%4の間で重複することもあるが，colで指定したcycle%4のtop/botにHITすればlmringから流し込めばよい. */
  /* ただし，書き込み時にはLMMの分割数を判定する必要があり,colに対応するconf.lmm_modeの参照が必要 */
  /* 上位2bitのマスクは，EA04DRに書き込む際に適用する（LMRA/EA1,LMWA/EA0が各々共有）*/
  if (exring[cid].unit[i].cmd == CMD_NOP
      && (exring[cid].unit[i].cycle&3) == 3
      && (reg_ctrl.i[cid].cmd&3) == CMD_RESET) {
    exring[cid].unit[i].lmring_ful1    = 0;
    tr->rw   = 0;
    tr->ty   = 0;
    tr->col  = 0;
    tr->sq   = 0;
    tr->av   = 0;
    tr->a    = 0;
    tr->dm   = 0;
    tr->d[0] = 0LL;
    tr->d[1] = 0LL;
    tr->d[2] = 0LL;
    tr->d[3] = 0LL;
    tr->merge = 0;
  }
  else if (ful2 && !deq_wait) { /* for next cycle */
    exring[cid].unit[i].lmco    = br->col;  /* wire *//* -> col# */
    exring[cid].unit[i].lmca    = br->a;    /* wire *//* -> ea01dr *//* col#による2bit補正前addr */
    exring[cid].unit[i].lmwm    = br->dm & (((exring[cid].unit[i].rangew_ok&0x80)?0xf0000000:0) | ((exring[cid].unit[i].rangew_ok&0x40)?0x0f000000:0)
                                          | ((exring[cid].unit[i].rangew_ok&0x20)?0x00f00000:0) | ((exring[cid].unit[i].rangew_ok&0x10)?0x000f0000:0)
                                          | ((exring[cid].unit[i].rangew_ok&0x08)?0x0000f000:0) | ((exring[cid].unit[i].rangew_ok&0x04)?0x00000f00:0)
                                          | ((exring[cid].unit[i].rangew_ok&0x02)?0x000000f0:0) | ((exring[cid].unit[i].rangew_ok&0x01)?0x0000000f:0)); /* wire *//* <- axi */
    exring[cid].unit[i].lmwd[0] = br->d[0]; /* wire *//* <- axi   */
    exring[cid].unit[i].lmwd[1] = br->d[1]; /* wire *//* <- axi   */
    exring[cid].unit[i].lmwd[2] = br->d[2]; /* wire *//* <- axi   */
    exring[cid].unit[i].lmwd[3] = br->d[3]; /* wire *//* <- axi   */

    exring[cid].unit[i].lmring_ful1  = 1; /* next cycle */
    tr->rw   = br->rw;   /* next cycle */
    tr->ty   = br->ty;   /* next cycle */
    tr->col  = br->col;  /* next cycle */
    tr->sq   = br->sq;   /* next cycle */
    tr->av   = br->av || exring[cid].unit[i].lmranger_ok || exring[cid].unit[i].lmrangew_ok || (((reg_ctrl.i[cid].cmd>>16) == cdx || cdx == 0) && exring[cid].unit[i].l_row == row && br->ty<4);
    tr->a    = br->a;    /* next cycle */
    tr->dm   = br->dm;   /* next cycle */
    tr->d[0] = br->d[0]; /* next cycle */
    tr->d[1] = br->d[1]; /* next cycle */
    tr->d[2] = br->d[2]; /* next cycle */
    tr->d[3] = br->d[3]; /* next cycle */
    tr->merge = br->ty<4 ? 0 : exring[cid].unit[i].lmranger_ok; /* reg or read (VADDR/LDDMQ/TRANS) in range */
  }
  else
    exring[cid].unit[i].lmring_ful1  = 0; /* always dequeued */

  /* EX4DR EA04DR,MA0 EA14DR,MA1 TX4DR,MW */
#if 0
  Ull   ex4dr_prev       ; /* reg  *//* for siml-loop only */
  Ull   ex4dr            ; /* reg  *//* out for third-stage */
  Ull   ea04_lmask    :18; /* wire *//* offset */
  Ull   ea04_umask    : 2; /* wire *//* partition */
  Ull   ea04woofs_prev:18; /* reg  *//* for siml-loop only */
  Ull   ea04woofs     :18; /* reg  *//* for mex(&addr) feedback */
  Ull   ea04dr        :18; /* reg  */
  Ull   ea14_lmask    :18; /* wire *//* offset */
  Ull   ea14_umask    : 2; /* wire *//* partition */
  Ull   ea14woofs_prev:18; /* reg  *//* for siml-loop only */
  Ull   ea14woofs     :18; /* reg  *//* for mex(&addr) feedback */
  Ull   ea14dr        :18; /* reg  */
  Ull   tr_valid      : 1; /* TRの状態を表示 */
  Ull   tx4dr[UNIT_WIDTH]; /* reg  */
  Ull   mwmux[UNIT_WIDTH]; /* wire for mw0[] */
  struct lmm {
    Ull   en0         : 1; /* internal reg       */
    Ull   en1         : 1; /* internal reg       */
    Ull   rw0         : 1; /* 0:read, 1:write    */
    Ull   rw1         : 1; /* 0:read,(1:write)   */
    Ull   ma0         :18; /* internal reg  addr(32B aligned)      */
    Ull   ma1         :18; /* internal reg  addr(32B aligned)      */
    Ull   mm0         :32; /* internal reg  mask */
    Ull   mw0[UNIT_WIDTH]; /* internal reg  data */
    Ull   mr0[UNIT_WIDTH]; /* internal wire data */
    Ull   mr1[UNIT_WIDTH]; /* internal wire data */
    Uchar m[LMEM_SIZE]   ; /* local memory       */
  } lmm;
#endif

  if (exring[cid].unit[i].cmd == CMD_NOP
      && (exring[cid].unit[i].cycle&3) == 3
      && (reg_ctrl.i[cid].cmd&3) == CMD_RESET) {
    exring[cid].unit[i].ex4dr_prev     = 0LL; /* siml-loop only */
    exring[cid].unit[i].ex4dr          = 0LL;
    exring[cid].unit[i].ea04woofs_prev = 0;   /* ★siml-loop only */
    exring[cid].unit[i].ea04dr         = 0;
    exring[cid].unit[i].ea14woofs_prev = 0;   /* ★siml-loop only */
    exring[cid].unit[i].ea14dr         = 0;
    exring[cid].unit[i].tx4dr[0]       = 0LL;
    exring[cid].unit[i].tx4dr[1]       = 0LL;
    exring[cid].unit[i].tx4dr[2]       = 0LL;
    exring[cid].unit[i].tx4dr[3]       = 0LL;
    exring[cid].unit[i].tr_valid       = 0;
    exring[cid].unit[i].lmm.en0        = 0;
    exring[cid].unit[i].lmm.en1        = 0;
    exring[cid].unit[i].lmm.rw0        = 0;
    exring[cid].unit[i].lmm.rw1        = 0;
    exring[cid].unit[i].lmm.ma0        = 0;
    exring[cid].unit[i].lmm.ma1        = 0;
    exring[cid].unit[i].lmm.mm0        = 0;
    exring[cid].unit[i].lmm.mw0[0]     = 0LL;
    exring[cid].unit[i].lmm.mw0[1]     = 0LL;
    exring[cid].unit[i].lmm.mw0[2]     = 0LL;
    exring[cid].unit[i].lmm.mw0[3]     = 0LL;
  }
  else {
    exring[cid].unit[i].ex4dr_prev     = exring[cid].unit[i].ex4dr; /* siml-loop only */
    if (exring[cid].unit[i].stage4_exec || exring[cid].unit[i].stage4_fold) { /* active */
      /* LD/STによるLMM参照はlmm_modeの割り当てcycleを厳密に守る. */
      /* ex3dr -> ex4dr */
      if (reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_SFMA) { /* stage4でSFMA加算 */
	if ((!exring[cid].unit[i].one_shot_fold4 || ((reg_ctrl.i[cid].conf[i][j].cdw0.init&1)&&(exring[cid].unit[i].unit1_forstat_fold4&1))) && j==0)
	  softu64(3, NULL, &exring[cid].unit[i].ex3dr, &exring[cid].unit[i].ex4dr, exring[cid].unit[i].ex3passr1, exring[cid].unit[i].ex3passr2, exring[cid].unit[i].ex3passr3, 0LL);
	else
	  softu64(3, NULL, &exring[cid].unit[i].ex3dr, &exring[cid].unit[i].ex4dr, exring[cid].unit[i].ex4dr,     exring[cid].unit[i].ex3passr2, exring[cid].unit[i].ex3passr3, 0LL);
      }
      else 
	exring[cid].unit[i].ex4dr  = exring[cid].unit[i].ex3dr;
    }

    /* lmca/ea3dr -> ea4dr */
    /* exring[cid].unit[i].lmranger_ok   = rw==0 && ty==4 && [br->col].top <= br->a && br->a <= [br->col].bot); */
    /* exring[cid].unit[i].lmrangew_ok   = rw==1 && ty==4 && [br->col].top <= br->a && br->a <= [br->col].bot); */
    /* exring[cid].unit[i].lmlddmqw_ok   = rw==1 && ty==3 && [br->col].op1==LDDMQ   */
    /* exring[cid].unit[i].lmea0sfma     = STBR[*];                                 */
    /* exring[cid].unit[i].lmea0strq     = STRQ[*];                                 */
    /* exring[cid].unit[i].lmea0strqcol  = STRQ[*];                                 */
    /* exring[cid].unit[i].lmring_ea0bsy = EXEC && (normal_op0||(STBR[*]||STRQ[*]));*/
    /* exring[cid].unit[i].lmring_ea1bsy = EXEC && (normal_op1);                    */
    /* exring[cid].unit[i].lmring_ful    = NEXT_TR+NEXT_BR==FULL;                   */
    /* exring[cid].unit[i].deq_wait      = lmring_ful | (ranger_ok & ea1bsy) | (rangew_ok & ea0bsy) | (lddmqw_ok & col!=j); */

    /* eaop0/eaop1を直接検査するので,conf.mwsaは使わなくて良い */
    /* (NOP | EXEC) & !deq_wait & lmrangew_okの時 lmwa->ea04dr */
    /* lmring_ea0bsy                         の時,ea0d->ea04dr */
    exring[cid].unit[i].ea04woofs_prev = exring[cid].unit[i].ea04woofs; /* ★siml-loop only */
    exring[cid].unit[i].ea04woofs      = exring[cid].unit[i].ea03woofs; /* ★ */
    if ((exring[cid].unit[i].cmd == CMD_NOP || exring[cid].unit[i].cmd == CMD_EXEC)
      && ful2 && !deq_wait && exring[cid].unit[i].lmrangew_ok) { /* axi->lmm_write */
      /* LMEM_SIZE(128KB)/4 = 32KB... lmm_mode=1:adr=(block=col&0)*(LMEM_SIZE/4) | (ofs=adr&(LMEM_SIZE/1-1)) */
      /*                              lmm_mode=2:adr=(block=col&2)*(LMEM_SIZE/4) | (ofs=adr&(LMEM_SIZE/2-1)) */
      /*                              lmm_mode=3:adr=(block=col&3)*(LMEM_SIZE/4) | (ofs=adr&(LMEM_SIZE/4-1)) */
      switch (reg_ctrl.i[cid].conf[i][exring[cid].unit[i].lmco].cdw2.lmm_mode) {
      case 0: exring[cid].unit[i].ea04_umask = LMEM_UMASK0; exring[cid].unit[i].ea04_lmask = LMEM_LMASK0; break;
      case 1: exring[cid].unit[i].ea04_umask = LMEM_UMASK1; exring[cid].unit[i].ea04_lmask = LMEM_LMASK1; break;
      case 2: exring[cid].unit[i].ea04_umask = LMEM_UMASK2; exring[cid].unit[i].ea04_lmask = LMEM_LMASK2; break;
      case 3: exring[cid].unit[i].ea04_umask = LMEM_UMASK3; exring[cid].unit[i].ea04_lmask = LMEM_LMASK3; break;
      }
      exring[cid].unit[i].ea04dr      = ((exring[cid].unit[i].lmco & exring[cid].unit[i].ea04_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].lmca & exring[cid].unit[i].ea04_lmask);
      exring[cid].unit[i].lmm.en0     = 1;
      exring[cid].unit[i].lmm.rw0     = 1; /* write */
      exring[cid].unit[i].lmm.ma0     = (exring[cid].unit[i].ea04dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
      exring[cid].unit[i].lmm.mm0     = exring[cid].unit[i].lmwm;
      exring[cid].unit[i].lmm.mw0[0]  = exring[cid].unit[i].lmwd[0];
      exring[cid].unit[i].lmm.mw0[1]  = exring[cid].unit[i].lmwd[1];
      exring[cid].unit[i].lmm.mw0[2]  = exring[cid].unit[i].lmwd[2];
      exring[cid].unit[i].lmm.mw0[3]  = exring[cid].unit[i].lmwd[3];
#if 0
printf("====== WLMM row=%x br.col=%x ====axir=%x axiw=%x br->rw=%x br->ty=%x a=%08.8x lmranger_ok=%x lmrangew_ok=%x top=%08.8x bot=%08.8x\n", i, br->col, reg_ctrl.i[cid].conf[i][br->col].cdw2.lmm_axir, reg_ctrl.i[cid].conf[i][br->col].cdw2.lmm_axiw, br->rw, br->ty, br->a, exring[cid].unit[i].lmranger_ok, exring[cid].unit[i].lmrangew_ok, reg_ctrl.i[cid].addr[i][br->col].top, reg_ctrl.i[cid].addr[i][br->col].bot);
#endif
    }
    else if (exring[cid].unit[i].lmring_ea0bsy) { /* EXEC & ea0d->lmm_write/read (STRQ/SFMAの毎サイクル実行もここ) */
      int kmex0;
      k = (exring[cid].unit[i].lmea0sfma || exring[cid].unit[i].lmea0strq) ? exring[cid].unit[i].lmea0strqcol : j;
      /* ★★★★★★★★★★★MEX0用のADDR_MASK */
      /* conf[][col=2/3]mex0opは,conf[][col=1  ].lmm_modeを参照 */
      /* conf[][col=1  ]mex0opは,conf[][col=0  ].lmm_modeを参照 */
      kmex0 = ((reg_ctrl.i[cid].conf[i][2].cdw0.mex0op==OP_CMPA_LE || reg_ctrl.i[cid].conf[i][2].cdw0.mex0op==OP_CMPA_GE) && reg_ctrl.i[cid].conf[i][j].cdw1.ea0op < OP_IM_BUFWR) ? ((j==1||j==0)?0:1) : k; /* ★ */
      /* ★★★★★★★★★★★MEX0用のLD */
      /* if (i==2 && k==2) printf("[2][2] mexop0=%d\n", reg_ctrl.i[cid].conf[i][k].cdw0.mex0op); */
      switch (reg_ctrl.i[cid].conf[i][kmex0].cdw2.lmm_mode) {   /* ★ */
      case 0: exring[cid].unit[i].ea04_umask = LMEM_UMASK0; exring[cid].unit[i].ea04_lmask = LMEM_LMASK0; break;
      case 1: exring[cid].unit[i].ea04_umask = LMEM_UMASK1; exring[cid].unit[i].ea04_lmask = LMEM_LMASK1; break;
      case 2: exring[cid].unit[i].ea04_umask = LMEM_UMASK2; exring[cid].unit[i].ea04_lmask = LMEM_LMASK2; break;
      case 3: exring[cid].unit[i].ea04_umask = LMEM_UMASK3; exring[cid].unit[i].ea04_lmask = LMEM_LMASK3; break;
      }
      exring[cid].unit[i].ea04dr   = ((kmex0 & exring[cid].unit[i].ea04_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea03dr & exring[cid].unit[i].ea04_lmask); /* ★ */
      /* if (i==2 && k==2) printf("kmex0=%d lmm_mode=%d ea04dr=%08.8x\n", kmex0, reg_ctrl.i[cid].conf[i][kmex0].cdw2.lmm_mode, (Uint)exring[cid].unit[i].ea04dr); */
      exring[cid].unit[i].lmm.en0  = 1;
      exring[cid].unit[i].lmm.rw0  = (reg_ctrl.i[cid].conf[i][k].cdw1.ea0op & 0x10)!=0; /* read/write */
      exring[cid].unit[i].lmm.ma0  = (exring[cid].unit[i].ea04dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
                                        /* OP_TR   の場合,eag0->WRITE,eag1->READ */
                                        /* OP_LDDMQの場合,eag0->WRITE,eag1->READ */
      /* mws[0-3]:2; 0:lmwd1, 1:exdr, 2:ts1 */
      exring[cid].unit[i].mwmux[0] = reg_ctrl.i[cid].conf[i][k].cdw2.mws0==1 ? exring[cid].unit[i].ex4dr : exring[cid].unit[i].tx3dr[0]; /* ex3dr->ex4dr for SFMR+STBR */
      exring[cid].unit[i].mwmux[1] = reg_ctrl.i[cid].conf[i][k].cdw2.mws1==1 ? exring[cid].unit[i].ex4dr : exring[cid].unit[i].tx3dr[1]; /* ex3dr->ex4dr for SFMR+STBR */
      exring[cid].unit[i].mwmux[2] = reg_ctrl.i[cid].conf[i][k].cdw2.mws2==1 ? exring[cid].unit[i].ex4dr : exring[cid].unit[i].tx3dr[2]; /* ex3dr->ex4dr for SFMR+STBR */
      exring[cid].unit[i].mwmux[3] = reg_ctrl.i[cid].conf[i][k].cdw2.mws3==1 ? exring[cid].unit[i].ex4dr : exring[cid].unit[i].tx3dr[3]; /* ex3dr->ex4dr for SFMR+STBR */
      switch (reg_ctrl.i[cid].conf[i][k].cdw1.ea0op) {
      case OP_STR:
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfffffff0) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x0000000f : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff0f) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&2)) ? 0x000000f0 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfffff0ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000f00 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff0fff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&2)) ? 0x0000f000 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfff0ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x000f0000 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff0fffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&2)) ? 0x00f00000 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xf0ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x0f000000 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x0fffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&2)) ? 0xf0000000 : 0x00000000);
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]; /* align不要 */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]; /* align不要 */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]; /* align不要 */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]; /* align不要 */
        break;
      case OP_STWR:
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x0000000f<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000f00<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x000f0000<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x0f000000<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
        break;
#if 0
      case OP_STHR:
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000003<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000300<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00030000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x03000000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
        break;
#endif
      case OP_STBR:
        if (exring[cid].unit[i].lmea0sfma) { /* same */	}
	else                               { /* same */ }
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000001<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000100<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00010000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x01000000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
        break;
      case OP_IM_PREF:
      case OP_IM_BUFWR:
        exring[cid].unit[i].lmm.mm0    = 0xffffffff;         /* mask *//* 暫定記述 */
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]; /* 暫定記述 */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]; /* 暫定記述 */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]; /* 暫定記述 */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]; /* 暫定記述 */
        break;
      case OP_STRQ: /* OP_STRQ in target   slot */
        if (exring[cid].unit[i].lmea0strq) {
          /* STRQはSTRを4サイクル分割実行 */
          exring[cid].unit[i].lmm.mm0 = 0x000000ff << (j<<3);
          exring[cid].unit[i].lmm.mw0[j] = exring[cid].unit[i].mwmux[j]; /* align不要 */
        }
        break;
      default:
        break;
      }
      /*printf("===BUFWR write row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)exring[cid].unit[i][j].ea1d, (Uint)exring[cid].unit[i][j].ea0d);*/
    }
    else
      exring[cid].unit[i].lmm.en0     = 0;

    /* (NOP | EXEC) & !deq_wait & lmranger_okの時 lmra->ea14dr */
    /* lmring_ea1bsy                         の時,ea1d->ea14dr */
    exring[cid].unit[i].ea14woofs_prev = exring[cid].unit[i].ea14woofs; /* ★siml-loop only */
    exring[cid].unit[i].ea14woofs      = exring[cid].unit[i].ea13woofs; /* ★ */
    if ((exring[cid].unit[i].cmd == CMD_NOP || exring[cid].unit[i].cmd == CMD_EXEC)
      && ful2 && !deq_wait && exring[cid].unit[i].lmranger_ok) { /* axi->lmm_read */
      /* LMEM_SIZE(128KB)/4 = 32KB... lmm_mode=1:adr=(block=col&0)*(LMEM_SIZE/4) | (ofs=adr&(LMEM_SIZE/1-1)) */
      /*                              lmm_mode=2:adr=(block=col&2)*(LMEM_SIZE/4) | (ofs=adr&(LMEM_SIZE/2-1)) */
      /*                              lmm_mode=3:adr=(block=col&3)*(LMEM_SIZE/4) | (ofs=adr&(LMEM_SIZE/4-1)) */
      switch (reg_ctrl.i[cid].conf[i][exring[cid].unit[i].lmco].cdw2.lmm_mode) {
      case 0: exring[cid].unit[i].ea14_umask = LMEM_UMASK0; exring[cid].unit[i].ea14_lmask = LMEM_LMASK0; break;
      case 1: exring[cid].unit[i].ea14_umask = LMEM_UMASK1; exring[cid].unit[i].ea14_lmask = LMEM_LMASK1; break;
      case 2: exring[cid].unit[i].ea14_umask = LMEM_UMASK2; exring[cid].unit[i].ea14_lmask = LMEM_LMASK2; break;
      case 3: exring[cid].unit[i].ea14_umask = LMEM_UMASK3; exring[cid].unit[i].ea14_lmask = LMEM_LMASK3; break;
      }
      exring[cid].unit[i].ea14dr      = ((exring[cid].unit[i].lmco & exring[cid].unit[i].ea14_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].lmca & exring[cid].unit[i].ea14_lmask);
      exring[cid].unit[i].lmm.en1     = 1;
      exring[cid].unit[i].lmm.rw1     = 0; /* read */
      exring[cid].unit[i].lmm.ma1     = (exring[cid].unit[i].ea14dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
#if 0
printf("====== RLMM row=%x br.col=%x ====axir=%x axiw=%x br->rw=%x br->ty=%x a=%08.8x lmranger_ok=%x lmrangew_ok=%x top=%08.8x bot=%08.8x\n", i, br->col, reg_ctrl.i[cid].conf[i][br->col].cdw2.lmm_axir, reg_ctrl.i[cid].conf[i][br->col].cdw2.lmm_axiw, br->rw, br->ty, br->a, exring[cid].unit[i].lmranger_ok, exring[cid].unit[i].lmrangew_ok, reg_ctrl.i[cid].addr[i][br->col].top, reg_ctrl.i[cid].addr[i][br->col].bot);
#endif
    }
    else if (exring[cid].unit[i].lmring_ea1bsy) { /* EXEC & ea1d->lmm_read */
      int kmex1;
      /* ★★★★★★★★★★★MEX1用のADDR_MASK */
      /* conf[][col=2/3]mex1opは,conf[][col=2/3].lmm_modeを参照 */
      /* conf[][col=1  ]mex1opは,conf[][col=0  ].lmm_modeを参照 */
      kmex1 = ((reg_ctrl.i[cid].conf[i][2].cdw0.mex0op==OP_CMPA_LE || reg_ctrl.i[cid].conf[i][2].cdw0.mex0op==OP_CMPA_GE) && reg_ctrl.i[cid].conf[i][j].cdw1.ea1op < OP_IM_BUFRD) ? ((j==1||j==0)?0:j) : j; /* ★ */
      /* ★★★★★★★★★★★MEX1用のLD */
      /* if (i==2 && j==2) printf("[2][2] mexop1=%d\n", reg_ctrl.i[cid].conf[i][j].cdw0.mex1op); */
      switch (reg_ctrl.i[cid].conf[i][kmex1].cdw2.lmm_mode) {
      case 0: exring[cid].unit[i].ea14_umask = LMEM_UMASK0; exring[cid].unit[i].ea14_lmask = LMEM_LMASK0; break;
      case 1: exring[cid].unit[i].ea14_umask = LMEM_UMASK1; exring[cid].unit[i].ea14_lmask = LMEM_LMASK1; break;
      case 2: exring[cid].unit[i].ea14_umask = LMEM_UMASK2; exring[cid].unit[i].ea14_lmask = LMEM_LMASK2; break;
      case 3: exring[cid].unit[i].ea14_umask = LMEM_UMASK3; exring[cid].unit[i].ea14_lmask = LMEM_LMASK3; break;
      }
      exring[cid].unit[i].ea14dr   = ((kmex1 & exring[cid].unit[i].ea14_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea13dr & exring[cid].unit[i].ea14_lmask);
      /* if (i==2 && k==2) printf("ea14dr=%08.8x\n", (Uint)exring[cid].unit[i].ea14dr); */
      exring[cid].unit[i].lmm.en1  = 1;
      exring[cid].unit[i].lmm.rw1  = 0; /* read */
      exring[cid].unit[i].lmm.ma1  = (exring[cid].unit[i].ea14dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
      /*printf("===NLOAD read row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)exring[cid].unit[i][j].ea1d, (Uint)exring[cid].unit[i][j].ea0d);*/
    }
    else
      exring[cid].unit[i].lmm.en1  = 0;

    /* lmwd/tx3dr -> tx4dr */
    if (exring[cid].unit[i].stage4_exec) { /* active */
      /* 0:lmwd0, 1:exdr, 2:ts0 *//* 0:TR外部書き込み用, 1,2:EX/TS書き込み用 */
      if (reg_ctrl.i[cid].conf[i][j].cdw1.ea1op == OP_LDDMQ) {
        if (exring[cid].unit[i].lmlddmqw_ok && br->col == j) {
          exring[cid].unit[i].tx4dr[0] = exring[cid].unit[i].lmwd[0];
          exring[cid].unit[i].tx4dr[1] = exring[cid].unit[i].lmwd[1];
          exring[cid].unit[i].tx4dr[2] = exring[cid].unit[i].lmwd[2];
          exring[cid].unit[i].tx4dr[3] = exring[cid].unit[i].lmwd[3];
          exring[cid].unit[i].tr_valid = 1;
        }
        else
          exring[cid].unit[i].tr_valid = 0; /* no data for OP_LDDMQ */
      }
      else { /* trs==0の場合,lmwd->trだが,LDDMQ以外に使用するケースはない */
        exring[cid].unit[i].tx4dr[0] = reg_ctrl.i[cid].conf[i][j].cdw2.trs0==1 ? exring[cid].unit[i].ex4dr : exring[cid].unit[i].tx3dr[0]; /* ex3dr->ex4dr for SFMR+STBR */
        exring[cid].unit[i].tx4dr[1] = reg_ctrl.i[cid].conf[i][j].cdw2.trs1==1 ? exring[cid].unit[i].ex4dr : exring[cid].unit[i].tx3dr[1]; /* ex3dr->ex4dr for SFMR+STBR */
        exring[cid].unit[i].tx4dr[2] = reg_ctrl.i[cid].conf[i][j].cdw2.trs2==1 ? exring[cid].unit[i].ex4dr : exring[cid].unit[i].tx3dr[2]; /* ex3dr->ex4dr for SFMR+STBR */
        exring[cid].unit[i].tx4dr[3] = reg_ctrl.i[cid].conf[i][j].cdw2.trs3==1 ? exring[cid].unit[i].ex4dr : exring[cid].unit[i].tx3dr[3]; /* ex3dr->ex4dr for SFMR+STBR */
        exring[cid].unit[i].tr_valid = 1;
      }
    }
  }

  return (0);
}

siml_unit_stage5(Uint cid, Uint i) /* stage-5 (3DR->BROUT)(LMRING_TR->LMRING_BROUT) */
{
  /******************************************************************************************************************************************************************************************/
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /* reg_ctrl.cmd -----------------<==EXEC=========X==NOP>================================================================================================================================= */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         ----------------------------------<==EXEC=========================================================================================================================>------- */
  /* one_shot    __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* unit1_exec  __________________________________/~~(l_row==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* reg_ctrl.stat---------------------------------<==EXRING_BUSY==================================================================================>--------------------------------------- */

  /* reg_ctrl.cmd -----------------<==SCON=========X==NOP>================================================================================================================================= */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         ----------------------------------<==SCON=========================================================================================>--------------------------------------- */
  /* scon_count  ----------------------------------<==conf.mapdist*2===============X==conf.mapdist*2-1=============X==0============================>======================================= */
  /*                                                      Ascon2  Ascon2  Ascon2  Ascon2  Ascon1  Ascon1  Ascon1  Ascon1                                                                    */
  /*                                                      ->br0   ->br1   ->br2   ->br3   br0->   br1->   br2->   br3->                                                                     */
  /* unit1_exec  __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* stage1out** --------------------------------------------------------------------------<== 0===X== 1===X== 2===X== 3===>--------------------------------------------------------------- */
  /* stage4out** ------------------------------------------<== 0===X== 1===X== 2===X== 3===>----------------------------------------------------------------------------------------------- */
  /* reg_ctrl.stat---------------------------------<==EXRING_BUSY==================================================>----------------------------------------------------------------------- */

  /******************************************************************************************************************************************************************************************/
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* brout_valid __/~~(l_row==row0-1)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- row[i]--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         --<==EXEC=========================================================================================================================================================>------- */
  /* one_shot    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* unit1_exec  __/~~(l_row==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* stage1out** ----------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */
  /* stage2out   ------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2==> */
  /* stage3out   --------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1==> */
  /* stage4out   -------tx4dr----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0==> */
  /* tr_valid    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* stage5out   -------brout------------------------------<==p0===X==p1===X==p2===X==p3===X==q0===X==q1===X==q2===X==q3===X==q0===X==q1===X==q2===X==q3===X==q0===X==q1===X==q2===X==q3==> */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- row[i+1]------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         --<==EXEC=========================================================================================================================================================>------- */
  /* one_shot    __________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* stage1out   --------------------------------------------------------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */

  int ni = (i+1)%EMAX_DEPTH;
  int b  =~(exring[cid].unit[i].cycle / EMAX_WIDTH)&1; /* 1,1,1,1,0,0,0,0 */
  int j  =  exring[cid].unit[i].cycle % EMAX_WIDTH;    /* 0,1,2,3,0,1,2,3 */
  int k;
  struct lmring_tr *tr = &exring[cid].unit[i].lmring_tr;
  struct lmring_br *br = &exring[cid].unit[i].lmring_br[exring[cid].unit[i].lmring_b_top];
  int          br_ful2 = exring[cid].unit[i].lmring_ful2;
  int         deq_wait = ((i+1)%(EMAX_DEPTH/LMRING_MUX)==0)?axiif[cid].deq_wait           /* axi  deq_wait */
                                                           :exring[cid].unit[ni].deq_wait;/* next deq_wait */
  int cdx = tr->a / (REG_AREA_MASK+1) & (EMAX_NCHIP-1);               /* for registers */
  int idx = tr->a & (sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH*EMAX_DEPTH-1); /* for registers */
  int row = idx/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K/128B=0........63 *//* 64 rows */
  int ofs = idx%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K%128B=0,8,...,120 *//* 16 regs */

  Ull a0, a1, d;

  /* LMRING_BR LMRD BR */
#if 0
  Ull   mr0mux        : 2; /* mr0[3-0] -> brs0     */
  Ull   mr1mux        : 2; /* mr1[3-0] -> brs1     */
  Ull   mr0d             ; /* muxed data for BR[0] */
  Ull   mr1d             ; /* muxed data for BR[1] */
  Ull   lmrd[UNIT_WIDTH] ; /* wire *//* -> axi   */
  Ull   brout_valid   : 1; /* BRの状態を表示 常時tr_validを1τ後に伝搬 */
  struct {Ull r[UNIT_WIDTH];} b[2][EMAX_WIDTH]; /* shadow_breg *//* constantは両方にセット */

  Ull   lmring_ful2   : 2; /* 0:empty, 3:full */
  Ull   lmring_b_top  : 2; /* to be enqueued next */
  Ull   lmring_b_bot  : 2; /* to be dequeued next */
  struct lmring_br {
    Ull   rw          : 1; /* 0:read, 1:write */
    Ull   ty          : 3; /* 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
    Ull   col         : 2; /* logical col# for target lmm */
    Ull   sq          :16; /* sequential # for pipelined DMA */
    Ull   av          : 1; /* address valid */
    Ull   a           :31; /* logical addr reg/lmm */
    Ull   dm          :32; /* <- lmm wdata       */
    Ull   d[UNIT_WIDTH]  ; /* <- lmm wdata/rdata */
  } lmring_br[LMRING_BR_BUF];
#endif

  a0   = exring[cid].unit[i].ea04dr;  /* not aligned (lower bits are user for load-select) */
  a1   = exring[cid].unit[i].ea14dr;  /* not aligned (lower bits are user for load-select) */
  exring[cid].unit[i].mr0mux = (a0/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr0[3-0] -> mr0d */
  exring[cid].unit[i].mr0d   = exring[cid].unit[i].lmm.mr0[exring[cid].unit[i].mr0mux];
  exring[cid].unit[i].mr1mux = (a1/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr1[3-0] -> mr0d */
  exring[cid].unit[i].mr1d   = exring[cid].unit[i].lmm.mr1[exring[cid].unit[i].mr1mux];

  exring[cid].unit[i].mexmr0d_prev = exring[cid].unit[i].mexmr0d; /* ★ */
  exring[cid].unit[i].mexmr0d      = exring[cid].unit[i].mr0d;    /* ★ */
  exring[cid].unit[i].mexmr1d_prev = exring[cid].unit[i].mexmr1d; /* ★ */
  exring[cid].unit[i].mexmr1d      = exring[cid].unit[i].mr1d;    /* ★ */

  for (k=0; k<UNIT_WIDTH; k++)
    exring[cid].unit[i].lmrd[k] = exring[cid].unit[i].lmm.mr1[k];

  if (exring[cid].unit[i].cmd == CMD_NOP
      && (exring[cid].unit[i].cycle&3) == 3
      && (reg_ctrl.i[cid].cmd&3) == CMD_RESET) {
    exring[cid].unit[i].brout_valid      = 0;
    for (k=0; k<EMAX_WIDTH; k++) {
      exring[cid].unit[i].b[0][k].r[0]   = 0LL;
      exring[cid].unit[i].b[0][k].r[1]   = 0LL;
      exring[cid].unit[i].b[0][k].r[2]   = 0LL;
      exring[cid].unit[i].b[0][k].r[3]   = 0LL;
      exring[cid].unit[i].b[1][k].r[0]   = 0LL;
      exring[cid].unit[i].b[1][k].r[1]   = 0LL;
      exring[cid].unit[i].b[1][k].r[2]   = 0LL;
      exring[cid].unit[i].b[1][k].r[3]   = 0LL;
    }
  }
  else if (exring[cid].unit[i].cmd == CMD_NOP && ((reg_ctrl.i[cid].cmd>>16) == cdx || cdx == 0) && exring[cid].unit[i].l_row == row && exring[cid].unit[i].lmring_ful1) { /* reg setup by PIO */
#if 0
if (tr->ty<4)
printf("====== WREG chip=%d cdx=%d l_row=%x row=%x cmd=%d ==== tr->ty=%x a=%08.8x dm=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n", (Uint)(reg_ctrl.i[cid].cmd>>16), cdx, exring[cid].unit[i].l_row, row, exring[cid].unit[i].cmd&3, tr->ty, tr->a, tr->dm, (Uint)(tr->d[3]>>32), (Uint)(tr->d[3]), (Uint)(tr->d[2]>>32), (Uint)(tr->d[2]), (Uint)(tr->d[1]>>32), (Uint)(tr->d[1]), (Uint)(tr->d[0]>>32), (Uint)(tr->d[0]));
#endif
    switch (tr->ty) {
    case 0: /* reg/conf */
      if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].conf[i]+ofs)+0) = tr->d[0];     }
      if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].conf[i]+ofs)+1) = tr->d[0]>>32; }
      if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].conf[i]+ofs)+2) = tr->d[1];     }
      if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].conf[i]+ofs)+3) = tr->d[1]>>32; }
      if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].conf[i]+ofs)+4) = tr->d[2];     }
      if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].conf[i]+ofs)+5) = tr->d[2]>>32; }
      if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].conf[i]+ofs)+6) = tr->d[3];     }
      if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].conf[i]+ofs)+7) = tr->d[3]>>32; }
      break;
    case 1: /* reg/breg */
      if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+0) = tr->d[0];     *((Uint*)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+0) = tr->d[0];     }
      if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+1) = tr->d[0]>>32; *((Uint*)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+1) = tr->d[0]>>32; }
      if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+2) = tr->d[1];     *((Uint*)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+2) = tr->d[1];     }
      if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+3) = tr->d[1]>>32; *((Uint*)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+3) = tr->d[1]>>32; }
      if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+4) = tr->d[2];     *((Uint*)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+4) = tr->d[2];     }
      if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+5) = tr->d[2]>>32; *((Uint*)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+5) = tr->d[2]>>32; }
      if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+6) = tr->d[3];     *((Uint*)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+6) = tr->d[3];     }
      if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+7) = tr->d[3]>>32; *((Uint*)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+7) = tr->d[3]>>32; }
      break;
    case 2: /* reg/addr */
      if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+0) = tr->d[0];     }
      if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+1) = tr->d[0]>>32; }
      if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+2) = tr->d[1];     }
      if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+3) = tr->d[1]>>32; }
      if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+4) = tr->d[2];     }
      if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+5) = tr->d[2]>>32; }
      if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+6) = tr->d[3];     }
      if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+7) = tr->d[3]>>32; }
      break;
    case 3: /* lddmq/tr */
      if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+0) = tr->d[0];   }/* only write is implemented */
      if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+1) = tr->d[1];   }/* only write is implemented */
      if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+2) = tr->d[2];   }/* only write is implemented */
      if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+3) = tr->d[3];   }/* only write is implemented */
      break;
    }
  }
  else if (exring[cid].unit[i].cmd == CMD_SCON) {
    if (exring[cid].unit[i].unit1_exec && !(exring[cid].unit[i].scon_count & 1)) {
      exring[cid].unit[i].b[0][j].r[0] = *((Ull*)(&reg_ctrl.i[cid].conf[i][j])+0);
      exring[cid].unit[i].b[0][j].r[1] = *((Ull*)(&reg_ctrl.i[cid].conf[i][j])+1);
      exring[cid].unit[i].b[0][j].r[2] = *((Ull*)(&reg_ctrl.i[cid].conf[i][j])+2);
      exring[cid].unit[i].b[0][j].r[3] = *((Ull*)(&reg_ctrl.i[cid].conf[i][j])+3);
    }
  }
  else if (exring[cid].unit[i].cmd == CMD_EXEC) {
    if (((reg_ctrl.i[cid].cmd>>16) == cdx || cdx == 0) && exring[cid].unit[i].l_row == row && exring[cid].unit[i].lmring_ful1) { /* reg setup by PIO */
#if 0
if (tr->ty<4)
printf("====== WREG chip=%d cdx=%d l_row=%x row=%x cmd=%d ==== tr->ty=%x a=%08.8x dm=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n", (Uint)(reg_ctrl.i[cid].cmd>>16), cdx, exring[cid].unit[i].l_row, row, exring[cid].unit[i].cmd&3, tr->ty, tr->a, tr->dm, (Uint)(tr->d[3]>>32), (Uint)(tr->d[3]), (Uint)(tr->d[2]>>32), (Uint)(tr->d[2]), (Uint)(tr->d[1]>>32), (Uint)(tr->d[1]), (Uint)(tr->d[0]>>32), (Uint)(tr->d[0]));
#endif
      switch (tr->ty) {
      case 2: /* reg/addr */
        if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+0) = tr->d[0];     }
        if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+1) = tr->d[0]>>32; }
        if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+2) = tr->d[1];     }
        if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+3) = tr->d[1]>>32; }
        if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+4) = tr->d[2];     }
        if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+5) = tr->d[2]>>32; }
        if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+6) = tr->d[3];     }
        if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+7) = tr->d[3]>>32; }
        break;
      case 3: /* lddmq/tr */
        if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+0) = tr->d[0];   }/* only write is implemented */
        if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+1) = tr->d[1];   }/* only write is implemented */
        if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+2) = tr->d[2];   }/* only write is implemented */
        if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+3) = tr->d[3];   }/* only write is implemented */
        break;
      }
    }
    /* load mr -> br0 *//* brs0: 0:off, 1:mr10, 2:tr0, 3:mr0 */
    switch (reg_ctrl.i[cid].conf[i][j].cdw2.brs0) {
    case 0:                                                                    break; /* off */
    case 1: exring[cid].unit[i].b[b][j].r[0] = exring[cid].unit[i].lmm.mr1[0]; break; /* 1:mr10 align不要 */
    case 2: exring[cid].unit[i].b[b][j].r[0] = exring[cid].unit[i].tx4dr[0];   break; /* 2:tr0  align不要 */
    case 3:                                                                           /* 3:mr0  align必要 */
      switch (reg_ctrl.i[cid].conf[i][j].cdw1.ea0op) {
      case OP_LDR :
	switch (a0&7) { /* unaligned load */
	case 0:      exring[cid].unit[i].b[b][j].r[0] =                                            exring[cid].unit[i].mr0d;             break;
	default:     exring[cid].unit[i].b[b][j].r[0] = exring[cid].unit[i].mr1d << (8-(a0&7))*8 | exring[cid].unit[i].mr0d >> (a0&7)*8; break;
	}
	break;
      case OP_LDWR:  exring[cid].unit[i].b[b][j].r[0] = (Ull)            (Uint)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
#if 0
      case OP_LDHR:  exring[cid].unit[i].b[b][j].r[0] = (Ull)(Uint)    (Ushort)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
#endif
      case OP_LDBR:  exring[cid].unit[i].b[b][j].r[0] = (Ull)(Uint)     (Uchar)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      }
    }
    /* load mr -> br1 *//* brs1: 0:off, 1:mr11, 2:tr1, 3:mr1 */
    switch (reg_ctrl.i[cid].conf[i][j].cdw2.brs1) {
    case 0:                                                                    break; /* off */
    case 1: exring[cid].unit[i].b[b][j].r[1] = exring[cid].unit[i].lmm.mr1[1]; break; /* 1:mr11 align不要 */
    case 2: exring[cid].unit[i].b[b][j].r[1] = exring[cid].unit[i].tx4dr[1];   break; /* 2:tr1  align不要 */
    case 3:                                                                           /* 3:mr1  align必要 */
      switch (reg_ctrl.i[cid].conf[i][j].cdw1.ea1op) {
      case OP_LDR:   
	switch (a1&7) { /* unaligned load */
	case 0:      exring[cid].unit[i].b[b][j].r[1] =                          exring[cid].unit[i].mr1d;             break;
	default:     exring[cid].unit[i].b[b][j].r[1] =                          exring[cid].unit[i].mr1d >> (a1&7)*8; break;
	}
        break;
      case OP_LDWR:  exring[cid].unit[i].b[b][j].r[1] = (Ull)            (Uint)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
#if 0
      case OP_LDHR:  exring[cid].unit[i].b[b][j].r[1] = (Ull)(Uint)    (Ushort)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
#endif
      case OP_LDBR:  exring[cid].unit[i].b[b][j].r[1] = (Ull)(Uint)     (Uchar)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      }
    }
    /* load mr -> br2 *//* brs2: 0:off, 1:mr12, 2:tr2, 3:exdr    (brs3=3の場合,ea0woofsに接続) */
    switch (reg_ctrl.i[cid].conf[i][j].cdw2.brs2) {
    case 0:                                                                    break; /* off */
    case 1: exring[cid].unit[i].b[b][j].r[2] = exring[cid].unit[i].lmm.mr1[2]; break; /* 1:mr12 align不要 */
    case 2: exring[cid].unit[i].b[b][j].r[2] = exring[cid].unit[i].tx4dr[2];   break; /* 2:tr2  align不要 */
    case 3: if (reg_ctrl.i[cid].conf[i][j].cdw2.brs3!=3)
              exring[cid].unit[i].b[b][j].r[2] = exring[cid].unit[i].ex4dr;
            else
	      exring[cid].unit[i].b[b][j].r[2] = exring[cid].unit[i].ea04woofs;
            break; /* 3:ea0woofs */
    }
    /* load mr -> br3 *//* brs3: 0:off, 1:mr13, 2:tr3, 3:ea1woofs */
    switch (reg_ctrl.i[cid].conf[i][j].cdw2.brs3) {
    case 0:                                                                    break; /* off */
    case 1: exring[cid].unit[i].b[b][j].r[3] = exring[cid].unit[i].lmm.mr1[3]; break; /* 1:mr13 align不要 */
    case 2: exring[cid].unit[i].b[b][j].r[3] = exring[cid].unit[i].tx4dr[3];   break; /* 2:tr3  align不要 */
    case 3: exring[cid].unit[i].b[b][j].r[3] = exring[cid].unit[i].ea14woofs;  break; /* 3:ea1woofs */
    }
  }

  if ((exring[cid].unit[i].cycle&3) == 3) /* final */
    exring[cid].unit[i].brout_valid = exring[cid].unit[i].tr_valid;

  if (exring[cid].unit[i].cmd == CMD_NOP
      && (exring[cid].unit[i].cycle&3) == 3
      && (reg_ctrl.i[cid].cmd&3) == CMD_RESET) {
    exring[cid].unit[i].lmring_ful2    = 0;
    exring[cid].unit[i].lmring_b_top   = 0;
    exring[cid].unit[i].lmring_b_bot   = 0;
    for (k=0; k<LMRING_BR_BUF; k++) {
      exring[cid].unit[i].lmring_br[k].rw   = 0;
      exring[cid].unit[i].lmring_br[k].ty   = 0;
      exring[cid].unit[i].lmring_br[k].col  = 0;
      exring[cid].unit[i].lmring_br[k].sq   = 0;
      exring[cid].unit[i].lmring_br[k].av   = 0;
      exring[cid].unit[i].lmring_br[k].a    = 0;
      exring[cid].unit[i].lmring_br[k].dm   = 0;
      exring[cid].unit[i].lmring_br[k].d[0] = 0LL;
      exring[cid].unit[i].lmring_br[k].d[1] = 0LL;
      exring[cid].unit[i].lmring_br[k].d[2] = 0LL;
      exring[cid].unit[i].lmring_br[k].d[3] = 0LL;
    }
  }
  /* lmring_ful1とlmring_ful2はreg, exring[cid].unit[ni].deq_waitはwire */
  /* 後段からsimlするので,[ni].deq_waitは最新 */
  /* exring[cid].unit[i].lmring_ful1は0に変更し直後のsiml_unit_stage4()にて1に戻る.ハードも同じ */
  /* exring[cid].unit[i].lmring_ful2をここで更新.ハードも同じ */
  else {
    if (exring[cid].unit[i].lmring_ful1) { /* enqueue to lmring_br for next cycle */
      /* enqueue */
      br->rw   = tr->rw;   /* next cycle */
      br->ty   = tr->ty;   /* next cycle */
      br->col  = tr->col;  /* next cycle */
      br->sq   = tr->sq;   /* next cycle */
      br->av   = tr->av;
      br->a    = tr->a;    /* next cycle */
      br->dm   = tr->dm;   /* next cycle */
      *((Uint*)(&br->d[0])+0) = (tr->merge & 0x01) ? *((Uint*)(&exring[cid].unit[i].lmrd[0])+0) : *((Uint*)(&tr->d[0])+0); /* next cycle */
      *((Uint*)(&br->d[0])+1) = (tr->merge & 0x02) ? *((Uint*)(&exring[cid].unit[i].lmrd[0])+1) : *((Uint*)(&tr->d[0])+1); /* next cycle */
      *((Uint*)(&br->d[1])+0) = (tr->merge & 0x04) ? *((Uint*)(&exring[cid].unit[i].lmrd[1])+0) : *((Uint*)(&tr->d[1])+0); /* next cycle */
      *((Uint*)(&br->d[1])+1) = (tr->merge & 0x08) ? *((Uint*)(&exring[cid].unit[i].lmrd[1])+1) : *((Uint*)(&tr->d[1])+1); /* next cycle */
      *((Uint*)(&br->d[2])+0) = (tr->merge & 0x10) ? *((Uint*)(&exring[cid].unit[i].lmrd[2])+0) : *((Uint*)(&tr->d[2])+0); /* next cycle */
      *((Uint*)(&br->d[2])+1) = (tr->merge & 0x20) ? *((Uint*)(&exring[cid].unit[i].lmrd[2])+1) : *((Uint*)(&tr->d[2])+1); /* next cycle */
      *((Uint*)(&br->d[3])+0) = (tr->merge & 0x40) ? *((Uint*)(&exring[cid].unit[i].lmrd[3])+0) : *((Uint*)(&tr->d[3])+0); /* next cycle */
      *((Uint*)(&br->d[3])+1) = (tr->merge & 0x80) ? *((Uint*)(&exring[cid].unit[i].lmrd[3])+1) : *((Uint*)(&tr->d[3])+1); /* next cycle */
      exring[cid].unit[i].lmring_ful2++;
      exring[cid].unit[i].lmring_b_top = (exring[cid].unit[i].lmring_b_top + 1)%LMRING_BR_BUF;
    }
    if (br_ful2 && !deq_wait) { /* dequeued for next cycle */
      exring[cid].unit[i].lmring_ful2--;
      exring[cid].unit[i].lmring_b_bot = (exring[cid].unit[i].lmring_b_bot + 1)%LMRING_BR_BUF;
    }
  }

  return (0);
}

siml_unit_lmm(cid,  i) Uint cid, i;
{
  Uint a0al, a1al;
  Ull mm0[UNIT_WIDTH];
  int k;

  /* write:  cexdr,mw,ma                                -> LMM                      */
  /* read:   cexdr,exdr,mw/tr,ma/ea[01]dr,LMM -> mr[01] -> br,lmrd                  */
  /*        |         |         |         |         |         |         |         | */
  /* clk ___/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/ */
  /* en  ____/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\___________________ */
  /* rw  _______read___/~~~~~~write~~~~~~~~\______read_____________________________ */
  /* ma  -----<   A0  ><   A1   ><   A2   ><   A3   ><   A4   >-------------------- */
  /* mw  --------------<   W1   ><   W2   >---------------------------------------- */
  /* mr  --------------<   R0   >--------------------<   R3   ><   R4   >---------- */

#if 0
  struct lmm {
    Ull   en0         : 1; /* internal reg       */
    Ull   en1         : 1; /* internal reg       */
    Ull   rw0         : 1; /* 0:read, 1:write    */
    Ull   rw1         : 1; /* 0:read,(1:write)   */
    Ull   ma0         :18; /* internal reg  addr(32B aligned)      */
    Ull   ma1         :18; /* internal reg  addr(32B aligned)      */
    Ull   mm0         :32; /* internal reg  mask */
    Ull   mw0[UNIT_WIDTH]; /* internal reg  data */
    Ull   mr0[UNIT_WIDTH]; /* internal wire data */
    Ull   mr1[UNIT_WIDTH]; /* internal wire data */
    Uchar m[LMEM_SIZE]   ; /* local memory       */
  } lmm;
#endif

  a0al    = exring[cid].unit[i].lmm.ma0; /* 64B aligned */
  a1al    = exring[cid].unit[i].lmm.ma1; /* 64B aligned */
  mm0[0]  = ((exring[cid].unit[i].lmm.mm0 & 0x00000001) ? 0x00000000000000ffLL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00000002) ? 0x000000000000ff00LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00000004) ? 0x0000000000ff0000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00000008) ? 0x00000000ff000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00000010) ? 0x000000ff00000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00000020) ? 0x0000ff0000000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00000040) ? 0x00ff000000000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00000080) ? 0xff00000000000000LL : 0x0000000000000000LL);
  mm0[1]  = ((exring[cid].unit[i].lmm.mm0 & 0x00000100) ? 0x00000000000000ffLL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00000200) ? 0x000000000000ff00LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00000400) ? 0x0000000000ff0000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00000800) ? 0x00000000ff000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00001000) ? 0x000000ff00000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00002000) ? 0x0000ff0000000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00004000) ? 0x00ff000000000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00008000) ? 0xff00000000000000LL : 0x0000000000000000LL);
  mm0[2]  = ((exring[cid].unit[i].lmm.mm0 & 0x00010000) ? 0x00000000000000ffLL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00020000) ? 0x000000000000ff00LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00040000) ? 0x0000000000ff0000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00080000) ? 0x00000000ff000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00100000) ? 0x000000ff00000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00200000) ? 0x0000ff0000000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00400000) ? 0x00ff000000000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x00800000) ? 0xff00000000000000LL : 0x0000000000000000LL);
  mm0[3]  = ((exring[cid].unit[i].lmm.mm0 & 0x01000000) ? 0x00000000000000ffLL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x02000000) ? 0x000000000000ff00LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x04000000) ? 0x0000000000ff0000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x08000000) ? 0x00000000ff000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x10000000) ? 0x000000ff00000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x20000000) ? 0x0000ff0000000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x40000000) ? 0x00ff000000000000LL : 0x0000000000000000LL)
           |((exring[cid].unit[i].lmm.mm0 & 0x80000000) ? 0xff00000000000000LL : 0x0000000000000000LL);

  if (exring[cid].unit[i].lmm.en0) {
    if (exring[cid].unit[i].lmm.rw0==0) { /* lmm read enabled */
      for (k=0; k<UNIT_WIDTH; k++)
        exring[cid].unit[i].lmm.mr0[k] = *((Ull*)&exring[cid].unit[i].lmm.m[a0al]+k);
#if 0
      printf("%03.3d.%02.2d:LMM RD0 a=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
             cid, i, a0al,
             (Uint)(exring[cid].unit[i].lmm.mr0[3]>>32), (Uint)exring[cid].unit[i].lmm.mr0[3],
             (Uint)(exring[cid].unit[i].lmm.mr0[2]>>32), (Uint)exring[cid].unit[i].lmm.mr0[2],
             (Uint)(exring[cid].unit[i].lmm.mr0[1]>>32), (Uint)exring[cid].unit[i].lmm.mr0[1],
             (Uint)(exring[cid].unit[i].lmm.mr0[0]>>32), (Uint)exring[cid].unit[i].lmm.mr0[0]);
#endif
    }
    else { /* lmm write enabled */
      for (k=0; k<UNIT_WIDTH; k++)
        *((Ull*)&exring[cid].unit[i].lmm.m[a0al]+k) = (*((Ull*)&exring[cid].unit[i].lmm.m[a0al]+k) & ~mm0[k]) | (exring[cid].unit[i].lmm.mw0[k] & mm0[k]);
#if 0
      printf("%03.3d.%02.2d:LMM WR0 a=%08.8x m=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
             cid, i, a0al, exring[cid].unit[i].lmm.mm0,
             (Uint)(exring[cid].unit[i].lmm.mw0[3]>>32), (Uint)exring[cid].unit[i].lmm.mw0[3],
             (Uint)(exring[cid].unit[i].lmm.mw0[2]>>32), (Uint)exring[cid].unit[i].lmm.mw0[2],
             (Uint)(exring[cid].unit[i].lmm.mw0[1]>>32), (Uint)exring[cid].unit[i].lmm.mw0[1],
             (Uint)(exring[cid].unit[i].lmm.mw0[0]>>32), (Uint)exring[cid].unit[i].lmm.mw0[0]);
#endif
    }
  }

  if (exring[cid].unit[i].lmm.en1 && !exring[cid].unit[i].lmm.rw1) { /* lmm read enabled */
    for (k=0; k<UNIT_WIDTH; k++)
      exring[cid].unit[i].lmm.mr1[k] = *((Ull*)&exring[cid].unit[i].lmm.m[a1al]+k);
#if 0
      printf("%03.3d.%02.2d:LMM RD1 a=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
             cid, i, a1al,
             (Uint)(exring[cid].unit[i].lmm.mr1[3]>>32), (Uint)exring[cid].unit[i].lmm.mr1[3],
             (Uint)(exring[cid].unit[i].lmm.mr1[2]>>32), (Uint)exring[cid].unit[i].lmm.mr1[2],
             (Uint)(exring[cid].unit[i].lmm.mr1[1]>>32), (Uint)exring[cid].unit[i].lmm.mr1[1],
             (Uint)(exring[cid].unit[i].lmm.mr1[0]>>32), (Uint)exring[cid].unit[i].lmm.mr1[0]);
#endif
  }

  return (0);
}

show_emax6_status(cid) Uint cid;
{
  int row, col, i;

  /* Black       0;30     Dark Gray     1;30 */
  /* Blue        0;34     Light Blue    1;34 */
  /* Green       0;32     Light Green   1;32 */
  /* Cyan        0;36     Light Cyan    1;36 */
  /* Red         0;31     Light Red     1;31 */
  /* Purple      0;35     Light Purple  1;35 */
  /* Brown       0;33     Yellow        1;33 */
  /* Light Gray  0;37     White         1;37 */

  /* show axiif */
  printf("=AXIIF[%02.2d]           axiarr-arv-arl-ara    =%d-%d-%08.8x-%08.8x          r_v=%d-%d d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         cid, axiif[cid].axi_arready, axiif[cid].axi_arvalid, axiif[cid].axi_arlen, (Uint)axiif[cid].axi_araddr, axiif[cid].axi_rready, axiif[cid].axi_rvalid,
         (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3], (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
         (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1], (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
  printf("=EXRING[%02.2d].cuy=%d%d_%d axiawr-awv-awl-awa-stb=%d-%d-%08.8x-%08.8x-%08.8x r_v=%d-%d d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         cid, exring[cid].cmd_busy, exring[cid].unit_busy, exring[cid].cycle, axiif[cid].axi_awready, axiif[cid].axi_awvalid, axiif[cid].axi_awlen, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb, axiif[cid].axi_wready, axiif[cid].axi_wvalid,
         (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3], (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
         (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1], (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);

  printf(" reqn=%04.4x srw=%x sadr=%08.8x slen=%04.4x sreq=%04.4x ful2-top-bot=%d-%d-%d",
         axiif[cid].reqn,
         axiif[cid].srw,
         axiif[cid].sadr,
         axiif[cid].slen,
         axiif[cid].sreq,
         axiif[cid].axring_ful2,
         axiif[cid].axring_b_top,
         axiif[cid].axring_b_bot);

  for (col=0; col<AXRING_BR_BUF; col++) {
    if (col>0) printf("                                                           ");
    printf(" XBR[%d].rw-ty-col-sq-av=%x-%x-%x-%04.4x-%x a-dm=%08.8x-%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           col,
           (Uint)axiif[cid].axring_br[col].rw, (Uint)axiif[cid].axring_br[col].ty, axiif[cid].axring_br[col].col, axiif[cid].axring_br[col].sq, axiif[cid].axring_br[col].av, axiif[cid].axring_br[col].a, axiif[cid].axring_br[col].dm,
           (Uint)(axiif[cid].axring_br[col].d[3]>>32), (Uint)axiif[cid].axring_br[col].d[3], (Uint)(axiif[cid].axring_br[col].d[2]>>32), (Uint)axiif[cid].axring_br[col].d[2],
           (Uint)(axiif[cid].axring_br[col].d[1]>>32), (Uint)axiif[cid].axring_br[col].d[1], (Uint)(axiif[cid].axring_br[col].d[0]>>32), (Uint)axiif[cid].axring_br[col].d[0]);
  }

  for (row=0; row<EMAX_DEPTH; row++) {
    /* show conf */
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|conf[%d][%d]-------------------------------------------------", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|\033[1;%dmv%d\033[0m op%02.2x_%x_%x e1/2/3=%x_%d%d/%x_%d/%x_%d 2i%08.8x%08.8x_%d 3i%02.2x_%d",
             reg_ctrl.i[cid].conf[row][col].cdw0.v?36:34, reg_ctrl.i[cid].conf[row][col].cdw0.v,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.op1,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.op2,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.op3,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.ex1brs,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.ex1s,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.ex1exp,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.ex2brs,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.ex2exp,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.ex3brs,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.ex3exp,
             (Uint)(reg_ctrl.i[cid].conf[row][col].cdw3.e2imm>>32),
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw3.e2imm,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.e2is,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.e3imm,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw0.e3is);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|cop=%x%x%x%x_%04.4x ea1=%02.2x_%d_%d_%x ea0=%02.2x_%d_%d_%x eab=%x eao=%x        ",
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.cs3,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.cs2,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.cs1,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.cs0,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.cex_tab,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.ea1op,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.ea1bs,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.ea1os,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.ea1msk,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.ea0op,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.ea0bs,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.ea0os,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.ea0msk,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.eabbrs,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw1.eaobrs);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|ts3-0=%x%x%x%x trs3-0=%x%x%x%x mwsa3210=%x%x%x%x%x brs3-0=%x%x%x%x md=%d lm=%d",
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.ts3,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.ts2,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.ts1,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.ts0,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.trs3,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.trs2,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.trs1,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.trs0,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.mwsa,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.mws3,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.mws2,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.mws1,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.mws0,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.brs3,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.brs2,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.brs1,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.brs0,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.mapdist,
             (Uint) reg_ctrl.i[cid].conf[row][col].cdw2.lmm_mode);
    printf("\n");

    /* show exring-stage1 */
    printf("-stage1-out: cmd=%d cycle=%d", exring[cid].unit[row].cmd, exring[cid].unit[row].cycle);
    printf(" l_row=%02.2d scan_count=%03.3d one_shot=%d \033[1;%dmu1exec=%d\033[0m \033[1;%dmu1fold=%d\033[0m \033[1;%dmu1stop=%d\033[0m \033[1;%dmu2exec=%d\033[0m \033[1;%dmu2fold=%d\033[0m \033[1;%dmu2stop=%d\033[0m\n",
           exring[cid].unit[row].l_row,
           exring[cid].unit[row].scon_count,
           exring[cid].unit[row].one_shot,
           exring[cid].unit[row].unit1_exec?36:34, exring[cid].unit[row].unit1_exec,
           exring[cid].unit[row].unit1_fold?36:34, exring[cid].unit[row].unit1_fold,
           exring[cid].unit[row].unit1_stop?31:34, exring[cid].unit[row].unit1_stop,
           exring[cid].unit[row].unit2_exec?36:34, exring[cid].unit[row].unit2_exec,
           exring[cid].unit[row].unit2_fold?36:34, exring[cid].unit[row].unit2_fold,
           exring[cid].unit[row].unit2_stop?31:34, exring[cid].unit[row].unit2_stop);

    printf("            ");
    printf(" ea31b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.i[cid].addr[row][3].ea1b&0x3ffff, reg_ctrl.i[cid].addr[row][3].ea1o&0x3ffff, reg_ctrl.i[cid].addr[row][3].ea0b&0x3ffff, reg_ctrl.i[cid].addr[row][3].ea0o&0x3ffff, reg_ctrl.i[cid].addr[row][3].top,  reg_ctrl.i[cid].addr[row][3].bot);
    printf(" ea21b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.i[cid].addr[row][2].ea1b&0x3ffff, reg_ctrl.i[cid].addr[row][2].ea1o&0x3ffff, reg_ctrl.i[cid].addr[row][2].ea0b&0x3ffff, reg_ctrl.i[cid].addr[row][2].ea0o&0x3ffff, reg_ctrl.i[cid].addr[row][2].top,  reg_ctrl.i[cid].addr[row][2].bot);
    printf("\n");
    printf("            ");
    printf(" ea11b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.i[cid].addr[row][1].ea1b&0x3ffff, reg_ctrl.i[cid].addr[row][1].ea1o&0x3ffff, reg_ctrl.i[cid].addr[row][1].ea0b&0x3ffff, reg_ctrl.i[cid].addr[row][1].ea0o&0x3ffff, reg_ctrl.i[cid].addr[row][1].top,  reg_ctrl.i[cid].addr[row][1].bot);
    printf(" ea01b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.i[cid].addr[row][0].ea1b&0x3ffff, reg_ctrl.i[cid].addr[row][0].ea1o&0x3ffff, reg_ctrl.i[cid].addr[row][0].ea0b&0x3ffff, reg_ctrl.i[cid].addr[row][0].ea0o&0x3ffff, reg_ctrl.i[cid].addr[row][0].top,  reg_ctrl.i[cid].addr[row][0].bot);
    printf("\n");

    printf("             cx=%d%d%d%d ex123=%08.8x%08.8x/%08.8x%08.8x/%08.8x%08.8x",
           (Uint)exring[cid].unit[row].cx[3],
           (Uint)exring[cid].unit[row].cx[2],
           (Uint)exring[cid].unit[row].cx[1],
           (Uint)exring[cid].unit[row].cx[0],
           (Uint)(exring[cid].unit[row].ex1>>32), (Uint)exring[cid].unit[row].ex1,
           (Uint)(exring[cid].unit[row].ex2>>32), (Uint)exring[cid].unit[row].ex2,
           (Uint)(exring[cid].unit[row].ex3>>32), (Uint)exring[cid].unit[row].ex3);
    printf(" ea1=%05.5x+%05.5x eab/o=%05.5x/%05.5x ea0=%05.5x+%05.5x st2ex=%d st2fd=%d",
           exring[cid].unit[row].ea1b,
           (Uint)exring[cid].unit[row].ea1o&0x3ffff, /* 本当は64bitからMSKにより選択 */
           exring[cid].unit[row].eab,
           (Uint)exring[cid].unit[row].eao&0x3ffff,  /* 本当は64bitからMSKにより選択 */
           exring[cid].unit[row].ea0b,
           (Uint)exring[cid].unit[row].ea0o&0x3ffff, /* 本当は64bitからMSKにより選択 */
           exring[cid].unit[row].stage2_exec, exring[cid].unit[row].stage2_fold);
    printf(" tx3210   =%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           (Uint)(exring[cid].unit[row].tx[3]>>32), (Uint)exring[cid].unit[row].tx[3],
           (Uint)(exring[cid].unit[row].tx[2]>>32), (Uint)exring[cid].unit[row].tx[2],
           (Uint)(exring[cid].unit[row].tx[1]>>32), (Uint)exring[cid].unit[row].tx[1],
           (Uint)(exring[cid].unit[row].tx[0]>>32), (Uint)exring[cid].unit[row].tx[0]);

    /* show exring-stage2 */
    printf("-stage2-out: cx2dr=%x ex2dr=%08.8x%08.8x \033[1;%dmstfstat=%d\033[0m \033[1;%dmu1fstat=%d\033[0m \033[1;%dmarbrk=%d\033[0m       ea12dr=%05.5x                      ea02dr=%05.5x    st3ex=%d st3fd=%d",
           exring[cid].unit[row].cx2dr,
           (Uint)(exring[cid].unit[row].ex2dr>>32), (Uint)exring[cid].unit[row].ex2dr,
           exring[cid].unit[row].stage_forstat?31:34, exring[cid].unit[row].stage_forstat,
           exring[cid].unit[row].unit1_forstat?31:34, exring[cid].unit[row].unit1_forstat,
           exring[cid].unit[row].unit1_arbrk?31:34, exring[cid].unit[row].unit1_arbrk,
           (Uint)exring[cid].unit[row].ea12dr,
           (Uint)exring[cid].unit[row].ea02dr,
           exring[cid].unit[row].stage3_exec, exring[cid].unit[row].stage3_fold);
    printf(" tx2dr3210=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           (Uint)(exring[cid].unit[row].tx2dr[3]>>32), (Uint)exring[cid].unit[row].tx2dr[3],
           (Uint)(exring[cid].unit[row].tx2dr[2]>>32), (Uint)exring[cid].unit[row].tx2dr[2],
           (Uint)(exring[cid].unit[row].tx2dr[1]>>32), (Uint)exring[cid].unit[row].tx2dr[1],
           (Uint)(exring[cid].unit[row].tx2dr[0]>>32), (Uint)exring[cid].unit[row].tx2dr[0]);

    /* show exring-stage3 */
    printf("-stage3-out: cx3dr=%x ex3dr=%08.8x%08.8x                                   ea13dr=%05.5x                      ea03dr=%05.5x    st4ex=%d st4fd=%d",
           exring[cid].unit[row].cx3dr,
           (Uint)(exring[cid].unit[row].ex3dr>>32), (Uint)exring[cid].unit[row].ex3dr,
           (Uint)exring[cid].unit[row].ea13dr,
           (Uint)exring[cid].unit[row].ea03dr,
           exring[cid].unit[row].stage4_exec, exring[cid].unit[row].stage4_fold);
    printf(" tx3dr3210=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           (Uint)(exring[cid].unit[row].tx3dr[3]>>32), (Uint)exring[cid].unit[row].tx3dr[3],
           (Uint)(exring[cid].unit[row].tx3dr[2]>>32), (Uint)exring[cid].unit[row].tx3dr[2],
           (Uint)(exring[cid].unit[row].tx3dr[1]>>32), (Uint)exring[cid].unit[row].tx3dr[1],
           (Uint)(exring[cid].unit[row].tx3dr[0]>>32), (Uint)exring[cid].unit[row].tx3dr[0]);

    /* show exring-stage4 */
    printf("-stage4-out:         ex4dr=%08.8x%08.8x          ",
           (Uint)(exring[cid].unit[row].ex4dr>>32), (Uint)exring[cid].unit[row].ex4dr);
    printf("       ea14um/lm=%x/%05.5x ea14dr=%05.5x    ea04um/lm=%x/%05.5x ea04dr=%05.5x    trval=%d        ",
           exring[cid].unit[row].ea14_umask,
           exring[cid].unit[row].ea14_lmask,
           exring[cid].unit[row].ea14dr,
           exring[cid].unit[row].ea04_umask,
           exring[cid].unit[row].ea04_lmask,
           exring[cid].unit[row].ea04dr,
           exring[cid].unit[row].tr_valid);
    printf(" tx4dr3210=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           (Uint)(exring[cid].unit[row].tx4dr[3]>>32), (Uint)exring[cid].unit[row].tx4dr[3],
           (Uint)(exring[cid].unit[row].tx4dr[2]>>32), (Uint)exring[cid].unit[row].tx4dr[2],
           (Uint)(exring[cid].unit[row].tx4dr[1]>>32), (Uint)exring[cid].unit[row].tx4dr[1],
           (Uint)(exring[cid].unit[row].tx4dr[0]>>32), (Uint)exring[cid].unit[row].tx4dr[0]);
    printf("                                                                                                                            rk-wk-dk-sf-s4-col-e1b-e0b-ful-dqw-fl1=%01.1x-%01.1x-%d-%d-%d-%d-%d-%d-%d-%d-%d\n",
           exring[cid].unit[row].lmranger_ok,
           exring[cid].unit[row].lmrangew_ok,
           exring[cid].unit[row].lmlddmqw_ok,
           exring[cid].unit[row].lmea0sfma,
           exring[cid].unit[row].lmea0strq,
           exring[cid].unit[row].lmea0strqcol,
           exring[cid].unit[row].lmring_ea1bsy,
           exring[cid].unit[row].lmring_ea0bsy,
           exring[cid].unit[row].lmring_ful,
           exring[cid].unit[row].deq_wait,
           exring[cid].unit[row].lmring_ful1);
    printf(" l1.e-rw-a    =%d-%d-%05.5x       mx=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
           exring[cid].unit[row].lmm.en1,
           exring[cid].unit[row].lmm.rw1,
           exring[cid].unit[row].lmm.ma1,
           (Uint)(exring[cid].unit[row].mwmux[3]>>32), (Uint)exring[cid].unit[row].mwmux[3],
           (Uint)(exring[cid].unit[row].mwmux[2]>>32), (Uint)exring[cid].unit[row].mwmux[2],
           (Uint)(exring[cid].unit[row].mwmux[1]>>32), (Uint)exring[cid].unit[row].mwmux[1],
           (Uint)(exring[cid].unit[row].mwmux[0]>>32), (Uint)exring[cid].unit[row].mwmux[0]);
    printf("                       lmwd lmco-ca-m-d=%d-%05.5x-%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           exring[cid].unit[row].lmco,
           exring[cid].unit[row].lmca,
           exring[cid].unit[row].lmwm,
           (Uint)(exring[cid].unit[row].lmwd[3]>>32), (Uint)exring[cid].unit[row].lmwd[3],
           (Uint)(exring[cid].unit[row].lmwd[2]>>32), (Uint)exring[cid].unit[row].lmwd[2],
           (Uint)(exring[cid].unit[row].lmwd[1]>>32), (Uint)exring[cid].unit[row].lmwd[1],
           (Uint)(exring[cid].unit[row].lmwd[0]>>32), (Uint)exring[cid].unit[row].lmwd[0]);
    printf(" l0.e-rw-a-m-d=%d-%d-%05.5x-%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
           exring[cid].unit[row].lmm.en0,
           exring[cid].unit[row].lmm.rw0,
           exring[cid].unit[row].lmm.ma0,
           exring[cid].unit[row].lmm.mm0,
           (Uint)(exring[cid].unit[row].lmm.mw0[3]>>32), (Uint)exring[cid].unit[row].lmm.mw0[3],
           (Uint)(exring[cid].unit[row].lmm.mw0[2]>>32), (Uint)exring[cid].unit[row].lmm.mw0[2],
           (Uint)(exring[cid].unit[row].lmm.mw0[1]>>32), (Uint)exring[cid].unit[row].lmm.mw0[1],
           (Uint)(exring[cid].unit[row].lmm.mw0[0]>>32), (Uint)exring[cid].unit[row].lmm.mw0[0]);
    printf(" LTR.rw-t-c-s-m-v-a-m-d=%x-%x-%x-%04.4x-%x-%x-%08.8x-%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           exring[cid].unit[row].lmring_tr.rw,
           exring[cid].unit[row].lmring_tr.ty,
           exring[cid].unit[row].lmring_tr.col,
           exring[cid].unit[row].lmring_tr.sq,
           exring[cid].unit[row].lmring_tr.merge,
           exring[cid].unit[row].lmring_tr.av,
           exring[cid].unit[row].lmring_tr.a,
           exring[cid].unit[row].lmring_tr.dm,
           (Uint)(exring[cid].unit[row].lmring_tr.d[3]>>32), (Uint)exring[cid].unit[row].lmring_tr.d[3],
           (Uint)(exring[cid].unit[row].lmring_tr.d[2]>>32), (Uint)exring[cid].unit[row].lmring_tr.d[2],
           (Uint)(exring[cid].unit[row].lmring_tr.d[1]>>32), (Uint)exring[cid].unit[row].lmring_tr.d[1],
           (Uint)(exring[cid].unit[row].lmring_tr.d[0]>>32), (Uint)exring[cid].unit[row].lmring_tr.d[0]);

    /* show exring-stage5 */
    printf("-stage5-out:\n");
    for (col=0; col<EMAX_WIDTH; col++) {
      Uint lmm_mode, umask, lmask, toph, topl, both, botl; /* 18bits */
      lmm_mode = reg_ctrl.i[cid].conf[row][col].cdw2.lmm_mode;
      switch (lmm_mode) {
      case 0: umask = LMEM_UMASK0; lmask = LMEM_LMASK0; break;
      case 1: umask = LMEM_UMASK1; lmask = LMEM_LMASK1; break;
      case 2: umask = LMEM_UMASK2; lmask = LMEM_LMASK2; break;
      case 3: umask = LMEM_UMASK3; lmask = LMEM_LMASK3; break;
      }
      if (reg_ctrl.i[cid].conf[row][col].cdw1.ea0op == OP_IM_BUFWR
        ||reg_ctrl.i[cid].conf[row][col].cdw1.ea1op == OP_IM_BUFRD) { /* sequential from addr=0 (including OP_LDDMQ) */
        toph = ((col & umask) * (LMEM_SIZE/4)) | (sizeof(Ull)*15 & lmask);
        topl = ((col & umask) * (LMEM_SIZE/4)) | (0              & lmask);
        printf(" \033[1;33mlm%d(%d):%08.8x-%08.8x\033[0m", col, lmm_mode, toph, topl);
        for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull))
          printf("-%08.8x%08.8x", (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[toph-i]>>32), (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[toph-i]));
        printf("\n");
        both = ((col & umask) * (LMEM_SIZE/4)) | ((LMEM_SIZE-sizeof(Ull)               ) & lmask);
        botl = ((col & umask) * (LMEM_SIZE/4)) | ((LMEM_SIZE-sizeof(Ull)-sizeof(Ull)*15) & lmask);
        printf(" \033[1;33mlm%d(%d):%08.8x-%08.8x\033[0m", col, lmm_mode, both, botl);
        for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull))
          printf("-%08.8x%08.8x", (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[both-i]>>32), (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[both-i]));
        printf("\n");
      }
      else if ((reg_ctrl.i[cid].conf[row][col].cdw1.ea0op && reg_ctrl.i[cid].conf[row][col].cdw1.ea0op < OP_IM_BUFWR)
             ||(reg_ctrl.i[cid].conf[row][col].cdw1.ea1op && reg_ctrl.i[cid].conf[row][col].cdw1.ea1op < OP_IM_BUFRD)) {
        toph = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.i[cid].addr[row][col].top+sizeof(Ull)*15) & lmask);
        topl = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.i[cid].addr[row][col].top               ) & lmask);
        printf(" \033[1;33mlm%d(%d):%08.8x-%08.8x\033[0m", col, lmm_mode, toph, topl);
        for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull))
          printf("-%08.8x%08.8x", (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[toph-i]>>32), (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[toph-i]));
        printf("\n");
        both = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.i[cid].addr[row][col].bot+1-sizeof(Ull)   ) & lmask);
        botl = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.i[cid].addr[row][col].bot+1-sizeof(Ull)*16) & lmask);
        printf(" \033[1;33mlm%d(%d):%08.8x-%08.8x\033[0m", col, lmm_mode, both, botl);
        for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull))
          printf("-%08.8x%08.8x", (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[both-i]>>32), (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[both-i]));
        printf("\n");
      }
    }

    printf(" mr1=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
           (Uint)(exring[cid].unit[row].lmm.mr1[3]>>32), (Uint)exring[cid].unit[row].lmm.mr1[3],
           (Uint)(exring[cid].unit[row].lmm.mr1[2]>>32), (Uint)exring[cid].unit[row].lmm.mr1[2],
           (Uint)(exring[cid].unit[row].lmm.mr1[1]>>32), (Uint)exring[cid].unit[row].lmm.mr1[1],
           (Uint)(exring[cid].unit[row].lmm.mr1[0]>>32), (Uint)exring[cid].unit[row].lmm.mr1[0]);
    printf(" mr0=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
           (Uint)(exring[cid].unit[row].lmm.mr0[3]>>32), (Uint)exring[cid].unit[row].lmm.mr0[3],
           (Uint)(exring[cid].unit[row].lmm.mr0[2]>>32), (Uint)exring[cid].unit[row].lmm.mr0[2],
           (Uint)(exring[cid].unit[row].lmm.mr0[1]>>32), (Uint)exring[cid].unit[row].lmm.mr0[1],
           (Uint)(exring[cid].unit[row].lmm.mr0[0]>>32), (Uint)exring[cid].unit[row].lmm.mr0[0]);
    printf(" mr1mux-mr1d-mr0mux-mr0d=%d-%08.8x%08.8x-%d-%08.8x%08.8x\n",
           exring[cid].unit[row].mr1mux,
           (Uint)(exring[cid].unit[row].mr1d>>32), (Uint)exring[cid].unit[row].mr1d,
           exring[cid].unit[row].mr0mux,
           (Uint)(exring[cid].unit[row].mr0d>>32), (Uint)exring[cid].unit[row].mr0d);
    printf(" lmr=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           (Uint)(exring[cid].unit[row].lmrd[3]>>32), (Uint)exring[cid].unit[row].lmrd[3],
           (Uint)(exring[cid].unit[row].lmrd[2]>>32), (Uint)exring[cid].unit[row].lmrd[2],
           (Uint)(exring[cid].unit[row].lmrd[1]>>32), (Uint)exring[cid].unit[row].lmrd[1],
           (Uint)(exring[cid].unit[row].lmrd[0]>>32), (Uint)exring[cid].unit[row].lmrd[0]);

    printf(" bv%d", exring[cid].unit[row].brout_valid);
    for (col=EMAX_WIDTH-1; col>=0; col--) {
      printf(" 0%d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
             col,
             (Uint)(exring[cid].unit[row].b[0][col].r[3]>>32), (Uint)exring[cid].unit[row].b[0][col].r[3],
             (Uint)(exring[cid].unit[row].b[0][col].r[2]>>32), (Uint)exring[cid].unit[row].b[0][col].r[2],
             (Uint)(exring[cid].unit[row].b[0][col].r[1]>>32), (Uint)exring[cid].unit[row].b[0][col].r[1],
             (Uint)(exring[cid].unit[row].b[0][col].r[0]>>32), (Uint)exring[cid].unit[row].b[0][col].r[0]);
    }
    printf("\n");
    printf("    ");
    for (col=EMAX_WIDTH-1; col>=0; col--) {
      printf(" 1%d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
             col,
             (Uint)(exring[cid].unit[row].b[1][col].r[3]>>32), (Uint)exring[cid].unit[row].b[1][col].r[3],
             (Uint)(exring[cid].unit[row].b[1][col].r[2]>>32), (Uint)exring[cid].unit[row].b[1][col].r[2],
             (Uint)(exring[cid].unit[row].b[1][col].r[1]>>32), (Uint)exring[cid].unit[row].b[1][col].r[1],
             (Uint)(exring[cid].unit[row].b[1][col].r[0]>>32), (Uint)exring[cid].unit[row].b[1][col].r[0]);
    }
    printf("\n");

    printf(" fl2-btop-bbot=%d-%d-%d",
           exring[cid].unit[row].lmring_ful2,
           exring[cid].unit[row].lmring_b_top,
           exring[cid].unit[row].lmring_b_bot);

    for (col=0; col<LMRING_BR_BUF; col++) {
      if (col>0) printf("                    ");
      printf(" LBR[%d].rw-ty-col-sq-av-a-dm=%x-%x-%x-%04.4x-%x-%08.8x-%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
             col,
             exring[cid].unit[row].lmring_br[col].rw,
             exring[cid].unit[row].lmring_br[col].ty,
             exring[cid].unit[row].lmring_br[col].col,
             exring[cid].unit[row].lmring_br[col].sq,
             exring[cid].unit[row].lmring_br[col].av,
             exring[cid].unit[row].lmring_br[col].a,
             exring[cid].unit[row].lmring_br[col].dm,
             (Uint)(exring[cid].unit[row].lmring_br[col].d[3]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[3],
             (Uint)(exring[cid].unit[row].lmring_br[col].d[2]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[2],
             (Uint)(exring[cid].unit[row].lmring_br[col].d[1]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[1],
             (Uint)(exring[cid].unit[row].lmring_br[col].d[0]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[0]);
    }
  }
}
@


1.407
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.406 2022/10/28 04:19:31 nakashim Exp nakashim $";
d1896 1
a1896 1
      mex(mex0op, &exring[cid].unit[i].ea12dr, base1, &exring[cid].unit[i].ea02dr, base0, mexblock, mex0ofs, exring[cid].unit[i].mexmr1d_prev, exring[cid].unit[i].mexmr0d_prev); /* ★ */
d2395 1
a2395 1
      kmex0 = (reg_ctrl.i[cid].conf[i][2].cdw0.mex0op==OP_CMPA_LEGE && reg_ctrl.i[cid].conf[i][j].cdw1.ea0op < OP_IM_BUFWR) ? ((j==1||j==0)?0:1) : k; /* ★ */
d2516 1
a2516 1
      kmex1 = (reg_ctrl.i[cid].conf[i][2].cdw0.mex0op==OP_CMPA_LEGE && reg_ctrl.i[cid].conf[i][j].cdw1.ea1op < OP_IM_BUFRD) ? ((j==1||j==0)?0:j) : j; /* ★ */
@


1.406
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.405 2022/10/27 09:56:34 nakashim Exp nakashim $";
d2816 1
a2816 1
    /* load mr -> br3 *//* brs3: 0:off, 1:mr13, 2:tr3, 3:ea1woofs(brs2=3の場合,ea1woofsに接続) */
@


1.405
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.404 2022/10/11 08:06:49 nakashim Exp nakashim $";
d2811 4
a2814 6
             exring[cid].unit[i].b[b][j].r[2] = exring[cid].unit[i].ex4dr;
    else {
             exring[cid].unit[i].b[b][j].r[2] = exring[cid].unit[i].ea04woofs;
	     printf("unit[%d] br2=%d\n", i, exring[cid].unit[i].ea04woofs);
    }
 break; /* 3:ea0woofs */
d2821 1
a2821 3
    case 3: exring[cid].unit[i].b[b][j].r[3] = exring[cid].unit[i].ea14woofs;
	     printf("unit[%d] br3=%d\n", i, exring[cid].unit[i].ea14woofs);
  break; /* 3:ea1woofs */
@


1.404
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.403 2022/09/08 09:25:32 nakashim Exp nakashim $";
d1723 2
d1834 1
a1856 2
      mex(mex0op, &exring[cid].unit[i].ea02dr, base0, mex0ofs, exring[cid].unit[i].mexmr1d_prev, exring[cid].unit[i].mexmr0d_prev); /* ★ */

d1875 22
a1896 1
      mex(mex1op, &exring[cid].unit[i].ea12dr, base1, mex1ofs, exring[cid].unit[i].mexmr1d_prev, exring[cid].unit[i].mexmr0d_prev); /* ★ */
d2395 1
a2395 1
      kmex0 = ((reg_ctrl.i[cid].conf[i][2].cdw0.mex0op==OP_CMPA_LE || reg_ctrl.i[cid].conf[i][2].cdw0.mex0op==OP_CMPA_GE) && reg_ctrl.i[cid].conf[i][j].cdw1.ea0op < OP_IM_BUFWR) ? ((j==1||j==0)?0:1) : k; /* ★ */
d2516 1
a2516 1
      kmex1 = ((reg_ctrl.i[cid].conf[i][2].cdw0.mex0op==OP_CMPA_LE || reg_ctrl.i[cid].conf[i][2].cdw0.mex0op==OP_CMPA_GE) && reg_ctrl.i[cid].conf[i][j].cdw1.ea1op < OP_IM_BUFRD) ? ((j==1||j==0)?0:j) : j; /* ★ */
d2805 1
a2805 1
    /* load mr -> br2 *//* brs2: 0:off, 1:mr12, 2:tr2, 3:exdr */
d2810 7
a2816 1
    case 3: exring[cid].unit[i].b[b][j].r[2] = exring[cid].unit[i].ex4dr;      break; /* 3:exdr align不要 */
d2818 1
a2818 1
    /* load mr -> br3 *//* brs3: 0:off, 1:mr13, 2:tr3 */
d2823 3
@


1.403
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.402 2022/04/18 23:38:17 nakashim Exp nakashim $";
d557 1
a557 1
      default:                                       printf("%03.3d:emax6_ctl: dma_space load: opcd=%x (should be LDRW/LDR)\n", c[cid].iorq.tid, c[cid].iorq.opcd); break; }
d742 1
a742 1
      default:                                       printf("%03.3d:emax6_ctl: dma_space store: opcd=%x (should be STRW/STR)\n", c[cid].iorq.tid, c[cid].iorq.opcd); break; }
@


1.402
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.401 2022/03/04 04:14:29 nakashim Exp nakashim $";
d1534 4
a1537 4
      s = reg_ctrl.i[cid].conf[i][j].cdw1.cs0;    exring[cid].unit[i].cx[0] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.i[cid].conf[i][j].cdw1.cs1;    exring[cid].unit[i].cx[1] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.i[cid].conf[i][j].cdw1.cs2;    exring[cid].unit[i].cx[2] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.i[cid].conf[i][j].cdw1.cs3;    exring[cid].unit[i].cx[3] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
d3136 2
a3137 2
           exring[cid].unit[row].ea13dr,
           exring[cid].unit[row].ea03dr,
@


1.401
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.400 2022/03/04 03:03:33 nakashim Exp nakashim $";
d2683 8
a2690 4
      if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+0) = tr->d[0]; *((Ull *)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+0) = tr->d[0]; }
      if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+1) = tr->d[1]; *((Ull *)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+1) = tr->d[1]; }
      if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+2) = tr->d[2]; *((Ull *)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+2) = tr->d[2]; }
      if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+3) = tr->d[3]; *((Ull *)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+3) = tr->d[3]; }
@


1.400
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.399 2022/03/04 02:10:32 nakashim Exp nakashim $";
d364 1
a364 1
  prev_stat[cid] =  c[0].iorq.v_stat || (reg_ctrl.i[cid].stat & 0xff);
d370 1
a370 1
  if (prev_stat[cid] && !c[0].iorq.v_stat && !(reg_ctrl.i[cid].stat & 0xff))
d375 1
a375 1
  for (i=0; i<EMAX_NCHIP; i++) emax_stat |= (reg_ctrl.i[i].stat & 0xff);
@


1.399
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.398 2022/03/04 02:09:24 nakashim Exp nakashim $";
d364 1
a364 1
  prev_stat[cid] =  c[0].iorq.v_stat || reg_ctrl.i[cid].stat;
d370 1
a370 1
  if (prev_stat[cid] && !c[0].iorq.v_stat && !reg_ctrl.i[cid].stat)
d375 1
a375 1
  for (i=0; i<EMAX_NCHIP; i++) emax_stat |= reg_ctrl.i[i].stat;
@


1.398
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.397 2022/03/03 14:59:26 nakashim Exp nakashim $";
d366 1
a366 1
  reg_ctrl.i[cid].stat = ((LMM_SIZE==131072)?2:(LMM_SIZE==65536)?1:0)<<12
@


1.397
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.396 2022/02/17 11:26:40 nakashim Exp nakashim $";
d366 3
a368 1
  reg_ctrl.i[cid].stat = (!(axiif[cid].axi_arvalid||axiif[cid].axi_awvalid||axiif[cid].axi_wvalid||axiif[cid].reqn)?LMRING_IDLE:LMRING_BUSY)<<4
@


1.396
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.395 2021/12/21 03:57:50 nakashim Exp nakashim $";
d244 1
a244 1
  } unit[EMAX_DEPTH];
@


1.395
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.394 2021/12/08 00:59:26 nakashim Exp nakashim $";
d2366 1
a2366 1
      int kmex;
d2369 3
a2371 3
      /* conf[][col=2]mex1opは,conf[][col=2].lmm_modeを参照 */
      /* conf[][col=2]mex0opは,conf[][col=1].lmm_modeを参照 */
      kmex = (reg_ctrl.i[cid].conf[i][j].cdw0.mex0op && reg_ctrl.i[cid].conf[i][j].cdw1.ea0op < OP_IM_BUFRD) ? ((k==3)?2:(k==2)?1:0) : k; /* ★ */
d2374 1
a2374 1
      switch (reg_ctrl.i[cid].conf[i][kmex].cdw2.lmm_mode) {   /* ★ */
d2380 2
a2381 2
      exring[cid].unit[i].ea04dr   = ((kmex & exring[cid].unit[i].ea04_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea03dr & exring[cid].unit[i].ea04_lmask); /* ★ */
      /* if (i==2 && k==2) printf("kmex=%d lmm_mode=%d ea04dr=%08.8x\n", kmex, reg_ctrl.i[cid].conf[i][kmex].cdw2.lmm_mode, (Uint)exring[cid].unit[i].ea04dr); */
d2488 5
d2495 1
a2495 1
      switch (reg_ctrl.i[cid].conf[i][j].cdw2.lmm_mode) {
d2501 1
a2501 1
      exring[cid].unit[i].ea14dr   = ((j & exring[cid].unit[i].ea14_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea13dr & exring[cid].unit[i].ea14_lmask);
@


1.394
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.393 2021/10/24 13:29:32 nakashim Exp nakashim $";
d1675 1
a1675 1
  /* mop(OP_LDUBR, 1, &b00,      (Ull)c0[s][CHIP],         (Ull)oofs,        MSK_W0,    (Ull)c[s][CHIP], RMGRP/4,   0,      1,    (Ull)NULL,   RMGRP/4);                                    */
d2745 1
a2745 4
      case OP_LDWR:  exring[cid].unit[i].b[b][j].r[0] = (Ull)            (Uint)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL)<<32
                                                      | (Ull)            (Uint)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDUWR: exring[cid].unit[i].b[b][j].r[0] = (Ull)            (Uint)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL)<<32
                                                      | (Ull)            (Uint)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
d2747 3
a2749 9
      case OP_LDHR:  exring[cid].unit[i].b[b][j].r[0] = (Ull)(Uint)(int)(short)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL)<<32
                                                      | (Ull)(Uint)(int)(short)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDUHR: exring[cid].unit[i].b[b][j].r[0] = (Ull)(Uint)    (Ushort)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL)<<32
                                                      | (Ull)(Uint)    (Ushort)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
#endif
      case OP_LDBR:  exring[cid].unit[i].b[b][j].r[0] = (Ull)(Uint)(int) (char)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL)<<32
                                                      | (Ull)(Uint)(int) (char)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      case OP_LDUBR: exring[cid].unit[i].b[b][j].r[0] = (Ull)(Uint)     (Uchar)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL)<<32
                                                      | (Ull)(Uint)     (Uchar)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
d2765 1
a2765 4
      case OP_LDWR:  exring[cid].unit[i].b[b][j].r[1] = (Ull)            (Uint)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL)<<32
                                                      | (Ull)            (Uint)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDUWR: exring[cid].unit[i].b[b][j].r[1] = (Ull)            (Uint)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL)<<32
                                                      | (Ull)            (Uint)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
d2767 3
a2769 9
      case OP_LDHR:  exring[cid].unit[i].b[b][j].r[1] = (Ull)(Uint)(int)(short)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL)<<32
                                                      | (Ull)(Uint)(int)(short)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDUHR: exring[cid].unit[i].b[b][j].r[1] = (Ull)(Uint)    (Ushort)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL)<<32
                                                      | (Ull)(Uint)    (Ushort)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
#endif
      case OP_LDBR:  exring[cid].unit[i].b[b][j].r[1] = (Ull)(Uint)(int) (char)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL)<<32
                                                      | (Ull)(Uint)(int) (char)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      case OP_LDUBR: exring[cid].unit[i].b[b][j].r[1] = (Ull)(Uint)     (Uchar)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL)<<32
                                                      | (Ull)(Uint)     (Uchar)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
@


1.393
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.392 2021/09/21 07:42:49 nakashim Exp nakashim $";
d1875 2
a1876 2
      eam(&exring[cid].unit[i].ea02dofs, offs0, reg_ctrl.i[cid].conf[i][k].cdw1.ea0msk); /* ★ */
      eam(&exring[cid].unit[i].ea12dofs, offs1, reg_ctrl.i[cid].conf[i][j].cdw1.ea1msk); /* ★ */
@


1.392
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.391 2021/09/19 00:04:15 nakashim Exp nakashim $";
d2371 1
a2371 1
      kmex = reg_ctrl.i[cid].conf[i][j].cdw0.mex0op ? k-1 : k; /* ★ */
@


1.391
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.390 2021/07/18 23:14:29 nakashim Exp nakashim $";
d151 8
a158 4
    Ull   ea02dr           ; /* reg  *//* for eag(&addr) */
    Ull   ea12dr           ; /* reg  *//* for eag(&addr) */
    Ull   ea03dr        :18; /* reg  */
    Ull   ea13dr        :18; /* reg  */
d161 3
a163 2
    Ull   ea04dr_prev   :18; /* reg  *//* for siml-loop only */
    Ull   ea04dr        :18; /* reg  */
d166 3
a168 2
    Ull   ea14dr_prev   :18; /* reg  *//* for siml-loop only */
    Ull   ea14dr        :18; /* reg  */
d223 4
d1563 15
d1581 13
d1597 13
a1609 6
      ofs =                                   exring[cid].unit[i].lmea0strq  ? (j<<3)                           : 0;
      sb = reg_ctrl.i[cid].conf[i][k].cdw1.ea0bs; exring[cid].unit[i].ea0b  = (!(sb&1)||!exring[cid].unit[i].one_shot)?(((sb&2)?exring[cid].unit[i].eab:reg_ctrl.i[cid].addr[i][k].ea0b)|ofs) : exring[cid].unit[i].ea04dr_prev;
      so = reg_ctrl.i[cid].conf[i][k].cdw1.ea0os; exring[cid].unit[i].ea0o  = (!(sb&1)|| exring[cid].unit[i].one_shot)?( (so&1)?exring[cid].unit[i].eao:reg_ctrl.i[cid].addr[i][k].ea0o     ) : 0LL;
      /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
      sb = reg_ctrl.i[cid].conf[i][j].cdw1.ea1bs; exring[cid].unit[i].ea1b  = (!(sb&1)||!exring[cid].unit[i].one_shot)?( (sb&2)?exring[cid].unit[i].eab:reg_ctrl.i[cid].addr[i][j].ea1b     ) : exring[cid].unit[i].ea14dr_prev;
      so = reg_ctrl.i[cid].conf[i][j].cdw1.ea1os; exring[cid].unit[i].ea1o  = (!(sb&1)|| exring[cid].unit[i].one_shot)?( (so&1)?exring[cid].unit[i].eao:reg_ctrl.i[cid].addr[i][j].ea1o     ) : 0LL;
d1717 4
d1745 1
d1747 1
d1824 53
a1876 3
      k     = (exring[cid].unit[i].lmea0sfma || exring[cid].unit[i].lmea0strq) ? exring[cid].unit[i].lmea0strqcol : j;
      eag(&exring[cid].unit[i].ea02dr, base0, offs0, reg_ctrl.i[cid].conf[i][k].cdw1.ea0msk);
      eag(&exring[cid].unit[i].ea12dr, base1, offs1, reg_ctrl.i[cid].conf[i][j].cdw1.ea1msk);
d1907 3
d1923 1
d1925 1
d1953 10
a1962 2
      exring[cid].unit[i].ea03dr = exring[cid].unit[i].ea02dr;
      exring[cid].unit[i].ea13dr = exring[cid].unit[i].ea12dr;
d2037 10
a2046 3
  exring[cid].unit[i].lmring_ea0bsy  =((!reg_ctrl.i[cid].conf[i][0].cdw0.fold && exring[cid].unit[i].stage4_exec) || (reg_ctrl.i[cid].conf[i][0].cdw0.fold && exring[cid].unit[i].stage4_fold))
                                     &&((reg_ctrl.i[cid].conf[i][j].cdw1.ea0op && reg_ctrl.i[cid].conf[i][j].cdw1.ea0op <= OP_IM_BUFWR)||(exring[cid].unit[i].lmea0sfma||exring[cid].unit[i].lmea0strq));/*op0*/
  exring[cid].unit[i].lmring_ea1bsy  = exring[cid].unit[i].stage4_exec &&  (reg_ctrl.i[cid].conf[i][j].cdw1.ea1op && reg_ctrl.i[cid].conf[i][j].cdw1.ea1op <= OP_IM_BUFRD);      /* op1 */
d2257 3
a2259 2
  Ull   ea04dr_prev      ; /* reg  *//* for siml-loop only */
  Ull   ea04dr           ; /* reg  */
d2262 3
a2264 2
  Ull   ea14dr_prev      ; /* reg  *//* for siml-loop only */
  Ull   ea14dr           ; /* reg  */
d2288 1
a2288 1
    exring[cid].unit[i].ea04dr_prev    = 0;   /* siml-loop only */
d2290 1
a2290 1
    exring[cid].unit[i].ea14dr_prev    = 0;   /* siml-loop only */
d2339 2
a2340 1
    exring[cid].unit[i].ea04dr_prev = exring[cid].unit[i].ea04dr; /* siml-loop only */
d2366 1
d2368 7
a2374 1
      switch (reg_ctrl.i[cid].conf[i][k].cdw2.lmm_mode) {
d2380 5
a2384 4
      exring[cid].unit[i].ea04dr      = ((k & exring[cid].unit[i].ea04_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea03dr & exring[cid].unit[i].ea04_lmask);
      exring[cid].unit[i].lmm.en0     = 1;
      exring[cid].unit[i].lmm.rw0     = (reg_ctrl.i[cid].conf[i][k].cdw1.ea0op & 0x10)!=0; /* read/write */
      exring[cid].unit[i].lmm.ma0     = (exring[cid].unit[i].ea04dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
d2466 2
a2467 1
    exring[cid].unit[i].ea14dr_prev = exring[cid].unit[i].ea14dr; /* siml-loop only */
d2488 2
d2496 5
a2500 4
      exring[cid].unit[i].ea14dr      = ((j & exring[cid].unit[i].ea14_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea13dr & exring[cid].unit[i].ea14_lmask);
      exring[cid].unit[i].lmm.en1     = 1;
      exring[cid].unit[i].lmm.rw1     = 0; /* read */
      exring[cid].unit[i].lmm.ma1     = (exring[cid].unit[i].ea14dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
d2504 1
a2504 1
      exring[cid].unit[i].lmm.en1     = 0;
d2635 6
@


1.390
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.389 2021/07/18 13:20:16 nakashim Exp nakashim $";
d79 2
a80 2
  Ull   cmd_busy        : 1; /* ★★★reg_ctrl.statに直接反映★★★ */
  Ull   unit_busy       : 1; /* ★★★reg_ctrl.statに直接反映★★★ */
d96 1
a96 1
    Ull   unit1_exec    : 1; /* 次の動作を指示 (cex,exe,eag), 0:wait 1:exec *//* ★★★reg_ctrl.statに直接反映★★★ */
d108 1
a108 1
    Ull   unit2_exec    : 1; /* 次の動作を指示 (lmm),         0:wait 1:exec *//* ★★★reg_ctrl.statに直接反映★★★ */
d173 3
a175 3
    Ull   lmea0sfma     : 1; /* wire *//* sfma+ea0.stbr存在★★★4サイクルに分けて実行 */
    Ull   lmea0strq     : 1; /* wire *//* ea0.strq存在     ★★★4サイクルに分けて実行 */
    Ull   lmea0strqcol  : 2; /* wire *//* ea0.strq_col番号 ★★★4サイクルに分けて実行 */
d373 2
a374 2
  for (row0=0; row0<EMAX_DEPTH; row0++)           /* ★★EXRINGは論理row0からsimlする必要があり,LMRINGも合わせる */
    if (exring[cid].unit[row0].l_row == 0) break; /* ★★LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */
d445 2
a446 2
  /*   ★siml起点(broutは定数)   unit[].lmring_br -------  SIML起点(1τ前の次段deq_waitを使う.正常)  */
  /* row0                     62        |            V   ★SIML最後(前段brの値が1τ未来になる)       */
d484 1
a484 1
  /* rvalid     SLAVE                                                   _____/~~~~~★\___                                                                                                                     */
d486 1
a486 1
  /* rready    MASTER*                                                  _____/~~~~~★\___                                                                                                                     */
d613 1
a613 1
  /* awvalid   MASTER*  ___★/~~~~~~~\___ valid=1                                                                                                                                                             */
d617 1
a617 1
  /* wvalid    MASTER*  ___★/~~~~~~~\___                                                                                                                                                                     */
d622 1
a622 1
  /* arvalid   MASTER*                                  ___★/~~~~~~~\___                                                                                                                                     */
d890 2
a891 2
  /*   ★siml起点(broutは定数)   unit[].lmring_br -------  SIML起点(1τ前の次段deq_waitを使う.正常)  */
  /* row0                     62        |            V   ★SIML最後(前段brの値が1τ未来になる)       */
d1066 2
a1067 2
  /* awvalid   MASTER   _____/~~~~~★\___ valid=1                                                                                                                                                             */
  /* awready    SLAVE*  ~~~~~~~~~~~★\___ ready=1の時に授受                                                                                                                                                   */
d1070 1
a1070 1
  /* wvalid    MASTER   _____/~~~~~★\___                                                                                                                                                                     */
d1072 1
a1072 1
  /* wready     SLAVE*  ~~~~~~~~~~~★\___                                                                                                                                                                     */
d1075 2
a1076 2
  /* arvalid   MASTER                |                          _____/~~~~~★\___                                                                                                                             */
  /* arready    SLAVE*               |                          ~~~~~~~~~~~★\___                                                                                                                             */
d1514 1
a1514 1
/*★*/  bi = (reg_ctrl.i[cid].conf[i][k].cdw1.ea0bs&2)? i : pi; /* if ea0 takes eabbrs, shuold be i (else ea1(load) from pi) */
d1553 1
a1553 1
/*★*/s = reg_ctrl.i[cid].conf[i][k].cdw1.eabbrs; exring[cid].unit[i].eab   = exring[cid].unit[bi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]; //★ここがSFMA+STBRの起源
d1557 2
a1558 2
      /* ★★★STRQ/SFMA+STBRはSTRを4サイクル分割実行★★★ */
      /* ★★★exring[cid].unit[i].lmea0strq と exring[cid].unit[i].lmea0strqcol は siml_unit_stage4()にて先行セット */
d1774 1
a1774 1
/*★*/eag(&exring[cid].unit[i].ea02dr, base0, offs0, reg_ctrl.i[cid].conf[i][k].cdw1.ea0msk);
d2028 3
a2030 3
  Ull   lmea0sfma     : 1; /* wire *//* sfma+ea0.stbr存在★★★4サイクルに分けて実行 */
  Ull   lmea0strq     : 1; /* wire *//* ea0.strq存在     ★★★4サイクルに分けて実行 */
  Ull   lmea0strqcol  : 2; /* wire *//* ea0.strq_col番号 ★★★4サイクルに分けて実行 */
d2059 1
a2059 1
  /* OP_IM_PREF      0x1f lmring-write動作 ★自身なので干渉しない */
d2064 3
a2066 3
  /* OP_IM_DRAIN     0x0f lmring-read動作 ★自身なので干渉しない */
  /* OP_LDDMQ        0x18 lmring-read動作 ★自身なので干渉しない */
  /* OP_TR           0x19 lmring-read動作 ★自身なので干渉しない */
d2311 5
a2315 5
        exring[cid].unit[i].lmm.mm0    = 0xffffffff;         /* mask *//* ★★★暫定記述★★★ */
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]; /* ★★★暫定記述★★★ */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]; /* ★★★暫定記述★★★ */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]; /* ★★★暫定記述★★★ */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]; /* ★★★暫定記述★★★ */
d2319 1
a2319 1
          /* ★★★STRQはSTRを4サイクル分割実行★★★ */
d2550 4
a2553 4
      if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+0) = tr->d[0];   }/* ★★★ only write is implemented */
      if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+1) = tr->d[1];   }/* ★★★ only write is implemented */
      if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+2) = tr->d[2];   }/* ★★★ only write is implemented */
      if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+3) = tr->d[3];   }/* ★★★ only write is implemented */
d2583 4
a2586 4
        if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+0) = tr->d[0];   }/* ★★★ only write is implemented */
        if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+1) = tr->d[1];   }/* ★★★ only write is implemented */
        if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+2) = tr->d[2];   }/* ★★★ only write is implemented */
        if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+3) = tr->d[3];   }/* ★★★ only write is implemented */
@


1.389
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.388 2021/06/21 09:25:08 nakashim Exp nakashim $";
d1534 1
a1534 1
                                                                            ||(reg_ctrl.i[cid].conf[i][j].cdw0.ex1s!=1)
d2192 1
a2192 1
	if ((!exring[cid].unit[i].one_shot_fold4 || (exring[cid].unit[i].unit1_forstat_fold4 & 1)) && j==0)
@


1.388
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.387 2021/06/18 02:52:03 nakashim Exp nakashim $";
d93 3
d1437 1
d1578 1
d1794 1
d1867 1
d2192 1
a2192 1
	if ((exring[cid].unit[i].unit1_forstat_fold4 & 1) && j==0)
@


1.387
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.386 2021/06/16 11:41:36 nakashim Exp nakashim $";
d2185 1
a2185 1
	if (exring[cid].unit[i].unit1_forstat_fold4 && j==0)
@


1.386
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.385 2021/06/15 09:30:24 nakashim Exp nakashim $";
a92 3
    Ull   one_shot_fold2: 1; /* one_shot for stage3 for OP_SFMA */
    Ull   one_shot_fold3: 1; /* one_shot for stage3 for OP_SFMA */
    Ull   one_shot_fold4: 1; /* one_shot for stage4 for OP_SFMA */
d98 4
a101 1
    Ull   unit1_forstat_fold: 2; /* forstat+folding */
a1433 1
        exring[cid].unit[i].one_shot_fold2= 0; /* reset to default */
d1438 2
a1439 1
        exring[cid].unit[i].unit1_forstat_fold = 0;/* reset to default */
d1505 3
d1510 1
a1510 1
        bi = (reg_ctrl.i[cid].conf[i][j].cdw1.ea0bs&2)? i : pi; /* if ea0 takes eabbrs, shuold be i (else ea1(load) from pi) */
d1549 1
a1549 2

      s = reg_ctrl.i[cid].conf[i][j].cdw1.eabbrs; exring[cid].unit[i].eab   = exring[cid].unit[bi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
a1554 1
      k   = (exring[cid].unit[i].lmea0sfma || exring[cid].unit[i].lmea0strq) ? exring[cid].unit[i].lmea0strqcol : j;
d1557 1
a1557 2
      so = reg_ctrl.i[cid].conf[i][k].cdw1.ea0os; exring[cid].unit[i].ea0o  = (!(sb&1)|| exring[cid].unit[i].one_shot)?((so&1)?exring[cid].unit[i].eao:reg_ctrl.i[cid].addr[i][k].ea0o) : 0LL;

d1559 2
a1560 2
      sb = reg_ctrl.i[cid].conf[i][j].cdw1.ea1bs; exring[cid].unit[i].ea1b  = (!(sb&1)||!exring[cid].unit[i].one_shot)?((sb&2)?exring[cid].unit[i].eab:reg_ctrl.i[cid].addr[i][j].ea1b) : exring[cid].unit[i].ea14dr_prev;
      so = reg_ctrl.i[cid].conf[i][j].cdw1.ea1os; exring[cid].unit[i].ea1o  = (!(sb&1)|| exring[cid].unit[i].one_shot)?((so&1)?exring[cid].unit[i].eao:reg_ctrl.i[cid].addr[i][j].ea1o) : 0LL;
d1573 3
a1575 3
    exring[cid].unit[i].one_shot2      = exring[cid].unit[i].one_shot;
    exring[cid].unit[i].one_shot_fold2 = exring[cid].unit[i].one_shot_fold;
    exring[cid].unit[i].unit1_forstat2 = exring[cid].unit[i].unit1_forstat;
a1587 1

d1656 1
d1661 1
a1661 1
  Uint   init, one_shot2, one_shot_fold2, forstat2;
a1673 1
	exring[cid].unit[i].one_shot_fold3 = 0;
a1720 1
      one_shot_fold2 = exring[cid].unit[i].one_shot_fold2;
a1740 4
	if (cid == 0 && i==2 && reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_SFMA) {
	  printf("======stage2===SFMA=== r1=%08.8x r2=%08.8x_%08.8x r3=%08.8x_%08.8x r4=%d ex2dr_sfma0=%08.8x_%08.8x\n",
		 (Uint)r1, (Uint)(r2>>32), (Uint)r2, (Uint)(r3>>32), (Uint)r3, (Uint)r4, (Uint)(exring[cid].unit[i].ex2dr_sfma0>>32), (Uint)exring[cid].unit[i].ex2dr_sfma0);
	}
d1768 2
a1769 1
      eag(&exring[cid].unit[i].ea02dr, base0, offs0, reg_ctrl.i[cid].conf[i][j].cdw1.ea0msk);
d1789 1
a1789 1
    exring[cid].unit[i].one_shot_fold3 = one_shot_fold2;
a1799 1
  Uint   one_shot_fold3;
a1805 1
	exring[cid].unit[i].one_shot_fold4 = 0;
a1826 1
      one_shot_fold3 = exring[cid].unit[i].one_shot_fold3;
a1835 3
	if (cid == 0 && i==2 && reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_SFMA) {
printf("======stage3===SFMA=== ex2dr_sfma0=%08.8x_%08.8x ex3dr_sfma0=%08.8x_%08.8x \n", (Uint)(exring[cid].unit[i].ex2dr_sfma0>>32), (Uint)exring[cid].unit[i].ex2dr_sfma0, (Uint)(exring[cid].unit[i].ex3dr>>32), (Uint)exring[cid].unit[i].ex3dr);
	}
d1861 2
a1862 2
    exring[cid].unit[i].one_shot_fold4 = one_shot_fold3;
    
d1913 1
a1913 1
  exring[cid].unit[i].lmea0sfma      = reg_ctrl.i[cid].conf[i][0].cdw1.ea0op == OP_STBR && reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_SFMA; /* SFMA+STBR */
a2004 1
  Uint   one_shot_fold4;
a2181 1
      one_shot_fold4 = exring[cid].unit[i].one_shot_fold4;
d2185 1
a2185 1
	if (!one_shot_fold4)
d2188 1
a2188 4
	  softu64(3, NULL, &exring[cid].unit[i].ex3dr, &exring[cid].unit[i].ex4dr, exring[cid].unit[i].ex4dr, exring[cid].unit[i].ex3passr2, exring[cid].unit[i].ex3passr3, 0LL);
	if (cid == 0 && i==2 && reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_SFMA) {
printf("======stage4===SFMA=== ex3passr1=%08.8x ex4dr=%08.8x_%08.8x \n", (Uint)exring[cid].unit[i].ex3passr1, (Uint)(exring[cid].unit[i].ex4dr>>32), (Uint)exring[cid].unit[i].ex4dr);
	}
d2249 4
a2252 4
      exring[cid].unit[i].mwmux[0] = reg_ctrl.i[cid].conf[i][k].cdw2.mws0==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[0];
      exring[cid].unit[i].mwmux[1] = reg_ctrl.i[cid].conf[i][k].cdw2.mws1==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[1];
      exring[cid].unit[i].mwmux[2] = reg_ctrl.i[cid].conf[i][k].cdw2.mws2==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[2];
      exring[cid].unit[i].mwmux[3] = reg_ctrl.i[cid].conf[i][k].cdw2.mws3==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[3];
d2378 4
a2381 4
        exring[cid].unit[i].tx4dr[0] = reg_ctrl.i[cid].conf[i][j].cdw2.trs0==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[0];
        exring[cid].unit[i].tx4dr[1] = reg_ctrl.i[cid].conf[i][j].cdw2.trs1==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[1];
        exring[cid].unit[i].tx4dr[2] = reg_ctrl.i[cid].conf[i][j].cdw2.trs2==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[2];
        exring[cid].unit[i].tx4dr[3] = reg_ctrl.i[cid].conf[i][j].cdw2.trs3==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[3];
@


1.385
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.384 2021/06/13 11:02:10 nakashim Exp nakashim $";
d170 3
a172 2
    Ull   lmea0strq     : 1; /* wire *//* ea0.strq存在    ★★★4サイクルに分けて実行 */
    Ull   lmea0strqcol  : 2; /* wire *//* ea0.strq_col番号★★★4サイクルに分けて実行 */
d1419 2
a1420 2
  int k;   /* tmp, and for STRQ(lmea0strqcol) */
  int ofs; /*          for STRQ(lmea0strqcol) */
d1551 1
a1551 1
      /* ★★★STRQはSTRを4サイクル分割実行★★★ */
d1553 2
a1554 2
      k   = !exring[cid].unit[i].lmea0strq ? j : exring[cid].unit[i].lmea0strqcol;
      ofs = !exring[cid].unit[i].lmea0strq ? 0 : (j<<3);
d1621 35
d1924 3
a1926 5
  exring[cid].unit[i].lmea0strq      = reg_ctrl.i[cid].conf[i][0].cdw1.ea0op == OP_STRQ || reg_ctrl.i[cid].conf[i][1].cdw1.ea0op == OP_STRQ
                                    || reg_ctrl.i[cid].conf[i][2].cdw1.ea0op == OP_STRQ || reg_ctrl.i[cid].conf[i][3].cdw1.ea0op == OP_STRQ; /* op0 */
  exring[cid].unit[i].lmea0strqcol   = reg_ctrl.i[cid].conf[i][0].cdw1.ea0op == OP_STRQ ? 0 :
                                       reg_ctrl.i[cid].conf[i][1].cdw1.ea0op == OP_STRQ ? 1 :
                                       reg_ctrl.i[cid].conf[i][2].cdw1.ea0op == OP_STRQ ? 2 : 3;
d1928 2
a1929 2
                                                                              && ((reg_ctrl.i[cid].conf[i][j].cdw1.ea0op && reg_ctrl.i[cid].conf[i][j].cdw1.ea0op <= OP_IM_BUFWR)||exring[cid].unit[i].lmea0strq); /* op0 */
  exring[cid].unit[i].lmring_ea1bsy  = exring[cid].unit[i].stage4_exec &&  (reg_ctrl.i[cid].conf[i][j].cdw1.ea1op && reg_ctrl.i[cid].conf[i][j].cdw1.ea1op <= OP_IM_BUFRD); /* op1 */
d2033 3
a2035 2
  Ull   lmea0strq     : 1; /* wire *//* ea0.strq存在    ★★★4サイクルに分けて実行 */
  Ull   lmea0strqcol  : 2; /* wire *//* ea0.strq_col番号★★★4サイクルに分けて実行 */
d2214 6
a2219 5
    /* exring[cid].unit[i].lmea0strq     = STRQ[*];                       */
    /* exring[cid].unit[i].lmea0strqcol  = STRQ[*];                       */
    /* exring[cid].unit[i].lmring_ea0bsy = EXEC && (normal_op0||STRQ[*]); */
    /* exring[cid].unit[i].lmring_ea1bsy = EXEC && (normal_op1);          */
    /* exring[cid].unit[i].lmring_ful    = NEXT_TR+NEXT_BR==FULL;         */
d2250 2
a2251 2
    else if (exring[cid].unit[i].lmring_ea0bsy) { /* EXEC & ea0d->lmm_write/read (STRQの毎サイクル実行もここ) */
      k = !exring[cid].unit[i].lmea0strq ? j : exring[cid].unit[i].lmea0strqcol;
d2307 10
a2316 8
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000001<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000100<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00010000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x01000000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
d3035 1
a3035 1
    printf("                                                                                                                            rk-wk-dk-s4-col-e1b-e0b-ful-dqw-fl1=%01.1x-%01.1x-%d-%d-%d-%d-%d-%d-%d-%d\n",
d3039 1
@


1.384
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.383 2021/03/02 09:19:44 nakashim Exp nakashim $";
d1807 4
a1810 1
	softu64(2, &exring[cid].unit[i].ex2dr_sfma0, &exring[cid].unit[i].ex3dr, NULL, exring[cid].unit[i].ex2passr1, exring[cid].unit[i].ex2passr2, exring[cid].unit[i].ex2passr3, 0LL);
d2167 3
a2172 4
      
      if (cid == 0 && i==2 && reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_SFMA) {
printf("======stage4===SFMA=== ex3passr1=%08.8x ex3dr=%08.8x_%08.8x \n", (Uint)exring[cid].unit[i].ex3passr1, (Uint)(exring[cid].unit[i].ex3dr>>32), (Uint)exring[cid].unit[i].ex3dr);
      }
@


1.383
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.382 2021/02/28 06:00:46 nakashim Exp nakashim $";
d93 3
d123 17
a139 2
    Ull   ex2dr            ; /* reg  *//* out for first-stage */
    Ull   ex3dr            ; /* reg  *//* out for second-stage */
d141 1
a141 1
    Ull   ex4dr            ; /* reg  *//* out for third-stage */
d1433 1
d1529 2
a1530 2
						                            ||((reg_ctrl.i[cid].conf[i][j].cdw0.init&1)&&(!reg_ctrl.i[cid].conf[i][j].cdw0.fold)&&(exring[cid].unit[i].unit1_forstat&1))
						                            ||((reg_ctrl.i[cid].conf[i][j].cdw0.init&1)&&( reg_ctrl.i[cid].conf[i][j].cdw0.fold)&&(exring[cid].unit[i].unit1_forstat_fold&1))
d1572 2
a1573 1
    exring[cid].unit[i].one_shot2 = exring[cid].unit[i].one_shot;
d1587 1
d1625 1
a1625 1
  Uint   init, one_shot2, forstat2;
d1638 1
d1643 4
d1648 8
d1686 1
d1701 13
a1713 1
      ex1_retval = exe(op_ex1, &exring[cid].unit[i].ex2dr, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5);
d1758 2
d1768 2
a1769 1
  int j = (exring[cid].unit[i].cycle+(EMAX_WIDTH-2)) % EMAX_WIDTH; /* 2,3,0,1,2,3,0,1 */
d1776 1
d1779 11
a1789 8
        exring[cid].unit[i].cx3dr    = 0;
        exring[cid].unit[i].ex3dr    = 0LL;
        exring[cid].unit[i].ea03dr   = 0;
        exring[cid].unit[i].ea13dr   = 0;
        exring[cid].unit[i].tx3dr[0] = 0LL;
        exring[cid].unit[i].tx3dr[1] = 0LL;
        exring[cid].unit[i].tx3dr[2] = 0LL;
        exring[cid].unit[i].tx3dr[3] = 0LL;
d1798 1
d1803 8
a1810 1
      exring[cid].unit[i].ex3dr   = exring[cid].unit[i].ex2dr;
d1833 2
d1843 2
a1844 2
  int pi = (i+EMAX_DEPTH-1)%EMAX_DEPTH;
  int j  = (exring[cid].unit[i].cycle+(EMAX_WIDTH-3)) % EMAX_WIDTH; /* 1,2,3,0,1,2,3,0 */
d1847 1
a1847 1
  Uint  ftag, ltag, fmask, lmask, aximask;
d1964 17
a1980 3
  int pi = (i+EMAX_DEPTH-1)%EMAX_DEPTH;
  int j  = (exring[cid].unit[i].cycle+(EMAX_WIDTH-3)) % EMAX_WIDTH; /* 1,2,3,0,1,2,3,0 */
  int k; /* for STRQ(lmea0strqcol) */
d2156 1
d2159 12
a2170 1
      exring[cid].unit[i].ex4dr          = exring[cid].unit[i].ex3dr;
@


1.382
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.381 2020/11/29 13:12:55 nakashim Exp nakashim $";
d98 1
d1403 1
a1403 1
  int unit1_exec_next, unit1_fold_next, unit1_forstat_next, unit1_stop_next, unit2_exec_next, unit2_fold_next, unit2_forstat_next, unit2_stop_next;
d1419 1
d1510 2
a1511 1
						                            ||((reg_ctrl.i[cid].conf[i][j].cdw0.init&1)&&(exring[cid].unit[i].unit1_forstat&1))
d1515 11
d1570 1
d1579 1
@


1.381
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.380 2020/11/29 07:35:53 nakashim Exp nakashim $";
d46 2
a47 2
  Ull   fmask              : 4; /* mask for first 32B-chunk                                           */
  Ull   lmask              : 4; /* mask for last  32B-chunk                                           */
d146 4
a149 4
    Ull   ranger_ok     : 4; /* wire *//* lmring要求がread &ty==4&adr[col]<>lmm_range内 */
    Ull   rangew_ok     : 4; /* wire *//* lmring要求がwrite&ty==4&adr[col]<>lmm_range内 */
    Ull   lmranger_ok   : 4; /* wire *//* lmring要求がread &ty==4&adr[col]<>lmm_range内 */
    Ull   lmrangew_ok   : 4; /* wire *//* lmring要求がwrite&ty==4&adr[col]<>lmm_range内 */
d167 1
a167 1
      Ull   merge       : 4; /* wordwise 0:merge_lmm, 1:pass_lmm */
d478 8
a485 4
          if (axiif[cid].fmask&1) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
          if (axiif[cid].fmask&2) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
          if (axiif[cid].fmask&4) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
          if (axiif[cid].fmask&8) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
d488 8
a495 4
          if (axiif[cid].lmask&1) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
          if (axiif[cid].lmask&2) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
          if (axiif[cid].lmask&4) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
          if (axiif[cid].lmask&8) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
d632 8
a639 4
        axiif[cid].axi_wstrb = ((axiif[cid].fmask&8)?0xff000000:0)
                             | ((axiif[cid].fmask&4)?0x00ff0000:0)
                             | ((axiif[cid].fmask&2)?0x0000ff00:0)
                             | ((axiif[cid].fmask&1)?0x000000ff:0);
d641 8
a648 4
        axiif[cid].axi_wstrb = ((axiif[cid].lmask&8)?0xff000000:0)
                             | ((axiif[cid].lmask&4)?0x00ff0000:0)
                             | ((axiif[cid].lmask&2)?0x0000ff00:0)
                             | ((axiif[cid].lmask&1)?0x000000ff:0);
d717 2
a718 2
          axiif[cid].mlen     = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1)/UNIT_WIDTH)
                              - ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              )/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
d720 2
a721 2
          axiif[cid].fmask    = 0xf << ( (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              ) & (UNIT_WIDTH-1));
          axiif[cid].lmask    = 0xf >> (~(dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1) & (UNIT_WIDTH-1));
d733 2
a734 2
          axiif[cid].mlen     = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1)/UNIT_WIDTH)
                              - ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              )/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
d736 2
a737 2
          axiif[cid].fmask    = 0xf << ( (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              ) & (UNIT_WIDTH-1));
          axiif[cid].lmask    = 0xf >> (~(dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1) & (UNIT_WIDTH-1));
d1771 23
a1793 14
  switch ((reg_ctrl.i[cid].addr[i][br->col].top/sizeof(Ull)) & (UNIT_WIDTH-1)) {
  case 0: fmask = 0xf; break;
  case 1: fmask = 0xe; break;
  case 2: fmask = 0xc; break;
  case 3: fmask = 0x8; break;
  }
  switch (~(reg_ctrl.i[cid].addr[i][br->col].bot/sizeof(Ull)) & (UNIT_WIDTH-1)) {
  case 0: lmask = 0xf; break;
  case 1: lmask = 0x7; break;
  case 2: lmask = 0x3; break;
  case 3: lmask = 0x1; break;
  }
  aximask = ((br->dm & 0xff000000)?8:0) | ((br->dm & 0x00ff0000)?4:0) | ((br->dm & 0x0000ff00)?2:0) | ((br->dm & 0x000000ff)?1:0);
  exring[cid].unit[i].ranger_ok = (ftag< br->a && br->a< ltag) ? 0xf :
d1797 1
a1797 1
  exring[cid].unit[i].rangew_ok = (ftag< br->a && br->a< ltag) ? 0xf :
d1802 2
a1803 2
  exring[cid].unit[i].lmranger_ok    = (reg_ctrl.i[cid].conf[i][br->col].cdw2.lmm_axir && br->rw==0 && br->ty==4) ? exring[cid].unit[i].ranger_ok : 0; /* 4bits */
  exring[cid].unit[i].lmrangew_ok    = (reg_ctrl.i[cid].conf[i][br->col].cdw2.lmm_axiw && br->rw==1 && br->ty==4) ? exring[cid].unit[i].rangew_ok : 0; /* 4bits */
d1977 4
a1980 2
    exring[cid].unit[i].lmwm    = br->dm & (((exring[cid].unit[i].rangew_ok&8)?0xff000000:0) | ((exring[cid].unit[i].rangew_ok&4)?0x00ff0000:0)
                                          | ((exring[cid].unit[i].rangew_ok&2)?0x0000ff00:0) | ((exring[cid].unit[i].rangew_ok&1)?0x000000ff:0)); /* wire *//* <- axi */
d2563 8
a2570 4
      br->d[0] = (tr->merge & 1) ? exring[cid].unit[i].lmrd[0] : tr->d[0]; /* next cycle */
      br->d[1] = (tr->merge & 2) ? exring[cid].unit[i].lmrd[1] : tr->d[1]; /* next cycle */
      br->d[2] = (tr->merge & 4) ? exring[cid].unit[i].lmrd[2] : tr->d[2]; /* next cycle */
      br->d[3] = (tr->merge & 8) ? exring[cid].unit[i].lmrd[3] : tr->d[3]; /* next cycle */
@


1.380
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.379 2020/11/25 06:49:46 nakashim Exp nakashim $";
d2436 1
a2436 1
	default:     exring[cid].unit[i].b[b][j].r[0] = exring[cid].unit[i].mr1d >> (8-(a0&7))*8 | exring[cid].unit[i].mr0d >> (a0&7)*8; break;
@


1.379
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.378 2020/11/07 13:04:12 nakashim Exp nakashim $";
d2433 6
a2438 1
      case OP_LDR :  exring[cid].unit[i].b[b][j].r[0] =                          exring[cid].unit[i].mr0d;                                                                                 break;
d2462 6
a2467 1
      case OP_LDR:   exring[cid].unit[i].b[b][j].r[1] =                          exring[cid].unit[i].mr1d;                                                                                 break;
@


1.378
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.377 2020/05/05 13:55:08 nakashim Exp nakashim $";
d2123 1
d2134 1
d2438 1
d2443 1
d2462 1
d2467 1
@


1.377
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.376 2020/04/26 02:41:53 nakashim Exp nakashim $";
d2431 13
a2443 7
      case OP_LDR :  exring[cid].unit[i].b[b][j].r[0] =                exring[cid].unit[i].mr0d;                                                                                 break;
      case OP_LDWR:  exring[cid].unit[i].b[b][j].r[0] = (Sll)   (int)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDUWR: exring[cid].unit[i].b[b][j].r[0] = (Ull)  (Uint)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDHR:  exring[cid].unit[i].b[b][j].r[0] = (Sll) (short)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDUHR: exring[cid].unit[i].b[b][j].r[0] = (Ull)(Ushort)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDBR:  exring[cid].unit[i].b[b][j].r[0] = (Sll)  (char)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      case OP_LDUBR: exring[cid].unit[i].b[b][j].r[0] = (Ull) (Uchar)((exring[cid].unit[i].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
d2453 13
a2465 7
      case OP_LDR:   exring[cid].unit[i].b[b][j].r[1] =                exring[cid].unit[i].mr1d;                                                                                 break;
      case OP_LDWR:  exring[cid].unit[i].b[b][j].r[1] = (Sll)   (int)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDUWR: exring[cid].unit[i].b[b][j].r[1] = (Ull)  (Uint)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDHR:  exring[cid].unit[i].b[b][j].r[1] = (Sll) (short)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDUHR: exring[cid].unit[i].b[b][j].r[1] = (Ull)(Ushort)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDBR:  exring[cid].unit[i].b[b][j].r[1] = (Sll)  (char)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      case OP_LDUBR: exring[cid].unit[i].b[b][j].r[1] = (Ull) (Uchar)((exring[cid].unit[i].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
@


1.376
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.375 2019/08/29 03:15:14 nakashim Exp nakashim $";
d783 6
a788 6
        printf("%03.3d:PIO WR adr=%08.8x msk=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
               cid, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb,
               (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
               (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
               (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
               (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
d958 1
a958 1
    else if (cid < EMAX_NCHIP-1 && !axiif[cid+1].axi_rvalid) { /* 下流から何もなし */
d966 1
a966 1
	if (cid < EMAX_NCHIP-1)
d1066 3
a1068 3
  axiif[cid].axi_arready = (bri_ful2 < AXRING_BR_BUF && !axiif[cid].radr_recv && (cid == EMAX_NCHIP-1 || axiif[cid+1].axi_arready));
  axiif[cid].axi_awready = (bri_ful2 < AXRING_BR_BUF && !axiif[cid].wadr_recv && (cid == EMAX_NCHIP-1 || axiif[cid+1].axi_awready));
  axiif[cid].axi_wready  = (bri_ful2 < AXRING_BR_BUF                          && (cid == EMAX_NCHIP-1 || axiif[cid+1].axi_wready));
d1076 1
a1076 1
    if (cid < EMAX_NCHIP-1) {
d1126 1
a1126 1
    if (cid < EMAX_NCHIP-1) {
d1166 7
d1175 7
a1181 5
          if (!exring[cid].cmd_busy) {
            printf("%03.3d:ES %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 CMD(%x) START---\n", cid,
                   (Uint)(t[cid].total_steps>>32), (Uint)t[cid].total_steps,
                   (Uint)(t[cid].total_cycle>>32), (Uint)t[cid].total_cycle, reg_ctrl.i[cid].cmd&3);
            exring[cid].cmd_busy = 1;
d1221 1
a1221 1
        if (cid < EMAX_NCHIP-1) {
d1422 5
a1426 3
        exring[cid].unit[i].cmd = CMD_SCON;
        exring[cid].unit[i].scon_count = reg_ctrl.i[cid].conf[i][0].cdw2.mapdist<<1;
        exring[cid].unit[i].unit1_exec = 1;
d1429 8
a1436 6
        if (!reg_ctrl.i[cid].conf[i][0].cdw0.v)
          exring[cid].unit[i].cmd = CMD_NOP;
        else {
          exring[cid].unit[i].cmd = CMD_EXEC;
          if (exring[cid].unit[i].l_row == 0)
            exring[cid].unit[i].unit1_exec = 1;
@


1.375
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.374 2019/08/11 13:38:35 nakashim Exp nakashim $";
d595 1
a595 1
  if ((exring[cid].cycle & 3) == 3 && reg_ctrl.i[cid].cmd == CMD_RESET) {
d695 1
a695 1
      if ((dma_ctrl.ZDMA_CH_STATUS & 3) != 2 && (dma_ctrl.ZDMA_CH_CTRL2 & 1)) {
d1156 1
a1156 1
          axiif[cid+1].axi_wstrb    = axiif[cid].axi_wstrb    | (a==REG_BASE2_PHYS?0x00f00000:0x00000000); /* set cid=0,1,2,3 */;
d1159 1
a1159 1
          axiif[cid+1].axi_wdata[2] = axiif[cid].axi_wdata[2] + (a==REG_BASE2_PHYS?0x100000000LL:0x000000000LL); /* set cid=0,1,2,3 */
d1164 1
a1164 1
        switch (reg_ctrl.i[cid].cmd) {
d1171 1
a1171 1
                   (Uint)(t[cid].total_cycle>>32), (Uint)t[cid].total_cycle, reg_ctrl.i[cid].cmd);
d1234 1
a1234 1
    if (reg_ctrl.i[cid].cmd == CMD_RESET) {
d1248 2
a1249 2
    if ((exring[cid].cycle & 3) == 3) {
      reg_ctrl.i[cid].cmd = CMD_NOP;
d1259 1
a1259 1
  if ((exring[cid].cycle & 3) == 3 && reg_ctrl.i[cid].cmd == CMD_RESET)
d1381 2
a1382 2
    if ((exring[cid].unit[i].cycle & 3) == 3) {
      switch (reg_ctrl.i[cid].cmd) {
d1437 1
a1437 1
    if ((exring[cid].unit[i].cycle & 3) == 3) {
d1513 1
a1513 1
    if ((exring[cid].unit[i].cycle & 3) == 3) {
d1544 1
a1544 1
  if ((exring[cid].unit[i].cycle & 3) == 3 && reg_ctrl.i[cid].cmd == CMD_RESET)
d1568 2
a1569 2
    if ((exring[cid].unit[i].cycle & 3) == 3) {
      switch (reg_ctrl.i[cid].cmd) {
d1623 1
a1623 1
      if ((exring[cid].unit[i].cycle & 3) == 0)
d1678 2
a1679 2
    if ((exring[cid].unit[i].cycle & 3) == 3) {
      switch (reg_ctrl.i[cid].cmd) {
d1920 2
a1921 2
      && (exring[cid].unit[i].cycle & 3) == 3
      && reg_ctrl.i[cid].cmd == CMD_RESET) {
d1951 1
a1951 1
    tr->av   = br->av || exring[cid].unit[i].lmranger_ok || exring[cid].unit[i].lmrangew_ok || ((reg_ctrl.i[cid].cid == cdx || cdx == 0) && exring[cid].unit[i].l_row == row && br->ty<4);
d1994 2
a1995 2
      && (exring[cid].unit[i].cycle & 3) == 3
      && reg_ctrl.i[cid].cmd == CMD_RESET) {
d2324 2
a2325 2
      && (exring[cid].unit[i].cycle & 3) == 3
      && reg_ctrl.i[cid].cmd == CMD_RESET) {
d2338 1
a2338 1
  else if (exring[cid].unit[i].cmd == CMD_NOP && (reg_ctrl.i[cid].cid == cdx || cdx == 0) && exring[cid].unit[i].l_row == row && exring[cid].unit[i].lmring_ful1) { /* reg setup by PIO */
d2341 1
a2341 1
printf("====== WREG chip=%d cdx=%d l_row=%x row=%x cmd=%d ==== tr->ty=%x a=%08.8x dm=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n", (Uint)(reg_ctrl.i[cid].cid), cdx, exring[cid].unit[i].l_row, row, exring[cid].unit[i].cmd, tr->ty, tr->a, tr->dm, (Uint)(tr->d[3]>>32), (Uint)(tr->d[3]), (Uint)(tr->d[2]>>32), (Uint)(tr->d[2]), (Uint)(tr->d[1]>>32), (Uint)(tr->d[1]), (Uint)(tr->d[0]>>32), (Uint)(tr->d[0]));
d2387 1
a2387 1
    if ((reg_ctrl.i[cid].cid == cdx || cdx == 0) && exring[cid].unit[i].l_row == row && exring[cid].unit[i].lmring_ful1) { /* reg setup by PIO */
d2390 1
a2390 1
printf("====== WREG chip=%d cdx=%d l_row=%x row=%x cmd=%d ==== tr->ty=%x a=%08.8x dm=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n", (Uint)(reg_ctrl.i[cid].cid), cdx, exring[cid].unit[i].l_row, row, exring[cid].unit[i].cmd, tr->ty, tr->a, tr->dm, (Uint)(tr->d[3]>>32), (Uint)(tr->d[3]), (Uint)(tr->d[2]>>32), (Uint)(tr->d[2]), (Uint)(tr->d[1]>>32), (Uint)(tr->d[1]), (Uint)(tr->d[0]>>32), (Uint)(tr->d[0]));
d2458 1
a2458 1
  if ((exring[cid].unit[i].cycle & 3) == 3) /* final */
d2462 2
a2463 2
      && (exring[cid].unit[i].cycle & 3) == 3
      && reg_ctrl.i[cid].cmd == CMD_RESET) {
@


1.374
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.373 2019/08/02 14:25:38 nakashim Exp nakashim $";
d353 13
a370 1

a374 2
    siml_unit_lmm(cid, i);
    siml_unit_stage5(cid, i); /* stage-5 (4DR->BROUT)(LMRING_TR->LMRING_BROUT) */
a382 1
  siml_lmring_axi(cid, trace); /* LMRING->AXI */
d384 1
@


1.373
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.372 2019/03/28 08:52:55 nakashim Exp nakashim $";
a633 6
      printf("%03.3d:DMA WR mreq=%d last=%x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
             cid, axiif[cid].mreq, axiif[cid].axi_wlast, axiif[cid].axi_wstrb,
             (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
             (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
             (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
             (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
d635 6
@


1.372
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.371 2019/03/02 01:53:09 nakashim Exp nakashim $";
d320 1
a320 1
  if (cycle % ARM_EMAX6_RATIO) /* ARM:1.0GHz EMAX6:1.0GHz */
a352 8
  /* siml_unit_stage4()の前にLMRING_MUX個のdeq_waitを集約 */
  for (i=(row0+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
    siml_unit_lmm(cid, i);
    siml_unit_stage5(cid, i); /* stage-5 (4DR->BROUT)(LMRING_TR->LMRING_BROUT) */
    if (i==row0)
      break;
  }

d363 2
@


1.371
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.370 2019/02/24 14:06:47 nakashim Exp nakashim $";
d449 11
a459 11
  /* iorq.v_stat : 4 *1101===X=0000==========X========1101===========================X=1111
  /* iorq.tid    :12                                                                 A
  /* iorq.type   : 4  4:write                         3:read                         |
  /* iorq.opcd   : 6  2:LD/STRW 3:LD/STR 12:VLD/VSTRQ                                |
  /* iorq.ADR                                           ===A======                   |
  /* iorq.BUF[2]                                                                -----<=D=====>---
  /* iorq.rob
  /* rdata[]    SLAVE                                                   -----<=D=====>---
  /* rvalid     SLAVE                                                   _____/~~~~~★\___
  /* rlast      SLAVE                                                   _____/~~~~~~~\___
  /* rready    MASTER*                                                  _____/~~~~~★\___
d569 20
a588 20
  /* iorq.v_stat : 4 *1101===X=0000==========X========1101===========================X=1111
  /* iorq.tid    :12
  /* iorq.type   : 4  4:write                         3:read
  /* iorq.opcd   : 6  2:LD/STRW 3:LD/STR 12:VLD/VSTRQ
  /* iorq.ADR           ===A======                      ===A======
  /* iorq.BUF[2]        ===D======
  /* iorq.rob
  /* awaddr    MASTER*  -----<=A=====>---
  /* awlen     MASTER*  -----<=0=====>---
  /* awvalid   MASTER*  ___★/~~~~~~~\___ valid=1
  /* awready    SLAVE   ~~~~~~~~~~~~~\___ ready=1時に授受
  /* wstrb     MASTER*  -----<=M=====>---
  /* wdata[]   MASTER*  -----<=D=====>---
  /* wvalid    MASTER*  ___★/~~~~~~~\___
  /* wlast     MASTER*  _____/~~~~~~~\___ PIOの場合,常に1
  /* wready     SLAVE   ~~~~~~~~~~~~~\___
  /* araddr    MASTER*                                  -----<=A=====>---
  /* arlen     MASTER*                                  -----<=0=====>---
  /* arvalid   MASTER*                                  ___★/~~~~~~~\___
  /* arready    SLAVE                                   ~~~~~~~~~~~~~\___
d890 17
a906 17
  /* bro_ful2  0:emp,3:ful 0_/~1~~~~~\
  /* bro.rw    0:rd.1:wr   --<=0=====>-
  /* bro.ty    0:reg,4:lmm --<=*=====>-
  /* bro.col   :  2        reg_ctrl.csel
  /* bro.sq    : 16        --<=0=====>-
  /* bro.av    :  1        --<=0=====>-
  /* bro.a     : 31        --<=A=====>-
  /* bro.dm    : 32        ------------
  /* bro.d[4]  :256        --<=D=====>-
  /* axiif_reqn                                                         _____/~~~~~~~~~~~
  /* axiif_srw                  -----<=1=====>---                       -----<=0=====>---
  /* axiif_sadr                 -----<=A=====>---                       -----<=A=====>---
  /* axiif_sreq                 -----<=0=====>---                       -----<=0=====>---
  /* rdata[]    SLAVE*                                                  -----<=D=====>---
  /* rvalid     SLAVE*                                                  _____/~~~~~~~\___
  /* rlast      SLAVE*                                                  _____/~~~~~~~\___
  /* rready    MASTER                                                   ~~~~~~~~~~~~~~~~~
d1021 27
a1047 27
  /* awaddr    MASTER   -----<=A=====>---
  /* awlen     MASTER   -----<=0=====>---
  /* awvalid   MASTER   _____/~~~~~★\___ valid=1
  /* awready    SLAVE*  ~~~~~~~~~~~★\___ ready=1の時に授受
  /* wstrb     MASTER   -----<=M=====>---
  /* wdata[]   MASTER   -----<=D=====>---
  /* wvalid    MASTER   _____/~~~~~★\___
  /* wlast     MASTER   _____/~~~~~~~\___ PIOの場合,常に1
  /* wready     SLAVE*  ~~~~~~~~~~~★\___
  /* araddr    MASTER                A                          -----<=A=====>---
  /* arlen     MASTER                |                          -----<=0=====>---
  /* arvalid   MASTER                |                          _____/~~~~~★\___
  /* arready    SLAVE*               |                          ~~~~~~~~~~~★\___
  /* axiif_busy           *                                             _____/~~~~~~~~~~~
  /* axiif_srw            *     -----<=1=====>---                       -----<=0=====>---
  /* axiif_sadr           *     -----<=A=====>---                       -----<=A=====>---
  /* axiif_sreq           *     -----<=0=====>---                       -----<=0=====>---
  /* bri_ful2  0:emp,2:ful      __1__/~2~ update axring_b_top           __1__/~2~ update axring_b_top
  /* bri.rw    0:rd.1:wr  *     -----<=1=====>---                       -----<=0=====>---
  /* bri.ty    0:reg,4:lmm*     -----<=*=====>---                       -----<=*=====>---
  /* bri.col   :  2       *     reg_ctrl.csel                           reg_ctrl.csel
  /* bri.sq    : 16       *     -----<=0=====>---                       -----<=0=====>---
  /* bri.av    :  1       *     sadr <=0=====>---                       sadr <=0=====>---
  /* bri.a     : 31       *     sadr <=A=====>---                       sadr <=A=====>---
  /* bri.dm    : 32       *     wstrb<=M=====>---                       -----------------
  /* bri.d[4]  :256       *     wdata<=0=====>---                       -----------------
  /* deq_waiti 0:dq,1:wait      update axring_b_bot                     update axring_b_bot
@


1.370
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.369 2019/02/24 12:46:57 nakashim Exp nakashim $";
d255 12
@


1.369
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.368 2019/02/24 00:04:28 nakashim Exp nakashim $";
d1461 2
a1462 2
						                            ||(!reg_ctrl.i[cid].conf[i][0].cdw0.fold && !exring[cid].unit[i].one_shot)
						                            ||( reg_ctrl.i[cid].conf[i][0].cdw0.fold && !exring[cid].unit[i].one_shot_fold)
@


1.368
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.367 2018/12/27 22:45:56 nakashim Exp nakashim $";
a1582 1
    }
a1583 1
    if ((!reg_ctrl.i[cid].conf[i][0].cdw0.fold && exring[cid].unit[i].stage2_exec) || (reg_ctrl.i[cid].conf[i][0].cdw0.fold && exring[cid].unit[i].stage2_fold)) { /* active */
d1624 1
a1624 3
    }
 
    if (exring[cid].unit[i].stage2_exec || exring[cid].unit[i].stage2_fold) { /* active *//* folding時にEAGのself_loopは使わないと仮定 */
@


1.367
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.366 2018/12/26 03:35:46 nakashim Exp nakashim $";
d92 1
d1372 1
d1460 4
a1463 1
                                                                            ||(reg_ctrl.i[cid].conf[i][j].cdw0.ex1s!=1 || (!exring[cid].unit[i].one_shot || ((reg_ctrl.i[cid].conf[i][j].cdw0.init&1)&&(exring[cid].unit[i].unit1_forstat&1))))
d1502 1
a1502 1
      else if (exring[cid].unit[i].unit1_stop)
d1504 4
d1583 1
d1585 1
d1626 3
a1628 1

@


1.366
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.365 2018/12/25 10:58:47 nakashim Exp nakashim $";
a329 4
#if 0
  printf("ZZZZ cid=%d c[0].iorq.v_stat=%d arvalid=%d, awvalid=%d, wvalid=%d, reqn=%d, cmd_busy=%d, unit_busy=%d\n", cid, c[0].iorq.v_stat,
	 axiif[cid].axi_arvalid, axiif[cid].axi_awvalid, axiif[cid].axi_wvalid, axiif[cid].reqn, exring[cid].cmd_busy, exring[cid].unit_busy);
#endif
d379 11
a916 8
#if 0
printf("@@@@@@@@ cid=%d bro_ful2=%d", cid, bro_ful2);
for (i=0; i<EMAX_DEPTH; i++) {
if (i%8==0) printf(" ");
printf("%d", exring[cid].unit[i].lmring_ful2);
}
printf("\n");
#endif
d927 1
a927 1
      printf("%03.3d:BRO->AXIIF WR reqn--=%x ty=%x adr=%08.8x dm=%08.8x\n",
d1077 8
a1084 7
      if (axiif[cid].sreq == axiif[cid].slen)
        axiif[cid].radr_recv = 0; /* reset */
      bri->rw   = 0; /* read */
      bri->ty   = ( a              >=LMM_BASE2_PHYS) ? 4 : /* lmm  */
                  ((a&REG_AREA_MASK)>=REG_LDDM_OFFS) ? 3 : /* lddm */
                  ((a&REG_AREA_MASK)>=REG_ADDR_OFFS) ? 2 : /* addr */
                  ((a&REG_AREA_MASK)>=REG_BREG_OFFS) ? 1 : /* breg */
d1086 15
a1100 14
      bri->col  = reg_ctrl.i[cid].csel; /* logical col# for target lmm */
      bri->sq   = axiif[cid].sreq; /* from axiif[cid].axi_awlen to 0 */
      bri->av   = 0; /* initial */
      bri->a    = a + ((bri->ty==4)?reg_ctrl.i[cid].adtr:0) + axiif[cid].sreq*sizeof(Ull)*UNIT_WIDTH;
      bri->d[0] = 0;
      bri->d[1] = 0;
      bri->d[2] = 0;
      bri->d[3] = 0;
      axiif[cid].reqn++;
      axiif[cid].sreq++;
      axiif[cid].axring_ful2++;
      axiif[cid].axring_b_top = (axiif[cid].axring_b_top + 1)%AXRING_BR_BUF;
      if (trace)
        printf("%03.3d:AXIIF->BRI AR reqn++=%x adr=%08.8x\n", cid, axiif[cid].reqn, bri->a);
d1189 2
a1190 2
          printf("%03.3d:AXIIF->BRI WR reqn++=%x axring_ful2=%x bri_ful2=%x adr=%08.8x dm=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
                 cid, axiif[cid].reqn, axiif[cid].axring_ful2, bri_ful2, bri->a, bri->dm,
@


1.365
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.364 2018/12/24 14:18:28 nakashim Exp nakashim $";
d330 4
a333 2
printf("ZZZZZZZ cid=%d c[0].iorq.v_stat=%d arvalid=%d, awvalid=%d, wvalid=%d, reqn=%d, cmd_busy=%d, unit_busy=%d\n", cid, c[0].iorq.v_stat,
axiif[cid].axi_arvalid, axiif[cid].axi_awvalid, axiif[cid].axi_wvalid, axiif[cid].reqn, exring[cid].cmd_busy, exring[cid].unit_busy);
d893 1
a893 1
  /*│ I├─┤PD├→─◆─┌──────┐┐└→┤PD├─→─┤PD├→─◆─┌──────┐┐└→┤PD├→ */
d900 9
a908 1
  /* 後段へのrreadyは，自broが有効+前段がrreadyの場合に1                                                 */
d910 1
a910 1
#if 1
a931 1
    printf("TTTT cid=%d axi_rvalid=%d\n", cid, axiif[cid].axi_rvalid);
d936 1
a936 2
    if (cid < EMAX_NCHIP-1 && !axiif[cid+1].axi_rvalid) { /* 下流から何もなし */
      printf("XXXX %03.3d:BRO waiting for succeeding IMAX[%d]\n", cid, cid+1);
d939 2
d942 4
a945 3
    else if (cid < EMAX_NCHIP-1 && !axiif[cid+1].axi_rready) { /* 最終IMAX,または,下流から受取不可なら */
      printf("YYYY %03.3d:BRO waiting for succeeding rready\n", cid);
      axiif[cid].deq_wait = 1; /* 上流axiによるdeq不可 */
d948 2
a949 14
    else { /* 最終IMAX,または,下流から受信開始 */
      printf("CCCC cid=%d axi_rvalid=%d\n", cid, axiif[cid].axi_rvalid);
      if (!axiif[cid].axi_rvalid) { /* 上流に未sendなら */
	for (k=0; k<UNIT_WIDTH; k++) {
	  if (cid < EMAX_NCHIP-1)
	    axiif[cid].axi_rdata[k] = axiif[cid+1].axi_rdata[k];
	  else
	    axiif[cid].axi_rdata[k] = 0LL;
	  for (i=0; i<LMRING_MUX; i++) {
	    if (bro[i]->av)
	      axiif[cid].axi_rdata[k] |= bro[i]->d[k];
	  }
	}
	axiif[cid].axi_rvalid = 1; /* 上流axiはread-OK */
d951 1
a951 10
	  axiif[cid+1].axi_rready = 0;
	printf("OOOO cid=%d sent\n", cid);
      }
      else if (axiif[cid].axi_rready) {
	axiif[cid].deq_wait = 0; /* 上流axiによるdeq-OK */
	axiif[cid].reqn--;
	axiif[cid].axi_rvalid = 0;
	printf("PPPP cid=%d reqn--:%d\n", cid, axiif[cid].reqn);
	if (!bro_av)
	  printf("%03.3d:BRO RD no unit covers ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro[0]->ty, bro[0]->a, bro[0]->a-reg_ctrl.i[cid].adtr);
d953 5
a957 6
	  printf("%03.3d:AXI RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
		 cid, axiif[cid].sadr,
		 (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
		 (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
		 (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
		 (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
d959 14
d1047 1
a1047 1
  /*│  │  │ 　 └────────←──◆─┘ 　 ││  ││ 　 └────────←──◆─┘ 　 │   */
d1098 1
a1098 1
      if (1)
@


1.364
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.363 2018/12/24 13:20:44 nakashim Exp nakashim $";
d495 5
a499 5
	     cid, axiif[cid].sadr,
	     (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	     (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	     (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	     (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
d855 1
a855 1
  struct lmring_br *bro[LMRING_MUX];
d888 20
d910 1
a910 2
    axiif[cid].deq_wait = 0; /* 有効と無効が混在 *//* bro_ful2=1:全lmringが有効 1111 */
    axiif[cid].axi_rvalid = 0;
d912 3
d921 2
a922 1
  else if (bro_ful2 && bro[0]->rw==0) {
d927 24
a950 6
    if (cid < EMAX_NCHIP-1 && !axiif[cid+1].axi_rvalid) {
      printf("%03.3d:BRO waiting for succeeding IMAX[%d]\n", cid, cid+1);
      axiif[cid].deq_wait = 1; /* 有効と無効が混在 *//* bro_ful2=1:全lmringが有効 1111 */
    }
    else { /* RDは無条件にdequeue */
      for (k=0; k<UNIT_WIDTH; k++) {
d952 10
a961 1
	  axiif[cid].axi_rdata[k] = axiif[cid+1].axi_rdata[k];
d963 6
a968 5
	  axiif[cid].axi_rdata[k] = 0LL;
	for (i=0; i<LMRING_MUX; i++) {
	  if (bro[i]->av)
	    axiif[cid].axi_rdata[k] |= bro[i]->d[k];
	}
a969 16
      for (i=0; i<LMRING_MUX; i++) {
	exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2--;
	exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot = (exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot + 1)%LMRING_BR_BUF;
      }
      axiif[cid].deq_wait = 0; /* 有効と無効が混在 *//* bro_ful2=1:全lmringが有効 1111 */
      axiif[cid].axi_rvalid = 1;
      axiif[cid].reqn--;
      if (!bro_av)
	printf("%03.3d:BRO RD no unit covers ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro[0]->ty, bro[0]->a, bro[0]->a-reg_ctrl.i[cid].adtr);
      else
	printf("%03.3d:AXI RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	     cid, axiif[cid].sadr,
	     (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	     (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	     (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	     (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
d976 1
a976 1
    axiif[cid].axi_rvalid = 1;
d978 1
a978 2
    if (cid == 0)
      printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
d985 6
a990 2
  else
    axiif[cid].axi_rvalid = 0;
d1036 14
a1049 4

  axiif[cid].axi_arready = (bri_ful2 < AXRING_BR_BUF && !axiif[cid].radr_recv && (cid == EMAX_NCHIP-1 || axiif[cid+1].axi_arready)); /* wire ★0,1 */
  axiif[cid].axi_awready = (bri_ful2 < AXRING_BR_BUF && !axiif[cid].wadr_recv && (cid == EMAX_NCHIP-1 || axiif[cid+1].axi_awready)); /* wire ★0,1 */
  axiif[cid].axi_wready  = (bri_ful2 < AXRING_BR_BUF                          && (cid == EMAX_NCHIP-1 || axiif[cid+1].axi_wready));  /* wire ★0,1 */
d1076 1
a1076 1
	axiif[cid].radr_recv = 0; /* reset */
d1095 1
a1095 1
      if (trace)
d1118 37
a1154 37
	axiif[cid].wadr_recv = 0; /* reset */
	if      (axiif[cid].axi_wstrb & 0x000000ff) { k=0; mask=axiif[cid].axi_wstrb     & 0xff; }
	else if (axiif[cid].axi_wstrb & 0x0000ff00) { k=1; mask=axiif[cid].axi_wstrb>> 8 & 0xff; }
	else if (axiif[cid].axi_wstrb & 0x00ff0000) { k=2; mask=axiif[cid].axi_wstrb>>16 & 0xff; }
	else if (axiif[cid].axi_wstrb & 0xff000000) { k=3; mask=axiif[cid].axi_wstrb>>24 & 0xff; }
	if (mask & 0x0f)
	  *((Uint*)((Ull*)((Uchar*)&reg_ctrl.i[cid]+(a-REG_BASE2_PHYS))+k)  ) = axiif[cid].axi_wdata[k];
	if (mask & 0xf0)
	  *((Uint*)((Ull*)((Uchar*)&reg_ctrl.i[cid]+(a-REG_BASE2_PHYS))+k)+1) = axiif[cid].axi_wdata[k]>>32;
	if (trace)
	  printf("%03.3d:AXIIF->REG WR adr=%08.8x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
		 cid, a, axiif[cid].axi_wstrb,
		 (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
		 (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
		 (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
		 (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
	if (cid < EMAX_NCHIP-1) {
  	  axiif[cid+1].axi_wstrb    = axiif[cid].axi_wstrb    | (a==REG_BASE2_PHYS?0x00f00000:0x00000000); /* set cid=0,1,2,3 */;
	  axiif[cid+1].axi_wdata[0] = axiif[cid].axi_wdata[0];
	  axiif[cid+1].axi_wdata[1] = axiif[cid].axi_wdata[1];
	  axiif[cid+1].axi_wdata[2] = axiif[cid].axi_wdata[2] + (a==REG_BASE2_PHYS?0x100000000LL:0x000000000LL); /* set cid=0,1,2,3 */
	  axiif[cid+1].axi_wdata[3] = axiif[cid].axi_wdata[3];
	  axiif[cid+1].axi_wvalid   = 1; /* on */
	  axiif[cid+1].axi_wlast    = 1; /* on */
	}
	switch (reg_ctrl.i[cid].cmd) {
	case CMD_RESET:
	case CMD_SCON:  /* scon */
	case CMD_EXEC:  /* exec */
	  if (!exring[cid].cmd_busy) {
	    printf("%03.3d:ES %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 CMD(%x) START---\n", cid,
		   (Uint)(t[cid].total_steps>>32), (Uint)t[cid].total_steps,
		   (Uint)(t[cid].total_cycle>>32), (Uint)t[cid].total_cycle, reg_ctrl.i[cid].cmd);
	    exring[cid].cmd_busy = 1;
	  }
	  break;
	}
d1158 1
a1158 1
	  axiif[cid+1].axi_wvalid   = 0; /* off */
d1163 4
a1166 4
	if (axiif[cid].sreq == axiif[cid].slen)
	  axiif[cid].wadr_recv = 0; /* reset */
	bri->rw   = 1; /* write */
	bri->ty   = ( a              >=LMM_BASE2_PHYS) ? 4 : /* lmm  */
d1171 19
a1189 19
	bri->col  = reg_ctrl.i[cid].csel;   /* logical col# for target lmm */
	bri->sq   = axiif[cid].sreq; /* from 0 to axiif[cid].axi_awlen */
	bri->av   = 0; /* initial */
	bri->a    = a + ((bri->ty==4)?reg_ctrl.i[cid].adtr:0) + axiif[cid].sreq*sizeof(Ull)*UNIT_WIDTH;
	bri->dm   = axiif[cid].axi_wstrb;
	bri->d[0] = axiif[cid].axi_wdata[0];
	bri->d[1] = axiif[cid].axi_wdata[1];
	bri->d[2] = axiif[cid].axi_wdata[2];
	bri->d[3] = axiif[cid].axi_wdata[3];
	axiif[cid].reqn++;
	axiif[cid].sreq++;
	axiif[cid].axring_ful2++;
	axiif[cid].axring_b_top = (axiif[cid].axring_b_top + 1)%AXRING_BR_BUF;
	if (trace)
	  printf("%03.3d:AXIIF->BRI WR reqn++=%x axring_ful2=%x bri_ful2=%x adr=%08.8x dm=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
		 cid, axiif[cid].reqn, axiif[cid].axring_ful2, bri_ful2, bri->a, bri->dm,
		 (Uint)(bri->d[3]>>32), (Uint)bri->d[3],
		 (Uint)(bri->d[2]>>32), (Uint)bri->d[2],
		 (Uint)(bri->d[1]>>32), (Uint)bri->d[1],
d1191 12
a1202 12
	if (cid < EMAX_NCHIP-1) {
  	  axiif[cid+1].axi_wstrb    = axiif[cid].axi_wstrb;
	  axiif[cid+1].axi_wdata[0] = axiif[cid].axi_wdata[0];
	  axiif[cid+1].axi_wdata[1] = axiif[cid].axi_wdata[1];
	  axiif[cid+1].axi_wdata[2] = axiif[cid].axi_wdata[2];
	  axiif[cid+1].axi_wdata[3] = axiif[cid].axi_wdata[3];
	  axiif[cid+1].axi_wvalid   = 1; /* on */
	  if (axiif[cid].sreq == axiif[cid].slen)
	    axiif[cid+1].axi_wlast  = 1; /* on */
	  else
	    axiif[cid+1].axi_wlast  = 0; /* off */
	}
d1206 1
a1206 1
  	  axiif[cid+1].axi_wvalid   = 0; /* off */
@


1.363
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.362 2018/12/24 13:09:58 nakashim Exp nakashim $";
d445 1
a445 1
        printf("%03.3d:DMA LMM->MEM RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
d491 1
a491 1
        printf("%03.3d:DMA->IORQ RD opcd=%d adr=%08.8x data=%08.8x_%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
d494 6
d587 1
a587 1
        printf("%03.3d:DMA MEM->LMM WR start ddradr=%08.8x lmmadr=%08.8x len=%04.4x\n",
d618 1
a618 1
      printf("%03.3d:DMA MEM->LMM WR mreq=%d last=%x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
d630 1
a630 1
      printf("%03.3d:DMA MEM->LMM WR FIN\n", cid);
d646 1
a646 1
        printf("%03.3d:DMA LMM->MEM RD start lmmadr=%08.8x ddradr=%08.8x len=%04.4x\n",
d668 1
a668 1
        printf("%03.3d:IORQ->DMA WR opcd=%d adr=%08.8x data=%08.8x_%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
d684 1
a684 1
          printf("%03.3d:DMA MEM->LMM WR src=%08.8x dst=%08.8x len=%04.4x\n", cid,
d700 1
a700 1
          printf("%03.3d:DMA LMM->MEM RD src=%08.8x dst=%08.8x len=%04.4x\n", cid,
d929 1
a929 1
	printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
@


1.362
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.361 2018/12/24 10:35:41 nakashim Exp nakashim $";
d1021 2
a1043 3
    else { /* done */
      axiif[cid].radr_recv = 0; /* reset */
    }
d1109 2
a1154 5
    else { /* done */
      axiif[cid].wadr_recv = 0; /* reset */
      if (cid < EMAX_NCHIP-1)
         axiif[cid+1].axi_wvalid   = 0; /* off */
    }
@


1.361
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.360 2018/12/24 08:24:58 nakashim Exp nakashim $";
d330 2
d993 3
a995 3
  axiif[cid].axi_arready = (bri_ful2 < AXRING_BR_BUF && (cid == EMAX_NCHIP-1 || axiif[cid+1].axi_arready)); /* wire ★0,1 */
  axiif[cid].axi_awready = (bri_ful2 < AXRING_BR_BUF && (cid == EMAX_NCHIP-1 || axiif[cid+1].axi_awready)); /* wire ★0,1 */
  axiif[cid].axi_wready  = (bri_ful2 < AXRING_BR_BUF && (cid == EMAX_NCHIP-1 || axiif[cid+1].axi_wready));  /* wire ★0,1 */
@


1.360
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.359 2018/12/24 06:20:35 nakashim Exp nakashim $";
d301 1
a301 1
  int i, j, k, row0, prev_stat, busy;
d317 7
a323 6
  if (cid == 0) { /* cid#0のみ */
    /* update LMRING/EXRING */
    prev_stat = c[cid].iorq.v_stat || reg_ctrl.i[cid].stat;
    /* ソフトからのstat検査時に(c[cid].iorq.v_stat)を含めると常にbusy */
    reg_ctrl.i[cid].stat = (!(axiif[cid].reqn)?LMRING_IDLE:LMRING_BUSY)<<4 | (!(exring[cid].cmd_busy||exring[cid].unit_busy)?EXRING_IDLE:EXRING_BUSY);
  }
d325 4
a328 6
#if 0 
  if (!c[0].iorq.v_stat && !reg_ctrl.i[0].stat) {
    if (cid == 0 && prev_stat)
      printf("%03.3d:EE %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 IO/CMD-END----\n", cid, (Uint)(steps>>32), (Uint)steps, (Uint)(cycle>>32), (Uint)cycle);
    return (0);
  }
d1159 2
@


1.359
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.358 2018/12/23 13:57:02 nakashim Exp nakashim $";
d323 2
d330 1
@


1.358
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.357 2018/12/23 12:12:02 nakashim Exp nakashim $";
a999 1
printf("================== ARVALID=1 IMAX%d -> %d\n", cid, cid+1);
d1007 1
a1007 2
    if (cid < EMAX_NCHIP-1 && axiif[cid+1].axi_arvalid && axiif[cid+1].axi_arready) {
printf("================== ARVALID=0 IMAX%d -> %d\n", cid, cid+1);
a1008 1
    }
a1048 1
printf("================== AWVALID=1 IMAX%d -> %d\n", cid, cid+1);
d1056 1
a1056 2
    if (cid < EMAX_NCHIP-1 && axiif[cid+1].axi_awvalid && axiif[cid+1].axi_awready) {
printf("================== AWVALID=0 IMAX%d -> %d\n", cid, cid+1);
a1057 1
    }
d1078 1
a1078 2
printf("================== WVALID=1 IMAX%d -> %d\n", cid, cid+1);
  	  axiif[cid+1].axi_wstrb    = axiif[cid].axi_wstrb;
d1081 1
a1081 1
	  axiif[cid+1].axi_wdata[2] = axiif[cid].axi_wdata[2];
d1099 4
d1131 1
a1131 1
               (Uint)(bri->d[0]>>32), (Uint)bri->d[0]);
a1132 1
printf("================== WVALID=1 IMAX%d -> %d\n", cid, cid+1);
d1145 4
d1152 1
a1152 2
      if (cid < EMAX_NCHIP-1) {
printf("================== WVALID=0 IMAX%d -> %d\n", cid, cid+1);
a1153 1
      }
d1866 1
a1866 1
    tr->av   = br->av || exring[cid].unit[i].lmranger_ok || exring[cid].unit[i].lmrangew_ok || ((reg_ctrl.i[cid].cmd>>32&(EMAX_NCHIP-1)) == cdx && exring[cid].unit[i].l_row == row && br->ty<4);
d2253 1
a2253 1
  else if (exring[cid].unit[i].cmd == CMD_NOP && (reg_ctrl.i[cid].cmd>>32&(EMAX_NCHIP-1)) == cdx && exring[cid].unit[i].l_row == row && exring[cid].unit[i].lmring_ful1) { /* reg setup by PIO */
d2256 1
a2256 1
printf("====== WREG chip=%d cdx=%d l_row=%x row=%x cmd=%d ==== tr->ty=%x a=%08.8x dm=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n", (Uint)(reg_ctrl.i[cid].cmd>>32&(EMAX_NCHIP-1)), cdx, exring[cid].unit[i].l_row, row, exring[cid].unit[i].cmd, tr->ty, tr->a, tr->dm, (Uint)(tr->d[3]>>32), (Uint)(tr->d[3]), (Uint)(tr->d[2]>>32), (Uint)(tr->d[2]), (Uint)(tr->d[1]>>32), (Uint)(tr->d[1]), (Uint)(tr->d[0]>>32), (Uint)(tr->d[0]));
d2302 1
a2302 1
    if ((reg_ctrl.i[cid].cmd>>32&(EMAX_NCHIP-1)) == cdx && exring[cid].unit[i].l_row == row && exring[cid].unit[i].lmring_ful1) { /* reg setup by PIO */
d2305 1
a2305 1
printf("====== WREG chip=%d cdx=%d l_row=%x row=%x cmd=%d ==== tr->ty=%x a=%08.8x dm=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n", (Uint)(reg_ctrl.i[cid].cmd>>32&(EMAX_NCHIP-1)), cdx, exring[cid].unit[i].l_row, row, exring[cid].unit[i].cmd, tr->ty, tr->a, tr->dm, (Uint)(tr->d[3]>>32), (Uint)(tr->d[3]), (Uint)(tr->d[2]>>32), (Uint)(tr->d[2]), (Uint)(tr->d[1]>>32), (Uint)(tr->d[1]), (Uint)(tr->d[0]>>32), (Uint)(tr->d[0]));
@


1.357
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.356 2018/12/23 09:53:51 nakashim Exp nakashim $";
d1083 10
@


1.356
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.355 2018/12/23 03:41:14 nakashim Exp nakashim $";
a879 2
    if (!bro_av)
      printf("%03.3d:BRO WR no unit covers ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro[0]->ty, bro[0]->a, bro[0]->a-reg_ctrl.i[cid].adtr);
d883 2
a898 2
      if (!bro_av)
	printf("%03.3d:BRO RD no unit covers ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro[0]->ty, bro[0]->a, bro[0]->a-reg_ctrl.i[cid].adtr);
d916 4
a919 1
      printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
d933 2
a934 1
    printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
@


1.355
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.354 2018/12/23 00:11:30 nakashim Exp nakashim $";
d50 2
a51 1
  Ull   adr_recv           : 1; /* 0:none, 1:recv for read */
d891 4
a894 4
    /*                                 axiif[cid+1].axi_rvalid             */
    /*                                 axiif[cid+1].axi_rlast              */
    /*                                 axiif[cid+1].axi_rready             */
    if (0 /*cid < EMAX_NCHIP-1 && !axiif[cid+1].axi_rvalid*/) {
d987 3
a989 3
  axiif[cid].axi_awready = (bri_ful2 < AXRING_BR_BUF); /* wire ★0,1 */
  axiif[cid].axi_wready  = (bri_ful2 < AXRING_BR_BUF); /* wire ★0,1 */
  axiif[cid].axi_arready = (bri_ful2 < AXRING_BR_BUF); /* wire ★0,1 */
d992 1
a992 1
    axiif[cid].adr_recv = 1; /* fin */
d997 6
d1004 1
a1004 1
  else if (axiif[cid].adr_recv) {
d1006 4
d1012 1
a1012 1
      axiif[cid].adr_recv = 0; /* reset */
d1040 1
a1040 1
      axiif[cid].adr_recv = 0; /* reset */
d1044 1
d1049 6
d1056 1
a1056 1
  else if (axiif[cid].axi_wvalid && axiif[cid].axi_wready) {
d1058 5
a1062 4
    if (axiif[cid].axi_awvalid && axiif[cid].axi_awready)
      a = axiif[cid].axi_awaddr;
    else
      a = axiif[cid].sadr;
d1064 30
a1093 15
      if      (axiif[cid].axi_wstrb & 0x000000ff) { k=0; mask=axiif[cid].axi_wstrb     & 0xff; }
      else if (axiif[cid].axi_wstrb & 0x0000ff00) { k=1; mask=axiif[cid].axi_wstrb>> 8 & 0xff; }
      else if (axiif[cid].axi_wstrb & 0x00ff0000) { k=2; mask=axiif[cid].axi_wstrb>>16 & 0xff; }
      else if (axiif[cid].axi_wstrb & 0xff000000) { k=3; mask=axiif[cid].axi_wstrb>>24 & 0xff; }
      if (mask & 0x0f)
        *((Uint*)((Ull*)((Uchar*)&reg_ctrl.i[cid]+(a-REG_BASE2_PHYS))+k)  ) = axiif[cid].axi_wdata[k];
      if (mask & 0xf0)
        *((Uint*)((Ull*)((Uchar*)&reg_ctrl.i[cid]+(a-REG_BASE2_PHYS))+k)+1) = axiif[cid].axi_wdata[k]>>32;
      if (trace)
        printf("%03.3d:AXIIF->REG WR adr=%08.8x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
               cid, a, axiif[cid].axi_wstrb,
               (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
               (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
               (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
               (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
d1096 26
a1121 25
      bri->rw   = 1; /* write */
      bri->ty   = ( a              >=LMM_BASE2_PHYS) ? 4 : /* lmm  */
                  ((a&REG_AREA_MASK)>=REG_LDDM_OFFS) ? 3 : /* lddm */
                  ((a&REG_AREA_MASK)>=REG_ADDR_OFFS) ? 2 : /* addr */
                  ((a&REG_AREA_MASK)>=REG_BREG_OFFS) ? 1 : /* breg */
                                                       0 ; /* conf */
      bri->col  = reg_ctrl.i[cid].csel;   /* logical col# for target lmm */
      bri->sq   = axiif[cid].sreq; /* from 0 to axiif[cid].axi_awlen */
      bri->av   = 0; /* initial */
      bri->a    = a + ((bri->ty==4)?reg_ctrl.i[cid].adtr:0) + axiif[cid].sreq*sizeof(Ull)*UNIT_WIDTH;
      bri->dm   = axiif[cid].axi_wstrb;
      bri->d[0] = axiif[cid].axi_wdata[0];
      bri->d[1] = axiif[cid].axi_wdata[1];
      bri->d[2] = axiif[cid].axi_wdata[2];
      bri->d[3] = axiif[cid].axi_wdata[3];
      axiif[cid].reqn++;
      axiif[cid].sreq++;
      axiif[cid].axring_ful2++;
      axiif[cid].axring_b_top = (axiif[cid].axring_b_top + 1)%AXRING_BR_BUF;
      if (trace)
        printf("%03.3d:AXIIF->BRI WR reqn++=%x axring_ful2=%x bri_ful2=%x adr=%08.8x dm=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
               cid, axiif[cid].reqn, axiif[cid].axring_ful2, bri_ful2, bri->a, bri->dm,
               (Uint)(bri->d[3]>>32), (Uint)bri->d[3],
               (Uint)(bri->d[2]>>32), (Uint)bri->d[2],
               (Uint)(bri->d[1]>>32), (Uint)bri->d[1],
d1123 14
d1139 4
a1142 10
    }
    switch (reg_ctrl.i[cid].cmd) {
    case CMD_RESET:
    case CMD_SCON:  /* scon */
    case CMD_EXEC:  /* exec */
      if (!exring[cid].cmd_busy) {
        printf("%03.3d:ES %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 CMD(%x) START---\n", cid,
               (Uint)(t[cid].total_steps>>32), (Uint)t[cid].total_steps,
               (Uint)(t[cid].total_cycle>>32), (Uint)t[cid].total_cycle, reg_ctrl.i[cid].cmd);
        exring[cid].cmd_busy = 1;
a1143 1
      break;
d1148 2
a1149 1
      axiif[cid].adr_recv       = 0;
@


1.354
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.353 2018/12/22 13:54:51 nakashim Exp nakashim $";
d893 1
a893 1
    if (cid < EMAX_NCHIP-1 && !axiif[cid+1].axi_rvalid) {
d926 1
d984 2
d990 43
a1032 1
  if (axiif[cid].axi_awvalid && axiif[cid].axi_awready) {
d1038 1
a1038 1
  if (axiif[cid].axi_wvalid && axiif[cid].axi_wready) {
d1124 5
a1133 48
  if (axiif[cid].axi_arvalid && axiif[cid].axi_arready) { /* new read_req starts */
    axiif[cid].adr_recv = 1; /* fin */
    axiif[cid].srw  = 0; /* read */
    axiif[cid].sadr = axiif[cid].axi_araddr;
    axiif[cid].slen = axiif[cid].axi_arlen;
    axiif[cid].sreq = 0;
  }
  else if (axiif[cid].adr_recv) {
    Uint a;
    a = axiif[cid].sadr;
    if (a < REG_BASE2_PHYS+REG_CONF_OFFS) { /* control space ... 固定位置 *//* 本来はbri_ful2の影響を受けないが,統一管理のためにbri_ful2を使用 */
      axiif[cid].adr_recv = 0; /* reset */
      axiif[cid].creg = 1; /* set RD control regs */
      if (trace)
        printf("%03.3d:AXIIF->REG AR adr=%08.8x\n", cid, a);
    }
    else if (axiif[cid].sreq <= axiif[cid].slen) { /* (burst 256bit_LMM -> 256bit_AXI_read (256bit*256count = 8KB)) */
      bri->rw   = 0; /* read */
      bri->ty   = ( a              >=LMM_BASE2_PHYS) ? 4 : /* lmm  */
                  ((a&REG_AREA_MASK)>=REG_LDDM_OFFS) ? 3 : /* lddm */
                  ((a&REG_AREA_MASK)>=REG_ADDR_OFFS) ? 2 : /* addr */
                  ((a&REG_AREA_MASK)>=REG_BREG_OFFS) ? 1 : /* breg */
                                                       0 ; /* conf */
      bri->col  = reg_ctrl.i[cid].csel; /* logical col# for target lmm */
      bri->sq   = axiif[cid].sreq; /* from axiif[cid].axi_awlen to 0 */
      bri->av   = 0; /* initial */
      bri->a    = a + ((bri->ty==4)?reg_ctrl.i[cid].adtr:0) + axiif[cid].sreq*sizeof(Ull)*UNIT_WIDTH;
      bri->d[0] = 0;
      bri->d[1] = 0;
      bri->d[2] = 0;
      bri->d[3] = 0;
      axiif[cid].reqn++;
      axiif[cid].sreq++;
      axiif[cid].axring_ful2++;
      axiif[cid].axring_b_top = (axiif[cid].axring_b_top + 1)%AXRING_BR_BUF;
      if (trace)
        printf("%03.3d:AXIIF->BRI AR reqn++=%x adr=%08.8x\n", cid, axiif[cid].reqn, bri->a);
    }
    else { /* done */
      axiif[cid].adr_recv = 0; /* reset */
    }
  }

  if (bri_ful2 && !axiif[cid].exring_deq_wait) { /* dequeued for next cycle */
    axiif[cid].axring_ful2--;
    axiif[cid].axring_b_bot = (axiif[cid].axring_b_bot + 1)%AXRING_BR_BUF;
  }

@


1.353
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.352 2018/12/21 11:17:09 nakashim Exp nakashim $";
d894 1
a894 1
      printf("%03.3d:BRO waiting for succeeding IMAX%d\n", cid, cid+1);
d901 4
a904 1
	axiif[cid].axi_rdata[k] = 0LL;
d906 1
a906 1
	  if (bro[i]->av) {
a907 1
	  }
@


1.352
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.351 2018/12/21 10:35:05 nakashim Exp nakashim $";
a850 2
  /* bro_ful2=1:全lmringが有効 1111 */
  axiif[cid].deq_wait = !bro_ful2; /* 有効と無効が混在 */
d876 1
a876 4
  if (bro_ful2 && !bro_av) {
    printf("%03.3d:BRO no unit covers rw=%x ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro[0]->rw, bro[0]->ty, bro[0]->a, bro[0]->a-reg_ctrl.i[cid].adtr);
  }

d878 5
d888 36
a923 2

  if (axiif[cid].creg) { /* RD control regs */
a934 26
  else if (bro_ful2 && bro[0]->rw==0) { /* RDは無条件にdequeue */
    axiif[cid].axi_rdata[0] = 0LL;
    axiif[cid].axi_rdata[1] = 0LL;
    axiif[cid].axi_rdata[2] = 0LL;
    axiif[cid].axi_rdata[3] = 0LL;
    for (i=0; i<LMRING_MUX; i++) {
      if (bro[i]->av) {
        axiif[cid].axi_rdata[0] |= bro[i]->d[0];
        axiif[cid].axi_rdata[1] |= bro[i]->d[1];
        axiif[cid].axi_rdata[2] |= bro[i]->d[2];
        axiif[cid].axi_rdata[3] |= bro[i]->d[3];
      }
    }
    axiif[cid].axi_rvalid = 1;
    axiif[cid].reqn--;
    for (i=0; i<LMRING_MUX; i++) {
      exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2--;
      exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot = (exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot + 1)%LMRING_BR_BUF;
    }
    printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
           cid, axiif[cid].sadr,
           (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
           (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
           (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
           (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
  }
@


1.351
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.350 2018/12/21 10:07:22 nakashim Exp nakashim $";
d264 20
a283 20
  /*┌─┐┌───────────────────┐┌─┐┌───────────────────┐   */
  /*│ A││awaddr        $1 WR/RD-req      awaddr││ A││awaddr        $1 WR/RD-req      awaddr│   */
  /*│ R││awdata  ┌──────────┐awdata││ R││awdata  ┌──────────┐awdata│   */
  /*│ M││araddr  │  ┌exring─←─┐  │araddr││ M││araddr  │  ┌exring─←─┐  │araddr│   */
  /*│─┤├─┐  $1│$2│┌┐┌┐┌┐│  │  ┌─┤│  │├─┐  $1│$2│┌┐┌┐┌┐│  │  ┌─┤   */
  /*│ I├┤PD├→─◆─□□□□□□□□┐└→┤PD├─→─┤PD├→─◆─□□□□□□□□┐└→┤PD├→ */
  /*│ /││IM│SL l├─□□□□□□□□┤  MA│IM││  ││IM│SL l├─□□□□□□□□┤  MA│IM│   */
  /*│ O├┤OA├┐ m├─□□□□□□□□┤  ┌┤OA├─←─┤OA├┐ m├─□□□□□□□□┤  ┌┤OA├← */
  /*│─┤├─┘│ r├─□□□□□□□□┤  │└─┤│  │├─┘│ r├─□□□□□□□□┤  │└─┤   */
  /*│#0││　  │ i├─□□□□□□□□┤  │    ││#1││    │ i├─□□□□□□□□┤  │    │   */
  /*│　││  　│ n├─□□□□□□□□┤  │　  ││  ││  　│ n├─□□□□□□□□┤  │　  │   */
  /*│　││    │ g├─□□□□□□□□┤  │$4  ││  ││    │ g├─□□□□□□□□┤  │$4  │   */
  /*│　││    │  └─□□□□□□□□┤  │    ││  ││    │  └─□□□□□□□□┤  │    │   */
  /*│ L││ 　 │      └┘└┘└┘└┘↓$3│ 　 ││ L││ 　 │      └┘└┘└┘└┘↓$3│ 　 │   */
  /*│ 1││ 　 └────────←──◆─┘ 　 ││ 1││ 　 └────────←──◆─┘ 　 │   */
  /*│ $││ardata               $4 RD-wait ardata││ $││ardata               $4 RD-wait ardata│   */
  /*└─┘└───────────────────┘└─┘└───────────────────┘   */
  /*                               chip#0                             | #1             #2              */
  /* siml_axi_iorq(cid, trace)     c[0].iorq <- axiif[0]              | -              -               */
  /* siml_iorq_axi(cid, trace)     c[0].iorq -> axiif[0]              | -              -               */
d290 1
a290 1
  /* siml_exring_deq_wait(cid)     axiif.exring_deq_wait(axi->lmring) |                                */
d292 1
a292 1
  /*   siml_unit_stage4(cid, row)  bri: axring/lmring切替え                                            */
d297 2
a298 2
  /* siml_lmring_axi(cid, trace)   axiif[0] <- lmring[0.term]         | lm[1.term]     lm[2.term]      */
  /* siml_axi_lmring(cid, trace)   axiif[0] -> axiif[0].axring        |                                */
@


1.350
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.349 2018/12/07 02:52:04 nakashim Exp nakashim $";
d379 148
d791 12
a802 1
siml_axi_iorq(cid, trace) Uint cid, trace;
a821 8
  /* iorq.v_stat      : 4; v 0:empty 1:reserve 3:inuse | stat 0:empty 1:busy 3:RD-ok */
  /* iorq.tid         :12;                         */
  /* iorq.type        : 4; type                    */
  /* iorq.opcd        : 6; opcd                    */
  /* iorq.ADR            ; 以前のADDRに対応        */
  /* iorq.BUF[2]         ; for load/store          */
  /* iorq.rob            ; for DATA                */

d832 22
d855 1
a855 1
  /*       HOST:AXIIF->IORQ (ARM-restartにより,iorqに該当エントリがない場合がある) */
d859 17
a875 11
  /* iorq.v_stat : 4 *1101===X=0000==========X========1101===========================X=1111
  /* iorq.tid    :12                                                                 A
  /* iorq.type   : 4  4:write                         3:read                         |
  /* iorq.opcd   : 6  2:LD/STRW 3:LD/STR 12:VLD/VSTRQ                                |
  /* iorq.ADR                                           ===A======                   |
  /* iorq.BUF[2]                                                                -----<=D=====>---
  /* iorq.rob
  /* rdata[]    SLAVE                                                   -----<=D=====>---
  /* rvalid     SLAVE                                                   _____/~~~~~★\___
  /* rlast      SLAVE                                                   _____/~~~~~~~\___
  /* rready    MASTER*                                                  _____/~~~~~★\___
d878 3
a880 1
  axiif[cid].axi_rready = 1; /* always 1 */
d882 5
a886 36
  if (axiif[cid].dma_stat == 2) { /* DMA RD active */
    if (axiif[cid].mreq <= axiif[cid].mlen) { /* write active */
      if (axiif[cid].axi_rvalid && axiif[cid].axi_rready) { /* new read_req starts */
        printf("%03.3d:DMA LMM->MEM RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
               cid, axiif[cid].madr+axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH,
               (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
               (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
               (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
               (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
        if (axiif[cid].mreq == 0) {
          if (axiif[cid].fmask&1) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
          if (axiif[cid].fmask&2) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
          if (axiif[cid].fmask&4) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
          if (axiif[cid].fmask&8) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
        }
        else if (axiif[cid].mreq == axiif[cid].mlen) {
          if (axiif[cid].lmask&1) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
          if (axiif[cid].lmask&2) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
          if (axiif[cid].lmask&4) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
          if (axiif[cid].lmask&8) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
        }
        else {
          mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
          mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
          mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
          mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
        }
        axiif[cid].mreq++;
      }
    }
    else { /* data完了 */
      dma_ctrl.ZDMA_CH_STATUS = (dma_ctrl.ZDMA_CH_STATUS & ~3); /* free */
      dma_ctrl.ZDMA_CH_CTRL2  = (dma_ctrl.ZDMA_CH_CTRL2  & ~1); /* free */
      axiif[cid].dma_stat   = 0; /* reset */
      axiif[cid].radr_sent  = 0; /* reset */
    }
d889 24
a912 12
  if (c[cid].iorq.v_stat == ((3<<2)|1) && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
    /*emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);*/
    if (c[cid].iorq.ADR < REG_BASE2_PHYS) { /* dma space ... 固定位置 (DMA_BASE2_PHYS-REG_BASE2_PHYS) */
      switch (c[cid].iorq.opcd) {
      case 2:if (c[cid].iorq.ADR & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x adr=%08.8x (should be aligned to Uint)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    c[cid].iorq.BUF[0] = *(Uint*)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)); break;
      case 3:if (c[cid].iorq.ADR & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x adr=%08.8x (should be aligned to Ull)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    c[cid].iorq.BUF[0] = *(Ull *)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)); break;
      default:                                       printf("%03.3d:emax6_ctl: dma_space load: opcd=%x (should be LDRW/LDR)\n", c[cid].iorq.tid, c[cid].iorq.opcd); break; }
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|3; /* return to sim-core.c */
      if (trace)
        printf("%03.3d:DMA->IORQ RD opcd=%d adr=%08.8x data=%08.8x_%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
d914 5
a918 33
    else if (axiif[cid].axi_rvalid && axiif[cid].axi_rready) { /* new read_req starts */
      switch (c[cid].iorq.opcd) { /* 2:LD/STRW 3:LD/STR 12:VLD/VSTRQ */
      case 2: /* 32bit */
        switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
        case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
        case  8: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[1]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
        case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
        case 24: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[3]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
        }
        break;
      case 3: /* 64bit */
        switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
        case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0]; break;
        case  8: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[1]; break;
        case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2]; break;
        case 24: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[3]; break;
        }
        break;
      case 12: /* 128bit */
        switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
        case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0];
                 c[cid].iorq.BUF[1] = axiif[cid].axi_rdata[1]; break;
        case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2];
                 c[cid].iorq.BUF[1] = axiif[cid].axi_rdata[3]; break;
        }
        break;
      }
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|3; /* return to sim-core.c */
      axiif[cid].radr_sent = 0;
      if (trace)
        printf("%03.3d:AXIIF->IORQ RD opcd=%d adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR,
               (Uint)(c[cid].iorq.BUF[1]>>32), (Uint)c[cid].iorq.BUF[1],
               (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
d920 6
d927 2
a1124 142
siml_exring_deq_wait(cid, trace) Uint cid, trace;
{
  int i;

  /* axiifw側の準備 */
  /* 先頭のexring.deq_waitを集めておき,siml_stage4()の前にaxiif[cid].exring_deq_waitを確定 */
  axiif[cid].exring_deq_wait=0;
  for (i=0; i<LMRING_MUX; i++)
    axiif[cid].exring_deq_wait |= exring[cid].unit[EMAX_DEPTH/LMRING_MUX*i].deq_wait;/* top deq_wait */
}

siml_lmring_axi(cid, trace) Uint cid, trace;
{
  /* LMMのcolumnマルチスレッデイングは,EXRINGを優先し,LMRINGは隙間で動作させる */
  /* LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */

  /*                                                                                                 *//* axi_write_busy axi_read_busy */
  /* 論理番号           物理番号                     V<--------ENQ (siml_axiifが先にENQ)             *//* awaddr+awlen+awvalid ^> awready *//* wdata[]+wstrb+wvalid+wlast -> wready->next */
  /*                              axiif.axring_br =======bri_ful2 物理#0のpiはaxringに差し替え       *//* araddr+arlen+arvalid -> arready */
  /* row0+DEPTH-2              0        |            V^--------waiti(unit[0].deq_wait)               */
  /*                             unit[].lmring_br -------  下からsiml.deq_waitが同一τにドミノ倒し.  */
  /*                                    |                  実機と違うがoutputの出方は同じ            */
  /* row0+DEPTH-1              1        |            V        ↑                                     */
  /*   ★siml起点(broutは定数)   unit[].lmring_br -------  SIML起点(1τ前の次段deq_waitを使う.正常)  */
  /* row0                     62        |            V   ★SIML最後(前段brの値が1τ未来になる)       */
  /*                             unit[].lmring_br -------     ↑                                     */
  /* row0+1                   63        |            V                                               */
  /*                             unit[].lmring_br -------bro_ful2                                    */
  /*                                                 |^--------waito(axiif.deq_wait)                 */
  /*                                                 +-------->DEQ (siml_axiifが先にDEQ)             *//* rdata[]+rvalid+rlast -> rready->next  */

  /* exring.deq_wait  : 1; 0:deq,1:wait            */
  /* axring_ful2      : 2; 0:empty, 2:ful          */
  /* axring_br.rw     : 1; 0:read, 1:write         */
  /* axring_br.ty     : 3; 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
  /* axring_br.col    : 2; logical col# for target lmm */
  /* axring_br.sq     :16; sequential # for pipelined DMA */
  /* axring_br.a      :31; logical addr reg/lmm    */
  /* axring_br.dm     :32; <- lmm wdata            */
  /* axring_br.d[4]      ; <- lmm wdata/rdata      */

  /* axiif.deq_wait   : 1; 0:deq,1:wait            */
  /* lmring_ful2      : 2; 0:empty, 3:ful          */
  /* lmring_br.rw     : 1; 0:read, 1:write         */
  /* lmring_br.ty     : 3; 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
  /* lmring_br.col    : 2; logical col# for target lmm */
  /* lmring_br.sq     :16; sequential # for pipelined DMA */
  /* lmring_br.a      :31; logical addr reg/lmm    */
  /* lmring_br.dm     :32; <- lmm wdata            */
  /* lmring_br.d[4]      ; <- lmm wdata/rdata      */

  int    i, k;
  int    bro_ful2, bro_av;
  struct lmring_br *bro[LMRING_MUX];

  for (i=0, bro_ful2=1, bro_av=0; i<LMRING_MUX; i++) {
    bro_ful2 &= (exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2 > 0);
    bro[i]    = &exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_br[exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot]; /* AXI<-EMAX側 */
    bro_av   |= bro[i]->av;
  }
  /* bro_ful2=1:全lmringが有効 1111 */
  axiif[cid].deq_wait = !bro_ful2; /* 有効と無効が混在 */

  /* read: LMRING終端からの回収 bro->axiif->iorq */
  /*       EMAX:BRO->AXIIF  */
  /************************************************************************************************************************************************************************************************************/
  /*                        |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk                   _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* bro_ful2  0:emp,3:ful 0_/~1~~~~~\
  /* bro.rw    0:rd.1:wr   --<=0=====>-
  /* bro.ty    0:reg,4:lmm --<=*=====>-
  /* bro.col   :  2        reg_ctrl.csel
  /* bro.sq    : 16        --<=0=====>-
  /* bro.av    :  1        --<=0=====>-
  /* bro.a     : 31        --<=A=====>-
  /* bro.dm    : 32        ------------
  /* bro.d[4]  :256        --<=D=====>-
  /* axiif_reqn                                                         _____/~~~~~~~~~~~
  /* axiif_srw                  -----<=1=====>---                       -----<=0=====>---
  /* axiif_sadr                 -----<=A=====>---                       -----<=A=====>---
  /* axiif_sreq                 -----<=0=====>---                       -----<=0=====>---
  /* rdata[]    SLAVE*                                                  -----<=D=====>---
  /* rvalid     SLAVE*                                                  _____/~~~~~~~\___
  /* rlast      SLAVE*                                                  _____/~~~~~~~\___
  /* rready    MASTER                                                   ~~~~~~~~~~~~~~~~~
  /************************************************************************************************************************************************************************************************************/

  if (bro_ful2 && !bro_av) {
    printf("%03.3d:BRO no unit covers rw=%x ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro[0]->rw, bro[0]->ty, bro[0]->a, bro[0]->a-reg_ctrl.i[cid].adtr);
  }

  if (bro_ful2 && bro[0]->rw==1) { /* WRは無条件にdequeue */
    axiif[cid].reqn--;
    if (trace)
      printf("%03.3d:BRO->AXIIF WR reqn--=%x ty=%x adr=%08.8x dm=%08.8x\n",
             cid, axiif[cid].reqn, bro[0]->ty, bro[0]->a, bro[0]->dm);
  }

  if (axiif[cid].creg) { /* RD control regs */
    for (k=0; k<UNIT_WIDTH; k++)
      axiif[cid].axi_rdata[k] = *((Ull*)((Uchar*)&reg_ctrl.i[cid]+(axiif[cid].sadr-REG_BASE2_PHYS))+k);
    axiif[cid].axi_rvalid = 1;
    axiif[cid].creg = 0; /* reset RD control regs */
    printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
           cid, axiif[cid].sadr,
           (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
           (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
           (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
           (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
  }
  else if (bro_ful2 && bro[0]->rw==0) { /* RDは無条件にdequeue */
    axiif[cid].axi_rdata[0] = 0LL;
    axiif[cid].axi_rdata[1] = 0LL;
    axiif[cid].axi_rdata[2] = 0LL;
    axiif[cid].axi_rdata[3] = 0LL;
    for (i=0; i<LMRING_MUX; i++) {
      if (bro[i]->av) {
        axiif[cid].axi_rdata[0] |= bro[i]->d[0];
        axiif[cid].axi_rdata[1] |= bro[i]->d[1];
        axiif[cid].axi_rdata[2] |= bro[i]->d[2];
        axiif[cid].axi_rdata[3] |= bro[i]->d[3];
      }
    }
    axiif[cid].axi_rvalid = 1;
    axiif[cid].reqn--;
    for (i=0; i<LMRING_MUX; i++) {
      exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2--;
      exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot = (exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot + 1)%LMRING_BR_BUF;
    }
    printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
           cid, axiif[cid].sadr,
           (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
           (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
           (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
           (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
  }
  else
    axiif[cid].axi_rvalid = 0;

  return (0);
}

@


1.349
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.348 2018/12/02 07:03:41 nakashim Exp nakashim $";
d265 1
a265 1
  /*│ A││awaddr        1. WR/RD-req      awaddr││ A││awaddr        1. WR/RD-req      awaddr│   */
d268 1
a268 1
  /*│─┤├─┐  1.│2.│┌┐┌┐┌┐│  │  ┌─┤│  │├─┐  1.│2.│┌┐┌┐┌┐│  │  ┌─┤   */
d275 1
a275 1
  /*│　││    │ g├─□□□□□□□□┤  │4.  ││  ││    │ g├─□□□□□□□□┤  │4.  │   */
d277 1
a277 1
  /*│ L││ 　 │      └┘└┘└┘└┘↓3.│ 　 ││ L││ 　 │      └┘└┘└┘└┘↓3.│ 　 │   */
d279 1
a279 1
  /*│ $││ardata               4. RD-wait ardata││ $││ardata               4. RD-wait ardata│   */
d282 2
a283 2
  /* siml_axi_iorq(cid, trace)     axiif[0] -> c[0].iorq              | -              -               */
  /* siml_iorq_axi(cid, trace)     c[0].iorq    -> axiif[0]           | -              -               */
d297 1
a297 1
  /* siml_lmring_axi(cid, trace)   lmring[0.term] -> axiif[0]         | lm[1.term]     lm[2.term]      */
d316 1
a316 1
  /*  if (cid == 0) { *//* cid#0のみ */
d321 6
d328 1
a328 6
    if (!c[cid].iorq.v_stat && !reg_ctrl.i[cid].stat) {
      if (prev_stat)
        printf("%03.3d:EE %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 IO/CMD-END----\n", cid, (Uint)(steps>>32), (Uint)steps, (Uint)(cycle>>32), (Uint)cycle);
      return (0);
    }

d331 1
a331 1
  /*  }*/
@


1.348
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.347 2018/12/02 06:38:04 nakashim Exp nakashim $";
d9 1
a9 1
/* emax6.c 2012/9/22 */ 
d75 1
a75 1
} axiif[MAXCORE];
d264 20
a283 3
  /* siml_axiifr(cid)              */
  /*     **** axiif -> c[cid].iorq (imax[0]のみ) */
  /*     **** lmring-> axiif       */
d288 3
d292 1
a292 5
  /*   siml_unit_stage4_pre(cid, row) */
  /* }                             */
  /* siml_exring_deq_wait(cid)     */
  /* for (row) {                   */
  /*   siml_unit_stage4(cid, row)  */
d297 2
a298 3
  /* siml_axiifw(cid)              */
  /*     **** axiif       -> lmring*/
  /*     **** c[cid].iorq -> axiif (imax[0]のみ) */
d315 16
a330 11
 
  /* update LMRING/EXRING */
  prev_stat = c[cid].iorq.v_stat || reg_ctrl.i[cid].stat;
  /* ソフトからのstat検査時に(c[cid].iorq.v_stat)を含めると常にbusy */
  reg_ctrl.i[cid].stat = (!(axiif[cid].reqn)?LMRING_IDLE:LMRING_BUSY)<<4 | (!(exring[cid].cmd_busy||exring[cid].unit_busy)?EXRING_IDLE:EXRING_BUSY);

  if (!c[cid].iorq.v_stat && !reg_ctrl.i[cid].stat) {
    if (prev_stat)
      printf("%03.3d:EE %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 IO/CMD-END----\n", cid, (Uint)(steps>>32), (Uint)steps, (Uint)(cycle>>32), (Uint)cycle);
    return (0);
  }
a335 3
  siml_axi_iorq(cid, trace);   /* AXI->IORQ */
  siml_iorq_axi(cid, trace);   /* IORQ->AXI */

d389 1
a389 1
  /* iorq.type   : 4  4:write                         3:read 
d393 10
a402 10
  /* iorq.rob         
  /* awaddr    MASTER*  -----<=A=====>---                           
  /* awlen     MASTER*  -----<=0=====>---                           
  /* awvalid   MASTER*  ___★/~~~~~~~\___ valid=1                   
  /* awready    SLAVE   ~~~~~~~~~~~~~\___ ready=1時に授受           
  /* wstrb     MASTER*  -----<=M=====>---                           
  /* wdata[]   MASTER*  -----<=D=====>---                           
  /* wvalid    MASTER*  ___★/~~~~~~~\___                           
  /* wlast     MASTER*  _____/~~~~~~~\___ PIOの場合,常に1           
  /* wready     SLAVE   ~~~~~~~~~~~~~\___                           
d424 5
a428 5
	axiif[cid].axi_awaddr   = axiif[cid].madr;
	axiif[cid].axi_awlen    = axiif[cid].mlen;
	axiif[cid].axi_awvalid  = 1; /* on */
	printf("%03.3d:DMA MEM->LMM WR start ddradr=%08.8x lmmadr=%08.8x len=%04.4x\n",
	       cid, axiif[cid].dadr, axiif[cid].madr, axiif[cid].mlen);
d431 3
a433 3
	axiif[cid].wadr_sent    = 1; /* fin */
	/*axiif[cid].mreq       = 0; *//* length */
	axiif[cid].axi_awvalid  = 0; /* off */
d438 1
a438 1
	axiif[cid].axi_wstrb = ((axiif[cid].fmask&8)?0xff000000:0)
d443 1
a443 1
	axiif[cid].axi_wstrb = ((axiif[cid].lmask&8)?0xff000000:0)
d448 1
a448 1
	axiif[cid].axi_wstrb = 0xffffffff;
d455 1
a455 1
	axiif[cid].axi_wlast  = 1; /* on */
d457 1
a457 1
	axiif[cid].axi_wlast  = 0; /* off */
d459 5
a463 5
	     cid, axiif[cid].mreq, axiif[cid].axi_wlast, axiif[cid].axi_wstrb,
	     (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
	     (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
	     (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
	     (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
d465 2
a466 2
	axiif[cid].dadr+=sizeof(Ull)*UNIT_WIDTH;
	axiif[cid].mreq++;
d483 5
a487 5
	axiif[cid].axi_araddr   = axiif[cid].madr;
	axiif[cid].axi_arlen    = axiif[cid].mlen;
	axiif[cid].axi_arvalid  = 1; /* on */
	printf("%03.3d:DMA LMM->MEM RD start lmmadr=%08.8x ddradr=%08.8x len=%04.4x\n",
	       cid, axiif[cid].madr, axiif[cid].dadr, axiif[cid].mlen);
d490 3
a492 3
	axiif[cid].radr_sent    = 1; /* fin */
	/*axiif[cid].mreq       = 0; *//* length */
	axiif[cid].axi_arvalid  = 0; /* off */
d508 1
a508 1
	printf("%03.3d:IORQ->DMA WR opcd=%d adr=%08.8x data=%08.8x_%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
d510 33
a542 33
	dma_ctrl.ZDMA_CH_STATUS = (dma_ctrl.ZDMA_CH_STATUS & ~3) | 2; /* busy */
	if (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 < LMM_BASE2_PHYS) { /* mem->lmm */
	  axiif[cid].dma_stat = 3; /* write */
	  axiif[cid].dadr     = dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* mem addr */
	  axiif[cid].madr     = dma_ctrl.ZDMA_CH_DST_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* lmm addr */
	  axiif[cid].mlen     = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1)/UNIT_WIDTH)
	                      - ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              )/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
	  axiif[cid].mreq     = 0;
	  axiif[cid].fmask    = 0xf << ( (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              ) & (UNIT_WIDTH-1));
	  axiif[cid].lmask    = 0xf >> (~(dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1) & (UNIT_WIDTH-1));
	  if (axiif[cid].mlen==0) {
	    axiif[cid].fmask &= axiif[cid].lmask;
	    axiif[cid].lmask &= axiif[cid].fmask;
	  }
	  printf("%03.3d:DMA MEM->LMM WR src=%08.8x dst=%08.8x len=%04.4x\n", cid,
		 axiif[cid].dadr, axiif[cid].madr, axiif[cid].mlen);
	}
	else { /* lmm->mem */
	  axiif[cid].dma_stat = 2; /* read */
	  axiif[cid].dadr     = dma_ctrl.ZDMA_CH_DST_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* mem addr */
	  axiif[cid].madr     = dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* lmm addr */
	  axiif[cid].mlen     = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1)/UNIT_WIDTH)
	                      - ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              )/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
	  axiif[cid].mreq     = 0;
	  axiif[cid].fmask    = 0xf << ( (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              ) & (UNIT_WIDTH-1));
	  axiif[cid].lmask    = 0xf >> (~(dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1) & (UNIT_WIDTH-1));
	  if (axiif[cid].mlen==0) {
	    axiif[cid].fmask &= axiif[cid].lmask;
	    axiif[cid].lmask &= axiif[cid].fmask;
	  }
	  printf("%03.3d:DMA LMM->MEM RD src=%08.8x dst=%08.8x len=%04.4x\n", cid,
		 axiif[cid].madr, axiif[cid].dadr, axiif[cid].mlen);
	}
d547 13
a559 13
	if (!axiif[cid].axi_awvalid) {
	  axiif[cid].axi_awaddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1);
	  axiif[cid].axi_awlen    = 0;
	  axiif[cid].axi_awvalid  = 1; /* on */
	  if (trace)
	    printf("%03.3d:IORQ->AXIIF WR opcd=%x adr=%08.8x\n",
		   cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_awaddr);
	}
	else if (axiif[cid].axi_awready) { /* adr完了 */
	  axiif[cid].wadr_sent    = 1; /* fin */
	  axiif[cid].mreq         = 0; /* length */
	  axiif[cid].axi_awvalid  = 0; /* off */
	}
d593 13
a605 13
	if (axiif[cid].mreq == 0)
	  axiif[cid].axi_wlast  = 1; /* on */
	else
	  axiif[cid].axi_wlast  = 0; /* off */
	printf("%03.3d:PIO WR adr=%08.8x msk=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb,
	       (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
	       (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
	       (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
	       (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
	if (axiif[cid].axi_wready) { /* data完了 */
	  axiif[cid].mreq++;
	}
d622 13
a634 13
	if (!axiif[cid].axi_arvalid) {
	  axiif[cid].axi_araddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1); /* 全dword読み出し */
	  axiif[cid].axi_arlen    = 0;
	  axiif[cid].axi_arvalid  = 1; /* on */
	  if (trace)
	    printf("%03.3d:IORQ->AXIIF AR opcd=%x adr=%08.8x\n",
		   cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_araddr);
	}
	else if (axiif[cid].axi_arready) { /* adr完了 */
	  axiif[cid].radr_sent    = 1;
	  axiif[cid].mreq         = 0; /* length */
	  axiif[cid].axi_arvalid  = 0; /* off */
	}
d691 1
a691 1
  /* iorq.rob       
d703 25
a727 25
	printf("%03.3d:DMA LMM->MEM RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, axiif[cid].madr+axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH,
	       (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	       (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	       (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	       (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
	if (axiif[cid].mreq == 0) {
	  if (axiif[cid].fmask&1) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
	  if (axiif[cid].fmask&2) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
	  if (axiif[cid].fmask&4) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
	  if (axiif[cid].fmask&8) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
	}
	else if (axiif[cid].mreq == axiif[cid].mlen) {
	  if (axiif[cid].lmask&1) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
	  if (axiif[cid].lmask&2) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
	  if (axiif[cid].lmask&4) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
	  if (axiif[cid].lmask&8) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
	}
	else {
	  mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
	  mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
	  mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
	  mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
	}
	axiif[cid].mreq++;
d749 1
a749 1
	printf("%03.3d:DMA->IORQ RD opcd=%d adr=%08.8x data=%08.8x_%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
d754 7
a760 7
	switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
	case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
	case  8: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[1]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
	case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
	case 24: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[3]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
	}
	break;
d762 7
a768 7
	switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
	case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0]; break;
	case  8: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[1]; break;
	case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2]; break;
	case 24: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[3]; break;
	}
	break;
d770 7
a776 7
	switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
	case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0];
	         c[cid].iorq.BUF[1] = axiif[cid].axi_rdata[1]; break;
	case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2];
	         c[cid].iorq.BUF[1] = axiif[cid].axi_rdata[3]; break;
	}
	break;
d781 3
a783 3
	printf("%03.3d:AXIIF->IORQ RD opcd=%d adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR,
	       (Uint)(c[cid].iorq.BUF[1]>>32), (Uint)c[cid].iorq.BUF[1],
	       (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
d807 1
a807 1
  /* wvalid    MASTER   _____/~~~~~★\___ 
d851 4
a854 4
      if (mask & 0x0f) 
	*((Uint*)((Ull*)((Uchar*)&reg_ctrl.i[cid]+(a-REG_BASE2_PHYS))+k)  ) = axiif[cid].axi_wdata[k];
      if (mask & 0xf0) 
	*((Uint*)((Ull*)((Uchar*)&reg_ctrl.i[cid]+(a-REG_BASE2_PHYS))+k)+1) = axiif[cid].axi_wdata[k]>>32;
d856 6
a861 6
	printf("%03.3d:AXIIF->REG WR adr=%08.8x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, a, axiif[cid].axi_wstrb,
	       (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
	       (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
	       (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
	       (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
d868 2
a869 2
	          ((a&REG_AREA_MASK)>=REG_BREG_OFFS) ? 1 : /* breg */
	                                               0 ; /* conf */
d884 6
a889 6
	printf("%03.3d:AXIIF->BRI WR reqn++=%x axring_ful2=%x bri_ful2=%x adr=%08.8x dm=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, axiif[cid].reqn, axiif[cid].axring_ful2, bri_ful2, bri->a, bri->dm,
	       (Uint)(bri->d[3]>>32), (Uint)bri->d[3],
	       (Uint)(bri->d[2]>>32), (Uint)bri->d[2],
	       (Uint)(bri->d[1]>>32), (Uint)bri->d[1],
	       (Uint)(bri->d[0]>>32), (Uint)bri->d[0]);
d898 4
a901 4
	printf("%03.3d:ES %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 CMD(%x) START---\n", cid,
	       (Uint)(t[cid].total_steps>>32), (Uint)t[cid].total_steps,
	       (Uint)(t[cid].total_cycle>>32), (Uint)t[cid].total_cycle, reg_ctrl.i[cid].cmd);
	exring[cid].cmd_busy = 1;
d945 1
a945 1
	printf("%03.3d:AXIIF->REG AR adr=%08.8x\n", cid, a);
d952 2
a953 2
	          ((a&REG_AREA_MASK)>=REG_BREG_OFFS) ? 1 : /* breg */
	                                               0 ; /* conf */
d967 1
a967 1
	printf("%03.3d:AXIIF->BRI AR reqn++=%x adr=%08.8x\n", cid, axiif[cid].reqn, bri->a);
d1077 1
a1077 1
	     cid, axiif[cid].reqn, bro[0]->ty, bro[0]->a, bro[0]->dm);
d1086 5
a1090 5
	   cid, axiif[cid].sadr,
	   (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	   (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	   (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	   (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
d1099 4
a1102 4
	axiif[cid].axi_rdata[0] |= bro[i]->d[0];
	axiif[cid].axi_rdata[1] |= bro[i]->d[1];
	axiif[cid].axi_rdata[2] |= bro[i]->d[2];
	axiif[cid].axi_rdata[3] |= bro[i]->d[3];
d1112 5
a1116 5
	   cid, axiif[cid].sadr,
	   (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	   (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	   (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	   (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
d1248 1
a1248 1
	exring[cid].unit[i].unit1_forstat2 = 0;/* reset to default */
d1255 1
a1255 1
	exring[cid].unit[i].stage2_fold   = 0; /* reset to default */
d1274 7
a1280 7
	if (!reg_ctrl.i[cid].conf[i][0].cdw0.v)
	  exring[cid].unit[i].cmd = CMD_NOP;
	else {
	  exring[cid].unit[i].cmd = CMD_EXEC;
	  if (exring[cid].unit[i].l_row == 0)
	    exring[cid].unit[i].unit1_exec = 1;
	}
d1299 3
a1301 3
	if (exring[cid].unit[i].scon_count & 1)
	  exring[cid].unit[i].l_row = (exring[cid].unit[i].l_row+EMAX_DEPTH-1)%EMAX_DEPTH; /* adjust l_row */
	exring[cid].unit[i].scon_count--;
d1311 3
a1313 3
	xi = i;  /* refer current br */
	bi = (reg_ctrl.i[cid].conf[i][j].cdw1.ea0bs&2)? i : pi; /* if ea0 takes eabbrs, shuold be i (else ea1(load) from pi) */
	oi = (reg_ctrl.i[cid].conf[i][j].cdw1.ea0os&1)? i : pi; /* if ea0 takes eaobrs, shuold be i (else ea1(load) from pi) */
d1316 3
a1318 3
	xi = pi; /* normal */
	bi = pi; /* normal */
	oi = pi; /* normal */
d1331 2
a1332 2
				   	                                    ||(j == 1 && reg_ctrl.i[cid].conf[i][j].cdw0.op1 == OP_FOR && (exring[cid].unit[i].stage_forstat & (1<<j)))
					                                    ||(reg_ctrl.i[cid].conf[i][j].cdw0.ex1s!=1 || (!exring[cid].unit[i].one_shot || ((reg_ctrl.i[cid].conf[i][j].cdw0.init&1)&&(exring[cid].unit[i].unit1_forstat&1))))
d1347 1
a1347 1
	
d1370 1
a1370 1
	exring[cid].unit[i].one_shot = 1;
d1372 1
a1372 1
	exring[cid].unit[i].one_shot = 0;
d1420 2
a1421 2
	exring[cid].unit[i].stage_forstat = 0;
	exring[cid].unit[i].unit1_arbrk = 0;
d1423 1
a1423 1
	exring[cid].unit[i].stage3_fold = 0;
d1473 1
a1473 1
	exring[cid].unit[i].unit1_arbrk = 0;
d1475 2
a1476 2
	exring[cid].unit[i].unit1_arbrk = ex1_retval;
	/*printf("%d WHILE dst=%d arbrk=%d\n", j, (Uint)exring[cid].unit[i].ex2dr, exring[cid].unit[i].unit1_arbrk);*/
d1479 9
a1487 9
	if (j == 0) { /* LOOP0 */
	  exring[cid].unit[i].unit1_arbrk    = (op_nf1<<1 | ex1_retval)==3;
	  exring[cid].unit[i].stage_forstat  =  op_nf1<<1 | ex1_retval;
	}
	else if (j == 1) { /* LOOP1 */
	  exring[cid].unit[i].unit1_arbrk    = (ex1_retval<<1 | exring[cid].unit[i].stage_forstat)==3;
	  exring[cid].unit[i].stage_forstat  =  ex1_retval<<1 | exring[cid].unit[i].stage_forstat;
	}
	/*printf("%d FOR stage_forstat=%d dst=%d arbrk=%d\n", j, exring[cid].unit[i].stage_forstat, (Uint)exring[cid].unit[i].ex2dr, exring[cid].unit[i].unit1_arbrk);*/
d1531 1
a1531 1
	exring[cid].unit[i].stage4_fold = 0;
d1620 1
a1620 1
				       reg_ctrl.i[cid].conf[i][2].cdw1.ea0op == OP_STRQ ? 2 : 3;
d1936 13
a1948 13
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfffffff0) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x0000000f : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff0f) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&2)) ? 0x000000f0 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfffff0ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000f00 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff0fff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&2)) ? 0x0000f000 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfff0ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x000f0000 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff0fffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&2)) ? 0x00f00000 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xf0ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x0f000000 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x0fffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&2)) ? 0xf0000000 : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]; /* align不要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]; /* align不要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]; /* align不要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]; /* align不要 */
	break;
d1950 9
a1958 9
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x0000000f<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000f00<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x000f0000<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x0f000000<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
	break;
d1960 9
a1968 9
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000003<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000300<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00030000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x03000000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	break;
d1970 9
a1978 9
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000001<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000100<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00010000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x01000000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	break;
d1981 6
a1986 6
	exring[cid].unit[i].lmm.mm0    = 0xffffffff;         /* mask *//* ★★★暫定記述★★★ */
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]; /* ★★★暫定記述★★★ */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]; /* ★★★暫定記述★★★ */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]; /* ★★★暫定記述★★★ */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]; /* ★★★暫定記述★★★ */
	break;
d1988 6
a1993 6
	if (exring[cid].unit[i].lmea0strq) {
	  /* ★★★STRQはSTRを4サイクル分割実行★★★ */
	  exring[cid].unit[i].lmm.mm0 = 0x000000ff << (j<<3);
	  exring[cid].unit[i].lmm.mw0[j] = exring[cid].unit[i].mwmux[j]; /* align不要 */
	}
	break;
d1995 1
a1995 1
	break;
d2044 9
a2052 9
	if (exring[cid].unit[i].lmlddmqw_ok && br->col == j) {
	  exring[cid].unit[i].tx4dr[0] = exring[cid].unit[i].lmwd[0];
	  exring[cid].unit[i].tx4dr[1] = exring[cid].unit[i].lmwd[1];
	  exring[cid].unit[i].tx4dr[2] = exring[cid].unit[i].lmwd[2];
	  exring[cid].unit[i].tx4dr[3] = exring[cid].unit[i].lmwd[3];
	  exring[cid].unit[i].tr_valid = 1;
	}
	else
	  exring[cid].unit[i].tr_valid = 0; /* no data for OP_LDDMQ */
d2243 9
a2251 9
	if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+0) = tr->d[0];     }
	if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+1) = tr->d[0]>>32; }
	if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+2) = tr->d[1];     }
	if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+3) = tr->d[1]>>32; }
	if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+4) = tr->d[2];     }
	if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+5) = tr->d[2]>>32; }
	if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+6) = tr->d[3];     }
	if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&reg_ctrl.i[cid].addr[i]+ofs)+7) = tr->d[3]>>32; }
	break;
d2253 5
a2257 5
	if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+0) = tr->d[0];   }/* ★★★ only write is implemented */
	if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+1) = tr->d[1];   }/* ★★★ only write is implemented */
	if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+2) = tr->d[2];   }/* ★★★ only write is implemented */
	if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&reg_ctrl.i[cid].lddmrw[i]+ofs)+3) = tr->d[3];   }/* ★★★ only write is implemented */
	break;
d2433 5
a2437 5
	     cid, i, a0al, 
	     (Uint)(exring[cid].unit[i].lmm.mr0[3]>>32), (Uint)exring[cid].unit[i].lmm.mr0[3],
	     (Uint)(exring[cid].unit[i].lmm.mr0[2]>>32), (Uint)exring[cid].unit[i].lmm.mr0[2],
	     (Uint)(exring[cid].unit[i].lmm.mr0[1]>>32), (Uint)exring[cid].unit[i].lmm.mr0[1],
	     (Uint)(exring[cid].unit[i].lmm.mr0[0]>>32), (Uint)exring[cid].unit[i].lmm.mr0[0]);
d2445 5
a2449 5
	     cid, i, a0al, exring[cid].unit[i].lmm.mm0,
	     (Uint)(exring[cid].unit[i].lmm.mw0[3]>>32), (Uint)exring[cid].unit[i].lmm.mw0[3],
	     (Uint)(exring[cid].unit[i].lmm.mw0[2]>>32), (Uint)exring[cid].unit[i].lmm.mw0[2],
	     (Uint)(exring[cid].unit[i].lmm.mw0[1]>>32), (Uint)exring[cid].unit[i].lmm.mw0[1],
	     (Uint)(exring[cid].unit[i].lmm.mw0[0]>>32), (Uint)exring[cid].unit[i].lmm.mw0[0]);
d2459 5
a2463 5
	     cid, i, a1al, 
	     (Uint)(exring[cid].unit[i].lmm.mr1[3]>>32), (Uint)exring[cid].unit[i].lmm.mr1[3],
	     (Uint)(exring[cid].unit[i].lmm.mr1[2]>>32), (Uint)exring[cid].unit[i].lmm.mr1[2],
	     (Uint)(exring[cid].unit[i].lmm.mr1[1]>>32), (Uint)exring[cid].unit[i].lmm.mr1[1],
	     (Uint)(exring[cid].unit[i].lmm.mr1[0]>>32), (Uint)exring[cid].unit[i].lmm.mr1[0]);
d2494 8
a2501 8
	 axiif[cid].reqn, 
	 axiif[cid].srw,
	 axiif[cid].sadr,
	 axiif[cid].slen,
	 axiif[cid].sreq,
	 axiif[cid].axring_ful2,
	 axiif[cid].axring_b_top,
	 axiif[cid].axring_b_bot);
d2506 4
a2509 4
	   col,
	   (Uint)axiif[cid].axring_br[col].rw, (Uint)axiif[cid].axring_br[col].ty, axiif[cid].axring_br[col].col, axiif[cid].axring_br[col].sq, axiif[cid].axring_br[col].av, axiif[cid].axring_br[col].a, axiif[cid].axring_br[col].dm,
	   (Uint)(axiif[cid].axring_br[col].d[3]>>32), (Uint)axiif[cid].axring_br[col].d[3], (Uint)(axiif[cid].axring_br[col].d[2]>>32), (Uint)axiif[cid].axring_br[col].d[2],
	   (Uint)(axiif[cid].axring_br[col].d[1]>>32), (Uint)axiif[cid].axring_br[col].d[1], (Uint)(axiif[cid].axring_br[col].d[0]>>32), (Uint)axiif[cid].axring_br[col].d[0]);
d2580 9
a2588 9
	   exring[cid].unit[row].l_row,
	   exring[cid].unit[row].scon_count,
	   exring[cid].unit[row].one_shot,
	   exring[cid].unit[row].unit1_exec?36:34, exring[cid].unit[row].unit1_exec,
	   exring[cid].unit[row].unit1_fold?36:34, exring[cid].unit[row].unit1_fold,
	   exring[cid].unit[row].unit1_stop?31:34, exring[cid].unit[row].unit1_stop,
	   exring[cid].unit[row].unit2_exec?36:34, exring[cid].unit[row].unit2_exec,
	   exring[cid].unit[row].unit2_fold?36:34, exring[cid].unit[row].unit2_fold,
	   exring[cid].unit[row].unit2_stop?31:34, exring[cid].unit[row].unit2_stop);
d2660 1
a2660 1
	   exring[cid].unit[row].tr_valid);
d2729 12
a2740 12
	toph = ((col & umask) * (LMEM_SIZE/4)) | (sizeof(Ull)*15 & lmask);
	topl = ((col & umask) * (LMEM_SIZE/4)) | (0              & lmask);
	printf(" \033[1;33mlm%d(%d):%08.8x-%08.8x\033[0m", col, lmm_mode, toph, topl);
	for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull))
	  printf("-%08.8x%08.8x", (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[toph-i]>>32), (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[toph-i]));
	printf("\n");
	both = ((col & umask) * (LMEM_SIZE/4)) | ((LMEM_SIZE-sizeof(Ull)               ) & lmask);
	botl = ((col & umask) * (LMEM_SIZE/4)) | ((LMEM_SIZE-sizeof(Ull)-sizeof(Ull)*15) & lmask);
	printf(" \033[1;33mlm%d(%d):%08.8x-%08.8x\033[0m", col, lmm_mode, both, botl);
	for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull))
	  printf("-%08.8x%08.8x", (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[both-i]>>32), (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[both-i]));
	printf("\n");
d2744 12
a2755 12
	toph = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.i[cid].addr[row][col].top+sizeof(Ull)*15) & lmask);
	topl = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.i[cid].addr[row][col].top               ) & lmask);
	printf(" \033[1;33mlm%d(%d):%08.8x-%08.8x\033[0m", col, lmm_mode, toph, topl);
	for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull))
	  printf("-%08.8x%08.8x", (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[toph-i]>>32), (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[toph-i]));
	printf("\n");
	both = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.i[cid].addr[row][col].bot+1-sizeof(Ull)   ) & lmask);
	botl = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.i[cid].addr[row][col].bot+1-sizeof(Ull)*16) & lmask);
	printf(" \033[1;33mlm%d(%d):%08.8x-%08.8x\033[0m", col, lmm_mode, both, botl);
	for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull))
	  printf("-%08.8x%08.8x", (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[both-i]>>32), (Uint)(*(Ull*)&exring[cid].unit[row].lmm.m[both-i]));
	printf("\n");
d2783 5
a2787 5
	     col,
	     (Uint)(exring[cid].unit[row].b[0][col].r[3]>>32), (Uint)exring[cid].unit[row].b[0][col].r[3],
	     (Uint)(exring[cid].unit[row].b[0][col].r[2]>>32), (Uint)exring[cid].unit[row].b[0][col].r[2],
	     (Uint)(exring[cid].unit[row].b[0][col].r[1]>>32), (Uint)exring[cid].unit[row].b[0][col].r[1],
	     (Uint)(exring[cid].unit[row].b[0][col].r[0]>>32), (Uint)exring[cid].unit[row].b[0][col].r[0]);
d2793 5
a2797 5
	     col,
	     (Uint)(exring[cid].unit[row].b[1][col].r[3]>>32), (Uint)exring[cid].unit[row].b[1][col].r[3],
	     (Uint)(exring[cid].unit[row].b[1][col].r[2]>>32), (Uint)exring[cid].unit[row].b[1][col].r[2],
	     (Uint)(exring[cid].unit[row].b[1][col].r[1]>>32), (Uint)exring[cid].unit[row].b[1][col].r[1],
	     (Uint)(exring[cid].unit[row].b[1][col].r[0]>>32), (Uint)exring[cid].unit[row].b[1][col].r[0]);
d2809 12
a2820 12
	     col,
	     exring[cid].unit[row].lmring_br[col].rw,
	     exring[cid].unit[row].lmring_br[col].ty,
	     exring[cid].unit[row].lmring_br[col].col,
	     exring[cid].unit[row].lmring_br[col].sq,
	     exring[cid].unit[row].lmring_br[col].av,
	     exring[cid].unit[row].lmring_br[col].a,
	     exring[cid].unit[row].lmring_br[col].dm,
	     (Uint)(exring[cid].unit[row].lmring_br[col].d[3]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[3],
	     (Uint)(exring[cid].unit[row].lmring_br[col].d[2]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[2],
	     (Uint)(exring[cid].unit[row].lmring_br[col].d[1]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[1],
	     (Uint)(exring[cid].unit[row].lmring_br[col].d[0]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[0]);
@


1.347
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.346 2018/12/02 02:47:14 nakashim Exp nakashim $";
d317 1
a317 1
  siml_lmring_axi(cid, trace); /* LMRING->AXI */
d345 1
a346 1
  siml_iorq_axi(cid, trace);   /* IORQ->AXI */
@


1.346
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.345 2018/11/23 09:16:44 nakashim Exp nakashim $";
d361 1
a361 1
siml_axi_iorq(cid, trace) Uint cid, trace;
d363 1
a363 2
  /* LMMのcolumnマルチスレッデイングは,EXRINGを優先し,LMRINGは隙間で動作させる */
  /* LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */
d365 2
a366 35
  /*                                                                                                 *//* axi_write_busy axi_read_busy */
  /* 論理番号           物理番号                     V<--------ENQ (siml_axiifが先にENQ)             *//* awaddr+awlen+awvalid ^> awready *//* wdata[]+wstrb+wvalid+wlast -> wready->next */
  /*                              axiif.axring_br =======bri_ful2 物理#0のpiはaxringに差し替え       *//* araddr+arlen+arvalid -> arready */
  /* row0+DEPTH-2              0        |            V^--------waiti(unit[0].deq_wait)               */
  /*                             unit[].lmring_br -------  下からsiml.deq_waitが同一τにドミノ倒し.  */
  /*                                    |                  実機と違うがoutputの出方は同じ            */
  /* row0+DEPTH-1              1        |            V        ↑                                     */
  /*   ★siml起点(broutは定数)   unit[].lmring_br -------  SIML起点(1τ前の次段deq_waitを使う.正常)  */
  /* row0                     62        |            V   ★SIML最後(前段brの値が1τ未来になる)       */
  /*                             unit[].lmring_br -------     ↑                                     */
  /* row0+1                   63        |            V                                               */
  /*                             unit[].lmring_br -------bro_ful2                                    */
  /*                                                 |^--------waito(axiif.deq_wait)                 */
  /*                                                 +-------->DEQ (siml_axiifが先にDEQ)             *//* rdata[]+rvalid+rlast -> rready->next  */

  /* iorq.v_stat      : 4; v 0:empty 1:reserve 3:inuse | stat 0:empty 1:busy 3:RD-ok */
  /* iorq.tid         :12;                         */
  /* iorq.type        : 4; type                    */
  /* iorq.opcd        : 6; opcd                    */
  /* iorq.ADR            ; 以前のADDRに対応        */
  /* iorq.BUF[2]         ; for load/store          */
  /* iorq.rob            ; for DATA                */

  /* exring.deq_wait  : 1; 0:deq,1:wait            */
  /* axring_ful2      : 2; 0:empty, 2:ful          */
  /* axring_br.rw     : 1; 0:read, 1:write         */
  /* axring_br.ty     : 3; 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
  /* axring_br.col    : 2; logical col# for target lmm */
  /* axring_br.sq     :16; sequential # for pipelined DMA */
  /* axring_br.a      :31; logical addr reg/lmm    */
  /* axring_br.dm     :32; <- lmm wdata            */
  /* axring_br.d[4]      ; <- lmm wdata/rdata      */

  /* read: LMRING終端からの回収 bro->axiif->iorq */
  /*       HOST:AXIIF->IORQ (ARM-restartにより,iorqに該当エントリがない場合がある) */
d371 19
a389 10
  /* iorq.tid    :12                                                                 A
  /* iorq.type   : 4  4:write                         3:read                         |
  /* iorq.opcd   : 6  2:LD/STRW 3:LD/STR 12:VLD/VSTRQ                                |
  /* iorq.ADR                                           ===A======                   |
  /* iorq.BUF[2]                                                                -----<=D=====>---
  /* iorq.rob       
  /* rdata[]    SLAVE                                                   -----<=D=====>---
  /* rvalid     SLAVE                                                   _____/~~~~~★\___
  /* rlast      SLAVE                                                   _____/~~~~~~~\___
  /* rready    MASTER*                                                  _____/~~~~~★\___
d392 11
a402 1
  axiif[cid].axi_rready = 1; /* always 1 */
d404 45
a448 27
  if (axiif[cid].dma_stat == 2) { /* DMA RD active */
    if (axiif[cid].mreq <= axiif[cid].mlen) { /* write active */
      if (axiif[cid].axi_rvalid && axiif[cid].axi_rready) { /* new read_req starts */
	printf("%03.3d:DMA LMM->MEM RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, axiif[cid].madr+axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH,
	       (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	       (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	       (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	       (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
	if (axiif[cid].mreq == 0) {
	  if (axiif[cid].fmask&1) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
	  if (axiif[cid].fmask&2) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
	  if (axiif[cid].fmask&4) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
	  if (axiif[cid].fmask&8) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
	}
	else if (axiif[cid].mreq == axiif[cid].mlen) {
	  if (axiif[cid].lmask&1) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
	  if (axiif[cid].lmask&2) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
	  if (axiif[cid].lmask&4) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
	  if (axiif[cid].lmask&8) mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
	}
	else {
	  mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  0, 0xffffffffffffffffLL, axiif[cid].axi_rdata[0]);
	  mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH +  8, 0xffffffffffffffffLL, axiif[cid].axi_rdata[1]);
	  mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 16, 0xffffffffffffffffLL, axiif[cid].axi_rdata[2]);
	  mmw(axiif[cid].dadr + axiif[cid].mreq*sizeof(Ull)*UNIT_WIDTH + 24, 0xffffffffffffffffLL, axiif[cid].axi_rdata[3]);
	}
d453 1
d457 20
a476 1
      axiif[cid].radr_sent  = 0; /* reset */
d480 1
a480 1
  if (c[cid].iorq.v_stat == ((3<<2)|1) && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
d484 6
a489 6
      case 2:if (c[cid].iorq.ADR & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x adr=%08.8x (should be aligned to Uint)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    c[cid].iorq.BUF[0] = *(Uint*)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)); break;
      case 3:if (c[cid].iorq.ADR & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x adr=%08.8x (should be aligned to Ull)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    c[cid].iorq.BUF[0] = *(Ull *)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)); break;
      default:                                       printf("%03.3d:emax6_ctl: dma_space load: opcd=%x (should be LDRW/LDR)\n", c[cid].iorq.tid, c[cid].iorq.opcd); break; }
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|3; /* return to sim-core.c */
d491 18
a508 10
	printf("%03.3d:DMA->IORQ RD opcd=%d adr=%08.8x data=%08.8x_%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
    }
    else if (axiif[cid].axi_rvalid && axiif[cid].axi_rready) { /* new read_req starts */
      switch (c[cid].iorq.opcd) { /* 2:LD/STRW 3:LD/STR 12:VLD/VSTRQ */
      case 2: /* 32bit */
	switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
	case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
	case  8: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[1]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
	case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
	case 24: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[3]>>((c[cid].iorq.ADR & sizeof(int))*8); break;
d510 107
a616 15
	break;
      case 3: /* 64bit */
	switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
	case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0]; break;
	case  8: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[1]; break;
	case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2]; break;
	case 24: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[3]; break;
	}
	break;
      case 12: /* 128bit */
	switch (c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))) {
	case  0: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[0];
	         c[cid].iorq.BUF[1] = axiif[cid].axi_rdata[1]; break;
	case 16: c[cid].iorq.BUF[0] = axiif[cid].axi_rdata[2];
	         c[cid].iorq.BUF[1] = axiif[cid].axi_rdata[3]; break;
a617 1
	break;
a618 6
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|3; /* return to sim-core.c */
      axiif[cid].radr_sent = 0;
      if (trace)
	printf("%03.3d:AXIIF->IORQ RD opcd=%d adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR,
	       (Uint)(c[cid].iorq.BUF[1]>>32), (Uint)c[cid].iorq.BUF[1],
	       (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
d625 1
a625 1
siml_lmring_axi(cid, trace) Uint cid, trace;
d645 8
a662 22
  /* axiif.deq_wait   : 1; 0:deq,1:wait            */
  /* lmring_ful2      : 2; 0:empty, 3:ful          */
  /* lmring_br.rw     : 1; 0:read, 1:write         */
  /* lmring_br.ty     : 3; 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
  /* lmring_br.col    : 2; logical col# for target lmm */
  /* lmring_br.sq     :16; sequential # for pipelined DMA */
  /* lmring_br.a      :31; logical addr reg/lmm    */
  /* lmring_br.dm     :32; <- lmm wdata            */
  /* lmring_br.d[4]      ; <- lmm wdata/rdata      */

  int    i, k;
  int    bro_ful2, bro_av;
  struct lmring_br *bro[LMRING_MUX];

  for (i=0, bro_ful2=1, bro_av=0; i<LMRING_MUX; i++) {
    bro_ful2 &= (exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2 > 0);
    bro[i]    = &exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_br[exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot]; /* AXI<-EMAX側 */
    bro_av   |= bro[i]->av;
  }
  /* bro_ful2=1:全lmringが有効 1111 */
  axiif[cid].deq_wait = !bro_ful2; /* 有効と無効が混在 */

d664 1
a664 1
  /*       EMAX:BRO->AXIIF  */
d668 11
a678 17
  /* bro_ful2  0:emp,3:ful 0_/~1~~~~~\
  /* bro.rw    0:rd.1:wr   --<=0=====>-
  /* bro.ty    0:reg,4:lmm --<=*=====>-
  /* bro.col   :  2        reg_ctrl.csel
  /* bro.sq    : 16        --<=0=====>-
  /* bro.av    :  1        --<=0=====>-
  /* bro.a     : 31        --<=A=====>-
  /* bro.dm    : 32        ------------
  /* bro.d[4]  :256        --<=D=====>-
  /* axiif_reqn                                                         _____/~~~~~~~~~~~
  /* axiif_srw                  -----<=1=====>---                       -----<=0=====>---
  /* axiif_sadr                 -----<=A=====>---                       -----<=A=====>---
  /* axiif_sreq                 -----<=0=====>---                       -----<=0=====>---
  /* rdata[]    SLAVE*                                                  -----<=D=====>---
  /* rvalid     SLAVE*                                                  _____/~~~~~~~\___
  /* rlast      SLAVE*                                                  _____/~~~~~~~\___
  /* rready    MASTER                                                   ~~~~~~~~~~~~~~~~~
d681 1
a681 3
  if (bro_ful2 && !bro_av) {
    printf("%03.3d:BRO no unit covers rw=%x ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro[0]->rw, bro[0]->ty, bro[0]->a, bro[0]->a-reg_ctrl.i[cid].adtr);
  }
d683 28
a710 30
  if (bro_ful2 && bro[0]->rw==1) { /* WRは無条件にdequeue */
    axiif[cid].reqn--;
    if (trace)
      printf("%03.3d:BRO->AXIIF WR reqn--=%x ty=%x adr=%08.8x dm=%08.8x\n",
	     cid, axiif[cid].reqn, bro[0]->ty, bro[0]->a, bro[0]->dm);
  }

  if (axiif[cid].creg) { /* RD control regs */
    for (k=0; k<UNIT_WIDTH; k++)
      axiif[cid].axi_rdata[k] = *((Ull*)((Uchar*)&reg_ctrl.i[cid]+(axiif[cid].sadr-REG_BASE2_PHYS))+k);
    axiif[cid].axi_rvalid = 1;
    axiif[cid].creg = 0; /* reset RD control regs */
    printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	   cid, axiif[cid].sadr,
	   (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	   (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	   (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	   (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
  }
  else if (bro_ful2 && bro[0]->rw==0) { /* RDは無条件にdequeue */
    axiif[cid].axi_rdata[0] = 0LL;
    axiif[cid].axi_rdata[1] = 0LL;
    axiif[cid].axi_rdata[2] = 0LL;
    axiif[cid].axi_rdata[3] = 0LL;
    for (i=0; i<LMRING_MUX; i++) {
      if (bro[i]->av) {
	axiif[cid].axi_rdata[0] |= bro[i]->d[0];
	axiif[cid].axi_rdata[1] |= bro[i]->d[1];
	axiif[cid].axi_rdata[2] |= bro[i]->d[2];
	axiif[cid].axi_rdata[3] |= bro[i]->d[3];
d713 54
a766 5
    axiif[cid].axi_rvalid = 1;
    axiif[cid].reqn--;
    for (i=0; i<LMRING_MUX; i++) {
      exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2--;
      exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot = (exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot + 1)%LMRING_BR_BUF;
a767 6
    printf("%03.3d:PIO RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	   cid, axiif[cid].sadr,
	   (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	   (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	   (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	   (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
a768 2
  else
    axiif[cid].axi_rvalid = 0;
a772 11
siml_exring_deq_wait(cid, trace) Uint cid, trace;
{
  int i;

  /* axiifw側の準備 */
  /* 先頭のexring.deq_waitを集めておき,siml_stage4()の前にaxiif[cid].exring_deq_waitを確定 */
  axiif[cid].exring_deq_wait=0;
  for (i=0; i<LMRING_MUX; i++)
    axiif[cid].exring_deq_wait |= exring[cid].unit[EMAX_DEPTH/LMRING_MUX*i].deq_wait;/* top deq_wait */
}

d965 12
a976 1
siml_iorq_axi(cid, trace) Uint cid, trace;
d978 38
d1017 10
d1028 2
a1029 2
  /* read/write LMRING先端への投入   iorq->axiif->bri */
  /*       HOST:IORQ->AXIIF (ARM-restartにより,iorqに該当エントリがない場合がある) */
d1033 17
a1049 20
  /* iorq.v_stat : 4 *1101===X=0000==========X========1101===========================X=1111
  /* iorq.tid    :12
  /* iorq.type   : 4  4:write                         3:read 
  /* iorq.opcd   : 6  2:LD/STRW 3:LD/STR 12:VLD/VSTRQ
  /* iorq.ADR           ===A======                      ===A======
  /* iorq.BUF[2]        ===D======
  /* iorq.rob         
  /* awaddr    MASTER*  -----<=A=====>---                           
  /* awlen     MASTER*  -----<=0=====>---                           
  /* awvalid   MASTER*  ___★/~~~~~~~\___ valid=1                   
  /* awready    SLAVE   ~~~~~~~~~~~~~\___ ready=1時に授受           
  /* wstrb     MASTER*  -----<=M=====>---                           
  /* wdata[]   MASTER*  -----<=D=====>---                           
  /* wvalid    MASTER*  ___★/~~~~~~~\___                           
  /* wlast     MASTER*  _____/~~~~~~~\___ PIOの場合,常に1           
  /* wready     SLAVE   ~~~~~~~~~~~~~\___                           
  /* araddr    MASTER*                                  -----<=A=====>---
  /* arlen     MASTER*                                  -----<=0=====>---
  /* arvalid   MASTER*                                  ___★/~~~~~~~\___
  /* arready    SLAVE                                   ~~~~~~~~~~~~~\___
d1052 2
a1053 10
  if ((exring[cid].cycle & 3) == 3 && reg_ctrl.i[cid].cmd == CMD_RESET) {
    axiif[cid].dma_stat   = 0;
    axiif[cid].wadr_sent  = 0;
    axiif[cid].radr_sent  = 0;
    axiif[cid].dadr       = 0;
    axiif[cid].madr       = 0;
    axiif[cid].mlen       = 0;
    axiif[cid].mreq       = 0;
    axiif[cid].fmask      = 0;
    axiif[cid].lmask      = 0;
d1056 5
a1060 57
  if (axiif[cid].dma_stat == 3) { /* DMA WR active */
    if (!axiif[cid].wadr_sent) {
      if (!axiif[cid].axi_awvalid) {
	axiif[cid].axi_awaddr   = axiif[cid].madr;
	axiif[cid].axi_awlen    = axiif[cid].mlen;
	axiif[cid].axi_awvalid  = 1; /* on */
	printf("%03.3d:DMA MEM->LMM WR start ddradr=%08.8x lmmadr=%08.8x len=%04.4x\n",
	       cid, axiif[cid].dadr, axiif[cid].madr, axiif[cid].mlen);
      }
      else if (axiif[cid].axi_awready) { /* adr完了 */
	axiif[cid].wadr_sent    = 1; /* fin */
	/*axiif[cid].mreq       = 0; *//* length */
	axiif[cid].axi_awvalid  = 0; /* off */
      }
    }
    else if (axiif[cid].mreq <= axiif[cid].mlen) { /* write active */
      if (axiif[cid].mreq == 0)
	axiif[cid].axi_wstrb = ((axiif[cid].fmask&8)?0xff000000:0)
                             | ((axiif[cid].fmask&4)?0x00ff0000:0)
                             | ((axiif[cid].fmask&2)?0x0000ff00:0)
                             | ((axiif[cid].fmask&1)?0x000000ff:0);
      else if (axiif[cid].mreq == axiif[cid].mlen)
	axiif[cid].axi_wstrb = ((axiif[cid].lmask&8)?0xff000000:0)
                             | ((axiif[cid].lmask&4)?0x00ff0000:0)
                             | ((axiif[cid].lmask&2)?0x0000ff00:0)
                             | ((axiif[cid].lmask&1)?0x000000ff:0);
      else
	axiif[cid].axi_wstrb = 0xffffffff;
      axiif[cid].axi_wdata[0] = mmr(axiif[cid].dadr                );
      axiif[cid].axi_wdata[1] = mmr(axiif[cid].dadr|(sizeof(Ull)*1));
      axiif[cid].axi_wdata[2] = mmr(axiif[cid].dadr|(sizeof(Ull)*2));
      axiif[cid].axi_wdata[3] = mmr(axiif[cid].dadr|(sizeof(Ull)*3));
      axiif[cid].axi_wvalid   = 1; /* on */
      if (axiif[cid].mreq == axiif[cid].mlen)
	axiif[cid].axi_wlast  = 1; /* on */
      else
	axiif[cid].axi_wlast  = 0; /* off */
      printf("%03.3d:DMA MEM->LMM WR mreq=%d last=%x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	     cid, axiif[cid].mreq, axiif[cid].axi_wlast, axiif[cid].axi_wstrb,
	     (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
	     (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
	     (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
	     (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
      if (axiif[cid].axi_wready) { /* prepare next write */
	axiif[cid].dadr+=sizeof(Ull)*UNIT_WIDTH;
	axiif[cid].mreq++;
      }
    }
    else { /* data完了 */
      printf("%03.3d:DMA MEM->LMM WR FIN\n", cid);
      dma_ctrl.ZDMA_CH_STATUS = (dma_ctrl.ZDMA_CH_STATUS & ~3); /* free */
      dma_ctrl.ZDMA_CH_CTRL2  = (dma_ctrl.ZDMA_CH_CTRL2  & ~1); /* free */
      axiif[cid].dma_stat   = 0; /* reset */
      axiif[cid].wadr_sent  = 0; /* reset */
      axiif[cid].axi_wvalid = 0; /* off */
      axiif[cid].axi_wlast  = 0; /* off */
    }
d1063 11
a1073 15
  if (axiif[cid].dma_stat == 2) { /* DMA RD active */
    if (!axiif[cid].radr_sent) {
      if (!axiif[cid].axi_arvalid) {
	axiif[cid].axi_araddr   = axiif[cid].madr;
	axiif[cid].axi_arlen    = axiif[cid].mlen;
	axiif[cid].axi_arvalid  = 1; /* on */
	printf("%03.3d:DMA LMM->MEM RD start lmmadr=%08.8x ddradr=%08.8x len=%04.4x\n",
	       cid, axiif[cid].madr, axiif[cid].dadr, axiif[cid].mlen);
      }
      else if (axiif[cid].axi_arready) { /* adr完了 */
	axiif[cid].radr_sent    = 1; /* fin */
	/*axiif[cid].mreq       = 0; *//* length */
	axiif[cid].axi_arvalid  = 0; /* off */
      }
    }
d1075 11
a1085 47

  if (c[cid].iorq.v_stat == ((3<<2)|1) && c[cid].iorq.type == 4) { /* store *//* emax6_reg()機能は最終的には各担当stageに配置 */
    /*emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);*/
    if (c[cid].iorq.ADR < REG_BASE2_PHYS) { /* dma space ... 固定位置 (DMA_BASE2_PHYS-REG_BASE2_PHYS) */
      switch (c[cid].iorq.opcd) {
      case 2:if (c[cid].iorq.ADR & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%x adr=%08.8x (should be aligned to Uint)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    *(Uint*)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)) = c[cid].iorq.BUF[0]; break;
      case 3:if (c[cid].iorq.ADR & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%x adr=%08.8x (should be aligned to Ull)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    *(Ull *)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)) = c[cid].iorq.BUF[0]; break;
      default:                                       printf("%03.3d:emax6_ctl: dma_space store: opcd=%x (should be STRW/STR)\n", c[cid].iorq.tid, c[cid].iorq.opcd); break; }
      c[cid].iorq.v_stat = 0; /* immediately finished */
      if (trace)
	printf("%03.3d:IORQ->DMA WR opcd=%d adr=%08.8x data=%08.8x_%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
      if ((dma_ctrl.ZDMA_CH_STATUS & 3) != 2 && (dma_ctrl.ZDMA_CH_CTRL2 & 1)) {
	dma_ctrl.ZDMA_CH_STATUS = (dma_ctrl.ZDMA_CH_STATUS & ~3) | 2; /* busy */
	if (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 < LMM_BASE2_PHYS) { /* mem->lmm */
	  axiif[cid].dma_stat = 3; /* write */
	  axiif[cid].dadr     = dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* mem addr */
	  axiif[cid].madr     = dma_ctrl.ZDMA_CH_DST_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* lmm addr */
	  axiif[cid].mlen     = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1)/UNIT_WIDTH)
	                      - ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              )/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
	  axiif[cid].mreq     = 0;
	  axiif[cid].fmask    = 0xf << ( (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              ) & (UNIT_WIDTH-1));
	  axiif[cid].lmask    = 0xf >> (~(dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1) & (UNIT_WIDTH-1));
	  if (axiif[cid].mlen==0) {
	    axiif[cid].fmask &= axiif[cid].lmask;
	    axiif[cid].lmask &= axiif[cid].fmask;
	  }
	  printf("%03.3d:DMA MEM->LMM WR src=%08.8x dst=%08.8x len=%04.4x\n", cid,
		 axiif[cid].dadr, axiif[cid].madr, axiif[cid].mlen);
	}
	else { /* lmm->mem */
	  axiif[cid].dma_stat = 2; /* read */
	  axiif[cid].dadr     = dma_ctrl.ZDMA_CH_DST_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* mem addr */
	  axiif[cid].madr     = dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* lmm addr */
	  axiif[cid].mlen     = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1)/UNIT_WIDTH)
	                      - ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              )/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
	  axiif[cid].mreq     = 0;
	  axiif[cid].fmask    = 0xf << ( (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              ) & (UNIT_WIDTH-1));
	  axiif[cid].lmask    = 0xf >> (~(dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1) & (UNIT_WIDTH-1));
	  if (axiif[cid].mlen==0) {
	    axiif[cid].fmask &= axiif[cid].lmask;
	    axiif[cid].lmask &= axiif[cid].fmask;
	  }
	  printf("%03.3d:DMA LMM->MEM RD src=%08.8x dst=%08.8x len=%04.4x\n", cid,
		 axiif[cid].madr, axiif[cid].dadr, axiif[cid].mlen);
	}
d1088 5
a1092 91
    else if (!axiif[cid].dma_stat) { /* DMA is inactive */
      if (!axiif[cid].wadr_sent) {
	if (!axiif[cid].axi_awvalid) {
	  axiif[cid].axi_awaddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1);
	  axiif[cid].axi_awlen    = 0;
	  axiif[cid].axi_awvalid  = 1; /* on */
	  if (trace)
	    printf("%03.3d:IORQ->AXIIF WR opcd=%x adr=%08.8x\n",
		   cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_awaddr);
	}
	else if (axiif[cid].axi_awready) { /* adr完了 */
	  axiif[cid].wadr_sent    = 1; /* fin */
	  axiif[cid].mreq         = 0; /* length */
	  axiif[cid].axi_awvalid  = 0; /* off */
	}
      }
      else if (axiif[cid].mreq <= 0) { /* write active */
        switch (c[cid].iorq.opcd) { /* 2:LD/STRW 3:LD/STR 12:VLD/VSTRQ */
        case 2: /* 32bit */
          axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x0000000f<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 8 ? 0x00000f00<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==16 ? 0x000f0000<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==24 ? 0x0f000000<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000);
          axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
          axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
          axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
          axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
          break;
        case 3: /* 64bit */
          axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x000000ff : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 8 ? 0x0000ff00 : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==16 ? 0x00ff0000 : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==24 ? 0xff000000 : 0x00000000);
          axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0];
          axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[0];
          axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0];
          axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[0];
          break;
        case 12: /* 128bit */
          axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x0000ffff : 0x00000000)
                                  | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==16 ? 0xffff0000 : 0x00000000);
          axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0];
          axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[1];
          axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0];
          axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[1];
          break;
        }
        axiif[cid].axi_wvalid   = 1; /* on */
	if (axiif[cid].mreq == 0)
	  axiif[cid].axi_wlast  = 1; /* on */
	else
	  axiif[cid].axi_wlast  = 0; /* off */
	printf("%03.3d:PIO WR adr=%08.8x msk=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb,
	       (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
	       (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
	       (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
	       (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
	if (axiif[cid].axi_wready) { /* data完了 */
	  axiif[cid].mreq++;
	}
      }
      else {
        c[cid].iorq.v_stat      = 0; /* immediately finished */
        axiif[cid].wadr_sent    = 0; /* reset */
        axiif[cid].axi_wvalid   = 0; /* off */
        axiif[cid].axi_wlast    = 0; /* off */
      }
    }
  }

  if (c[cid].iorq.v_stat == ((3<<2)|1) && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
    /*emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);*/
    if (c[cid].iorq.ADR < REG_BASE2_PHYS) { /* dma space ... 固定位置 (DMA_BASE2_PHYS-REG_BASE2_PHYS) */
    }
    else if (!axiif[cid].dma_stat) { /* DMA is inactive */
      if (!axiif[cid].radr_sent) {
	if (!axiif[cid].axi_arvalid) {
	  axiif[cid].axi_araddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1); /* 全dword読み出し */
	  axiif[cid].axi_arlen    = 0;
	  axiif[cid].axi_arvalid  = 1; /* on */
	  if (trace)
	    printf("%03.3d:IORQ->AXIIF AR opcd=%x adr=%08.8x\n",
		   cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_araddr);
	}
	else if (axiif[cid].axi_arready) { /* adr完了 */
	  axiif[cid].radr_sent    = 1;
	  axiif[cid].mreq         = 0; /* length */
	  axiif[cid].axi_arvalid  = 0; /* off */
	}
      }
d1094 6
d1101 2
@


1.345
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.344 2018/11/22 14:53:29 nakashim Exp nakashim $";
d261 1
d264 21
d295 1
a295 1
  if (cid>=EMAX_NCHIP) { /* EMAX6 is attached on cid=0:EMAX_CHIP-1 */
d316 2
a317 1
  siml_axiifr(cid, trace); /* ★★AXIには物理row0が接続されている */
d345 2
a346 1
  siml_axiifw(cid, trace); /* ★★AXIには物理row0が接続されている */
d361 1
a361 1
siml_axiifr(cid, trace) Uint cid, trace;
a362 1
  /* 実際には,emax6_ctl()もAXI経由．ただしcsimでは分離してモデル化する. */
a398 22
  /* axiif.deq_wait   : 1; 0:deq,1:wait            */
  /* lmring_ful2      : 2; 0:empty, 3:ful          */
  /* lmring_br.rw     : 1; 0:read, 1:write         */
  /* lmring_br.ty     : 3; 0:reg/conf, 1:reg/breg, 2:reg/addr, 3:lddmq/tr, 4:lmm, 567:-- */
  /* lmring_br.col    : 2; logical col# for target lmm */
  /* lmring_br.sq     :16; sequential # for pipelined DMA */
  /* lmring_br.a      :31; logical addr reg/lmm    */
  /* lmring_br.dm     :32; <- lmm wdata            */
  /* lmring_br.d[4]      ; <- lmm wdata/rdata      */

  int    i, k, mask;
  int    bro_ful2, bro_av;
  struct lmring_br *bro[LMRING_MUX];

  for (i=0, bro_ful2=1, bro_av=0; i<LMRING_MUX; i++) {
    bro_ful2 &= (exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2 > 0);
    bro[i]    = &exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_br[exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_b_bot]; /* AXI<-EMAX側 */
    bro_av   |= bro[i]->av;
  }
  /* bro_ful2=1:全lmringが有効 1111 */
  axiif[cid].deq_wait = !bro_ful2; /* 有効と無効が混在 */

d506 55
d651 1
a651 1
siml_axiifw(cid, trace) Uint cid, trace;
d840 7
@


1.344
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.343 2018/11/21 06:13:45 nakashim Exp nakashim $";
d572 1
a572 1
	   cid, bro[0]->a,
@


1.343
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.342 2018/11/20 07:59:09 nakashim Exp nakashim $";
d1623 2
a1624 1
  int idx = br->a & (sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH*EMAX_DEPTH-1);      /* for registers */
d1720 1
a1720 1
    tr->av   = br->av || exring[cid].unit[i].lmranger_ok || exring[cid].unit[i].lmrangew_ok || (exring[cid].unit[i].l_row == row && br->ty<4);
d2051 2
a2052 1
  int idx = tr->a & (sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH*EMAX_DEPTH-1);      /* for registers */
d2107 1
a2107 1
  else if (exring[cid].unit[i].cmd == CMD_NOP && exring[cid].unit[i].l_row == row && exring[cid].unit[i].lmring_ful1) { /* reg setup by PIO */
d2110 1
a2110 1
printf("====== WREG l_row=%x row=%x cmd=%d ==== tr->ty=%x a=%08.8x dm=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n", exring[cid].unit[i].l_row, row, exring[cid].unit[i].cmd, tr->ty, tr->a, tr->dm, (Uint)(tr->d[3]>>32), (Uint)(tr->d[3]), (Uint)(tr->d[2]>>32), (Uint)(tr->d[2]), (Uint)(tr->d[1]>>32), (Uint)(tr->d[1]), (Uint)(tr->d[0]>>32), (Uint)(tr->d[0]));
d2156 1
a2156 1
    if (exring[cid].unit[i].l_row == row && exring[cid].unit[i].lmring_ful1) { /* reg setup by PIO */
d2159 1
a2159 1
printf("====== WREG l_row=%x row=%x cmd=%d ==== tr->ty=%x a=%08.8x dm=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n", exring[cid].unit[i].l_row, row, exring[cid].unit[i].cmd, tr->ty, tr->a, tr->dm, (Uint)(tr->d[3]>>32), (Uint)(tr->d[3]), (Uint)(tr->d[2]>>32), (Uint)(tr->d[2]), (Uint)(tr->d[1]>>32), (Uint)(tr->d[1]), (Uint)(tr->d[0]>>32), (Uint)(tr->d[0]));
@


1.342
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.341 2018/11/15 15:22:44 nakashim Exp nakashim $";
d670 5
a674 5
      bri->ty   = (a<REG_BASE2_PHYS+REG_BREG_OFFS) ? 0 : /* conf */
	          (a<REG_BASE2_PHYS+REG_ADDR_OFFS) ? 1 : /* breg */
	          (a<REG_BASE2_PHYS+REG_LDDM_OFFS) ? 2 : /* addr */
	          (a<REG_BASE2_PHYS+REG_AREA_SIZE) ? 3 : /* lddm */
	                                             4 ; /* lmm  */
d754 5
a758 5
      bri->ty   = (a<REG_BASE2_PHYS+REG_BREG_OFFS) ? 0 : /* conf */
	          (a<REG_BASE2_PHYS+REG_ADDR_OFFS) ? 1 : /* breg */
	          (a<REG_BASE2_PHYS+REG_LDDM_OFFS) ? 2 : /* addr */
	          (a<REG_BASE2_PHYS+REG_AREA_SIZE) ? 3 : /* lddm */
	                                             4 ; /* lmm  */
d913 1
a913 1
	if (dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 < LMM_MAP_TOP) { /* mem->lmm */
@


1.341
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.340 2018/11/03 13:40:21 nakashim Exp nakashim $";
d1623 2
d1719 1
a1719 1
    tr->av   = br->av || exring[cid].unit[i].lmranger_ok || exring[cid].unit[i].lmrangew_ok;
d2259 1
a2259 1
      br->av   = tr->av | (exring[cid].unit[i].l_row == row && tr->ty<4);
@


1.340
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.339 2018/10/23 10:42:49 nakashim Exp nakashim $";
d545 6
a550 7
    if (trace)
      printf("%03.3d:REG->AXIIF RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	     cid, axiif[cid].sadr,
	     (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	     (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	     (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	     (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
d571 6
a576 7
    if (trace)
      printf("%03.3d:BRO->AXIIF RD reqn--=%x adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	     cid, axiif[cid].reqn, bro[0]->a,
	     (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	     (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	     (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	     (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
d999 6
a1004 7
        if (trace)
          printf("%03.3d:IORQ->AXIIF WR wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
                 cid, axiif[cid].axi_wstrb,
                 (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
                 (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
                 (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
                 (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
@


1.339
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.338 2018/10/23 07:08:45 nakashim Exp nakashim $";
d1290 1
a1290 1
      if ((!reg_ctrl.i[cid].conf[i][j].cdw0.fold && exring[cid].unit[i].unit2_stop)||(reg_ctrl.i[cid].conf[i][j].cdw0.fold && exring[cid].unit[i].unit2_fold && !exring[cid].unit[i].stage4_fold))
d1544 1
a1544 1
  exring[cid].unit[i].lmring_ea0bsy  =((!reg_ctrl.i[cid].conf[i][j].cdw0.fold && exring[cid].unit[i].stage4_exec) || (reg_ctrl.i[cid].conf[i][j].cdw0.fold && exring[cid].unit[i].stage4_fold))
@


1.338
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.337 2018/10/18 12:42:18 nakashim Exp nakashim $";
d1381 1
a1381 1
      r2     = (op_ex1 == OP_FOR && j == 1 && one_shot2 && !(forstat2 & 1)) /* LOOP1は，LOOP0==0の時のみ更新 */
@


1.337
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.336 2018/09/18 02:02:52 nakashim Exp nakashim $";
d1402 8
a1409 5
	if (j == 0) /* LOOP0 */
	  exring[cid].unit[i].stage_forstat  =     op_nf1<<1 | ex1_retval;
	else if (j == 1) /* LOOP1 */
	  exring[cid].unit[i].stage_forstat |= ex1_retval<<1;
	exring[cid].unit[i].unit1_arbrk = (exring[cid].unit[i].stage_forstat == 3);
@


1.336
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.335 2018/09/17 08:24:47 nakashim Exp nakashim $";
d273 3
a275 1
  if (cid) /* EMAX6 is attached on cid=0 */
d277 1
d280 1
a280 1
  prev_stat = c[cid].iorq.v_stat || reg_ctrl.stat;
d282 1
a282 1
  reg_ctrl.stat = (!(axiif[cid].reqn)?LMRING_IDLE:LMRING_BUSY)<<4 | (!(exring[cid].cmd_busy||exring[cid].unit_busy)?EXRING_IDLE:EXRING_BUSY);
d284 1
a284 1
  if (!c[cid].iorq.v_stat && !reg_ctrl.stat) {
d530 1
a530 1
    printf("%03.3d:BRO no unit covers rw=%x ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro[0]->rw, bro[0]->ty, bro[0]->a, bro[0]->a-reg_ctrl.adtr);
d542 1
a542 1
      axiif[cid].axi_rdata[k] = *((Ull*)((Uchar*)&reg_ctrl+(axiif[cid].sadr-REG_BASE2_PHYS))+k);
d659 1
a659 1
	*((Uint*)((Ull*)((Uchar*)&reg_ctrl+(a-REG_BASE2_PHYS))+k)  ) = axiif[cid].axi_wdata[k];
d661 1
a661 1
	*((Uint*)((Ull*)((Uchar*)&reg_ctrl+(a-REG_BASE2_PHYS))+k)+1) = axiif[cid].axi_wdata[k]>>32;
d677 1
a677 1
      bri->col  = reg_ctrl.csel;   /* logical col# for target lmm */
d680 1
a680 1
      bri->a    = a + ((bri->ty==4)?reg_ctrl.adtr:0) + axiif[cid].sreq*sizeof(Ull)*UNIT_WIDTH;
d700 1
a700 1
    switch (reg_ctrl.cmd) {
d707 1
a707 1
	       (Uint)(t[cid].total_cycle>>32), (Uint)t[cid].total_cycle, reg_ctrl.cmd);
d714 1
a714 1
    if (reg_ctrl.cmd == CMD_RESET) {
d728 1
a728 1
      reg_ctrl.cmd = CMD_NOP;
d733 1
a733 1
  if ((exring[cid].cycle & 3) == 3 && reg_ctrl.cmd == CMD_RESET)
d761 1
a761 1
      bri->col  = reg_ctrl.csel; /* logical col# for target lmm */
d764 1
a764 1
      bri->a    = a + ((bri->ty==4)?reg_ctrl.adtr:0) + axiif[cid].sreq*sizeof(Ull)*UNIT_WIDTH;
d813 1
a813 1
  if ((exring[cid].cycle & 3) == 3 && reg_ctrl.cmd == CMD_RESET) {
d1162 1
a1162 1
      switch (reg_ctrl.cmd) {
d1193 1
a1193 1
        exring[cid].unit[i].scon_count = reg_ctrl.conf[i][0].cdw2.mapdist<<1;
d1197 1
a1197 1
	if (!reg_ctrl.conf[i][0].cdw0.v)
d1210 4
a1213 4
      *((Ull*)(&reg_ctrl.conf[i][j])+0) = exring[cid].unit[pi].b[0][j].r[0];
      *((Ull*)(&reg_ctrl.conf[i][j])+1) = exring[cid].unit[pi].b[0][j].r[1];
      *((Ull*)(&reg_ctrl.conf[i][j])+2) = exring[cid].unit[pi].b[0][j].r[2];
      *((Ull*)(&reg_ctrl.conf[i][j])+3) = exring[cid].unit[pi].b[0][j].r[3];
d1233 1
a1233 1
      if (reg_ctrl.conf[i][j].cdw0.fold) {
d1235 2
a1236 2
	bi = (reg_ctrl.conf[i][j].cdw1.ea0bs&2)? i : pi; /* if ea0 takes eabbrs, shuold be i (else ea1(load) from pi) */
	oi = (reg_ctrl.conf[i][j].cdw1.ea0os&1)? i : pi; /* if ea0 takes eaobrs, shuold be i (else ea1(load) from pi) */
d1243 16
a1258 16
      s = reg_ctrl.conf[i][j].cdw1.cs0;    exring[cid].unit[i].cx[0] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.conf[i][j].cdw1.cs1;    exring[cid].unit[i].cx[1] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.conf[i][j].cdw1.cs2;    exring[cid].unit[i].cx[2] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.conf[i][j].cdw1.cs3;    exring[cid].unit[i].cx[3] = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;

      s = reg_ctrl.conf[i][j].cdw2.ts0;    exring[cid].unit[i].tx[0] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw2.ts1;    exring[cid].unit[i].tx[1] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw2.ts2;    exring[cid].unit[i].tx[2] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw2.ts3;    exring[cid].unit[i].tx[3] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];

      s = reg_ctrl.conf[i][j].cdw0.ex1brs; exring[cid].unit[i].ex1   = (j == 0 && reg_ctrl.conf[i][j].cdw0.op1 == OP_FOR && (exring[cid].unit[i].stage_forstat & (1<<j)))
					                             ||(j == 1 && reg_ctrl.conf[i][j].cdw0.op1 == OP_FOR && (exring[cid].unit[i].stage_forstat & (1<<j)))
					                             ||(reg_ctrl.conf[i][j].cdw0.ex1s!=1 || (!exring[cid].unit[i].one_shot || ((reg_ctrl.conf[i][j].cdw0.init&1)&&(exring[cid].unit[i].unit1_forstat&1))))
                                                                     ? exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH] : exring[cid].unit[i].ex4dr_prev; /* self_loop */
      s = reg_ctrl.conf[i][j].cdw0.ex2brs; exring[cid].unit[i].ex2   = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw0.ex3brs; exring[cid].unit[i].ex3   = exring[cid].unit[xi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
d1260 2
a1261 2
      s = reg_ctrl.conf[i][j].cdw1.eabbrs; exring[cid].unit[i].eab   = exring[cid].unit[bi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw1.eaobrs; exring[cid].unit[i].eao   = exring[cid].unit[oi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
d1268 2
a1269 2
      sb = reg_ctrl.conf[i][k].cdw1.ea0bs; exring[cid].unit[i].ea0b  = (!(sb&1)||!exring[cid].unit[i].one_shot)?(((sb&2)?exring[cid].unit[i].eab:reg_ctrl.addr[i][k].ea0b)|ofs) : exring[cid].unit[i].ea04dr_prev;
      so = reg_ctrl.conf[i][k].cdw1.ea0os; exring[cid].unit[i].ea0o  = (!(sb&1)|| exring[cid].unit[i].one_shot)?((so&1)?exring[cid].unit[i].eao:reg_ctrl.addr[i][k].ea0o) : 0LL;
d1272 2
a1273 2
      sb = reg_ctrl.conf[i][j].cdw1.ea1bs; exring[cid].unit[i].ea1b  = (!(sb&1)||!exring[cid].unit[i].one_shot)?((sb&2)?exring[cid].unit[i].eab:reg_ctrl.addr[i][j].ea1b) : exring[cid].unit[i].ea14dr_prev;
      so = reg_ctrl.conf[i][j].cdw1.ea1os; exring[cid].unit[i].ea1o  = (!(sb&1)|| exring[cid].unit[i].one_shot)?((so&1)?exring[cid].unit[i].eao:reg_ctrl.addr[i][j].ea1o) : 0LL;
d1290 1
a1290 1
      if ((!reg_ctrl.conf[i][j].cdw0.fold && exring[cid].unit[i].unit2_stop)||(reg_ctrl.conf[i][j].cdw0.fold && exring[cid].unit[i].unit2_fold && !exring[cid].unit[i].stage4_fold))
d1296 2
a1297 2
      unit1_exec_next    = exring[cid].unit[i].unit1_exec     | (reg_ctrl.conf[i][0].cdw0.v && exring[cid].unit[i].l_row>0 && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_exec);
      unit1_fold_next    = exring[cid].unit[i].unit2_exec     &  reg_ctrl.conf[i][0].cdw0.fold;
d1299 1
a1299 1
      unit1_stop_next    = exring[cid].unit[i].unit1_arbrk    | (reg_ctrl.conf[i][0].cdw0.v && exring[cid].unit[i].l_row>0 && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_stop);
d1301 1
a1301 1
      unit2_fold_next    = exring[cid].unit[i].unit1_fold     &  reg_ctrl.conf[i][0].cdw0.fold;
d1316 1
a1316 1
  if ((exring[cid].unit[i].cycle & 3) == 3 && reg_ctrl.cmd == CMD_RESET)
d1330 1
a1330 1
  Uint   op_ex1, op_ex2, op_ex3;
d1341 1
a1341 1
      switch (reg_ctrl.cmd) {
d1368 1
a1368 1
      pattern = reg_ctrl.conf[i][j].cdw1.cex_tab;
d1373 5
a1377 4
      op_ex1 = reg_ctrl.conf[i][j].cdw0.op1;
      op_ex2 = reg_ctrl.conf[i][j].cdw0.op2;
      op_ex3 = reg_ctrl.conf[i][j].cdw0.op3;
      init   = reg_ctrl.conf[i][j].cdw0.init;
d1384 8
a1391 8
      r4     = reg_ctrl.conf[i][j].cdw0.e2is==0 ? reg_ctrl.conf[i][j].cdw3.e2imm
             : reg_ctrl.conf[i][j].cdw0.e2is==1 ? exring[cid].unit[i].ex2
             :                                    exring[cid].unit[i].ex3;
      r5     = reg_ctrl.conf[i][j].cdw0.e3is==0 ? reg_ctrl.conf[i][j].cdw0.e3imm
             :                                    exring[cid].unit[i].ex3;
      exp1   = reg_ctrl.conf[i][j].cdw0.ex1exp;
      exp2   = reg_ctrl.conf[i][j].cdw0.ex2exp;
      exp3   = reg_ctrl.conf[i][j].cdw0.ex3exp;
d1403 1
a1403 1
	  exring[cid].unit[i].stage_forstat  = (ex1_retval)<<j;
d1405 1
a1405 1
	  exring[cid].unit[i].stage_forstat |= (ex1_retval)<<j;
d1415 2
a1416 2
      eag(&exring[cid].unit[i].ea02dr, base0, offs0, reg_ctrl.conf[i][j].cdw1.ea0msk);
      eag(&exring[cid].unit[i].ea12dr, base1, offs1, reg_ctrl.conf[i][j].cdw1.ea1msk);
d1448 1
a1448 1
      switch (reg_ctrl.cmd) {
d1509 3
a1511 3
  ftag  = (reg_ctrl.addr[i][br->col].top&~(sizeof(Ull)*UNIT_WIDTH-1)); /* & 0xffffffe0 */
  ltag  = (reg_ctrl.addr[i][br->col].bot&~(sizeof(Ull)*UNIT_WIDTH-1)); /* & 0xffffffe0 */
  switch ( (reg_ctrl.addr[i][br->col].top/sizeof(Ull)) & (UNIT_WIDTH-1)) {
d1517 1
a1517 1
  switch (~(reg_ctrl.addr[i][br->col].bot/sizeof(Ull)) & (UNIT_WIDTH-1)) {
d1533 11
a1543 11
  exring[cid].unit[i].lmranger_ok    = (reg_ctrl.conf[i][br->col].cdw2.lmm_axir && br->rw==0 && br->ty==4) ? exring[cid].unit[i].ranger_ok : 0; /* 4bits */
  exring[cid].unit[i].lmrangew_ok    = (reg_ctrl.conf[i][br->col].cdw2.lmm_axiw && br->rw==1 && br->ty==4) ? exring[cid].unit[i].rangew_ok : 0; /* 4bits */
  exring[cid].unit[i].lmlddmqw_ok    = br->rw==1 && br->ty==3 && reg_ctrl.conf[i][br->col].cdw1.ea1op == OP_LDDMQ; /* lmwd[0]->tr *//* LDDMQは同一slotに高々1が前提 */
  exring[cid].unit[i].lmea0strq      = reg_ctrl.conf[i][0].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[i][1].cdw1.ea0op == OP_STRQ
                                    || reg_ctrl.conf[i][2].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[i][3].cdw1.ea0op == OP_STRQ; /* op0 */
  exring[cid].unit[i].lmea0strqcol   = reg_ctrl.conf[i][0].cdw1.ea0op == OP_STRQ ? 0 :
                                       reg_ctrl.conf[i][1].cdw1.ea0op == OP_STRQ ? 1 :
				       reg_ctrl.conf[i][2].cdw1.ea0op == OP_STRQ ? 2 : 3;
  exring[cid].unit[i].lmring_ea0bsy  =((!reg_ctrl.conf[i][j].cdw0.fold && exring[cid].unit[i].stage4_exec) || (reg_ctrl.conf[i][j].cdw0.fold && exring[cid].unit[i].stage4_fold))
                                                                       && ((reg_ctrl.conf[i][j].cdw1.ea0op && reg_ctrl.conf[i][j].cdw1.ea0op <= OP_IM_BUFWR)||exring[cid].unit[i].lmea0strq); /* op0 */
  exring[cid].unit[i].lmring_ea1bsy  = exring[cid].unit[i].stage4_exec &&  (reg_ctrl.conf[i][j].cdw1.ea1op && reg_ctrl.conf[i][j].cdw1.ea1op <= OP_IM_BUFRD); /* op1 */
d1687 1
a1687 1
      && reg_ctrl.cmd == CMD_RESET) {
d1761 1
a1761 1
      && reg_ctrl.cmd == CMD_RESET) {
d1813 1
a1813 1
      switch (reg_ctrl.conf[i][exring[cid].unit[i].lmco].cdw2.lmm_mode) {
d1829 1
a1829 1
printf("====== WLMM row=%x br.col=%x ====axir=%x axiw=%x br->rw=%x br->ty=%x a=%08.8x lmranger_ok=%x lmrangew_ok=%x top=%08.8x bot=%08.8x\n", i, br->col, reg_ctrl.conf[i][br->col].cdw2.lmm_axir, reg_ctrl.conf[i][br->col].cdw2.lmm_axiw, br->rw, br->ty, br->a, exring[cid].unit[i].lmranger_ok, exring[cid].unit[i].lmrangew_ok, reg_ctrl.addr[i][br->col].top, reg_ctrl.addr[i][br->col].bot);
d1834 1
a1834 1
      switch (reg_ctrl.conf[i][k].cdw2.lmm_mode) {
d1842 1
a1842 1
      exring[cid].unit[i].lmm.rw0     = (reg_ctrl.conf[i][k].cdw1.ea0op & 0x10)!=0; /* read/write */
d1847 5
a1851 5
      exring[cid].unit[i].mwmux[0] = reg_ctrl.conf[i][k].cdw2.mws0==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[0];
      exring[cid].unit[i].mwmux[1] = reg_ctrl.conf[i][k].cdw2.mws1==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[1];
      exring[cid].unit[i].mwmux[2] = reg_ctrl.conf[i][k].cdw2.mws2==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[2];
      exring[cid].unit[i].mwmux[3] = reg_ctrl.conf[i][k].cdw2.mws3==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[3];
      switch (reg_ctrl.conf[i][k].cdw1.ea0op) {
d1927 1
a1927 1
      switch (reg_ctrl.conf[i][exring[cid].unit[i].lmco].cdw2.lmm_mode) {
d1938 1
a1938 1
printf("====== RLMM row=%x br.col=%x ====axir=%x axiw=%x br->rw=%x br->ty=%x a=%08.8x lmranger_ok=%x lmrangew_ok=%x top=%08.8x bot=%08.8x\n", i, br->col, reg_ctrl.conf[i][br->col].cdw2.lmm_axir, reg_ctrl.conf[i][br->col].cdw2.lmm_axiw, br->rw, br->ty, br->a, exring[cid].unit[i].lmranger_ok, exring[cid].unit[i].lmrangew_ok, reg_ctrl.addr[i][br->col].top, reg_ctrl.addr[i][br->col].bot);
d1942 1
a1942 1
      switch (reg_ctrl.conf[i][j].cdw2.lmm_mode) {
d1960 1
a1960 1
      if (reg_ctrl.conf[i][j].cdw1.ea1op == OP_LDDMQ) {
d1972 4
a1975 4
        exring[cid].unit[i].tx4dr[0] = reg_ctrl.conf[i][j].cdw2.trs0==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[0];
        exring[cid].unit[i].tx4dr[1] = reg_ctrl.conf[i][j].cdw2.trs1==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[1];
        exring[cid].unit[i].tx4dr[2] = reg_ctrl.conf[i][j].cdw2.trs2==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[2];
        exring[cid].unit[i].tx4dr[3] = reg_ctrl.conf[i][j].cdw2.trs3==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[3];
d2090 1
a2090 1
      && reg_ctrl.cmd == CMD_RESET) {
d2110 8
a2117 8
      if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+0) = tr->d[0];     }
      if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+1) = tr->d[0]>>32; }
      if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+2) = tr->d[1];     }
      if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+3) = tr->d[1]>>32; }
      if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+4) = tr->d[2];     }
      if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+5) = tr->d[2]>>32; }
      if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+6) = tr->d[3];     }
      if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+7) = tr->d[3]>>32; }
d2126 8
a2133 8
      if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+0) = tr->d[0];     }
      if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+1) = tr->d[0]>>32; }
      if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+2) = tr->d[1];     }
      if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+3) = tr->d[1]>>32; }
      if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+4) = tr->d[2];     }
      if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+5) = tr->d[2]>>32; }
      if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+6) = tr->d[3];     }
      if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+7) = tr->d[3]>>32; }
d2136 4
a2139 4
      if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[i]+ofs)+0) = tr->d[0];   }/* ★★★ only write is implemented */
      if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[i]+ofs)+1) = tr->d[1];   }/* ★★★ only write is implemented */
      if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[i]+ofs)+2) = tr->d[2];   }/* ★★★ only write is implemented */
      if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[i]+ofs)+3) = tr->d[3];   }/* ★★★ only write is implemented */
d2145 4
a2148 4
      exring[cid].unit[i].b[0][j].r[0] = *((Ull*)(&reg_ctrl.conf[i][j])+0);
      exring[cid].unit[i].b[0][j].r[1] = *((Ull*)(&reg_ctrl.conf[i][j])+1);
      exring[cid].unit[i].b[0][j].r[2] = *((Ull*)(&reg_ctrl.conf[i][j])+2);
      exring[cid].unit[i].b[0][j].r[3] = *((Ull*)(&reg_ctrl.conf[i][j])+3);
d2159 8
a2166 8
	if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+0) = tr->d[0];     }
	if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+1) = tr->d[0]>>32; }
	if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+2) = tr->d[1];     }
	if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+3) = tr->d[1]>>32; }
	if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+4) = tr->d[2];     }
	if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+5) = tr->d[2]>>32; }
	if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+6) = tr->d[3];     }
	if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&reg_ctrl.addr[i]+ofs)+7) = tr->d[3]>>32; }
d2169 4
a2172 4
	if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[i]+ofs)+0) = tr->d[0];   }/* ★★★ only write is implemented */
	if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[i]+ofs)+1) = tr->d[1];   }/* ★★★ only write is implemented */
	if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[i]+ofs)+2) = tr->d[2];   }/* ★★★ only write is implemented */
	if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[i]+ofs)+3) = tr->d[3];   }/* ★★★ only write is implemented */
d2177 1
a2177 1
    switch (reg_ctrl.conf[i][j].cdw2.brs0) {
d2182 1
a2182 1
      switch (reg_ctrl.conf[i][j].cdw1.ea0op) {
d2193 1
a2193 1
    switch (reg_ctrl.conf[i][j].cdw2.brs1) {
d2198 1
a2198 1
      switch (reg_ctrl.conf[i][j].cdw1.ea1op) {
d2209 1
a2209 1
    switch (reg_ctrl.conf[i][j].cdw2.brs2) {
d2216 1
a2216 1
    switch (reg_ctrl.conf[i][j].cdw2.brs3) {
d2228 1
a2228 1
      && reg_ctrl.cmd == CMD_RESET) {
d2435 16
a2450 16
             reg_ctrl.conf[row][col].cdw0.v?36:34, reg_ctrl.conf[row][col].cdw0.v,
             (Uint) reg_ctrl.conf[row][col].cdw0.op1,
             (Uint) reg_ctrl.conf[row][col].cdw0.op2,
             (Uint) reg_ctrl.conf[row][col].cdw0.op3,
             (Uint) reg_ctrl.conf[row][col].cdw0.ex1brs,
             (Uint) reg_ctrl.conf[row][col].cdw0.ex1s,
             (Uint) reg_ctrl.conf[row][col].cdw0.ex1exp,
             (Uint) reg_ctrl.conf[row][col].cdw0.ex2brs,
             (Uint) reg_ctrl.conf[row][col].cdw0.ex2exp,
             (Uint) reg_ctrl.conf[row][col].cdw0.ex3brs,
             (Uint) reg_ctrl.conf[row][col].cdw0.ex3exp,
             (Uint)(reg_ctrl.conf[row][col].cdw3.e2imm>>32),
             (Uint) reg_ctrl.conf[row][col].cdw3.e2imm,
             (Uint) reg_ctrl.conf[row][col].cdw0.e2is,
             (Uint) reg_ctrl.conf[row][col].cdw0.e3imm,
             (Uint) reg_ctrl.conf[row][col].cdw0.e3is);
d2454 15
a2468 15
             (Uint) reg_ctrl.conf[row][col].cdw1.cs3,
             (Uint) reg_ctrl.conf[row][col].cdw1.cs2,
             (Uint) reg_ctrl.conf[row][col].cdw1.cs1,
             (Uint) reg_ctrl.conf[row][col].cdw1.cs0,
             (Uint) reg_ctrl.conf[row][col].cdw1.cex_tab,
             (Uint) reg_ctrl.conf[row][col].cdw1.ea1op,
             (Uint) reg_ctrl.conf[row][col].cdw1.ea1bs,
             (Uint) reg_ctrl.conf[row][col].cdw1.ea1os,
             (Uint) reg_ctrl.conf[row][col].cdw1.ea1msk,
             (Uint) reg_ctrl.conf[row][col].cdw1.ea0op,
             (Uint) reg_ctrl.conf[row][col].cdw1.ea0bs,
             (Uint) reg_ctrl.conf[row][col].cdw1.ea0os,
             (Uint) reg_ctrl.conf[row][col].cdw1.ea0msk,
             (Uint) reg_ctrl.conf[row][col].cdw1.eabbrs,
             (Uint) reg_ctrl.conf[row][col].cdw1.eaobrs);
d2472 19
a2490 19
             (Uint) reg_ctrl.conf[row][col].cdw2.ts3,
             (Uint) reg_ctrl.conf[row][col].cdw2.ts2,
             (Uint) reg_ctrl.conf[row][col].cdw2.ts1,
             (Uint) reg_ctrl.conf[row][col].cdw2.ts0,
             (Uint) reg_ctrl.conf[row][col].cdw2.trs3,
             (Uint) reg_ctrl.conf[row][col].cdw2.trs2,
             (Uint) reg_ctrl.conf[row][col].cdw2.trs1,
             (Uint) reg_ctrl.conf[row][col].cdw2.trs0,
             (Uint) reg_ctrl.conf[row][col].cdw2.mwsa,
             (Uint) reg_ctrl.conf[row][col].cdw2.mws3,
             (Uint) reg_ctrl.conf[row][col].cdw2.mws2,
             (Uint) reg_ctrl.conf[row][col].cdw2.mws1,
             (Uint) reg_ctrl.conf[row][col].cdw2.mws0,
             (Uint) reg_ctrl.conf[row][col].cdw2.brs3,
             (Uint) reg_ctrl.conf[row][col].cdw2.brs2,
             (Uint) reg_ctrl.conf[row][col].cdw2.brs1,
             (Uint) reg_ctrl.conf[row][col].cdw2.brs0,
             (Uint) reg_ctrl.conf[row][col].cdw2.mapdist,
             (Uint) reg_ctrl.conf[row][col].cdw2.lmm_mode);
d2507 2
a2508 2
    printf(" ea31b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.addr[row][3].ea1b&0x3ffff, reg_ctrl.addr[row][3].ea1o&0x3ffff, reg_ctrl.addr[row][3].ea0b&0x3ffff, reg_ctrl.addr[row][3].ea0o&0x3ffff, reg_ctrl.addr[row][3].top,  reg_ctrl.addr[row][3].bot);
    printf(" ea21b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.addr[row][2].ea1b&0x3ffff, reg_ctrl.addr[row][2].ea1o&0x3ffff, reg_ctrl.addr[row][2].ea0b&0x3ffff, reg_ctrl.addr[row][2].ea0o&0x3ffff, reg_ctrl.addr[row][2].top,  reg_ctrl.addr[row][2].bot);
d2511 2
a2512 2
    printf(" ea11b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.addr[row][1].ea1b&0x3ffff, reg_ctrl.addr[row][1].ea1o&0x3ffff, reg_ctrl.addr[row][1].ea0b&0x3ffff, reg_ctrl.addr[row][1].ea0o&0x3ffff, reg_ctrl.addr[row][1].top,  reg_ctrl.addr[row][1].bot);
    printf(" ea01b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.addr[row][0].ea1b&0x3ffff, reg_ctrl.addr[row][0].ea1o&0x3ffff, reg_ctrl.addr[row][0].ea0b&0x3ffff, reg_ctrl.addr[row][0].ea0o&0x3ffff, reg_ctrl.addr[row][0].top,  reg_ctrl.addr[row][0].bot);
d2636 1
a2636 1
      lmm_mode = reg_ctrl.conf[row][col].cdw2.lmm_mode;
d2643 2
a2644 2
      if (reg_ctrl.conf[row][col].cdw1.ea0op == OP_IM_BUFWR
        ||reg_ctrl.conf[row][col].cdw1.ea1op == OP_IM_BUFRD) { /* sequential from addr=0 (including OP_LDDMQ) */
d2658 4
a2661 4
      else if ((reg_ctrl.conf[row][col].cdw1.ea0op && reg_ctrl.conf[row][col].cdw1.ea0op < OP_IM_BUFWR)
             ||(reg_ctrl.conf[row][col].cdw1.ea1op && reg_ctrl.conf[row][col].cdw1.ea1op < OP_IM_BUFRD)) {
	toph = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.addr[row][col].top+sizeof(Ull)*15) & lmask);
	topl = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.addr[row][col].top               ) & lmask);
d2666 2
a2667 2
	both = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.addr[row][col].bot+1-sizeof(Ull)   ) & lmask);
	botl = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.addr[row][col].bot+1-sizeof(Ull)*16) & lmask);
@


1.335
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.334 2018/09/17 05:41:34 nakashim Exp nakashim $";
d2512 4
a2515 4
           exring[cid].unit[row].cx[3],
           exring[cid].unit[row].cx[2],
           exring[cid].unit[row].cx[1],
           exring[cid].unit[row].cx[0],
@


1.334
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.333 2018/09/17 02:15:11 nakashim Exp nakashim $";
d1257 1
a1257 1
      s = reg_ctrl.conf[i][j].cdw1.eabbrs; exring[cid].unit[i].eab   = exring[cid].unit[bi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]; if (i==2) printf("2:bi=%d s=%d eab=%08.8x\n", bi, s, exring[cid].unit[i].eab);
d1393 1
a1393 1
      if (op_ex1 == OP_WHILE) {
d1395 1
a1395 1
	printf("%d WHILE dst=%d arbrk=%d\n", j, (Uint)exring[cid].unit[i].ex2dr, exring[cid].unit[i].unit1_arbrk);
d1403 1
a1403 6
	printf("%d FOR stage_forstat=%d dst=%d arbrk=%d\n", j, exring[cid].unit[i].stage_forstat,
	       (Uint)exring[cid].unit[i].ex2dr, exring[cid].unit[i].unit1_arbrk);
      }
      else if (op_ex1 == OP_ADD /*&& init*/) {
	printf("%d.%d ADD init=%d cycle=%d one_shot2=%d stage_forstat=%d unit1_forstat2=%d dst=%d arbrk=%d\n", i, j, init, exring[cid].unit[i].cycle, one_shot2, exring[cid].unit[i].stage_forstat, exring[cid].unit[i].unit1_forstat2,
	       (Uint)exring[cid].unit[i].ex2dr, exring[cid].unit[i].unit1_arbrk);
@


1.333
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.332 2018/09/16 08:58:18 nakashim Exp nakashim $";
d100 1
d323 1
a323 1
    if (exring[cid].unit[i].unit1_exec || exring[cid].unit[i].unit1_fold || exring[cid].unit[i].unit1_stop || exring[cid].unit[i].unit2_exec || exring[cid].unit[i].unit2_stop)
d1154 1
a1154 1
  int unit1_exec_next, unit1_fold_next, unit1_forstat_next, unit1_stop_next, unit2_exec_next, unit2_forstat_next, unit2_stop_next;
a1158 1
      exring[cid].unit[i].stage2_fold = 0;
d1171 1
d1175 1
d1287 1
a1287 1
      if (exring[cid].unit[i].unit2_stop)
d1298 1
d1306 1
a1337 1
      exring[cid].unit[i].stage3_fold = 0;
d1343 1
a1448 1
      exring[cid].unit[i].stage4_fold = 0;
d1452 1
d2496 1
a2496 1
    printf(" l_row=%02.2d scan_count=%03.3d one_shot=%d \033[1;%dmu1exec=%d\033[0m \033[1;%dmu1fold=%d\033[0m \033[1;%dmu1stop=%d\033[0m \033[1;%dmu2exec=%d\033[0m \033[1;%dmu2stop=%d\033[0m\n",
d2504 1
@


1.332
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.331 2018/09/15 23:26:42 nakashim Exp nakashim $";
d858 2
a859 2
      printf("%03.3d:DMA MEM->LMM WR last=%x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	     cid, axiif[cid].axi_wlast, axiif[cid].axi_wstrb,
d1158 1
a1173 1
        exring[cid].unit[i].stage2_fold   = 0; /* reset to default */
d1334 1
a1339 1
        exring[cid].unit[i].stage3_fold = 0;
d1445 1
a1448 1
        exring[cid].unit[i].stage4_fold = 0;
a1544 1

@


1.331
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.330 2018/09/15 14:44:46 nakashim Exp nakashim $";
d92 1
d105 1
d107 1
d109 1
d322 1
a322 1
    if (exring[cid].unit[i].unit1_exec || exring[cid].unit[i].unit1_stop || exring[cid].unit[i].unit2_exec || exring[cid].unit[i].unit2_stop)
d1145 3
d1153 1
a1153 1
  int unit1_exec_next, unit1_forstat_next, unit1_stop_next, unit2_exec_next, unit2_forstat_next, unit2_stop_next;
d1165 1
d1167 1
a1167 1
	exring[cid].unit[i].unit1_forstat2 = 0;
d1170 1
d1172 2
a1173 1
        exring[cid].unit[i].stage2_exec   = 0;
d1226 16
a1241 5
    if (exring[cid].unit[i].unit1_exec && (exring[cid].unit[i].l_row==0 || exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid)) { /* active */
      s = reg_ctrl.conf[i][j].cdw1.cs0;    exring[cid].unit[i].cx[0] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.conf[i][j].cdw1.cs1;    exring[cid].unit[i].cx[1] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.conf[i][j].cdw1.cs2;    exring[cid].unit[i].cx[2] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.conf[i][j].cdw1.cs3;    exring[cid].unit[i].cx[3] = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
d1251 3
a1253 3
                                                                     ? exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH] : exring[cid].unit[i].ex4dr_prev; /* self_loop */
      s = reg_ctrl.conf[i][j].cdw0.ex2brs; exring[cid].unit[i].ex2   = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw0.ex3brs; exring[cid].unit[i].ex3   = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
d1255 2
a1256 2
      s = reg_ctrl.conf[i][j].cdw1.eabbrs; exring[cid].unit[i].eab   = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw1.eaobrs; exring[cid].unit[i].eao   = exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
d1269 1
d1271 1
a1272 1
    }
d1276 5
d1292 2
a1293 1
      unit1_forstat_next = exring[cid].unit[i].l_row==0 ? exring[cid].unit[i].stage_forstat : exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_forstat;
d1299 1
d1339 1
d1355 1
a1355 1
    if (exring[cid].unit[i].stage2_exec) { /* active */
d1420 1
d1422 1
a1423 1
    }
d1426 6
d1448 1
d1464 1
a1464 1
    if (exring[cid].unit[i].stage3_exec) { /* active */
d1480 1
d1482 1
a1483 1
    }
d1486 6
d1538 2
a1539 1
  exring[cid].unit[i].lmring_ea0bsy  = exring[cid].unit[i].stage4_exec && ((reg_ctrl.conf[i][j].cdw1.ea0op && reg_ctrl.conf[i][j].cdw1.ea0op <= OP_IM_BUFWR)||exring[cid].unit[i].lmea0strq); /* op0 */
d1785 1
a1785 1
    if (exring[cid].unit[i].stage4_exec) { /* active */
d2493 1
a2493 1
    printf(" l_row=%02.2d scan_count=%03.3d one_shot=%d \033[1;%dmu1exec=%d\033[0m \033[1;%dmu1stop=%d\033[0m \033[1;%dmu2exec=%d\033[0m \033[1;%dmu2stop=%d\033[0m\n",
d2498 1
d2520 1
a2520 1
    printf(" ea1=%05.5x+%05.5x eab/o=%05.5x/%05.5x ea0=%05.5x+%05.5x st2ex=%d",
d2527 1
a2527 1
           exring[cid].unit[row].stage2_exec);
d2535 1
a2535 1
    printf("-stage2-out: cx2dr=%x ex2dr=%08.8x%08.8x \033[1;%dmstfstat=%d\033[0m \033[1;%dmu1fstat=%d\033[0m \033[1;%dmarbrk=%d\033[0m       ea12dr=%05.5x                      ea02dr=%05.5x    st3ex=%d",
d2543 1
a2543 1
           exring[cid].unit[row].stage3_exec);
d2551 1
a2551 1
    printf("-stage3-out: cx3dr=%x ex3dr=%08.8x%08.8x                                   ea13dr=%05.5x                      ea03dr=%05.5x    st4ex=%d",
d2556 1
a2556 1
           exring[cid].unit[row].stage4_exec);
d2566 1
a2566 1
    printf("       ea14um/lm=%x/%05.5x ea14dr=%05.5x    ea04um/lm=%x/%05.5x ea04dr=%05.5x    trval=%d",
@


1.330
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.329 2018/09/12 15:25:59 nakashim Exp nakashim $";
d1156 1
a1156 1
        exring[cid].unit[i].one_shot2      = 0; /* reset to default */
d1229 1
a1229 1
					                             ||(reg_ctrl.conf[i][j].cdw0.ex1s!=1 || !exring[cid].unit[i].one_shot)
d1307 1
a1307 1
	exring[cid].unit[i].stage_forstat  = 0;
d1344 2
a1345 2
             ||((init & 1) && one_shot2 && !(forstat2 & 1)) ? 0LL /* init0 specified && LOOP0-not_end */ : exring[cid].unit[i].ex2;
      r3     = ((init & 2) && one_shot2 && !(forstat2 & 2)) ? 0LL /* init1 specified && LOOP1-not_end */ : exring[cid].unit[i].ex3;
@


1.329
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.328 2018/09/12 08:57:43 nakashim Exp nakashim $";
d90 1
d92 3
d99 1
d1077 4
a1080 1
  /* unit1_arbrk(stage2)___________________________________________________________________________________________________/~LOOP0~/~LOOP1~/~LOOP2~\_______________________________________ */
d1114 4
a1117 1
  /* unit1_arbrk(stage2)___/~LOOP0~/~LOOP1~/~LOOP2~\_______________________________________________________________________ */
d1119 1
d1146 1
a1146 1
  int unit1_stop_next, unit1_exec_next, unit2_stop_next, unit2_exec_next;
d1156 1
d1158 2
d1227 3
a1229 1
      s = reg_ctrl.conf[i][j].cdw0.ex1brs; exring[cid].unit[i].ex1   = (reg_ctrl.conf[i][j].cdw0.ex1s!=1 || !exring[cid].unit[i].one_shot)
d1254 3
d1264 12
a1275 8
      unit1_exec_next = exring[cid].unit[i].unit1_exec     | (reg_ctrl.conf[i][0].cdw0.v && exring[cid].unit[i].l_row>0 && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_exec);
      unit1_stop_next = exring[cid].unit[i].unit1_arbrk    | (reg_ctrl.conf[i][0].cdw0.v && exring[cid].unit[i].l_row>0 && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_stop);
      unit2_exec_next = exring[cid].unit[i].unit1_exec;
      unit2_stop_next = exring[cid].unit[i].unit1_stop;
      exring[cid].unit[i].unit1_exec = unit1_exec_next & ~unit1_stop_next;
      exring[cid].unit[i].unit1_stop =                    unit1_stop_next;
      exring[cid].unit[i].unit2_exec = unit2_exec_next & ~unit2_stop_next;
      exring[cid].unit[i].unit2_stop =                    unit2_stop_next;
d1295 1
d1298 1
d1307 1
d1339 3
d1343 3
a1345 2
      r2     = exring[cid].unit[i].ex2;
      r3     = exring[cid].unit[i].ex3;
d1355 2
d1358 18
a1375 3
        exring[cid].unit[i].unit1_arbrk  = exe(op_ex1, &exring[cid].unit[i].ex2dr, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5);
      else
        exring[cid].unit[i].unit1_arbrk |= exe(op_ex1, &exring[cid].unit[i].ex2dr, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5);
d2488 1
a2488 1
    printf("-stage2-out: cx2dr=%x ex2dr=%08.8x%08.8x \033[1;%dmu1arbrk=%d\033[0m                         ea12dr=%05.5x                      ea02dr=%05.5x    st3ex=%d",
d2491 2
@


1.328
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.327 2018/07/29 10:25:56 nakashim Exp nakashim $";
d91 1
a107 1
    Ull   ex2dbrk       : 1; /* reg  *//* out for first-stage */
a108 1
    Ull   ex3dbrk       : 1; /* reg  *//* out for second-stage */
a110 1
    Ull   unit1_arbrk   : 1; /* loop最終命令の実行完了を表示 */
d1072 2
d1078 4
a1081 8
  /* stage1out** ----------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */
  /* stage2out   ----------<-------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2==> */
  /* stage3out   ----------<---------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1==> */
  /* ex2dbrk     ----------<-----------------------------------------------------------------------<===0===X===1===X===2===X===3==>-------------------------------------------------------- */
  /* ex3dbrk     ----------<-------------------------------------------------------------------------------<===0===X===1===X===2===X===3==>------------------------------------------------ */
  /* stage4out   ----tx4dr-<-----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0==> */
  /* unit1_arbrk __________________________________________________________________________________________________/~~~~~~~/~~~~~~~/~~~~~~~/~~~~~~~\_______________________________________ */
  /*                                                                                                                                              A確定                                     */
d1094 34
d1281 1
a1284 1
        exring[cid].unit[i].ex2dbrk     = 0;
d1323 5
a1327 1
      exring[cid].unit[i].ex2dbrk = exe(op_ex1, &exring[cid].unit[i].ex2dr, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5);
a1364 1
        exring[cid].unit[i].ex3dbrk  = 0;
a1383 1
      exring[cid].unit[i].ex3dbrk = exring[cid].unit[i].ex2dbrk;
a1486 1
  /* ex3dbrk     ------------------------------------------------------------------------------------------<===0===X===1===X===2===X===3==>------------------------------------------------ */
a1504 2
  /* unit1_arbrk __________________________________________________________________________________________________/~~~~~~~/~~~~~~~/~~~~~~~/~~~~~~~\_______________________________________ */
  /*                                                                                                                                              A確定                                     */
a1636 1
  Ull   unit1_arbrk   : 1; /* loop最終命令の実行完了を表示 */
a1667 1
    exring[cid].unit[i].unit1_arbrk    = 0;
a1694 4
      if ((exring[cid].unit[i].cycle & 3) == 3)
        exring[cid].unit[i].unit1_arbrk  = exring[cid].unit[i].ex3dbrk;
      else
        exring[cid].unit[i].unit1_arbrk |= exring[cid].unit[i].ex3dbrk;
a1695 2
    else
      exring[cid].unit[i].unit1_arbrk  = 0;
a1929 1
  /* ex3dbrk     ------------------------------------------------------------------------------------------<===0===X===1===X===2===X===3==>------------------------------------------------ */
a1930 2
  /* unit1_arbrk __________________________________________________________________________________________________/~~~~~~~/~~~~~~~/~~~~~~~/~~~~~~~\_______________________________________ */
  /*                                                                                                                                              A確定                                     */
d2440 1
a2440 1
    printf("-stage2-out: cx2dr=%x ex2dr=%08.8x%08.8x \033[1;%dmex2dbrk=%d\033[0m                         ea12dr=%05.5x                      ea02dr=%05.5x    st3ex=%d",
d2443 1
a2443 1
           exring[cid].unit[row].ex2dbrk?31:34, exring[cid].unit[row].ex2dbrk,
d2454 1
a2454 1
    printf("-stage3-out: cx3dr=%x ex3dr=%08.8x%08.8x \033[1;%dmex3dbrk=%d\033[0m                         ea13dr=%05.5x                      ea03dr=%05.5x    st4ex=%d",
a2456 1
           exring[cid].unit[row].ex3dbrk?31:34, exring[cid].unit[row].ex3dbrk,
d2467 2
a2468 3
    printf("-stage4-out:         ex4dr=%08.8x%08.8x \033[1;%dmu1arbrk=%d\033[0m",
           (Uint)(exring[cid].unit[row].ex4dr>>32), (Uint)exring[cid].unit[row].ex4dr,
           exring[cid].unit[row].unit1_arbrk?31:34, exring[cid].unit[row].unit1_arbrk);
@


1.327
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.326 2018/07/29 09:44:25 nakashim Exp nakashim $";
d1216 1
a1216 1
      unit2_exec_next = exring[cid].unit[i].unit1_exec     | (                                                             exring[cid].unit[ i                         ].unit2_exec);
@


1.326
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.325 2018/07/29 09:38:08 nakashim Exp nakashim $";
d189 1
a189 1
#define LMRING_MUX    4
@


1.325
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.324 2018/07/29 05:09:14 nakashim Exp nakashim $";
d376 1
a376 1
  int    bro_ful2, bro_emp2, bro_av;
d379 1
a379 1
  for (i=0, bro_ful2=1, bro_emp2=0, bro_av=0; i<LMRING_MUX; i++) {
a380 1
    bro_emp2 |= (exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2 > 0);
d385 1
a385 2
  /* bro_emp2=0:全lmringが無効 0000 */
  axiif[cid].deq_wait = !bro_ful2/* && bro_emp2*/; /* 有効と無効が混在 */
@


1.324
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.323 2018/07/29 03:02:49 nakashim Exp nakashim $";
d289 5
a519 7
printf("=======bro_ful2=%d bro_av=%d axiif[cid].creg=%d\n", bro_ful2, bro_av, axiif[cid].creg);

  for (i=0; i<LMRING_MUX; i++) {
printf("=%d===lmring_ful2=%d rw=%d sq=%d bro_a=%08.8x bro_av=%d\n", i, 
exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2, bro[i]->rw, bro[i]->sq, bro[i]->a, bro[i]->av);
  }

@


1.323
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.322 2018/07/24 14:08:00 nakashim Exp nakashim $";
d287 2
d293 1
a297 2
    siml_unit_lmm(cid, i);
    siml_unit_stage5(cid, i); /* stage-5 (4DR->BROUT)(LMRING_TR->LMRING_BROUT) */
d519 1
a519 1
       exring[cid].unit[EMAX_DEPTH/LMRING_MUX*(i+1)-1].lmring_ful2, bro[i]->rw, bro[i]->sq, bro[i]->a, bro[i]->av);
d1502 1
d1581 1
a1581 1
  else if (ful2 && !axiif[cid].exring_deq_wait) { /* for next cycle */
d1696 1
a1696 1
      && ful2 && !axiif[cid].exring_deq_wait && exring[cid].unit[i].lmrangew_ok) { /* axi->lmm_write */
d1810 1
a1810 1
      && ful2 && !axiif[cid].exring_deq_wait && exring[cid].unit[i].lmranger_ok) { /* axi->lmm_read */
a2157 4
if ((i+1)%(EMAX_DEPTH/LMRING_MUX)==0) {
printf("==before==%d===== dequeue lmring_ful2=%d bro->sq=%d \n", i, exring[cid].unit[i].lmring_ful2,
    exring[cid].unit[i].lmring_br[exring[cid].unit[i].lmring_b_bot].sq);
}
a2159 4
if ((i+1)%(EMAX_DEPTH/LMRING_MUX)==0) {
printf("==after ==%d===== dequeue lmring_ful2=%d bro->sq=%d \n", i, exring[cid].unit[i].lmring_ful2,
    exring[cid].unit[i].lmring_br[exring[cid].unit[i].lmring_b_bot].sq);
}
@


1.322
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.321 2018/02/16 16:26:03 nakashim Exp nakashim $";
d62 1
d74 1
a74 1
  Ull   deq_wait      : 1; /* AXI->unit[EMAX6_DEPTH-1] */
d136 2
d189 1
d283 9
a291 1
  siml_axiifr(cid, row0, trace);           /* ★★LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */
d305 1
a305 1
  siml_axiifw(cid, row0, trace);           /* ★★LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */
d320 1
a320 1
siml_axiifr(cid, row0, trace) Uint cid, row0, trace;
d369 13
a381 4
  int          bro_ful2 = exring[cid].unit[EMAX_DEPTH-1].lmring_ful2;
  struct lmring_br *bro = &exring[cid].unit[EMAX_DEPTH-1].lmring_br[exring[cid].unit[EMAX_DEPTH-1].lmring_b_bot]; /* AXI<-EMAX側 */

  int j, k, mask;
a401 1
  axiif[cid].deq_wait = 0; /* always 0 */
d514 5
a518 2
  if (bro_ful2 && !bro->av) {
    printf("%03.3d:BRO no unit covers rw=%x ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro->rw, bro->ty, bro->a, bro->a-reg_ctrl.adtr);
d521 5
a525 1
  if (bro_ful2 && bro->rw==1) { /* WRは無条件にdequeue */
d529 1
a529 1
	     cid, axiif[cid].reqn, bro->ty, bro->a, bro->dm);
d545 26
a570 16
  else if (bro_ful2 && bro->rw==0) { /* RDは無条件にdequeue */
      axiif[cid].axi_rdata[0] = bro->d[0];
      axiif[cid].axi_rdata[1] = bro->d[1];
      axiif[cid].axi_rdata[2] = bro->d[2];
      axiif[cid].axi_rdata[3] = bro->d[3];
      axiif[cid].axi_rvalid = 1;
      axiif[cid].reqn--;
      exring[cid].unit[EMAX_DEPTH-1].lmring_ful2--;
      exring[cid].unit[EMAX_DEPTH-1].lmring_b_bot = (exring[cid].unit[EMAX_DEPTH-1].lmring_b_bot + 1)%LMRING_BR_BUF;
      if (trace)
	printf("%03.3d:BRO->AXIIF RD reqn--=%x adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, axiif[cid].reqn, bro->a,
	       (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	       (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	       (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	       (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
d578 1
a578 1
siml_axiifw(cid, row0, trace) Uint cid, row0, trace;
d580 13
a592 1
  int          bri_ful2 = axiif[cid].axring_ful2;
a593 3
  int         deq_waiti = exring[cid].unit[0].deq_wait;/* top deq_wait */

  int j, k, mask;
d717 1
d773 1
a773 1
  if (bri_ful2 && !deq_waiti) { /* dequeued for next cycle */
d1376 50
d1496 4
a1499 4
  struct lmring_br *br = (i==0)?(struct lmring_br*)&axiif[cid].axring_br[axiif[cid].axring_b_bot]
                               :(struct lmring_br*)&exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot];
  int             ful2 = (i==0)?axiif[cid].axring_ful2           /* axi      ful2 */
                               :exring[cid].unit[pi].lmring_ful2;/* previous ful2 */
a1501 2
  Uint  ftag, ltag, fmask, lmask, aximask, ranger_ok, rangew_ok;

a1554 39
  ftag  = (reg_ctrl.addr[i][br->col].top&~(sizeof(Ull)*UNIT_WIDTH-1)); /* & 0xffffffe0 */
  ltag  = (reg_ctrl.addr[i][br->col].bot&~(sizeof(Ull)*UNIT_WIDTH-1)); /* & 0xffffffe0 */
  switch ( (reg_ctrl.addr[i][br->col].top/sizeof(Ull)) & (UNIT_WIDTH-1)) {
  case 0: fmask = 0xf; break;
  case 1: fmask = 0xe; break;
  case 2: fmask = 0xc; break;
  case 3: fmask = 0x8; break;
  }
  switch (~(reg_ctrl.addr[i][br->col].bot/sizeof(Ull)) & (UNIT_WIDTH-1)) {
  case 0: lmask = 0xf; break;
  case 1: lmask = 0x7; break;
  case 2: lmask = 0x3; break;
  case 3: lmask = 0x1; break;
  }
  aximask = ((br->dm & 0xff000000)?8:0) | ((br->dm & 0x00ff0000)?4:0) | ((br->dm & 0x0000ff00)?2:0) | ((br->dm & 0x000000ff)?1:0);
  ranger_ok = (ftag< br->a && br->a< ltag) ? 0xf :
              (ftag==br->a && br->a< ltag) ? (fmask) :
              (ftag< br->a && br->a==ltag) ? (lmask) :
              (ftag==br->a && br->a==ltag) ? (fmask & lmask) : 0;
  rangew_ok = (ftag< br->a && br->a< ltag) ? 0xf :
              (ftag==br->a && br->a< ltag) ? (fmask & aximask) :
              (ftag< br->a && br->a==ltag) ? (lmask & aximask) :
              (ftag==br->a && br->a==ltag) ? (fmask & lmask & aximask) : 0;

  exring[cid].unit[i].lmranger_ok    = (reg_ctrl.conf[i][br->col].cdw2.lmm_axir && br->rw==0 && br->ty==4) ? ranger_ok : 0; /* 4bits */
  exring[cid].unit[i].lmrangew_ok    = (reg_ctrl.conf[i][br->col].cdw2.lmm_axiw && br->rw==1 && br->ty==4) ? rangew_ok : 0; /* 4bits */
  exring[cid].unit[i].lmlddmqw_ok    = br->rw==1 && br->ty==3 && reg_ctrl.conf[i][br->col].cdw1.ea1op == OP_LDDMQ; /* lmwd[0]->tr *//* LDDMQは同一slotに高々1が前提 */
  exring[cid].unit[i].lmea0strq      = reg_ctrl.conf[i][0].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[i][1].cdw1.ea0op == OP_STRQ
                                    || reg_ctrl.conf[i][2].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[i][3].cdw1.ea0op == OP_STRQ; /* op0 */
  exring[cid].unit[i].lmea0strqcol   = reg_ctrl.conf[i][0].cdw1.ea0op == OP_STRQ ? 0 :
                                       reg_ctrl.conf[i][1].cdw1.ea0op == OP_STRQ ? 1 :
				       reg_ctrl.conf[i][2].cdw1.ea0op == OP_STRQ ? 2 : 3;
  exring[cid].unit[i].lmring_ea0bsy  = exring[cid].unit[i].stage4_exec && ((reg_ctrl.conf[i][j].cdw1.ea0op && reg_ctrl.conf[i][j].cdw1.ea0op <= OP_IM_BUFWR)||exring[cid].unit[i].lmea0strq); /* op0 */
  exring[cid].unit[i].lmring_ea1bsy  = exring[cid].unit[i].stage4_exec &&  (reg_ctrl.conf[i][j].cdw1.ea1op && reg_ctrl.conf[i][j].cdw1.ea1op <= OP_IM_BUFRD); /* op1 */
  exring[cid].unit[i].lmring_ful     =(exring[cid].unit[i].lmring_ful2==LMRING_BR_BUF) || (exring[cid].unit[i].lmring_ful1 && exring[cid].unit[i].lmring_ful2==LMRING_BR_BUF-1); /* assign */
  exring[cid].unit[i].deq_wait       = exring[cid].unit[i].lmring_ful                  || (exring[cid].unit[i].lmranger_ok && exring[cid].unit[i].lmring_ea1bsy)
                                                                                       || (exring[cid].unit[i].lmrangew_ok && exring[cid].unit[i].lmring_ea0bsy)
                                                                                       || (exring[cid].unit[i].lmlddmqw_ok && br->col!=j                       );

d1579 1
a1579 1
  else if (ful2 && !exring[cid].unit[i].deq_wait) { /* for next cycle */
d1582 2
a1583 1
    exring[cid].unit[i].lmwm    = br->dm & (((rangew_ok&8)?0xff000000:0) | ((rangew_ok&4)?0x00ff0000:0) | ((rangew_ok&2)?0x0000ff00:0) | ((rangew_ok&1)?0x000000ff:0)); /* wire *//* <- axi */
d1694 1
a1694 1
      && ful2 && !exring[cid].unit[i].deq_wait && exring[cid].unit[i].lmrangew_ok) { /* axi->lmm_write */
d1808 1
a1808 1
      && ful2 && !exring[cid].unit[i].deq_wait && exring[cid].unit[i].lmranger_ok) { /* axi->lmm_read */
d1934 2
a1935 2
  int         deq_wait = (i==EMAX_DEPTH-1)?axiif[cid].deq_wait           /* axi  deq_wait */
                                          :exring[cid].unit[ni].deq_wait;/* next deq_wait */
d2156 4
d2162 4
@


1.321
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.320 2018/02/16 10:48:02 nakashim Exp nakashim $";
d819 1
a819 1
      printf("%03.3d:DMA MEM->LMM WR FIN\n");
@


1.320
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.319 2018/02/13 01:59:50 nakashim Exp nakashim $";
a110 1
    Ull   unit1_arb_prev: 1; /* reg  *//* for siml-loop only */
d1171 1
a1171 1
      unit1_stop_next = exring[cid].unit[i].unit1_arb_prev | (reg_ctrl.conf[i][0].cdw0.v && exring[cid].unit[i].l_row>0 && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_stop);
a1552 1
  Ull   unit1_arb_prev: 1; /* reg  *//* for siml-loop only */
a1584 1
    exring[cid].unit[i].unit1_arb_prev = 0;   /* siml-loop only */
a1608 1
    exring[cid].unit[i].unit1_arb_prev = exring[cid].unit[i].unit1_arbrk;
d1618 2
@


1.319
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.318 2017/12/24 14:13:32 nakashim Exp nakashim $";
d782 1
a782 1
	axiif[cid].mreq         = 0; /* length */
d841 1
a841 1
	axiif[cid].mreq         = 0; /* length */
d867 1
d874 1
a874 1
	  printf("%03.3d:DMA MEM->LMM WR src=%08.8x dst=%08.8x len=%08.8x\n", cid,
d883 1
d890 1
a890 1
	  printf("%03.3d:DMA LMM->MEM src=%08.8x dst=%08.8x len=%08.8x\n", cid,
@


1.318
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.317 2017/12/01 02:44:25 nakashim Exp nakashim $";
d257 1
a257 1
#if 0
a1536 1
/*printf("====== row=%x ====axir=%x axiw=%x br->rw=%x br->ty=%x  a=%08.8x lmranger_ok=%x lmrangew_ok=%x top=%08.8x bot=%08.8x\n", i, reg_ctrl.conf[i][br->col].cdw2.lmm_axir, reg_ctrl.conf[i][br->col].cdw2.lmm_axiw, br->rw, br->ty, br->a, exring[cid].unit[i].lmranger_ok, exring[cid].unit[i].lmrangew_ok, reg_ctrl.addr[i][br->col].top, reg_ctrl.addr[i][br->col].bot);*/
d1656 3
d1765 3
d1934 54
a1987 2
  else if (exring[cid].unit[i].cmd == CMD_NOP && exring[cid].unit[i].lmring_ful1) { /* reg setup by PIO */
    if (exring[cid].unit[i].l_row == row) { /* 自rowに一致 */
a1988 16
      case 0: /* reg/conf */
	if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+0) = tr->d[0];     }
	if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+1) = tr->d[0]>>32; }
	if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+2) = tr->d[1];     }
	if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+3) = tr->d[1]>>32; }
	if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+4) = tr->d[2];     }
	if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+5) = tr->d[2]>>32; }
	if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+6) = tr->d[3];     }
	if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&reg_ctrl.conf[i]+ofs)+7) = tr->d[3]>>32; }
	break;
      case 1: /* reg/breg */
	if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+0) = tr->d[0]; *((Ull *)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+0) = tr->d[0]; }
	if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+1) = tr->d[1]; *((Ull *)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+1) = tr->d[1]; }
	if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+2) = tr->d[2]; *((Ull *)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+2) = tr->d[2]; }
	if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&exring[cid].unit[i].b[0]+ofs)+3) = tr->d[3]; *((Ull *)((Uchar*)&exring[cid].unit[i].b[1]+ofs)+3) = tr->d[3]; }
	break;
a2006 10
  }
  else if (exring[cid].unit[i].cmd == CMD_SCON) {
    if (exring[cid].unit[i].unit1_exec && !(exring[cid].unit[i].scon_count & 1)) {
      exring[cid].unit[i].b[0][j].r[0] = *((Ull*)(&reg_ctrl.conf[i][j])+0);
      exring[cid].unit[i].b[0][j].r[1] = *((Ull*)(&reg_ctrl.conf[i][j])+1);
      exring[cid].unit[i].b[0][j].r[2] = *((Ull*)(&reg_ctrl.conf[i][j])+2);
      exring[cid].unit[i].b[0][j].r[3] = *((Ull*)(&reg_ctrl.conf[i][j])+3);
    }
  }
  else if (exring[cid].unit[i].cmd == CMD_EXEC) {
@


1.317
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.316 2017/12/01 02:10:58 nakashim Exp nakashim $";
d139 2
a140 1
    Ull   lmea0strq     : 1; /* wire *//* ea0.strq存在★★★4サイクルに分けて実行 */
d1056 2
a1057 1
  int k;
d1146 7
a1152 3
      sb = reg_ctrl.conf[i][j].cdw1.ea0bs; exring[cid].unit[i].ea0b  = (!(sb&1)||!exring[cid].unit[i].one_shot)?((sb&2)?exring[cid].unit[i].eab:reg_ctrl.addr[i][j].ea0b) : exring[cid].unit[i].ea04dr_prev;
      so = reg_ctrl.conf[i][j].cdw1.ea0os; exring[cid].unit[i].ea0o  = (!(sb&1)|| exring[cid].unit[i].one_shot)?((so&1)?exring[cid].unit[i].eao:reg_ctrl.addr[i][j].ea0o) : 0LL;

d1397 1
d1411 2
a1412 1
  Ull   lmea0strq     : 1; /* wire *//* ea0.strq存在★★★4サイクルに分けて実行 */
d1488 3
d1627 1
d1658 3
a1660 2
    else if (exring[cid].unit[i].lmring_ea0bsy) { /* EXEC & ea0d->lmm_write/read */
      switch (reg_ctrl.conf[i][j].cdw2.lmm_mode) {
d1666 1
a1666 1
      exring[cid].unit[i].ea04dr      = ((j & exring[cid].unit[i].ea04_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea03dr & exring[cid].unit[i].ea04_lmask);
d1668 1
a1668 1
      exring[cid].unit[i].lmm.rw0     = (reg_ctrl.conf[i][j].cdw1.ea0op & 0x10)!=0; /* read/write */
d1673 5
a1677 5
      exring[cid].unit[i].mwmux[0] = reg_ctrl.conf[i][j].cdw2.mws0==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[0];
      exring[cid].unit[i].mwmux[1] = reg_ctrl.conf[i][j].cdw2.mws1==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[1];
      exring[cid].unit[i].mwmux[2] = reg_ctrl.conf[i][j].cdw2.mws2==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[2];
      exring[cid].unit[i].mwmux[3] = reg_ctrl.conf[i][j].cdw2.mws3==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[3];
      switch (reg_ctrl.conf[i][j].cdw1.ea0op) {
d1679 13
a1691 13
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfffffff0) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x0000000f : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff0f) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&2)) ? 0x000000f0 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfffff0ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000f00 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff0fff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&2)) ? 0x0000f000 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfff0ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x000f0000 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff0fffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&2)) ? 0x00f00000 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xf0ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x0f000000 : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x0fffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&2)) ? 0xf0000000 : 0x00000000);
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]; /* align不要 */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]; /* align不要 */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]; /* align不要 */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]; /* align不要 */
        break;
d1693 9
a1701 9
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x0000000f<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000f00<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x000f0000<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x0f000000<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
        break;
d1703 9
a1711 9
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000003<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000300<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00030000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x03000000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
        break;
d1713 9
a1721 9
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000001<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000100<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00010000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
        exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x01000000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
        break;
d1724 6
a1729 6
        exring[cid].unit[i].lmm.mm0    = 0xffffffff;         /* mask *//* ★★★暫定記述★★★ */
        exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]; /* ★★★暫定記述★★★ */
        exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]; /* ★★★暫定記述★★★ */
        exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]; /* ★★★暫定記述★★★ */
        exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]; /* ★★★暫定記述★★★ */
        break;
d1731 8
a1738 7
      default:      /* OP_STRQ in neighbor slot */
        if (exring[cid].unit[i].lmea0strq) {
          /* ★★★STRQはSTRを4サイクル分割実行★★★ */
          exring[cid].unit[i].lmm.mm0 = 0x000000ff << j;
          exring[cid].unit[i].lmm.mw0[j] = exring[cid].unit[i].mwmux[j]; /* align不要 */
        }
        break;
d2380 1
a2380 1
    printf("                                                                                                                            rk-wk-dk-s4-e1b-e0b-ful-dqw-fl1=%01.1x-%01.1x-%d-%d-%d-%d-%d-%d-%d\n",
d2385 1
d2457 1
a2457 2
             ||(reg_ctrl.conf[row][col].cdw1.ea1op && reg_ctrl.conf[row][col].cdw1.ea1op < OP_IM_BUFRD)
             ||(reg_ctrl.conf[row][0].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[row][1].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[row][2].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[row][3].cdw1.ea0op == OP_STRQ)) {
@


1.316
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.315 2017/11/28 07:53:57 nakashim Exp nakashim $";
d2133 1
a2133 1
#if 1
d2145 1
a2145 1
#if 1
d2159 1
a2159 1
#if 1
@


1.315
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.314 2017/09/13 14:33:19 nakashim Exp nakashim $";
d136 2
a137 2
    Ull   lmranger_ok   : 1; /* wire *//* lmring要求がread &ty==4&adr[col]<>lmm_range内 */
    Ull   lmrangew_ok   : 1; /* wire *//* lmring要求がwrite&ty==4&adr[col]<>lmm_range内 */
d154 1
a154 1
      Ull   pass        : 1; /* 0:hit, 1:pass */
d710 4
d1397 1
a1397 1
  Uint  ftag, ltag, fmask, lmask, aximask, rangeok;
d1401 2
a1402 2
  Ull   lmranger_ok   : 1; /* wire *//* lmring要求がread &ty==4&adr[col]<>lmm_range内 */
  Ull   lmrangew_ok   : 1; /* wire *//* lmring要求がwrite&ty==4&adr[col]<>lmm_range内 */
d1419 1
a1419 1
    Ull   pass        : 1; /* 0:hit, 1:pass */
d1451 23
a1473 6
  ftag  = (reg_ctrl.addr[i][br->col].top&~(sizeof(Ull)*UNIT_WIDTH-1));
  ltag  = (reg_ctrl.addr[i][br->col].bot&~(sizeof(Ull)*UNIT_WIDTH-1));
  fmask = 0xf << ( (reg_ctrl.addr[i][br->col].top/sizeof(Ull)) & (UNIT_WIDTH-1));
  lmask = 0xf >> (~(reg_ctrl.addr[i][br->col].bot/sizeof(Ull)) & (UNIT_WIDTH-1));
  aximask = ((br->dm>>21)&8) | ((br->dm>>14)&4) | ((br->dm>>7)&2) | ((br->dm>>0)&1);
  rangeok = (ftag<br->a || (ftag==br->a && (fmask & aximask))) && (ltag>br->a || (ltag==br->a && (lmask & aximask)));
d1475 2
a1476 2
  exring[cid].unit[i].lmranger_ok    = reg_ctrl.conf[i][br->col].cdw2.lmm_axir && br->rw==0 && br->ty==4 && rangeok;
  exring[cid].unit[i].lmrangew_ok    = reg_ctrl.conf[i][br->col].cdw2.lmm_axiw && br->rw==1 && br->ty==4 && rangeok;
d1509 1
a1509 1
    tr->pass = 0;
d1514 1
a1514 1
    exring[cid].unit[i].lmwm    = br->dm;   /* wire *//* <- axi   */
d1525 1
a1525 1
    tr->av   = br->av | exring[cid].unit[i].lmranger_ok | exring[cid].unit[i].lmrangew_ok;
d1533 1
a1533 1
    tr->pass = br->ty<4 || !exring[cid].unit[i].lmranger_ok; /* reg or read (VADDR/LDDMQ/TRANS) in range */
d2046 4
a2049 14

      if (tr->pass) {
        br->d[0] = tr->d[0]; /* next cycle */
        br->d[1] = tr->d[1]; /* next cycle */
        br->d[2] = tr->d[2]; /* next cycle */
        br->d[3] = tr->d[3]; /* next cycle */
      }
      else {
        br->d[0] = exring[cid].unit[i].lmrd[0]; /* next cycle */
        br->d[1] = exring[cid].unit[i].lmrd[1]; /* next cycle */
        br->d[2] = exring[cid].unit[i].lmrd[2]; /* next cycle */
        br->d[3] = exring[cid].unit[i].lmrd[3]; /* next cycle */
      }

d2133 1
a2133 1
#if 0
d2145 3
a2147 3
#if 0
      printf("%03.3d.%02.2d:LMM WR0 a=%08.8x d=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	     cid, i, a0al, 
d2159 1
a2159 1
#if 0
d2366 1
a2366 1
    printf("                                                                                                                            rk-wk-dk-s4-e1b-e0b-ful-dqw-fl1=%d-%d-%d-%d-%d-%d-%d-%d-%d\n",
d2401 1
a2401 1
    printf(" LTR.rw-t-c-s-p-v-a-m-d=%x-%x-%x-%04.4x-%x-%x-%08.8x-%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d2406 1
a2406 1
           exring[cid].unit[row].lmring_tr.pass,
@


1.314
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.313 2017/09/11 15:40:41 nakashim Exp nakashim $";
d1393 2
d1440 16
a1455 2
  exring[cid].unit[i].lmranger_ok    = reg_ctrl.conf[i][br->col].cdw2.lmm_axir && br->rw==0 && br->ty==4 && (reg_ctrl.addr[i][br->col].top&~(sizeof(Ull)*UNIT_WIDTH-1))<=br->a && br->a<=(reg_ctrl.addr[i][br->col].bot|(sizeof(Ull)*UNIT_WIDTH-1)); /* assign */
  exring[cid].unit[i].lmrangew_ok    = reg_ctrl.conf[i][br->col].cdw2.lmm_axiw && br->rw==1 && br->ty==4 && (reg_ctrl.addr[i][br->col].top&~(sizeof(Ull)*UNIT_WIDTH-1))<=br->a && br->a<=(reg_ctrl.addr[i][br->col].bot|(sizeof(Ull)*UNIT_WIDTH-1)); /* assign */
d2122 8
d2134 8
d2148 8
@


1.313
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.312 2017/09/11 09:16:03 nakashim Exp $";
d257 1
a257 1
  if (cycle % ARM_EMAX6_RATIO) /* ARM:2.4GHz EMAX6:1.2GHz */
@


1.312
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.311 2017/09/11 00:01:18 nakashim Exp nakashim $";
d9 1
a9 1
/* emax6.c 2012/9/22 */
@


1.311
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.310 2017/09/10 14:58:51 nakashim Exp nakashim $";
d392 18
@


1.310
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.309 2017/09/10 12:23:41 nakashim Exp nakashim $";
d608 1
a608 1
      bri->a    = a + ((bri->ty==4)?reg_ctrl.adtr:0) + axiif[cid].sreq*sizeof(Ull);
d691 1
a691 1
      bri->a    = a + ((bri->ty==4)?reg_ctrl.adtr:0) + axiif[cid].sreq*sizeof(Ull);
d1809 1
a1809 1
  Ull a0, a1, a0al, a1al, d;
d2019 2
a2020 1
  Ull a0al, a1al, mm0[UNIT_WIDTH];
@


1.309
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.308 2017/09/10 10:33:25 nakashim Exp nakashim $";
d384 12
a395 2
    printf("%03.3d:DMA LMM->MEM RD final \n", cid);
    if (0) {
d818 1
d958 1
@


1.308
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.307 2017/09/10 08:17:55 nakashim Exp nakashim $";
d385 1
a385 1
    if (1) {
d393 1
a393 1
  if (c[cid].iorq.v_stat == ((3<<2)|1) && axiif[cid].radr_sent && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
a402 1
      axiif[cid].radr_sent = 0;
d931 1
a931 1
  if (c[cid].iorq.v_stat == ((3<<2)|1) && !axiif[cid].radr_sent && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
a933 1
      axiif[cid].radr_sent = 1;
d936 13
a948 11
      if (!axiif[cid].axi_arvalid) {
	axiif[cid].axi_araddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1); /* 全dword読み出し */
	axiif[cid].axi_arlen    = 0;
	axiif[cid].axi_arvalid  = 1; /* on */
	if (trace)
	  printf("%03.3d:IORQ->AXIIF AR opcd=%x adr=%08.8x\n",
		 cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_araddr);
      }
      else if (axiif[cid].axi_arready) { /* adr完了 */
	axiif[cid].radr_sent    = 1;
	axiif[cid].axi_arvalid  = 0; /* off */
@


1.307
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.306 2017/09/10 00:12:07 nakashim Exp nakashim $";
d745 1
a745 1
	printf("%03.3d:DMA MEM->LMM WR active ddradr=%08.8x lmmadr=%08.8x len=%04.4x\n",
d804 1
a804 1
	printf("%03.3d:DMA LMM->MEM RD active lmmadr=%08.8x ddradr=%08.8x len=%04.4x\n",
@


1.306
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.305 2017/09/09 12:11:26 nakashim Exp nakashim $";
d40 2
a41 1
  Ull   adr_sent           : 1; /* 0:none, 1:sent for write */
d329 1
a329 1
  /* iorq.v_stat      : 4; v 0:empty 1:reserve 3:inuse | stat 0:empty 1:busy 2:axi 3:RD-ok */
d389 1
a389 1
      axiif[cid].adr_sent   = 0; /* reset */
d393 1
a393 1
  if (c[cid].iorq.v_stat == ((3<<2)|2) && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
d403 1
d435 1
d705 1
a705 1
  /* iorq.v_stat : 4 *1101===X=0000==========X========1101===========================X=1110
d729 2
a730 1
    axiif[cid].adr_sent   = 0;
d740 1
a740 1
    if (!axiif[cid].adr_sent) {
d749 1
a749 1
	axiif[cid].adr_sent     = 1; /* fin */
d792 1
a792 1
      axiif[cid].adr_sent   = 0; /* reset */
d799 1
a799 1
    if (!axiif[cid].adr_sent) {
d808 1
a808 1
	axiif[cid].adr_sent     = 1; /* fin */
d861 1
a861 1
      if (!axiif[cid].adr_sent) {
d871 1
a871 1
	  axiif[cid].adr_sent     = 1; /* fin */
d925 1
a925 1
        axiif[cid].adr_sent     = 0; /* reset */
d932 1
a932 1
  if (c[cid].iorq.v_stat == ((3<<2)|1) && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
d935 1
a935 1
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|2; /* axi */
d947 1
a947 1
	c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|2; /* axi */
@


1.305
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.304 2017/09/09 11:55:41 nakashim Exp nakashim $";
d383 7
a389 1
    printf("%03.3d:DMA LMM->MEM RD active\n", cid);
d742 1
a742 1
	       cid, axiif[cid].dadr, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_awlen);
d795 13
a807 1
    printf("%03.3d:DMA LMM->MEM RD active\n", cid);
@


1.304
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.303 2017/09/09 11:50:41 nakashim Exp nakashim $";
d763 1
a763 1
	axiif[cid].axi_wlast    = 1; /* on */
d765 1
a765 1
	axiif[cid].axi_wlast    = 0; /* off */
d839 14
a852 7
      if (!axiif[cid].axi_awvalid) {
        axiif[cid].axi_awaddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1);
        axiif[cid].axi_awlen    = 0;
        axiif[cid].axi_awvalid  = 1; /* on */
        if (trace)
          printf("%03.3d:IORQ->AXIIF WR opcd=%x adr=%08.8x\n",
                 cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_awaddr);
d854 1
a854 5
      else if (axiif[cid].axi_awready) { /* adr完了 */
        axiif[cid].adr_sent     = 1; /* fin */
        axiif[cid].axi_awvalid  = 0; /* off */
      }
      if (!axiif[cid].axi_wvalid) {
d886 4
a889 1
        axiif[cid].axi_wlast    = 1; /* on */
d897 3
d901 1
a901 1
      else if (axiif[cid].axi_wready) { /* data完了 */
@


1.303
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.302 2017/09/09 03:11:04 nakashim Exp nakashim $";
d554 1
d580 1
a580 1
    else if (axiif[cid].sreq <= axiif[cid].axi_awlen) { /* 0-3:conf/breg/addr/lddm, 4:lmm (burst 256bit_AXI_write -> 256bit_LMM (256bit*256count = 8KB)) */
d630 1
d651 1
d663 1
a663 1
    else if (axiif[cid].sreq <= axiif[cid].axi_arlen) { /* (burst 256bit_LMM -> 256bit_AXI_read (256bit*256count = 8KB)) */
d2082 1
a2082 1
  printf(" reqn=%04.4x srw=%x sadr=%08.8x sreq=%04.4x ful2-top-bot=%d-%d-%d",
d2086 1
@


1.302
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.301 2017/09/08 14:25:18 nakashim Exp nakashim $";
d451 1
a451 1
  /* axiif_slen                 -----<=0=====>---                       -----<=0=====>---
d475 2
a476 2
      printf("%03.3d:REG->AXIIF RD reqn--=%x adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	     cid, axiif[cid].reqn, axiif[cid].sadr,
d534 1
a534 1
  /* axiif_slen           *     -----<=0=====>---                       -----<=0=====>---
d554 1
a554 1
    axiif[cid].slen = 0;
d579 1
a579 1
    else if (axiif[cid].slen <= axiif[cid].axi_awlen) { /* 0-3:conf/breg/addr/lddm, 4:lmm (burst 256bit_AXI_write -> 256bit_LMM (256bit*256count = 8KB)) */
d587 1
a587 1
      bri->sq   = axiif[cid].slen; /* from 0 to axiif[cid].axi_awlen */
d589 1
a589 1
      bri->a    = a + ((bri->ty==4)?reg_ctrl.adtr:0) + axiif[cid].slen*sizeof(Ull);
d596 1
a596 1
      axiif[cid].slen++;
d629 1
a629 1
      axiif[cid].slen           = 0;
d649 3
a651 3
    axiif[cid].slen = 0;
  /*}*/
  /*  else if (axiif[cid].adr_recv) { */
d655 1
d658 1
a658 1
	printf("%03.3d:AXIIF->REG AR reqn++=%x adr=%08.8x\n", cid, axiif[cid].reqn, a);
d660 1
a660 1
    else if (axiif[cid].slen <= axiif[cid].axi_arlen) { /* (burst 256bit_LMM -> 256bit_AXI_read (256bit*256count = 8KB)) */
d668 1
a668 1
      bri->sq   = axiif[cid].slen; /* from axiif[cid].axi_awlen to 0 */
d670 1
a670 1
      bri->a    = a + ((bri->ty==4)?reg_ctrl.adtr:0) + axiif[cid].slen*sizeof(Ull);
d672 1
a672 1
      axiif[cid].slen++;
d2079 1
a2079 1
  printf(" reqn=%04.4x srw=%x sadr=%08.8x slen=%04.4x ful2-top-bot=%d-%d-%d",
d2083 1
a2083 1
	 axiif[cid].slen,
@


1.301
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.300 2017/09/08 08:06:57 nakashim Exp nakashim $";
d42 3
a44 3
  Ull   ladr               :31; /* lmm-adr (internal) */
  Ull   nlen               :16; /* len (internal) */
  Ull   nreq               :16; /* counter (internal) */
d52 4
a55 3
  Ull   irw                : 1; /* 0:read, 1:write */
  Ull   iadr               :31; /* adr (internal) */
  Ull   ilen               :16; /* len (internal) */
d449 3
a451 3
  /* axiif_irw                  -----<=1=====>---                       -----<=0=====>---
  /* axiif_iadr                 -----<=A=====>---                       -----<=A=====>---
  /* axiif_ilen                 -----<=0=====>---                       -----<=0=====>---
d471 1
a471 1
      axiif[cid].axi_rdata[k] = *((Ull*)((Uchar*)&reg_ctrl+(axiif[cid].iadr-REG_BASE2_PHYS))+k);
d476 1
a476 1
	     cid, axiif[cid].reqn, axiif[cid].iadr,
d532 3
a534 3
  /* axiif_irw            *     -----<=1=====>---                       -----<=0=====>---
  /* axiif_iadr           *     -----<=A=====>---                       -----<=A=====>---
  /* axiif_ilen           *     -----<=0=====>---                       -----<=0=====>---
d540 2
a541 2
  /* bri.av    :  1       *     iadr <=0=====>---                       iadr <=0=====>---
  /* bri.a     : 31       *     iadr <=A=====>---                       iadr <=A=====>---
d552 3
a554 3
    axiif[cid].irw  = 1; /* write */
    axiif[cid].iadr = axiif[cid].axi_awaddr;
    axiif[cid].ilen = 0;
d561 1
a561 1
      a = axiif[cid].iadr;
d579 1
a579 1
    else if (axiif[cid].ilen <= axiif[cid].axi_awlen) { /* 0-3:conf/breg/addr/lddm, 4:lmm (burst 256bit_AXI_write -> 256bit_LMM (256bit*256count = 8KB)) */
d587 1
a587 1
      bri->sq   = axiif[cid].ilen; /* from 0 to axiif[cid].axi_awlen */
d589 1
a589 1
      bri->a    = a + ((bri->ty==4)?reg_ctrl.adtr:0) + axiif[cid].ilen*sizeof(Ull);
d596 1
a596 1
      axiif[cid].ilen++;
d627 3
a629 3
      axiif[cid].irw            = 0;
      axiif[cid].iadr           = 0;
      axiif[cid].ilen           = 0;
d647 3
a649 3
    axiif[cid].irw  = 0; /* read */
    axiif[cid].iadr = axiif[cid].axi_araddr;
    axiif[cid].ilen = 0;
d653 1
a653 1
    a = axiif[cid].iadr;
d659 1
a659 1
    else if (axiif[cid].ilen <= axiif[cid].axi_arlen) { /* (burst 256bit_LMM -> 256bit_AXI_read (256bit*256count = 8KB)) */
d667 1
a667 1
      bri->sq   = axiif[cid].ilen; /* from axiif[cid].axi_awlen to 0 */
d669 1
a669 1
      bri->a    = a + ((bri->ty==4)?reg_ctrl.adtr:0) + axiif[cid].ilen*sizeof(Ull);
d671 1
a671 1
      axiif[cid].ilen++;
d718 3
a720 3
    axiif[cid].ladr       = 0;
    axiif[cid].nlen       = 0;
    axiif[cid].nreq       = 0;
d728 2
a729 2
	axiif[cid].axi_awaddr   = axiif[cid].ladr;
	axiif[cid].axi_awlen    = axiif[cid].nlen;
d736 1
a736 1
	axiif[cid].nreq         = 0; /* length */
d740 2
a741 2
    else if (axiif[cid].nreq <= axiif[cid].nlen) { /* write active */
      if (axiif[cid].nreq == 0)
d746 1
a746 1
      else if (axiif[cid].nreq == axiif[cid].nlen)
d758 1
a758 1
      if (axiif[cid].nreq == axiif[cid].nlen)
d770 1
a770 1
	axiif[cid].nreq++;
d805 2
a806 2
	  axiif[cid].ladr     = dma_ctrl.ZDMA_CH_DST_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* lmm addr */
	  axiif[cid].nlen     = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1)/UNIT_WIDTH)
d810 1
a810 1
	  if (axiif[cid].nlen==0) {
d815 1
a815 1
		 axiif[cid].dadr, axiif[cid].ladr, axiif[cid].nlen);
d820 2
a821 2
	  axiif[cid].ladr     = dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* lmm addr */
	  axiif[cid].nlen     = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1)/UNIT_WIDTH)
d825 1
a825 1
	  if (axiif[cid].nlen==0) {
d830 1
a830 1
		 axiif[cid].ladr, axiif[cid].dadr, axiif[cid].nlen);
d2078 1
a2078 1
  printf(" reqn=%04.4x irw=%x iadr=%08.8x ilen=%04.4x ful2-top-bot=%d-%d-%d",
d2080 3
a2082 3
	 axiif[cid].irw,
	 axiif[cid].iadr,
	 axiif[cid].ilen,
@


1.300
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.299 2017/09/08 07:43:13 nakashim Exp nakashim $";
d622 1
a622 1
    if ((exring[cid].cycle & 3) == 3 && reg_ctrl.cmd == CMD_RESET) {
d632 2
d649 2
a650 2
  }
  else if (axiif[cid].adr_recv) {
d834 11
a844 14
      if (!axiif[cid].adr_sent) {
	if (!axiif[cid].axi_awvalid) {
	  axiif[cid].axi_awaddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1);
	  axiif[cid].axi_awlen    = 0;
	  axiif[cid].axi_awvalid  = 1; /* on */
	  if (trace)
	    printf("%03.3d:IORQ->AXIIF WR opcd=%x adr=%08.8x\n",
		   cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_awaddr);
	}
	else if (axiif[cid].axi_awready) { /* adr完了 */
	  axiif[cid].adr_sent     = 1; /* fin */
	  axiif[cid].nreq         = 0; /* length */
	  axiif[cid].axi_awvalid  = 0; /* off */
	}
d846 4
a849 4
      else if (axiif[cid].nreq <= 0) { /* write active */
	switch (c[cid].iorq.opcd) { /* 2:LD/STRW 3:LD/STR 12:VLD/VSTRQ */
	case 2: /* 32bit */
	  axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x0000000f<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
d853 7
a859 7
	  axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
	  axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
	  axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
	  axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
	  break;
	case 3: /* 64bit */
	  axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x000000ff : 0x00000000)
d863 7
a869 7
	  axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0];
	  axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[0];
	  axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0];
	  axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[0];
	  break;
	case 12: /* 128bit */
	  axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x0000ffff : 0x00000000)
d871 21
a891 28
	  axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0];
	  axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[1];
	  axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0];
	  axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[1];
	  break;
	}
	axiif[cid].axi_wvalid   = 1; /* on */
	if (axiif[cid].nreq == 0)
	  axiif[cid].axi_wlast    = 1; /* on */
	else
	  axiif[cid].axi_wlast    = 0; /* off */
	if (trace)
	  printf("%03.3d:IORQ->AXIIF WR wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
		 cid, axiif[cid].axi_wstrb,
		 (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
		 (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
		 (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
		 (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
	if (axiif[cid].axi_wready) { /* prepare next write */
	  axiif[cid].dadr+=sizeof(Ull)*UNIT_WIDTH;
	  axiif[cid].nreq++;
	}
      }
      else { /* data完了 */
	c[cid].iorq.v_stat      = 0; /* immediately finished */
	axiif[cid].adr_sent     = 0; /* reset */
	axiif[cid].axi_wvalid   = 0; /* off */
	axiif[cid].axi_wlast    = 0; /* off */
@


1.299
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.298 2017/09/08 03:49:33 nakashim Exp nakashim $";
d458 1
a458 1
    printf("%03.3d:BRO no unit covers ty=%x adr=%08.8x(%08.8x) (maybe out-of-order/speculative load)\n", cid, bro->ty, bro->a, bro->a-reg_ctrl.adtr);
d733 1
d737 13
a749 13
    if (axiif[cid].nreq == 0)
      axiif[cid].axi_wstrb = ((axiif[cid].fmask&8)?0xff000000:0)
                           | ((axiif[cid].fmask&4)?0x00ff0000:0)
                           | ((axiif[cid].fmask&2)?0x0000ff00:0)
                           | ((axiif[cid].fmask&1)?0x000000ff:0);
    else if (axiif[cid].nreq == axiif[cid].nlen)
      axiif[cid].axi_wstrb = ((axiif[cid].lmask&8)?0xff000000:0)
                           | ((axiif[cid].lmask&4)?0x00ff0000:0)
                           | ((axiif[cid].lmask&2)?0x0000ff00:0)
                           | ((axiif[cid].lmask&1)?0x000000ff:0);
    else
      axiif[cid].axi_wstrb = 0xffffffff;
    if (axiif[cid].nreq <= axiif[cid].nlen) { /* write active */
a804 1
	  axiif[cid].nreq     = 0; /* length */
a819 1
	  axiif[cid].nreq     = 0; /* length */
d832 14
a845 7
      if (!axiif[cid].axi_awvalid) {
	axiif[cid].axi_awaddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1);
	axiif[cid].axi_awlen    = 0;
	axiif[cid].axi_awvalid  = 1; /* on */
	if (trace)
	  printf("%03.3d:IORQ->AXIIF WR opcd=%x adr=%08.8x\n",
		 cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_awaddr);
d847 1
a847 5
      else if (axiif[cid].axi_awready) { /* adr完了 */
	axiif[cid].adr_sent     = 1; /* fin */
	axiif[cid].axi_awvalid  = 0; /* off */
      }
      if (!axiif[cid].axi_wvalid) {
d879 4
a882 1
	axiif[cid].axi_wlast    = 1; /* on */
d890 4
d895 1
a895 1
      else if (axiif[cid].axi_wready) { /* data完了 */
@


1.298
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.297 2017/09/07 14:51:30 nakashim Exp nakashim $";
d40 1
a40 1
  Ull   adr_sent           : 1; /* 0:none, 1:sent */
d49 1
d381 4
d623 1
d643 1
d647 2
d650 1
a650 1
    a = axiif[cid].axi_araddr;
d675 1
@


1.297
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.296 2017/09/07 04:18:46 nakashim Exp nakashim $";
d40 7
a46 2
  Ull   dadr               :31; /* adr (internal) */
  Ull   dlen               :16; /* len (internal) */
d703 1
d705 67
a771 1
    axiif[cid].dlen       = 0;
d791 12
a802 4
	  axiif[cid].dlen     = 0; /* length */
	  printf("%03.3d:DMA MEM->LMM src=%08.8x dst=%08.8x len=%08.8x\n", cid,
		 dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0, dma_ctrl.ZDMA_CH_DST_DSCR_WORD0,
		 dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2);
d807 10
a816 1
	  axiif[cid].dlen     = 0; /* length */
d818 1
a818 2
		 dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0, dma_ctrl.ZDMA_CH_DST_DSCR_WORD0,
		 dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2);
d832 1
d878 1
a883 40
  if (axiif[cid].dma_stat == 3) { /* DMA WR active */
    if (!axiif[cid].axi_awvalid) {
      axiif[cid].axi_awaddr   = dma_ctrl.ZDMA_CH_DST_DSCR_WORD0 & ~(sizeof(Ull)*UNIT_WIDTH-1);
      axiif[cid].axi_awlen    = ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)+dma_ctrl.ZDMA_CH_SRC_DSCR_WORD2/sizeof(Ull)-1)/UNIT_WIDTH)
	                      - ((dma_ctrl.ZDMA_CH_SRC_DSCR_WORD0/sizeof(Ull)                                              )/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
      axiif[cid].axi_awvalid  = 1; /* on */
      printf("%03.3d:DMA MEM->LMM WR active ddradr=%08.8x lmmadr=%08.8x len=%04.4x\n",
	     cid, axiif[cid].dadr, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_awlen);
    }
    else if (axiif[cid].axi_awready) { /* adr完了 */
      axiif[cid].axi_awvalid  = 0; /* off */
    }
    if (!axiif[cid].axi_wvalid) {
      if (axiif[cid].dlen < axiif[cid].axi_awlen) {
	axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x000000ff : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 8 ? 0x0000ff00 : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==16 ? 0x00ff0000 : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==24 ? 0xff000000 : 0x00000000);
	axiif[cid].axi_wdata[0] = mmr(axiif[cid].dadr                );
	axiif[cid].axi_wdata[1] = mmr(axiif[cid].dadr|(sizeof(Ull)*1));
	axiif[cid].axi_wdata[2] = mmr(axiif[cid].dadr|(sizeof(Ull)*2));
	axiif[cid].axi_wdata[3] = mmr(axiif[cid].dadr|(sizeof(Ull)*3));
	axiif[cid].dlen++;
      }
      axiif[cid].axi_wvalid   = 1; /* on */
      axiif[cid].axi_wlast    = 1; /* on */
      if (trace)
	printf("%03.3d:DMA MEM->LMM WR wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, axiif[cid].axi_wstrb,
	       (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
	       (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
	       (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
	       (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
    }
    else if (axiif[cid].axi_wready) { /* data完了 */
      c[cid].iorq.v_stat      = 0; /* immediately finished */
      axiif[cid].axi_wvalid   = 0; /* off */
      axiif[cid].axi_wlast    = 0; /* off */
    }
  }
a904 3
  if (axiif[cid].dma_stat == 2) { /* DMA RD active */
    printf("%03.3d:DMA LMM->MEM RD active\n", cid);
  }
@


1.296
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.295 2017/09/06 09:45:43 nakashim Exp nakashim $";
d38 1
a38 1
  /* work for axi-emax bridge */
d40 4
d543 1
a543 1
    axiif[cid].ilen = axiif[cid].axi_awlen;
d612 1
a612 2
    if (reg_ctrl.cmd == CMD_RESET) {
      axiif[cid].dma_stat       = 0;
a620 2
    }
    if ((exring[cid].cycle & 3) == 3) {
d634 1
a634 1
    axiif[cid].ilen = axiif[cid].axi_arlen;
d696 6
d718 2
d724 1
a724 1
	else {
d726 2
d795 38
a832 1
    printf("%03.3d:DMA MEM->LMM WR active\n", cid);
@


1.295
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.294 2017/09/05 12:11:25 nakashim Exp nakashim $";
d39 1
d609 1
d707 15
d723 1
a723 1
    else {
d783 3
d792 1
a792 1
    else {
d807 3
@


1.294
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.293 2017/09/03 11:47:06 nakashim Exp nakashim $";
d538 1
a538 1
    axiif[cid].ilen = 0;
d631 1
a631 1
    axiif[cid].ilen = 0;
@


1.293
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.292 2017/09/03 05:57:14 nakashim Exp nakashim $";
d706 57
a762 33
    else if (!axiif[cid].axi_awvalid && !axiif[cid].axi_wvalid) {
      axiif[cid].axi_awaddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1);
      axiif[cid].axi_awlen    = 0;
      axiif[cid].axi_awvalid  = 1; /* on */
      switch (c[cid].iorq.opcd) { /* 2:LD/STRW 3:LD/STR 12:VLD/VSTRQ */
      case 2: /* 32bit */
	axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x0000000f<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 8 ? 0x00000f00<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==16 ? 0x000f0000<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==24 ? 0x0f000000<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000);
	axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
	axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
	axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
	axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[0]<<(c[cid].iorq.ADR & sizeof(int))*8;
	break;
      case 3: /* 64bit */
	axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x000000ff : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 8 ? 0x0000ff00 : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==16 ? 0x00ff0000 : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==24 ? 0xff000000 : 0x00000000);
	axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0];
	axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[0];
	axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0];
	axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[0];
	break;
      case 12: /* 128bit */
	axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))== 0 ? 0x0000ffff : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull)))==16 ? 0xffff0000 : 0x00000000);
	axiif[cid].axi_wdata[0] = c[cid].iorq.BUF[0];
	axiif[cid].axi_wdata[1] = c[cid].iorq.BUF[1];
	axiif[cid].axi_wdata[2] = c[cid].iorq.BUF[0];
	axiif[cid].axi_wdata[3] = c[cid].iorq.BUF[1];
	break;
a763 15
      axiif[cid].axi_wvalid   = 1; /* on */
      axiif[cid].axi_wlast    = 1; /* on */
      if (trace)
	printf("%03.3d:IORQ->AXIIF WR opcd=%x adr=%08.8x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, c[cid].iorq.opcd, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb,
	       (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
	       (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
	       (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
	       (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
    }
    else if (axiif[cid].axi_awready && axiif[cid].axi_wready) { /* adr/data完了 */
      c[cid].iorq.v_stat      = 0; /* immediately finished */
      axiif[cid].axi_awvalid  = 0; /* off */
      axiif[cid].axi_wvalid   = 0; /* off */
      axiif[cid].axi_wlast    = 0; /* off */
d772 13
a784 10
    else if (!axiif[cid].axi_arvalid) {
      axiif[cid].axi_araddr   = c[cid].iorq.ADR & ~(sizeof(Ull)*UNIT_WIDTH-1); /* 全dword読み出し */
      axiif[cid].axi_arlen    = 0;
      axiif[cid].axi_arvalid  = 1; /* on */
      if (trace)
	printf("%03.3d:IORQ->AXIIF AR adr=%08.8x\n", cid, (Uint)axiif[cid].axi_araddr);
    }
    else if (axiif[cid].axi_arready) { /* adr完了 */
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|2; /* axi */
      axiif[cid].axi_arvalid  = 0; /* off */
@


1.292
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.291 2017/09/02 12:37:46 nakashim Exp nakashim $";
d380 1
a380 1
      /*if (trace)*/
d411 1
a411 1
      /*if (trace)*/
d448 3
a450 3
    /*if (trace)*/
    printf("%03.3d:BRO->AXIIF WR reqn--=%x ty=%x adr=%08.8x dm=%08.8x\n",
	   cid, axiif[cid].reqn, bro->ty, bro->a, bro->dm);
d458 1
a458 1
    /*if (trace)*/
d475 1
a475 1
      /*if (trace)*/
d555 1
a555 1
      /*if (trace)*/
d583 1
a583 1
      /*if (trace)*/
d636 1
a636 1
      /*if (trace)*/
d654 1
a654 1
      /*if (trace)*/
d703 1
a703 1
      /*if (trace)*/
d742 1
a742 1
      /*if (trace)*/
d767 1
a767 1
      /*if (trace)*/
@


1.291
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.290 2017/09/01 15:45:46 nakashim Exp nakashim $";
a250 11
  switch (reg_ctrl.cmd) {
  case CMD_RESET:
  case CMD_SCON:  /* scon */
  case CMD_EXEC:  /* exec */
    if (!exring[cid].cmd_busy) {
      printf("%03.3d:ES %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6 CMD(%x) START---\n", cid, (Uint)(steps>>32), (Uint)steps, (Uint)(cycle>>32), (Uint)cycle, reg_ctrl.cmd);
      exring[cid].cmd_busy = 1;
    }
    break;
  }

a288 11
  if ((exring[cid].cycle & 3) == 3) {
    if (reg_ctrl.cmd == CMD_RESET)
      exring[cid].cycle = 0;
    else
      exring[cid].cycle++;
    reg_ctrl.cmd = CMD_NOP;
    exring[cid].cmd_busy = 0;
  }
  else
    exring[cid].cycle++;

a496 12
  if (reg_ctrl.cmd == CMD_RESET) {
    axiif[cid].reqn           = 0;
    axiif[cid].creg           = 0;
    axiif[cid].irw            = 0;
    axiif[cid].iadr           = 0;
    axiif[cid].ilen           = 0;
    axiif[cid].axring_ful2    = 0;
    axiif[cid].axring_b_top   = 0;
    axiif[cid].axring_b_bot   = 0;
    return (0);
  }

d593 12
d606 21
@


1.290
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.289 2017/09/01 14:52:51 nakashim Exp nakashim $";
d465 1
a465 1
    printf("%03.3d:BRO no unit covers ty=%x adr=%08.8x (maybe out-of-order/speculative load)\n", cid, bro->ty, bro->a);
d607 1
a607 1
      bri->a    = a + axiif[cid].ilen*sizeof(Ull);
d650 1
a650 1
      bri->a    = a + axiif[cid].ilen*sizeof(Ull);
d1232 2
a1233 2
  exring[cid].unit[i].lmranger_ok    = reg_ctrl.conf[i][br->col].cdw2.lmm_axir && br->rw==0 && br->ty==4 && reg_ctrl.addr[i][br->col].top<=br->a && br->a<=reg_ctrl.addr[i][br->col].bot; /* assign */
  exring[cid].unit[i].lmrangew_ok    = reg_ctrl.conf[i][br->col].cdw2.lmm_axiw && br->rw==1 && br->ty==4 && reg_ctrl.addr[i][br->col].top<=br->a && br->a<=reg_ctrl.addr[i][br->col].bot; /* assign */
d1283 1
d1676 8
a1683 8
	if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&reg_ctrl.conf[row]+ofs)+0) = tr->d[0];     }
	if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&reg_ctrl.conf[row]+ofs)+1) = tr->d[0]>>32; }
	if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&reg_ctrl.conf[row]+ofs)+2) = tr->d[1];     }
	if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&reg_ctrl.conf[row]+ofs)+3) = tr->d[1]>>32; }
	if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&reg_ctrl.conf[row]+ofs)+4) = tr->d[2];     }
	if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&reg_ctrl.conf[row]+ofs)+5) = tr->d[2]>>32; }
	if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&reg_ctrl.conf[row]+ofs)+6) = tr->d[3];     }
	if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&reg_ctrl.conf[row]+ofs)+7) = tr->d[3]>>32; }
d1686 4
a1689 4
	if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&exring[cid].unit[row].b[0]+ofs)+0) = tr->d[0]; *((Ull *)((Uchar*)&exring[cid].unit[row].b[1]+ofs)+0) = tr->d[0]; }
	if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&exring[cid].unit[row].b[0]+ofs)+1) = tr->d[1]; *((Ull *)((Uchar*)&exring[cid].unit[row].b[1]+ofs)+1) = tr->d[1]; }
	if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&exring[cid].unit[row].b[0]+ofs)+2) = tr->d[2]; *((Ull *)((Uchar*)&exring[cid].unit[row].b[1]+ofs)+2) = tr->d[2]; }
	if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&exring[cid].unit[row].b[0]+ofs)+3) = tr->d[3]; *((Ull *)((Uchar*)&exring[cid].unit[row].b[1]+ofs)+3) = tr->d[3]; }
d1692 8
a1699 8
	if      (tr->dm & 0x0000000f) { *((Uint*)((Uchar*)&reg_ctrl.addr[row]+ofs)+0) = tr->d[0];     }
	if      (tr->dm & 0x000000f0) { *((Uint*)((Uchar*)&reg_ctrl.addr[row]+ofs)+1) = tr->d[0]>>32; }
	if      (tr->dm & 0x00000f00) { *((Uint*)((Uchar*)&reg_ctrl.addr[row]+ofs)+2) = tr->d[1];     }
	if      (tr->dm & 0x0000f000) { *((Uint*)((Uchar*)&reg_ctrl.addr[row]+ofs)+3) = tr->d[1]>>32; }
	if      (tr->dm & 0x000f0000) { *((Uint*)((Uchar*)&reg_ctrl.addr[row]+ofs)+4) = tr->d[2];     }
	if      (tr->dm & 0x00f00000) { *((Uint*)((Uchar*)&reg_ctrl.addr[row]+ofs)+5) = tr->d[2]>>32; }
	if      (tr->dm & 0x0f000000) { *((Uint*)((Uchar*)&reg_ctrl.addr[row]+ofs)+6) = tr->d[3];     }
	if      (tr->dm & 0xf0000000) { *((Uint*)((Uchar*)&reg_ctrl.addr[row]+ofs)+7) = tr->d[3]>>32; }
d1702 4
a1705 4
	if      (tr->dm & 0x000000ff) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[row]+ofs)+0) = tr->d[0];   }/* ★★★ only write is implemented */
	if      (tr->dm & 0x0000ff00) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[row]+ofs)+1) = tr->d[1];   }/* ★★★ only write is implemented */
	if      (tr->dm & 0x00ff0000) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[row]+ofs)+2) = tr->d[2];   }/* ★★★ only write is implemented */
	if      (tr->dm & 0xff000000) { *((Ull *)((Uchar*)&reg_ctrl.lddmrw[row]+ofs)+3) = tr->d[3];   }/* ★★★ only write is implemented */
@


1.289
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.288 2017/09/01 13:31:52 nakashim Exp nakashim $";
d263 3
a265 2
  prev_stat = reg_ctrl.stat;
  reg_ctrl.stat = (!(c[cid].iorq.v_stat||axiif[cid].reqn)?LMRING_IDLE:LMRING_BUSY)<<4 | (!(exring[cid].cmd_busy||exring[cid].unit_busy)?EXRING_IDLE:EXRING_BUSY);
d267 1
a267 1
  if (!reg_ctrl.stat) {
a478 1
    axiif[cid].reqn--;
a635 1
      axiif[cid].reqn++;
@


1.288
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.287 2017/09/01 00:02:39 nakashim Exp nakashim $";
d40 1
d474 15
a488 15
  if (axiif[cid].reqn && axiif[cid].irw==0) { /* RDはiorq格納後dequeue */
    if (axiif[cid].iadr < REG_BASE2_PHYS+REG_CONF_OFFS) { /* control space ... 固定位置 */
      for (k=0; k<UNIT_WIDTH; k++)
	axiif[cid].axi_rdata[k] = *((Ull*)((Uchar*)&reg_ctrl+(axiif[cid].iadr-REG_BASE2_PHYS))+k);
      axiif[cid].axi_rvalid = 1;
      axiif[cid].reqn--;
      /*if (trace)*/
	printf("%03.3d:REG->AXIIF RD reqn--=%x adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, axiif[cid].reqn, axiif[cid].iadr,
	       (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	       (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	       (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	       (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
    }
    else if (bro_ful2) {
a503 3
    }
    else
      axiif[cid].axi_rvalid = 0;
d505 2
d521 1
d637 1
d639 1
a639 1
	printf("%03.3d:AXIIF->REG RD reqn++=%x adr=%08.8x\n", cid, axiif[cid].reqn, a);
d657 1
a657 1
	printf("%03.3d:AXIIF->BRI RD reqn++=%x adr=%08.8x\n", cid, axiif[cid].reqn, bri->a);
d770 1
a770 1
	printf("%03.3d:IORQ->AXIIF RD adr=%08.8x\n", cid, (Uint)axiif[cid].axi_araddr);
@


1.287
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.286 2017/08/31 12:27:19 nakashim Exp nakashim $";
d336 1
a336 1
  /* iorq.v_stat      : 4; v 0:empty 1:reserve 3:inuse | stat 0:empty 1:busy 2:OP-ok */
d374 1
a374 1
  /* iorq.v_stat : 4 *1101===X=0000==========X========1101===========================X=1110      
d390 1
a390 1
  if (c[cid].iorq.v_stat == ((3<<2)|1) && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
d399 1
a399 1
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|2; /* return to sim-core.c */
d430 1
a430 1
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|2; /* return to sim-core.c */
d637 1
a637 1
	printf("%03.3d:AXIIF->CREG RD reqn++=%x adr=%08.8x\n", cid, axiif[cid].reqn, a);
d761 1
d771 1
@


1.286
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.285 2017/08/31 08:21:09 nakashim Exp nakashim $";
d463 1
a463 1
    printf("%03.3d:BRO no lmm covers adr=%08.8x (maybe out-of-order/speculative load)\n", cid, bro->a);
d469 2
a470 2
    printf("%03.3d:BRO->AXIIF WR reqn--=%x adr=%08.8x\n",
	   cid, axiif[cid].reqn, bro->a);
d596 1
a596 1
    else if (axiif[cid].ilen <= axiif[cid].axi_awlen) { /* 0:conf/breg/addr/lddm, 1:lmm (burst 256bit_AXI_write -> 256bit_LMM (256bit*256count = 8KB)) */
d1613 4
a1668 4
    int idx = tr->a & (sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH*EMAX_DEPTH-1);
    int row = idx/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K/128B=0........63 *//* 64 rows */
    int ofs = idx%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K%128B=0,8,...,120 *//* 16 regs */

d1796 1
a1796 1
      br->av   = tr->av;   /* next cycle */
@


1.285
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.284 2017/08/31 07:37:58 nakashim Exp nakashim $";
a363 4
  int          bri_ful2 = axiif[cid].axring_ful2;
  struct axring_br *bri = &axiif[cid].axring_br[axiif[cid].axring_b_top]; /* AXI->EMAX側 */
  int         deq_waiti = exring[cid].unit[0].deq_wait;/* top deq_wait */

a365 1
  int         deq_waito = axiif[cid].deq_wait; /* AXI deq_wait */
d388 1
a451 1
  /* deq_waito 0:dq,1:wait
a467 2
    exring[cid].unit[EMAX_DEPTH-1].lmring_ful2--;
    exring[cid].unit[EMAX_DEPTH-1].lmring_b_bot = (exring[cid].unit[EMAX_DEPTH-1].lmring_b_bot + 1)%LMRING_BR_BUF;
d498 1
a498 1
	       cid, axiif[cid].reqn, bri->a,
a516 4
  int          bro_ful2 = exring[cid].unit[EMAX_DEPTH-1].lmring_ful2;
  struct lmring_br *bro = &exring[cid].unit[EMAX_DEPTH-1].lmring_br[exring[cid].unit[EMAX_DEPTH-1].lmring_b_bot]; /* AXI<-EMAX側 */
  int         deq_waito = axiif[cid].deq_wait; /* AXI deq_wait */

d1610 1
d1816 1
a1816 2
    if (exring[cid].unit[i].lmring_ful2 && !deq_wait) { /* dequeued for next cycle */
      /* dequeue */
@


1.284
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.283 2017/08/31 05:35:07 nakashim Exp nakashim $";
d275 1
a275 2
  /* axi<->all-rows *//* exringの動作を優先し,隙間でDDR<->LMMを動かす */
  siml_axiif(cid, row0, trace);           /* ★★LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */
d289 2
d315 1
a315 1
siml_axiif(cid, row0, trace) Uint cid, row0, trace;
a373 11
  if (reg_ctrl.cmd == CMD_RESET) {
    axiif[cid].reqn           = 0;
    axiif[cid].irw            = 0;
    axiif[cid].iadr           = 0;
    axiif[cid].ilen           = 0;
    axiif[cid].axring_ful2    = 0;
    axiif[cid].axring_b_top   = 0;
    axiif[cid].axring_b_bot   = 0;
    return (0);
  }

d515 26
d1955 1
a1955 1
    printf(" xbr[%d].rw-ty-col-sq-av=%x-%x-%x-%04.4x-%x a-dm=%08.8x-%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d2149 1
a2149 1
    printf(" ltr.rw-t-c-s-p-v-a-m-d=%x-%x-%x-%04.4x-%x-%x-%08.8x-%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d2256 1
a2256 1
      printf(" lbr[%d].rw-ty-col-sq-av-a-dm=%x-%x-%x-%04.4x-%x-%08.8x-%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
@


1.283
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.282 2017/08/30 23:39:45 nakashim Exp nakashim $";
d1631 1
a1631 1
  } lmring_br[3];
d1765 1
a1765 1
    for (k=0; k<3; k++) {
d1937 1
a1937 1
  for (col=0; col<3; col++) {
d2098 1
a2098 1
    printf("                                                                                                                           rk-wk-dk-s4-e1b-e0b-ful-dqw-fl1=%d-%d-%d-%d-%d-%d-%d-%d-%d\n",
d2116 1
a2116 1
    printf("                      lmwd lmco-ca-m-d=%d-%05.5x-%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d2133 1
a2133 1
    printf(" lt.rw-t-c-s-p-v-a-m-d=%x-%x-%x-%04.4x-%x-%x-%08.8x-%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d2238 1
a2238 1
    for (col=0; col<3; col++) {
d2240 1
a2240 1
      printf(" rbr[%d].rw-ty-col-sq-av-a-dm=%x-%x-%x-%04.4x-%x-%08.8x-%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
@


1.282
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.281 2017/08/30 05:34:00 nakashim Exp nakashim $";
d255 1
a255 1
      printf("%03.3d:ES %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6-START---\n", cid, (Uint)(steps>>32), (Uint)steps, (Uint)(cycle>>32), (Uint)cycle);
a264 3
  if (c[cid].iorq.v_stat)
    printf("%03.3d:IO %08.8x_%08.8x cycle=%08.8x_%08.8x ---IORQ-ON type=%x adr=%08.8x -----\n", cid, (Uint)(steps>>32), (Uint)steps, (Uint)(cycle>>32), (Uint)cycle, c[cid].iorq.type, c[cid].iorq.ADR);

d267 1
a267 1
      printf("%03.3d:EE %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6-END-----\n", cid, (Uint)(steps>>32), (Uint)steps, (Uint)(cycle>>32), (Uint)cycle);
d402 2
d417 1
a417 1
    else if (axiif[cid].axi_arvalid && axiif[cid].axi_arready) { /* new read_req starts */
a443 1
      axiif[cid].axi_arready = 0;
d485 3
d497 2
a498 2
	printf("%03.3d:REG->AXIIF RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, axiif[cid].iadr,
d514 2
a515 2
	printf("%03.3d:BRO->AXIIF RD adr=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, bri->a,
d612 2
a613 2
	printf("%03.3d:AXIIF->BRI WR adr=%08.8x dm=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, bri->a, bri->dm,
d631 2
d650 1
a650 2
	printf("%03.3d:AXIIF->BRI RD adr=%08.8x\n",
	       cid, bri->a);
d1938 1
a1938 1
    if (col>0) printf("                                                        ");
@


1.281
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.280 2017/08/29 12:51:09 nakashim Exp nakashim $";
d39 1
a39 1
  Ull   busy               : 1; /* ★★★reg_ctrl.statに直接反映★★★ */
d263 4
a266 1
  reg_ctrl.stat = (!(axiif[cid].busy)?LMRING_IDLE:LMRING_BUSY)<<4 | (!(exring[cid].cmd_busy||exring[cid].unit_busy)?EXRING_IDLE:EXRING_BUSY);
d271 1
a271 2
    if (!c[cid].iorq.v_stat)
      return (0);
d377 1
a377 1
    axiif[cid].busy           = 0;
d415 1
a415 1
      if (trace)
d447 1
a447 1
      if (trace)
d469 1
a469 1
  /* axiif_busy                                                         _____/~~~~~~~~~~~
d480 1
a480 1
      printf("%03.3d:BRO no lmm covers adr=%08.8x (maybe out-of-order/speculative load)\n", cid, bro->a);
d483 2
a484 1
  if (bro_ful2 && axiif[cid].irw==1) { /* WRは無条件にdequeue */
d489 1
a489 1
  if (axiif[cid].busy && axiif[cid].irw==0) { /* RDはiorq格納後dequeue */
d494 2
a495 1
      if (trace)
d509 1
d512 1
a512 3
      if (bro->sq == axiif[cid].axi_arlen)
	axiif[cid].busy = 0;
      if (trace)
d582 1
a582 1
      if (trace)
d606 2
d610 1
a610 2
      axiif[cid].ilen++;
      if (trace)
a622 1
    axiif[cid].busy = 1;
d629 1
d642 1
d644 3
a646 1
      if (trace)
d696 1
a696 1
      if (trace)
d705 4
a708 4
	axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))== 0) ? 0x0000000f<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))== 8) ? 0x00000f00<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))==16) ? 0x000f0000<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))==24) ? 0x0f000000<<(c[cid].iorq.ADR&sizeof(int)) : 0x00000000);
d715 4
a718 4
	axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))== 0) ? 0x000000ff : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))== 8) ? 0x0000ff00 : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))==16) ? 0x00ff0000 : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))==24) ? 0xff000000 : 0x00000000);
d725 2
a726 2
	axiif[cid].axi_wstrb    = ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))== 0) ? 0x0000ffff : 0x00000000)
                                | ((c[cid].iorq.ADR&((UNIT_WIDTH-1)*sizeof(Ull))==16) ? 0xffff0000 : 0x00000000);
d735 3
a737 3
      if (trace)
	printf("%03.3d:IORQ->AXIIF WR adr=%08.8x wstrb=%08.8x data=%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x_%08.8x%08.8x\n",
	       cid, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb,
d759 1
a759 1
      if (trace)
d1926 2
a1927 2
  printf(" busy=%x irw=%x iadr=%08.8x ilen=%04.4x ful2-top-bot=%d-%d-%d",
	 axiif[cid].busy, 
d2096 1
a2096 1
    printf("                                                                                                                       rk-wk-dk-s4-e1b-e0b-ful-dqw-fl1=%d-%d-%d-%d-%d-%d-%d-%d-%d\n",
d2114 1
a2114 1
    printf("                  lmwd lmco-ca-m-d=%d-%05.5x-%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
@


1.280
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.279 2017/08/29 08:22:49 nakashim Exp nakashim $";
d51 1
a51 1
    Ull   ty          : 2; /* アドレスから区別 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
d54 1
d122 3
a124 3
    Ull   lmranger_ok   : 1; /* wire *//* lmring要求がread &ty==1&adr[col]<>lmm_range内 */
    Ull   lmrangew_ok   : 1; /* wire *//* lmring要求がwrite&ty==1&adr[col]<>lmm_range内 */
    Ull   lmlddmqw_ok   : 1; /* wire *//* lmring要求がwrite&ty==2&op1[col]==LDDMQ */
d133 1
a133 1
      Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
d136 1
d175 1
a175 1
      Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
d178 1
a314 124
emax6_reg(tid, type, opcd, addr, val)
     Uint tid, type, opcd, addr; Ull *val;
     /* type=3:load, 4:store */
     /* opcd:   LD.... 0:LDRB, 1:LDRH, 2:LDRW, 3:LDR,  4:LDRSB, 5:LDRSH, 6:LDRSW, 7:LDREX     */
     /*                8:VLDRB, 9:VLDRH,10:VLDRS,11:VLDRD,12:VLDRQ                            */
     /*         ST.... 0:STRB, 1:STRH, 2:STRW, 3:STR                                          */
     /*                8:VSTRB, 9:VSTRH,10:VSTRS,11:VSTRD,12:VSTRQ                            */
{
  Uint cid = tid2cid(tid);
  int  ofs, i, j, k, p_row, found;
  Uint lmm_mode, umask, lmask; /* 18bits */

  if (addr < REG_BASE2_PHYS+REG_BREG_OFFS) { /* reg space ... rowはexring[cid].unit[*].l_rowの一致検索, colはreg_ctrl.cselにより指定 */
                                                  /*           REG_CONF_OFFS    0x00002000 */
    ofs = addr-(REG_BASE2_PHYS+REG_CONF_OFFS);
    i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K/128B=0..63 */
    j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K%128B=0,8,...,120 */
    for (p_row=0; p_row<EMAX_DEPTH; p_row++) if (exring[cid].unit[p_row].l_row == i) break; /* 論理row==iを検索 */
    switch (type) { case 4:/* store */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%x adr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                              else                         *(Uint*)((Uchar*)&reg_ctrl.conf[p_row]+j) = val[0]; break;
			                              case  3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%x adr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
		                                              else                         *(Ull *)((Uchar*)&reg_ctrl.conf[p_row]+j) = val[0]; break;
			                              case 12:if (addr & (sizeof(Dll )-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%x adr=%08.8x (should be aligned to Dll)\n", tid, opcd, addr);
		                                              else {                       *((Ull *)((Uchar*)&reg_ctrl.conf[p_row]+j)+0) = val[0];
							                                   *((Ull *)((Uchar*)&reg_ctrl.conf[p_row]+j)+1) = val[1];} break;
                                                      default:printf("%03.3d:emax6_ctl: conf_space store: opcd=%x (should be STRW/STR)\n", tid, opcd); break; } break;
    }
  }
  else if (addr < REG_BASE2_PHYS+REG_ADDR_OFFS) { /* reg space ... rowはexring[cid].unit[*].l_rowの一致検索, colはreg_ctrl.cselにより指定 */
                                                  /*           REG_BREG_OFFS    0x00004000 */
    ofs = addr-(REG_BASE2_PHYS+REG_BREG_OFFS);
    i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K/128B=0..63 */
    j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K%128B=0,8,...,120 */
    for (p_row=0; p_row<EMAX_DEPTH; p_row++) if (exring[cid].unit[p_row].l_row == i) break; /* 論理row==iを検索 */
    switch (type) { case 4:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: breg_space store: opcd=%x adr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                             else *(Uint*)((Uchar*)&exring[cid].unit[p_row].b[0]+j) = val[0]; /* BREG定数初期化はdouble-buffer両面に必要 */
					                          *(Uint*)((Uchar*)&exring[cid].unit[p_row].b[1]+j) = val[0]; break;
			                              case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: breg_space store: opcd=%x adr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
		                                             else *(Ull *)((Uchar*)&exring[cid].unit[p_row].b[0]+j) = val[0]; /* BREG定数初期化はdouble-buffer両面に必要 */
				                                  *(Ull *)((Uchar*)&exring[cid].unit[p_row].b[1]+j) = val[0]; break;
                                                      default:printf("%03.3d:emax6_ctl: breg_space store: opcd=%x (should be STRW/STR)\n", tid, opcd); break; } break;
    }
  }
  else if (addr < REG_BASE2_PHYS+REG_LDDM_OFFS) { /* reg space ... rowはexring[cid].unit[*].l_rowの一致検索, colはreg_ctrl.cselにより指定 */
                                                  /*           REG_ADDR_OFFS    0x00006000 */
    ofs = addr-(REG_BASE2_PHYS+REG_ADDR_OFFS);
    i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K/128B=0..63 */
    j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K%128B=0,8,...,120 */
    for (p_row=0; p_row<EMAX_DEPTH; p_row++) if (exring[cid].unit[p_row].l_row == i) break; /* 論理row==iを検索 */
    switch (type) { case 4:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: addr_space store: opcd=%x adr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                             else                         *(Uint*)((Uchar*)&reg_ctrl.addr[p_row]+j) = val[0]; break;
			                              case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: addr_space store: opcd=%x adr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
		                                             else                         *(Ull *)((Uchar*)&reg_ctrl.addr[p_row]+j) = val[0]; break;
                                                      default:printf("%03.3d:emax6_ctl: addr_space store: opcd=%x (should be STRW/STR)\n", tid, opcd); break; } break;
    }
  }
  else if (addr < REG_BASE2_PHYS+REG_AREA_SIZE) { /* reg space ... rowはexring[cid].unit[*].l_rowの一致検索, colはreg_ctrl.cselにより指定 */
                                                  /*           REG_LDDM_OFFS    0x00008000 */
    ofs = addr-(REG_BASE2_PHYS+REG_LDDM_OFFS);
    i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K/128B=0..63 */
    j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* max8K%128B=0,8,...,120 */
    for (p_row=0; p_row<EMAX_DEPTH; p_row++) if (exring[cid].unit[p_row].l_row == i) break; /* 論理row==iを検索 */
    switch (type) { case 3:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%x adr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
                                                             else                         val[0] = *(Uint*)((Uchar*)&reg_ctrl.lddmrw[p_row]+j); break;
                                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%x adr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
                                                             else                         val[0] = *(Ull *)((Uchar*)&reg_ctrl.lddmrw[p_row]+j); break;
		                                      default:printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%x (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                    case 4:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%x adr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                             else                         *(Uint*)((Uchar*)&reg_ctrl.lddmrw[p_row]+j) = val[0]; break;
		                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%x adr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
				                             else                         *(Ull *)((Uchar*)&reg_ctrl.lddmrw[p_row]+j) = val[0]; break;
		                                      default:printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%x (should be STRW/STR)\n", tid, opcd); break; } break;
    }
  }
  else if (addr <= MEM_VALID_ADDR) { /* lmm space ... rowは指定なし(rangeの一致検索), colはreg_ctrl.cselにより指定 */
    ofs = addr+reg_ctrl.adtr; /* LMM_MAP_TOP->membase */
    j   = reg_ctrl.csel;
    found = 0;
    for (p_row=0; p_row<EMAX_DEPTH; p_row++) {
      /*printf("%03.3d:emax6_ctl: type=%d axir=%d axiw=%d addr=%08.8x ofs=%08.8x top=%08.8x bot=%08.8x\n", tid, type, reg_ctrl.conf[p_row][j].cdw2.lmm_axir, reg_ctrl.conf[p_row][j].cdw2.lmm_axiw, addr, ofs, reg_ctrl.addr[p_row][j].top, reg_ctrl.addr[p_row][j].bot);*/
      if (((type==3 && reg_ctrl.conf[p_row][j].cdw2.lmm_axir) || (type==4 && reg_ctrl.conf[p_row][j].cdw2.lmm_axiw)) && reg_ctrl.addr[p_row][j].top<=ofs && ofs<=reg_ctrl.addr[p_row][j].bot) {
	found = 1;
	lmm_mode = reg_ctrl.conf[p_row][j].cdw2.lmm_mode;
	switch (lmm_mode) {
	case 0: umask = LMEM_UMASK0; lmask = LMEM_LMASK0; break;
	case 1: umask = LMEM_UMASK1; lmask = LMEM_LMASK1; break;
	case 2: umask = LMEM_UMASK2; lmask = LMEM_LMASK2; break;
	case 3: umask = LMEM_UMASK3; lmask = LMEM_LMASK3; break;
	}
	ofs = ((j & umask) * (LMEM_SIZE/4)) | (ofs & lmask);
	switch (type) { case 3:/* load  */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x adr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                                  else                         val[0] = *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]); break;
		                                          case  3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x adr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
			    	                                  else                         val[0] = *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]); break;
                                                          case 12:if (addr & (sizeof(Dll )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x adr=%08.8x (should be aligned to Dll)\n", tid, opcd, addr);
                                                                  else {                       val[0] = *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]+0);
							                                       val[1] = *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]+1);} break;
		                                          default:printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x (should be LDRW/LDR/VLDRQ)\n", tid, opcd);  break; } break;
                        case 4:/* store */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x adr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                                  else                         *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0]; break;
		                                          case  3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x adr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
				                                  else                         *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0]; break;
		                                          case 12:if (addr & (sizeof(Dll )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x adr=%08.8x (should be aligned to Dll)\n", tid, opcd, addr);
				                                  else {                       *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]+0) = val[0];
							  	                               *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]+1) = val[1];} break;
		                                          default:printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x (should be STRW/STR/VSTRQ)\n", tid, opcd); break; } break;
	}
      }
    }
    if (!found)
      printf("%03.3d:emax6_ctl: no lmm covers addr=%08.8x (maybe out-of-order/speculative load)\n", tid, addr);
  }
  else /* error */
    printf("%03.3d:emax6_ctl: out of range: addr=%08.8x (>= REG_BASE2_PHYS+REG_BASE2_SIZE)\n", tid, addr);

  printf("%03.3d:EC %08.8x_%08.8x cycle=%08.8x_%08.8x type=%d opcd=%x addr=%08.8x, val=%08.8x_%08.8x_%08.8x_%08.8x\n",
         tid, (Uint)(t[tid].total_steps>>32), (Uint)(t[tid].total_steps),
	 (Uint)(t[tid].total_cycle>>32), (Uint)t[tid].total_cycle,
	 type, opcd, addr,
         (Uint)(val[1]>>32), (Uint)val[1], (Uint)(val[0]>>32), (Uint)val[0]);

  return (0);
}

d347 1
a347 1
  /* axring_br.ty     : 2; アドレスから区別 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
d357 1
a357 1
  /* lmring_br.ty     : 2; 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
d459 1
a459 1
  /* bro.ty    0:reg,1:lmm --<=*=====>-
d462 1
d477 10
a486 1
  if (axiif[cid].busy && axiif[cid].irw==0) {
d545 1
a545 1
  /* bri.ty    0:reg,1:lmm*     -----<=*=====>---                       -----<=*=====>---
d548 1
d589 5
a593 1
      bri->ty   = (a<REG_BASE2_PHYS+REG_AREA_SIZE) ? 0 : 1; /* 0:conf/breg/addr/lddm, 1:lmm */
d596 1
d629 5
a633 1
      bri->ty   = (a<REG_BASE2_PHYS+REG_AREA_SIZE) ? 0 : 1; /* 0:conf/breg/addr/lddm, 1:lmm */
d636 1
d1172 3
a1174 3
  Ull   lmranger_ok   : 1; /* wire *//* lmring要求がread &ty==1&adr[col]<>lmm_range内 */
  Ull   lmrangew_ok   : 1; /* wire *//* lmring要求がwrite&ty==1&adr[col]<>lmm_range内 */
  Ull   lmlddmqw_ok   : 1; /* wire *//* lmring要求がwrite&ty==2&op1[col]==LDDMQ */
d1183 1
a1183 1
    Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
d1186 1
d1215 3
a1217 3
  exring[cid].unit[i].lmranger_ok    = reg_ctrl.conf[i][br->col].cdw2.lmm_axir && br->rw==0 && br->ty==1 && reg_ctrl.addr[i][br->col].top<=br->a && br->a<=reg_ctrl.addr[i][br->col].bot; /* assign */
  exring[cid].unit[i].lmrangew_ok    = reg_ctrl.conf[i][br->col].cdw2.lmm_axiw && br->rw==1 && br->ty==1 && reg_ctrl.addr[i][br->col].top<=br->a && br->a<=reg_ctrl.addr[i][br->col].bot; /* assign */
  exring[cid].unit[i].lmlddmqw_ok    = br->rw==1 && br->ty==2 && reg_ctrl.conf[i][br->col].cdw1.ea1op == OP_LDDMQ; /* lmwd[0]->tr *//* LDDMQは同一slotに高々1が前提 */
a1233 8
  exring[cid].unit[i].lmco    = br->col;  /* wire *//* -> col# */
  exring[cid].unit[i].lmca    = br->a;    /* wire *//* -> ea01dr *//* col#による2bit補正前addr */
  exring[cid].unit[i].lmwm    = br->dm;   /* wire *//* <- axi   */
  exring[cid].unit[i].lmwd[0] = br->d[0]; /* wire *//* <- axi   */
  exring[cid].unit[i].lmwd[1] = br->d[1]; /* wire *//* <- axi   */
  exring[cid].unit[i].lmwd[2] = br->d[2]; /* wire *//* <- axi   */
  exring[cid].unit[i].lmwd[3] = br->d[3]; /* wire *//* <- axi   */

d1242 1
d1252 8
d1265 1
d1272 1
a1272 1
    tr->pass = br->ty == 0 || !exring[cid].unit[i].lmranger_ok; /* reg or read (VADDR/LDDMQ/TRANS) in range */
d1351 3
a1353 3
    /* exring[cid].unit[i].lmranger_ok   = rw==0 && ty==1 && [br->col].top <= br->a && br->a <= [br->col].bot); */
    /* exring[cid].unit[i].lmrangew_ok   = rw==1 && ty==1 && [br->col].top <= br->a && br->a <= [br->col].bot); */
    /* exring[cid].unit[i].lmlddmqw_ok   = rw==1 && ty==2 && [br->col].op1==LDDMQ   */
d1615 1
a1615 1
    Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
d1618 1
d1649 42
d1761 1
d1781 1
d1930 1
a1930 1
    printf(" xbr[%d].rw-ty-col-sq=%d-%d-%d-%04.4x a-dm=%08.8x-%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1932 1
a1932 1
	   (Uint)axiif[cid].axring_br[col].rw, (Uint)axiif[cid].axring_br[col].ty, axiif[cid].axring_br[col].col, axiif[cid].axring_br[col].sq, axiif[cid].axring_br[col].a, axiif[cid].axring_br[col].dm,
d2124 1
a2124 1
    printf(" lt.rw-t-c-s-p-a-m-d=%d-%d-%d-%04.4x-%x-%08.8x-%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d2130 1
d2231 1
a2231 1
      printf(" rbr[%d].rw-ty-col-sq-a-dm=%d-%d-%d-%04.4x-%08.8x-%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d2237 1
@


1.279
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.278 2017/08/27 02:39:22 nakashim Exp nakashim $";
d511 6
a516 6
  /* iorq.v_stat : 4      
  /* iorq.tid    :12
  /* iorq.type   : 4       
  /* iorq.opcd   : 6
  /* iorq.ADR       
  /* iorq.BUF[2]    
d518 4
a521 11
  /* axiif_busy
  /* axiif_irw
  /* axiif_iadr
  /* axiif_ilen
  /* write_busy SLAVE
  /* read_busy  SLAVE
  /* iadr   (internal)
  /* rdata[]    SLAVE
  /* rvalid     SLAVE
  /* rlast      SLAVE     
  /* rready    MASTER*
d525 46
a570 13
    emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);
    c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|2; /* return to sim-core.c */
    if (trace)
      printf("%03.3d:AXIIFRD adr=%08.8x data=%08.8x_%08.8x_%08.8x_%08.8x\n",
	     cid, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[1]>>32), (Uint)c[cid].iorq.BUF[1], (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
  }

  if (axiif[cid].axi_arready && axiif[cid].axi_arvalid) { /* new read_req starts */
    axiif[cid].axi_arready = 0;                /* start read */
    axiif[cid].ilen  = 0;                      /* start read (unit is multople of 64bits) */
    if (trace)
      printf("%03.3d:AXIIF: read start araddr=%08.8x arlen=%08.8x\n",
             cid, (Uint)axiif[cid].axi_araddr, axiif[cid].axi_arlen);
d591 4
a594 4
  /* rdata[]    SLAVE*             --<=D=====>-
  /* rvalid     SLAVE*             __/~~~~~~~\_
  /* rlast      SLAVE*             __/~~~~~~~\_
  /* rready    MASTER              ~~~~~~~~~~~~
d601 1
a608 1
      axiif[cid].axi_rvalid = 1;
d618 2
a626 2
      if (bro->sq == axiif[cid].axi_arlen)
	axiif[cid].busy = 0;
d628 2
d710 1
a717 1
      axiif[cid].ilen++;
d724 4
d738 1
a741 1
      axiif[cid].ilen++;
d788 1
a790 1
      c[cid].iorq.v_stat = 0; /* immediately finished */
a846 9
      switch (c[cid].iorq.opcd) {
      case 2:if (c[cid].iorq.ADR & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x adr=%08.8x (should be aligned to Uint)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    c[cid].iorq.BUF[0] = *(Uint*)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)); break;
      case 3:if (c[cid].iorq.ADR & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x adr=%08.8x (should be aligned to Ull)\n", c[cid].iorq.tid, c[cid].iorq.opcd, c[cid].iorq.ADR);
             else                                    c[cid].iorq.BUF[0] = *(Ull *)((Uchar*)&dma_ctrl+(c[cid].iorq.ADR-DMA_BASE2_PHYS)); break;
      default:                                       printf("%03.3d:emax6_ctl: dma_space load: opcd=%x (should be LDRW/LDR)\n", c[cid].iorq.tid, c[cid].iorq.opcd); break; }
      if (trace)
	printf("%03.3d:IORQ->DMA RD opcd=%d adr=%08.8x data=%08.8x_%08.8x\n", cid, c[cid].iorq.opcd, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
      c[cid].iorq.v_stat = 0; /* immediately finished */
@


1.278
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.277 2017/08/25 08:38:21 nakashim Exp nakashim $";
a18 5
  Ull   busy               : 1; /* ★★★reg_ctrl.statに直接反映★★★ */
  Ull   pio_dma            : 1; /* 0:pio(iorq),  1:dma(dmac) */
  Ull   iadr               :31; /* adr (internal) */
  Ull   ilen               :16; /* len (internal) */

a19 11
  Ull   axi_read_busy      : 1; /* for controlling status */
  Ull   axi_arready        : 1; /* axi -> fsm                                                         */
  Ull   axi_arvalid        : 1; /* axi <- fsm                                                         */
  Ull   axi_araddr            ; /* aligned-address of mm    v   v   v   v           v                 */
  Ull   axi_arlen          :16; /* aligned-length  of mm    v   v   v   v           1                 */
  Ull   axi_rready         : 1; /* axi -> fsm read-ready                                              */
  Ull   axi_rvalid         : 1; /* axi <- fsm read-valid                                              */
  Ull   axi_rdata[UNIT_WIDTH] ; /* axi read-data            v   v   v   v           v                 */
  Ull   axi_write_busy     : 1; /* for controlling status */
  Ull   axi_awready        : 1; /* axi -> fsm                                                         */
  Ull   axi_awvalid        : 1; /* axi <- fsm                                                         */
d22 2
d25 3
d29 14
a42 2
  Ull   axi_wvalid         : 1; /* axi -> fsm write-valid                                             */
  Ull   axi_wdata[UNIT_WIDTH] ; /* axi -> write-data                        v                         */
d45 1
a45 1
  Ull   axring_ful2   : 2; /* 0:empty, 3:full */
d324 1
a324 29
  if (addr < DMA_BASE2_PHYS) /* error */
    printf("%03.3d:emax6_ctl: out of range: addr=%08.8x (< DMA_BASE2_PHYS)\n", tid, addr);
  else if (addr < REG_BASE2_PHYS) { /* dma space ... 固定位置 */
    switch (type) { case 3:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
                                                             else                         val[0] = *(Uint*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)); break;
                                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
                                                             else                         val[0] = *(Ull *)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)); break;
                                                      default:printf("%03.3d:emax6_ctl: dma_space load: opcd=%x (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                    case 4:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
                                                             else                         *(Uint*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)) = val[0]; break;
                                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
                                                             else                         *(Ull *)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)) = val[0]; break;
                                                      default:printf("%03.3d:emax6_ctl: dma_space store: opcd=%x (should be STRW/STR)\n", tid, opcd); break; } break;
    }
  }
  else if (addr < REG_BASE2_PHYS+REG_CONF_OFFS) { /* control space ... 固定位置 */
    switch (type) { case 3:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: reg_space load: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
                                                             else                         val[0] = *(Uint*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)); break;
                                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: reg_space load: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
                                                             else                         val[0] = *(Ull *)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)); break;
		                                      default:printf("%03.3d:emax6_ctl: reg_space load: opcd=%x (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                    case 4:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: reg_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                             else                         *(Uint*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)) = val[0]; break;
		                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: reg_space store: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
				                             else                         *(Ull *)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)) = val[0]; break;
		                                      default:printf("%03.3d:emax6_ctl: reg_space store: opcd=%x (should be STRW/STR)\n", tid, opcd); break; } break;
    }
  }
  else if (addr < REG_BASE2_PHYS+REG_BREG_OFFS) { /* reg space ... rowはexring[cid].unit[*].l_rowの一致検索, colはreg_ctrl.cselにより指定 */
d330 1
a330 1
    switch (type) { case 4:/* store */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d332 1
a332 1
			                              case  3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d334 1
a334 1
			                              case 12:if (addr & (sizeof(Dll )-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%x addr=%08.8x (should be aligned to Dll)\n", tid, opcd, addr);
d346 1
a346 1
    switch (type) { case 4:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: breg_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d349 1
a349 1
			                              case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: breg_space store: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d361 1
a361 1
    switch (type) { case 4:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: addr_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d363 1
a363 1
			                              case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: addr_space store: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d374 1
a374 1
    switch (type) { case 3:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d376 1
a376 1
                                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d379 1
a379 1
                    case 4:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d381 1
a381 1
		                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d402 1
a402 1
	switch (type) { case 3:/* load  */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d404 1
a404 1
		                                          case  3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d406 1
a406 1
                                                          case 12:if (addr & (sizeof(Dll )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x addr=%08.8x (should be aligned to Dll)\n", tid, opcd, addr);
d410 1
a410 1
                        case 4:/* store */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d412 1
a412 1
		                                          case  3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d414 1
a414 1
		                                          case 12:if (addr & (sizeof(Dll )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x addr=%08.8x (should be aligned to Dll)\n", tid, opcd, addr);
d466 1
a466 1
  /* axring_ful2      : 2; 0:empty, 3:ful          */
d493 1
a493 1
  int j, k;
d497 3
a499 4
    axiif[cid].axi_read_busy  = 0; /* for controlling status */
    axiif[cid].axi_arready    = 1;
    axiif[cid].axi_write_busy = 0; /* for controlling status */
    axiif[cid].axi_awready    = 1;
d519 2
a520 2
  /* axiif_pio_dma
  /* axiif_iaddr
d539 8
d552 8
d561 8
a568 14
  /* bro_ful2  0:emp,3:ful
  /* bro.rw    0:rd.1:wr
  /* bro.ty    0:reg,1:lmm
  /* bro.col   :  2
  /* bro.sq    : 16
  /* bro.a     : 31
  /* bro.dm    : 32
  /* bro.d[4]  :256
  /* write_busy SLAVE*
  /* read_busy  SLAVE*
  /* rdata[]    SLAVE*
  /* rvalid     SLAVE*
  /* rlast      SLAVE*
  /* rready    MASTER
d571 12
a582 9
  if (axiif[cid].axi_read_busy) {
    /* burst 256bit_LMM -> 256bit_AXI_read (256bit*256count = 8KB) */
    if (axiif[cid].ilen <= axiif[cid].axi_arlen) {
      bri->rw = 0;
      bri->ty = 1;             /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
      bri->col= reg_ctrl.csel; /* logical col# for target lmm */
      bri->sq = 0;             /* not used */
      bri->a  = axiif[cid].axi_araddr + axiif[cid].ilen*sizeof(Ull);
      bri->dm = 0xffffffff;    /* always on */
d584 1
a584 7
    else { /* done */
      axiif[cid].axi_arready = 1;
      axiif[cid].axi_rvalid  = 0;
      axiif[cid].axi_read_busy = 0;
    }
    if (bro_ful2) {
      axiif[cid].axi_rvalid = 1;
d589 1
d593 2
a594 2
	printf("%03.3d:AXIIF: read a=%08.8x rdata=%08.8x_%08.8x %08.8x_%08.8x %08.8x_%08.8x %08.8x_%08.8x\n",
                 cid, bri->a,
d599 2
a600 1
      axiif[cid].ilen++;
d609 26
a634 26
  /* deq_waiti 0:dq,1:wait
  /* bri_ful2  0:emp,3:ful
  /* bri.rw    0:rd.1:wr
  /* bri.ty    0:reg,1:lmm
  /* bri.col   :  2
  /* bri.sq    : 16
  /* bri.a     : 31
  /* bri.dm    : 32
  /* bri.d[4]  :256
  /* write_busy SLAVE*
  /* read_busy  SLAVE*
  /* awaddr    MASTER
  /* iadr   (internal)
  /* awlen     MASTER
  /* awvalid   MASTER
  /* awready    SLAVE*
  /* wdata[]   MASTER
  /* wstrb     MASTER
  /* wvalid    MASTER
  /* wlast     MASTER
  /* wready     SLAVE*
  /* araddr    MASTER
  /* iadr   (internal)
  /* arlen     MASTER
  /* arvalid   MASTER
  /* arready    SLAVE*
d637 73
a709 25
  if (axiif[cid].axi_write_busy) {
    /* burst 256bit_AXI_write -> 256bit_LMM (256bit*256count = 8KB) */
    if (axiif[cid].ilen <= axiif[cid].axi_awlen) {
      if (axiif[cid].axi_wvalid) {
	bri->rw = 1;
	bri->ty = 1;             /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
	bri->col= reg_ctrl.csel; /* logical col# for target lmm */
	bri->sq = 0;             /* not used */
	bri->a  = axiif[cid].axi_awaddr + axiif[cid].ilen*sizeof(Ull);
	bri->dm = 0xffffffff;    /* always on */
	bri->d[0] = axiif[cid].axi_wdata[0];
	bri->d[1] = axiif[cid].axi_wdata[1];
	bri->d[2] = axiif[cid].axi_wdata[2];
	bri->d[3] = axiif[cid].axi_wdata[3];
	axiif[cid].axring_ful2++;
	axiif[cid].axring_b_top = (axiif[cid].axring_b_top + 1)%AXRING_BR_BUF;
	if (trace)
	  printf("%03.3d:AXIIF: write a=%08.8x wdata=%08.8x_%08.8x %08.8x_%08.8x %08.8x_%08.8x %08.8x_%08.8x\n",
		 cid, bri->a,
		 (Uint)(axiif[cid].axi_wdata[3]>>32), (Uint)axiif[cid].axi_wdata[3],
		 (Uint)(axiif[cid].axi_wdata[2]>>32), (Uint)axiif[cid].axi_wdata[2],
		 (Uint)(axiif[cid].axi_wdata[1]>>32), (Uint)axiif[cid].axi_wdata[1],
		 (Uint)(axiif[cid].axi_wdata[0]>>32), (Uint)axiif[cid].axi_wdata[0]);
        axiif[cid].ilen++;
      }
a711 2
      axiif[cid].axi_awready = 1;
      axiif[cid].axi_write_busy = 0;
d715 5
d725 1
a725 1
  /* iorq.v_stat : 4  1101===X=0000==========X========1101===========================X=1110
d732 13
a744 19
  /* axiif_busy         _____/~~~                       _____/~~~
  /* axiif_pio_dma      -----<=0=PIO                    -----<=0=PIO
  /* axiif_iaddr        -----<=A=                       -----<=A=
  /* axiif_ilen         -----<=0=
  /* write_busy SLAVE   _____________/~~~
  /* read_busy  SLAVE               A                   _____________/~~~
  /* awaddr    MASTER*  -----<=A=   |                               A
  /* awlen     MASTER*  -----<=0=   |                               |
  /* awvalid   MASTER*  _____/~~~~~~~\___                           |
  /* awready    SLAVE   ~~~~~\___                                   |
  /* wdata[]   MASTER*          -----<=D=                           |
  /* wstrb     MASTER*          -----<=M=                           |
  /* wvalid    MASTER*          _____/~~~                           |
  /* wlast     MASTER*          _____/~~~ PIOの場合,常に1           |
  /* wready     SLAVE           ~~~~~\___                           |
  /* araddr    MASTER*                                  -----<=A=   |
  /* arlen     MASTER*                                  -----<=0=   |
  /* arvalid   MASTER*                                  _____/~~~~~~~\___
  /* arready    SLAVE                                   ~~~~~\___
d748 62
a809 5
    emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);
    c[cid].iorq.v_stat = 0; /* immediately finished */
    if (trace)
      printf("%03.3d:AXIIFWR adr=%08.8x data=%08.8x_%08.8x_%08.8x_%08.8x\n",
	     cid, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[1]>>32), (Uint)c[cid].iorq.BUF[1], (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
d812 23
a834 22
  if (axiif[cid].axi_arready && axiif[cid].axi_arvalid) { /* new read_req starts */
    axiif[cid].axi_arready = 0;                /* start read */
    axiif[cid].axi_read_busy = 1;
    axiif[cid].ilen  = 0;                      /* start read (unit is multople of 64bits) */
    if (trace)
      printf("%03.3d:AXIIF: read start araddr=%08.8x_%08.8x arlen=%08.8x\n",
             cid, (Uint)(axiif[cid].axi_araddr>>32), (Uint)axiif[cid].axi_araddr, axiif[cid].axi_arlen);
  }

  if (axiif[cid].axi_awready && axiif[cid].axi_awvalid) { /* new write_req starts */
    axiif[cid].axi_awready = 0;                /* start write */
    axiif[cid].axi_write_busy = 1;
    axiif[cid].ilen  = 0;                      /* start write (unit is multiple of 64bits) */
    if (trace)
      printf("%03.3d:AXIIF: write start awaddr=%08.8x_%08.8x awlen=%08.8x\n",
             cid, (Uint)(axiif[cid].axi_awaddr>>32), (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_awlen);
  }

  if (bri_ful2 && !deq_waiti) { /* dequeued for next cycle */
    /* dequeue */
    axiif[cid].axring_ful2--;
    axiif[cid].axring_b_bot = (axiif[cid].axring_b_bot + 1)%AXRING_BR_BUF;
d1939 2
a1940 2
  printf("=AXIIF[%02.2d]   bsy=%d   arbusy=%d axiarr-arv-arl-ara    =%d-%d-%08.8x-%08.8x          r_v=%d-%d d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         cid, axiif[cid].busy, axiif[cid].axi_read_busy, axiif[cid].axi_arready, axiif[cid].axi_arvalid, axiif[cid].axi_arlen, (Uint)axiif[cid].axi_araddr, axiif[cid].axi_rready, axiif[cid].axi_rvalid,
d1943 2
a1944 2
  printf("=EXRING[%02.2d].cuy=%d%d_%d awbusy=%d axiawr-awv-awl-awa-stb=%d-%d-%08.8x-%08.8x-%08.8x r_v=%d-%d d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         cid, exring[cid].cmd_busy, exring[cid].unit_busy, exring[cid].cycle, axiif[cid].axi_write_busy, axiif[cid].axi_awready, axiif[cid].axi_awvalid, axiif[cid].axi_awlen, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb, axiif[cid].axi_wready, axiif[cid].axi_wvalid,
d1948 5
a1952 1
  printf(" ful2-top-bot=%d-%d-%d ilen=%04.4x",
d1955 1
a1955 2
	 axiif[cid].axring_b_bot,
	 axiif[cid].ilen);
d1958 2
a1959 2
    if (col>0) printf("                             ");
    printf(" xbr[%d].rw-ty-col-sq=%d-%d-%d-%04.4x a-dm=%08.8x-%08.8x         d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
@


1.277
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.276 2017/08/25 00:06:02 nakashim Exp nakashim $";
d20 3
d29 1
a29 1
  Ull   axi_arlen             ; /* aligned-length  of mm    v   v   v   v           1                 */
d37 1
a37 1
  Ull   axi_awlen             ; /* aligned-length  of mm                    v                         */
a46 1
  Ull   ilen          :31; /* len (internal) */
d52 1
a52 1
    Ull   sq          :16; /* sequential # for pipelined DMA */
a178 1

d470 2
a471 2
  /* 論理番号           物理番号                     V<--------ENQ (siml_axiifが先にENQ)             *//* axi_awready awvalid awaddr awlen *//* axi_wstrb wready wvalid wdata[] */
  /*                              axiif.axring_br =======bri_ful2 物理#0のpiはaxringに差し替え       *//* axi_arready arvalid araddr arlen */
d482 1
a482 1
  /*                                                 +-------->DEQ (siml_axiifが先にDEQ)             *//* axi_rready rvalid rdata[] */
d539 1
a539 1
  /* iorq.v_stat : 4
d541 1
a541 1
  /* iorq.type   : 4
d546 4
d552 1
a552 1
  /* araddr    MASTER
d555 2
a556 1
  /* rready    MASTER
d573 13
a585 12
  /* bro_ful2 0:emp,3:ful
  /* bro.rw   0:rd.1:wr
  /* bro.ty   0:reg,1:lmm
  /* bro.col  :  2
  /* bro.sq   : 16
  /* bro.a    : 31
  /* bro.dm   : 32
  /* bro.d[4] :256
  /* write_busy SLAVE
  /* read_busy  SLAVE
  /* rdata[]    SLAVE
  /* rvalid     SLAVE
d629 10
a638 10
  /* bri_ful2 0:emp,3:ful
  /* bri.rw   0:rd.1:wr
  /* bri.ty   0:reg,1:lmm
  /* bri.col  :  2
  /* bri.sq   : 16
  /* bri.a    : 31
  /* bri.dm   : 32
  /* bri.d[4] :256
  /* write_busy SLAVE
  /* read_busy  SLAVE
d640 1
d643 6
a648 5
  /* awready    SLAVE
  /* wdata[]    SLAVE
  /* wstrb      SLAVE
  /* wvalid     SLAVE
  /* wready    MASTER
d650 1
d653 1
a653 1
  /* arready    SLAVE
d693 1
a693 1
  /* iorq.v_stat : 4
d695 24
a718 19
  /* iorq.type   : 4
  /* iorq.opcd   : 6
  /* iorq.ADR       
  /* iorq.BUF[2]    
  /* iorq.rob       
  /* write_busy SLAVE
  /* read_busy  SLAVE
  /* awaddr    MASTER
  /* awlen     MASTER
  /* awvalid   MASTER
  /* awready    SLAVE
  /* wdata[]    SLAVE
  /* wstrb      SLAVE
  /* wvalid     SLAVE
  /* wready    MASTER
  /* araddr    MASTER
  /* arlen     MASTER
  /* arvalid   MASTER
  /* arready    SLAVE
d734 2
a735 2
      printf("%03.3d:AXIIF: read start araddr=%08.8x_%08.8x arlen=%08.8x_%08.8x\n",
             cid, (Uint)(axiif[cid].axi_araddr>>32), (Uint)axiif[cid].axi_araddr, (Uint)(axiif[cid].axi_arlen>>32), (Uint)axiif[cid].axi_arlen);
d743 2
a744 2
      printf("%03.3d:AXIIF: write start awaddr=%08.8x_%08.8x awlen=%08.8x_%08.8x\n",
             cid, (Uint)(axiif[cid].axi_awaddr>>32), (Uint)axiif[cid].axi_awaddr, (Uint)(axiif[cid].axi_awlen>>32), (Uint)axiif[cid].axi_awlen);
d1856 1
a1856 1
         cid, axiif[cid].busy, axiif[cid].axi_read_busy, axiif[cid].axi_arready, axiif[cid].axi_arvalid, (Uint)axiif[cid].axi_arlen, (Uint)axiif[cid].axi_araddr, axiif[cid].axi_rready, axiif[cid].axi_rvalid,
d1860 1
a1860 1
         cid, exring[cid].cmd_busy, exring[cid].unit_busy, exring[cid].cycle, axiif[cid].axi_write_busy, axiif[cid].axi_awready, axiif[cid].axi_awvalid, (Uint)axiif[cid].axi_awlen, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb, axiif[cid].axi_wready, axiif[cid].axi_wvalid,
@


1.276
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.275 2017/08/24 02:30:20 nakashim Exp nakashim $";
d553 8
a614 8
  else if (axiif[cid].axi_arready && axiif[cid].axi_arvalid) { /* new read_req starts */
    axiif[cid].axi_arready = 0;                /* start read */
    axiif[cid].axi_read_busy = 1;
    axiif[cid].ilen  = 0;                      /* start read (unit is multople of 64bits) */
    if (trace)
      printf("%03.3d:AXIIF: read start araddr=%08.8x_%08.8x arlen=%08.8x_%08.8x\n",
             cid, (Uint)(axiif[cid].axi_araddr>>32), (Uint)axiif[cid].axi_araddr, (Uint)(axiif[cid].axi_arlen>>32), (Uint)axiif[cid].axi_arlen);
  }
a645 28
  /* read/write LMRING先端への投入   iorq->axiif->bri */
  /*       HOST:IORQ->AXIIF (ARM-restartにより,iorqに該当エントリがない場合がある) */
  /************************************************************************************************************************************************************************************************************/
  /*                        |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk                   _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* iorq.v_stat : 4
  /* iorq.tid    :12
  /* iorq.type   : 4
  /* iorq.opcd   : 6
  /* iorq.ADR       
  /* iorq.BUF[2]    
  /* iorq.rob       
  /* write_busy SLAVE
  /* read_busy  SLAVE
  /* awaddr    MASTER
  /* awlen     MASTER
  /* awvalid   MASTER
  /* awready    SLAVE
  /* wdata[]    SLAVE
  /* wstrb      SLAVE
  /* wvalid     SLAVE
  /* wready    MASTER
  /* araddr    MASTER
  /* arlen     MASTER
  /* arvalid   MASTER
  /* arready    SLAVE
  /************************************************************************************************************************************************************************************************************/

a676 8
  else if (axiif[cid].axi_awready && axiif[cid].axi_awvalid) { /* new write_req starts */
    axiif[cid].axi_awready = 0;                /* start write */
    axiif[cid].axi_write_busy = 1;
    axiif[cid].ilen  = 0;                      /* start write (unit is multiple of 64bits) */
    if (trace)
      printf("%03.3d:AXIIF: write start awaddr=%08.8x_%08.8x awlen=%08.8x_%08.8x\n",
             cid, (Uint)(axiif[cid].axi_awaddr>>32), (Uint)axiif[cid].axi_awaddr, (Uint)(axiif[cid].axi_awlen>>32), (Uint)axiif[cid].axi_awlen);
  }
d678 27
a704 7
  if (c[cid].iorq.v_stat == ((3<<2)|1) && c[cid].iorq.type == 3) { /* load *//* emax6_reg()機能は最終的には各担当stageに配置 */
    emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);
    c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|2; /* return to sim-core.c */
    if (trace)
      printf("%03.3d:AXIIFRD adr=%08.8x data=%08.8x_%08.8x_%08.8x_%08.8x\n",
	     cid, c[cid].iorq.ADR, (Uint)(c[cid].iorq.BUF[1]>>32), (Uint)c[cid].iorq.BUF[1], (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
  }
d714 18
@


1.275
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.274 2017/08/24 00:00:07 nakashim Exp nakashim $";
a467 8
  /* iorq.v_stat      : 4;  v 0:empty 1:reserve 3:inuse | stat 0:empty 1:busy 2:OP-ok */
  /* iorq.tid         :12;                                                            */
  /* iorq.type        : 4;    type                    */
  /* iorq.opcd        : 6;    opcd                    */
  /* iorq.ADR            ;    以前のADDRに対応        */
  /* iorq.BUF[2]         ;    for load/store          */
  /* iorq.rob            ;    for DATA                */

d483 28
d534 18
a551 2
  /* AXIIF->IORQ */
  /* BRO->AXIIF */
d553 20
a572 3
  /* read/write LMRING先端への投入   iorq->axiif->bri */
  /* AXIIF->BRI */
  /* IORQ->AXIIF */
d574 37
a610 7
  if (c[cid].iorq.v_stat == ((3<<2)|1)) {
    /* emax6_reg()機能は最終的には各担当stageに配置 */
    emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);
    if (c[cid].iorq.type == 3) /* load */
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|2; /* return to sim-core.c */
    else /* store */
      c[cid].iorq.v_stat = 0; /* immediately finished */
d612 2
a613 3
      printf("%03.3d:AXIIF: iorq.type=%d adr=%08.8x data=%08.8x_%08.8x_%08.8x_%08.8x\n",
	     cid, c[cid].iorq.type, c[cid].iorq.ADR,
	     (Uint)(c[cid].iorq.BUF[1]>>32), (Uint)c[cid].iorq.BUF[1], (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
d616 58
a673 2
  /* AXIがslave -> axring/lmring */
  /* 先頭にenq */
a704 37

  /* 終端からdeq */
  else if (axiif[cid].axi_read_busy) {
    /* burst 256bit_LMM -> 256bit_AXI_read (256bit*256count = 8KB) */
    if (axiif[cid].ilen <= axiif[cid].axi_arlen) {
      bri->rw = 0;
      bri->ty = 1;             /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
      bri->col= reg_ctrl.csel; /* logical col# for target lmm */
      bri->sq = 0;             /* not used */
      bri->a  = axiif[cid].axi_araddr + axiif[cid].ilen*sizeof(Ull);
      bri->dm = 0xffffffff;    /* always on */
    }
    else { /* done */
      axiif[cid].axi_arready = 1;
      axiif[cid].axi_rvalid  = 0;
      axiif[cid].axi_read_busy = 0;
    }
    if (bro_ful2) {
      axiif[cid].axi_rvalid = 1;
      axiif[cid].axi_rdata[0] = bro->d[0];
      axiif[cid].axi_rdata[1] = bro->d[1];
      axiif[cid].axi_rdata[2] = bro->d[2];
      axiif[cid].axi_rdata[3] = bro->d[3];
      exring[cid].unit[EMAX_DEPTH-1].lmring_ful2--;
      exring[cid].unit[EMAX_DEPTH-1].lmring_b_bot = (exring[cid].unit[EMAX_DEPTH-1].lmring_b_bot + 1)%LMRING_BR_BUF;
      if (trace)
	printf("%03.3d:AXIIF: read a=%08.8x rdata=%08.8x_%08.8x %08.8x_%08.8x %08.8x_%08.8x %08.8x_%08.8x\n",
                 cid, bri->a,
	       (Uint)(axiif[cid].axi_rdata[3]>>32), (Uint)axiif[cid].axi_rdata[3],
	       (Uint)(axiif[cid].axi_rdata[2]>>32), (Uint)axiif[cid].axi_rdata[2],
	       (Uint)(axiif[cid].axi_rdata[1]>>32), (Uint)axiif[cid].axi_rdata[1],
	       (Uint)(axiif[cid].axi_rdata[0]>>32), (Uint)axiif[cid].axi_rdata[0]);
      axiif[cid].ilen++;
    }
  }

  /* start read/write */
d713 12
a724 4
  else if (axiif[cid].axi_arready && axiif[cid].axi_arvalid) { /* new read_req starts */
    axiif[cid].axi_arready = 0;                /* start read */
    axiif[cid].axi_read_busy = 1;
    axiif[cid].ilen  = 0;                      /* start read (unit is multople of 64bits) */
d726 2
a727 2
      printf("%03.3d:AXIIF: read start araddr=%08.8x_%08.8x arlen=%08.8x_%08.8x\n",
             cid, (Uint)(axiif[cid].axi_araddr>>32), (Uint)axiif[cid].axi_araddr, (Uint)(axiif[cid].axi_arlen>>32), (Uint)axiif[cid].axi_arlen);
@


1.274
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.273 2017/08/23 23:02:51 nakashim Exp nakashim $";
d514 1
a515 1
  /* AXIIF->IORQ */
d518 1
a519 1
  /* AXIIF->BRI */
@


1.273
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.272 2017/08/23 15:27:39 nakashim Exp nakashim $";
d468 8
a489 14
  
  if (c[cid].iorq.v_stat == ((3<<2)|1)) {
    emax6_reg(c[cid].iorq.tid, c[cid].iorq.type, c[cid].iorq.opcd, c[cid].iorq.ADR, c[cid].iorq.BUF);
    if (c[cid].iorq.type == 3) /* load */
      c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|2; /* return to sim-core.c */
    else /* store */
      c[cid].iorq.v_stat = 0; /* immediately finished */
    if (trace)
      printf("%03.3d:AXIIF: iorq.type=%d adr=%08.8x data=%08.8x_%08.8x_%08.8x_%08.8x\n",
	     cid, c[cid].iorq.type, c[cid].iorq.ADR,
	     (Uint)(c[cid].iorq.BUF[1]>>32), (Uint)c[cid].iorq.BUF[1], (Uint)(c[cid].iorq.BUF[0]>>32), (Uint)c[cid].iorq.BUF[0]);
  }

  return (0);
d492 1
a492 1
  struct axring_br *bri = &axiif[cid].axring_br[axiif[cid].axring_b_top];
d496 2
a497 2
  struct lmring_br *bro = &exring[cid].unit[EMAX_DEPTH-1].lmring_br[exring[cid].unit[EMAX_DEPTH-1].lmring_b_bot];
  int         deq_waito = axiif[cid].deq_wait;
d513 21
d553 1
a553 1
	  printf("%03.3d:siml_axiif: write a=%08.8x wdata=%08.8x_%08.8x %08.8x_%08.8x %08.8x_%08.8x %08.8x_%08.8x\n",
d593 1
a593 1
	printf("%03.3d:siml_axiif: read a=%08.8x rdata=%08.8x_%08.8x %08.8x_%08.8x %08.8x_%08.8x %08.8x_%08.8x\n",
d609 1
a609 1
      printf("%03.3d:siml_axiif: write start awaddr=%08.8x_%08.8x awlen=%08.8x_%08.8x\n",
d617 1
a617 1
      printf("%03.3d:siml_axiif: read start araddr=%08.8x_%08.8x arlen=%08.8x_%08.8x\n",
@


1.272
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.271 2017/08/18 12:23:14 nakashim Exp nakashim $";
d485 4
a488 1
    c[cid].iorq.v_stat = (c[cid].iorq.v_stat&0xc)|2; /* OP */
@


1.271
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.270 2017/08/17 12:18:45 nakashim Exp nakashim $";
d226 87
a312 3
emax6_ctl(tid, type, opcd, addr, mask, val)
     Uint tid, type, opcd, addr; Ull *mask; Ull *val;
     /* type=8:load, 9:store, 10:ldstub, 11:svc */
d325 1
a325 1
    switch (type) { case 8:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d330 1
a330 1
                    case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d338 1
a338 1
    switch (type) { case 8:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: reg_space load: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d343 1
a343 1
                    case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: reg_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d356 1
a356 1
    switch (type) { case 9:/* store */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d372 1
a372 1
    switch (type) { case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: breg_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d387 1
a387 1
    switch (type) { case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: addr_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d400 1
a400 1
    switch (type) { case 8:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d405 1
a405 1
                    case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d418 1
a418 1
      if (((type==8 && reg_ctrl.conf[p_row][j].cdw2.lmm_axir) || (type==9 && reg_ctrl.conf[p_row][j].cdw2.lmm_axiw)) && reg_ctrl.addr[p_row][j].top<=ofs && ofs<=reg_ctrl.addr[p_row][j].bot) {
d428 1
a428 1
	switch (type) { case 8:/* load  */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d436 1
a436 1
                        case 9:/* store */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d453 1
a453 1
  printf("%03.3d:EC %08.8x_%08.8x cycle=%08.8x_%08.8x type=%d opcd=%x addr=%08.8x, mask=%08.8x_%08.8x_%08.8x_%08.8x val=%08.8x_%08.8x_%08.8x_%08.8x\n",
a456 1
         (Uint)(mask[1]>>32), (Uint)mask[1], (Uint)(mask[0]>>32), (Uint)mask[0],
a461 83
//application -> emax6_start((Ull*)emax6_conf_x1, (Ull*)emax6_lmmi_x1, (Ull*)emax6_regv_x1);
//            -> svc 0xf1
siml_emax6(cid, trace, trace_pipe)
     /* core毎にemaxは1つなので,t[cid]を使用 */
     Uint cid; Uint trace, trace_pipe;
{
  int i, j, k, row0, prev_stat, busy;
  Ull a;
  Ull steps = t[cid].total_steps;
  Ull cycle = t[cid].total_cycle;

#if 0
  if (cycle % ARM_EMAX6_RATIO) /* ARM:2.4GHz EMAX6:1.2GHz */
    return (0);
#endif

  if (cid) /* EMAX6 is attached on cid=0 */
    return (0);

  switch (reg_ctrl.cmd) {
  case CMD_RESET:
  case CMD_SCON:  /* scon */
  case CMD_EXEC:  /* exec */
    if (!exring[cid].cmd_busy) {
      printf("%03.3d:ES %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6-START---\n", cid, (Uint)(steps>>32), (Uint)steps, (Uint)(cycle>>32), (Uint)cycle);
      exring[cid].cmd_busy = 1;
    }
    break;
  }

  /* update LMRING/EXRING */
  prev_stat = reg_ctrl.stat;
  reg_ctrl.stat = (!axiif[cid].busy?LMRING_IDLE:LMRING_BUSY)<<4 | (!(exring[cid].cmd_busy||exring[cid].unit_busy)?EXRING_IDLE:EXRING_BUSY);

  if (!reg_ctrl.stat) {
    if (prev_stat)
      printf("%03.3d:EE %08.8x_%08.8x cycle=%08.8x_%08.8x ---EMAX6-END-----\n", cid, (Uint)(steps>>32), (Uint)steps, (Uint)(cycle>>32), (Uint)cycle);
    return (0);
  }

  /* find top_row */
  for (row0=0; row0<EMAX_DEPTH; row0++)           /* ★★EXRINGは論理row0からsimlする必要があり,LMRINGも合わせる */
    if (exring[cid].unit[row0].l_row == 0) break; /* ★★LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */

  /* axi<->all-rows *//* exringの動作を優先し,隙間でDDR<->LMMを動かす */
  siml_axiif(cid, row0, trace);           /* ★★LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */

  /* siml unit */
  for (i=(row0+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
    siml_unit_lmm(cid, i);
    siml_unit_stage5(cid, i); /* stage-5 (4DR->BROUT)(LMRING_TR->LMRING_BROUT) */
    siml_unit_stage4(cid, i); /* stage-4 (3DR->4DR)  (LMRING_BRIN->LMRING_TR) */
    siml_unit_stage3(cid, i); /* stage-3 (2DR->3DR) */
    siml_unit_stage2(cid, i); /* stage-2 (EX/TX->2DR) */
    siml_unit_stage1(cid, i); /* stage-1 (BRIN->EX/TX) */
    if (i==row0)
      break;
  }

  busy = 0;
  for (i=0; i<EMAX_DEPTH; i++) { /* for each unit */
    if (exring[cid].unit[i].unit1_exec || exring[cid].unit[i].unit1_stop || exring[cid].unit[i].unit2_exec || exring[cid].unit[i].unit2_stop)
      busy = 1;
  }
  exring[cid].unit_busy = busy;

  if ((exring[cid].cycle & 3) == 3) {
    if (reg_ctrl.cmd == CMD_RESET)
      exring[cid].cycle = 0;
    else
      exring[cid].cycle++;
    reg_ctrl.cmd = CMD_NOP;
    exring[cid].cmd_busy = 0;
  }
  else
    exring[cid].cycle++;

  if (trace && trace_pipe)
    show_emax6_status(cid);

  return (0);
}

d482 11
@


1.270
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.269 2017/08/17 01:30:42 nakashim Exp nakashim $";
d235 2
a236 1
  int  ofs, i, j, k, p_row;
d331 30
a360 28
    for (p_row=0; p_row<EMAX_DEPTH; p_row++) if (reg_ctrl.addr[p_row][j].top<=ofs && ofs<=reg_ctrl.addr[p_row][j].bot) break; /* range一致を検索 */
    /*printf("%03.3d:emax6_ctl: addr=%08.8x ofs=%08.8x top=%08.8x bot=%08.8x\n", tid, addr, ofs, reg_ctrl.addr[p_row][j].top, reg_ctrl.addr[p_row][j].bot);*/
    if (p_row<EMAX_DEPTH) {
      Uint lmm_mode, umask, lmask; /* 18bits */
      lmm_mode = reg_ctrl.conf[p_row][j].cdw2.lmm_mode;
      switch (lmm_mode) {
      case 0: umask = LMEM_UMASK0; lmask = LMEM_LMASK0; break;
      case 1: umask = LMEM_UMASK1; lmask = LMEM_LMASK1; break;
      case 2: umask = LMEM_UMASK2; lmask = LMEM_LMASK2; break;
      case 3: umask = LMEM_UMASK3; lmask = LMEM_LMASK3; break;
      }
      ofs = ((j & umask) * (LMEM_SIZE/4)) | (ofs & lmask);
      switch (type) { case 8:/* load  */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                                else                         val[0] = *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]); break;
		                                        case  3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
			  	                                else                         val[0] = *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]); break;
                                                        case 12:if (addr & (sizeof(Dll )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x addr=%08.8x (should be aligned to Dll)\n", tid, opcd, addr);
                                                                else {                       val[0] = *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]+0);
							                                     val[1] = *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]+1);} break;
		                                        default:printf("%03.3d:emax6_ctl: lmm_space load: opcd=%x (should be LDRW/LDR/VLDRQ)\n", tid, opcd);  break; } break;
                      case 9:/* store */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                                else                         *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0]; break;
		                                        case  3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
				                                else                         *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0]; break;
		                                        case 12:if (addr & (sizeof(Dll )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x addr=%08.8x (should be aligned to Dll)\n", tid, opcd, addr);
				                                else {                       *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]+0) = val[0];
								                             *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]+1) = val[1];} break;
		                                        default:printf("%03.3d:emax6_ctl: lmm_space store: opcd=%x (should be STRW/STR/VSTRQ)\n", tid, opcd); break; } break;
d363 1
a363 1
    else
d1052 2
a1053 2
  exring[cid].unit[i].lmranger_ok    = br->rw==0 && br->ty==1 && reg_ctrl.addr[i][br->col].top<=br->a && reg_ctrl.addr[i][br->col].bot>=br->a; /* assign */
  exring[cid].unit[i].lmrangew_ok    = br->rw==1 && br->ty==1 && reg_ctrl.addr[i][br->col].top<=br->a && reg_ctrl.addr[i][br->col].bot>=br->a; /* assign */
d1186 2
a1187 2
    /* exring[cid].unit[i].lmranger_ok   = rw==0 && ty==1 && [br->col].top <= br->a && [br->col].bot >= br->a); */
    /* exring[cid].unit[i].lmrangew_ok   = rw==1 && ty==1 && [br->col].top <= br->a && [br->col].bot >= br->a); */
@


1.269
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.268 2017/08/16 15:33:54 nakashim Exp nakashim $";
d96 1
a96 1
    Ull   eao           :18; /* wire *//* in for ALU */
d98 1
a98 1
    Ull   ea0o          :18; /* reg  *//* in for EA0 */
d100 1
a100 1
    Ull   ea1o          :18; /* reg  *//* in for EA1 */
d333 9
a341 1
      ofs = ofs % LMEM_SIZE;
d434 1
a441 3
  if (trace && trace_pipe)
    show_emax6_status(cid);

d453 3
d686 1
a686 1
        exring[cid].unit[i].ea0o          = 0;
d688 1
a688 1
        exring[cid].unit[i].ea1o          = 0;
d1697 1
a1697 1
  printf("=AXIIF[%02.2d]   busy=%d arbusy=%d  axiarr-arv-arl-ara    =%d-%d-%08.8x-%08.8x          r_v=%d-%d d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1701 2
a1702 2
  printf("=EXRING[%02.2d].cycle=%d awbusy=%d  axiawr-awv-awl-awa-stb=%d-%d-%08.8x-%08.8x-%08.8x r_v=%d-%d d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         cid, exring[cid].cycle, axiif[cid].axi_write_busy, axiif[cid].axi_awready, axiif[cid].axi_awvalid, (Uint)axiif[cid].axi_awlen, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb, axiif[cid].axi_wready, axiif[cid].axi_wvalid,
d1798 2
a1799 2
    printf(" ea31b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.addr[row][3].ea1b, reg_ctrl.addr[row][3].ea1o, reg_ctrl.addr[row][3].ea0b, reg_ctrl.addr[row][3].ea0o, reg_ctrl.addr[row][3].top,  reg_ctrl.addr[row][3].bot);
    printf(" ea21b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.addr[row][2].ea1b, reg_ctrl.addr[row][2].ea1o, reg_ctrl.addr[row][2].ea0b, reg_ctrl.addr[row][2].ea0o, reg_ctrl.addr[row][2].top,  reg_ctrl.addr[row][2].bot);
d1802 2
a1803 2
    printf(" ea11b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.addr[row][1].ea1b, reg_ctrl.addr[row][1].ea1o, reg_ctrl.addr[row][1].ea0b, reg_ctrl.addr[row][1].ea0o, reg_ctrl.addr[row][1].top,  reg_ctrl.addr[row][1].bot);
    printf(" ea01b/1o/0b/0o/top/bot=%05.5x/%05.5x/%05.5x/%05.5x/%08.8x/%08.8x", reg_ctrl.addr[row][0].ea1b, reg_ctrl.addr[row][0].ea1o, reg_ctrl.addr[row][0].ea0b, reg_ctrl.addr[row][0].ea0o, reg_ctrl.addr[row][0].top,  reg_ctrl.addr[row][0].bot);
d1816 1
a1816 1
           exring[cid].unit[row].ea1o,
d1818 1
a1818 1
           exring[cid].unit[row].eao,
d1820 1
a1820 1
           exring[cid].unit[row].ea0o,
d1924 1
a1924 1
      Uint lmm_mode, umask, lmask, top, bot; /* 18bits */
d1934 5
a1938 5
	for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull)) {
	  top = ((col & umask) * (LMEM_SIZE/4)) | (i & lmask);
	  if (i==0) printf(" \033[1;33mlm%d(%d):%08.8x\033[0m", col, lmm_mode, top);
	  printf("-%08.8x%08.8x", *(Ull*)&exring[cid].unit[row].lmm.m[top]);
	}
d1940 5
a1944 5
	for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull)) {
	  bot = ((col & umask) * (LMEM_SIZE/4)) | ((LMEM_SIZE-sizeof(Ull)*16+i) & lmask);
	  if (i==0) printf(" \033[1;33mlm%d(%d):%08.8x\033[0m", col, lmm_mode, bot);
	  printf("-%08.8x%08.8x", *(Ull*)&exring[cid].unit[row].lmm.m[bot]);
	}
d1950 5
a1954 5
	for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull)) {
	  top = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.addr[row][col].top+i) & lmask);
	  if (i==0) printf(" \033[1;33mlm%d(%d):%08.8x\033[0m", col, lmm_mode, top);
	  printf("-%08.8x%08.8x", *((Ull*)&exring[cid].unit[row].lmm.m[top]));
	}
d1956 5
a1960 5
	for (i=0; i<sizeof(Ull)*16; i+=sizeof(Ull)) {
	  bot = ((col & umask) * (LMEM_SIZE/4)) | ((reg_ctrl.addr[row][col].bot+1-sizeof(Ull)*16+i) & lmask);
	  if (i==0) printf(" \033[1;33mlm%d(%d):%08.8x\033[0m", col, lmm_mode, bot);
	  printf("-%08.8x%08.8x", *((Ull*)&exring[cid].unit[row].lmm.m[bot]));
	}
d1987 1
a1987 1
    for (col=0; col<EMAX_WIDTH; col++) {
d1997 1
a1997 1
    for (col=0; col<EMAX_WIDTH; col++) {
@


1.268
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.267 2017/08/16 08:44:11 nakashim Exp nakashim $";
d240 1
a240 1
    switch (type) { case 8:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d242 1
a242 1
                                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d244 2
a245 2
                                                      default:printf("%03.3d:emax6_ctl: dma_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                    case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d247 1
a247 1
                                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d249 1
a249 1
                                                      default:printf("%03.3d:emax6_ctl: dma_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d253 1
a253 1
    switch (type) { case 8:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: reg_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d255 1
a255 1
                                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: reg_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d257 2
a258 2
		                                      default:printf("%03.3d:emax6_ctl: reg_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                    case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: reg_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d260 1
a260 1
		                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: reg_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d262 1
a262 1
		                                      default:printf("%03.3d:emax6_ctl: reg_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d271 8
a278 5
    switch (type) { case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                             else                         *(Uint*)((Uchar*)&reg_ctrl.conf[p_row]+j) = val[0]; break;
			                              case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
		                                             else                         *(Ull *)((Uchar*)&reg_ctrl.conf[p_row]+j) = val[0]; break;
                                                      default:printf("%03.3d:emax6_ctl: conf_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d287 1
a287 1
    switch (type) { case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: breg_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d290 1
a290 1
			                              case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: breg_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d293 1
a293 1
                                                      default:printf("%03.3d:emax6_ctl: breg_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d302 1
a302 1
    switch (type) { case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: addr_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d304 1
a304 1
			                              case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: addr_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d306 1
a306 1
                                                      default:printf("%03.3d:emax6_ctl: addr_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d315 1
a315 1
    switch (type) { case 8:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d317 1
a317 1
                                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d319 2
a320 2
		                                      default:printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                    case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d322 1
a322 1
		                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d324 1
a324 1
		                                      default:printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d334 1
a334 1
      switch (type) { case 8:/* load  */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d336 1
a336 1
		                                        case  3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d338 1
a338 1
                                                        case 12:if (addr & (sizeof(Dll )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d addr=%08.8x (should be aligned to Dll)\n", tid, opcd, addr);
d341 2
a342 2
		                                        default:printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d (should be LDRW/LDR/VLDRQ)\n", tid, opcd);  break; } break;
                      case 9:/* store */switch (opcd) { case  2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d344 1
a344 1
		                                        case  3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d346 1
a346 1
		                                        case 12:if (addr & (sizeof(Dll )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d addr=%08.8x (should be aligned to Dll)\n", tid, opcd, addr);
d349 1
a349 1
		                                        default:printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d (should be STRW/STR/VSTRQ)\n", tid, opcd); break; } break;
d358 4
a361 2
  printf("%03.3d:emax6_ctl %08.8x_%08.8x type=%d opcd=%d addr=%08.8x, mask=%08.8x_%08.8x_%08.8x_%08.8x val=%08.8x_%08.8x_%08.8x_%08.8x\n",
         tid, (Uint)(t[tid].total_steps>>32), (Uint)(t[tid].total_steps), type, opcd, addr,
d370 3
a372 2
siml_emax6(cid, cycle, trace, trace_pipe)
     Uint cid; Ull cycle; Uint trace, trace_pipe;
d376 2
d392 1
a392 1
      printf("%03.3d:emax6 start cycle=%08.8x_%08.8x\n", cid, (Uint)(cycle>>32), (Uint)cycle);
d404 1
a404 1
      printf("%03.3d:emax6 end   cycle=%08.8x_%08.8x\n", cid, (Uint)(cycle>>32), (Uint)cycle);
@


1.267
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.266 2017/08/15 07:12:20 nakashim Exp nakashim $";
d331 16
a346 10
      switch (type) { case 8:/* load  */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                               else                         val[0] = *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]); break;
		                                        case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
			  	                               else                         val[0] = *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]); break;
		                                        default:printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                      case 9:/* store */switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                                               else                         *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0]; break;
		                                        case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
				                               else                         *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0]; break;
		                                        default:printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d368 1
a368 1
  int i, j, k, row0, busy;
d383 4
a386 1
    exring[cid].cmd_busy = 1;
d391 1
d394 3
a396 1
  if (!reg_ctrl.stat)
d398 1
@


1.266
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.265 2017/08/14 13:37:31 nakashim Exp nakashim $";
d59 2
a60 1
  Ull   busy            : 1; /* ★★★reg_ctrl.statに直接反映★★★ */
d373 14
d405 1
a405 3

  /* update LMRING/EXRING */
  busy = exring[cid].busy;
d407 1
a407 1
    if (exring[cid].unit[i].unit1_exec || exring[cid].unit[i].unit2_exec)
d410 1
a410 1
  reg_ctrl.stat = (!axiif[cid].busy?LMRING_IDLE:LMRING_BUSY)<<4 | (!busy?EXRING_IDLE:EXRING_BUSY);
d412 1
a412 1
  if (trace && trace_pipe && busy)
a414 11
  switch (reg_ctrl.cmd) {
  case CMD_RESET:
    break;
  case CMD_SCON:  /* scon */
    exring[cid].busy  = 1;
    break;
  case CMD_EXEC:  /* exec */
    exring[cid].busy  = 1;
    break;
  }

d421 1
a421 1
    exring[cid].busy  = 0;
@


1.265
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.264 2017/08/14 13:19:29 nakashim Exp nakashim $";
d59 1
d236 1
a236 1
  if (addr < DMA_BASE2_PHYS) { /* error */
a237 1
  }
d239 10
a248 12
    switch (type) { case 8:/* load */
                      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
                                             else                         val[0] = *(Uint*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)); break;
                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
                                             else                         val[0] = *(Ull *)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)); break;
                                      default:printf("%03.3d:emax6_ctl: dma_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                    case 9:/* store */
		      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
                                             else                         *(Uint*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)) = val[0]; break;
                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
                                             else                         *(Ull *)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)) = val[0]; break;
                                      default:printf("%03.3d:emax6_ctl: dma_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d252 10
a261 12
    switch (type) { case 8:/* load */
                      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: reg_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
                                             else                         val[0] = *(Uint*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)); break;
                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: reg_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
                                             else                         val[0] = *(Ull *)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)); break;
		                      default:printf("%03.3d:emax6_ctl: reg_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                    case 9:/* store */
		      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: reg_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                             else                         *(Uint*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)) = val[0]; break;
		                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: reg_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
				             else                         *(Ull *)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)) = val[0]; break;
		                      default:printf("%03.3d:emax6_ctl: reg_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
a265 4
                                                  /*           REG_BREG_OFFS    0x00004000 */
                                                  /*           REG_ADDR_OFFS    0x00006000 */
                                                  /*           REG_LDDM_OFFS    0x00008000 */
                                                  /*           REG_AREA_SIZE    0x0000a000 */
d269 6
a274 8
    for (p_row=0; p_row<EMAX_DEPTH; p_row++)
      if (exring[cid].unit[p_row].l_row == i) break; /* 論理row==iを検索 */
    switch (type) { case 9:/* store */
		      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                             else                         *(Uint*)((Uchar*)&reg_ctrl.conf[p_row]+j) = val[0]; break;
			              case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: conf_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
		                             else                         *(Ull *)((Uchar*)&reg_ctrl.conf[p_row]+j) = val[0]; break;
                                      default:printf("%03.3d:emax6_ctl: conf_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
a277 1
                                                  /*           REG_CONF_OFFS    0x00002000 */
a278 3
                                                  /*           REG_ADDR_OFFS    0x00006000 */
                                                  /*           REG_LDDM_OFFS    0x00008000 */
                                                  /*           REG_AREA_SIZE    0x0000a000 */
d282 8
a289 10
    for (p_row=0; p_row<EMAX_DEPTH; p_row++)
      if (exring[cid].unit[p_row].l_row == i) break; /* 論理row==iを検索 */
    switch (type) { case 9:/* store */
		      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: breg_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                             else *(Uint*)((Uchar*)&exring[cid].unit[p_row].b[0]+j) = val[0]; /* BREG定数初期化はdouble-buffer両面に必要 */
					          *(Uint*)((Uchar*)&exring[cid].unit[p_row].b[1]+j) = val[0]; break;
			              case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: breg_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
		                             else *(Ull *)((Uchar*)&exring[cid].unit[p_row].b[0]+j) = val[0]; /* BREG定数初期化はdouble-buffer両面に必要 */
				                  *(Ull *)((Uchar*)&exring[cid].unit[p_row].b[1]+j) = val[0]; break;
                                      default:printf("%03.3d:emax6_ctl: breg_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
a292 2
                                                  /*           REG_CONF_OFFS    0x00002000 */
                                                  /*           REG_BREG_OFFS    0x00004000 */
a293 2
                                                  /*           REG_LDDM_OFFS    0x00008000 */
                                                  /*           REG_AREA_SIZE    0x0000a000 */
d297 6
a302 8
    for (p_row=0; p_row<EMAX_DEPTH; p_row++)
      if (exring[cid].unit[p_row].l_row == i) break; /* 論理row==iを検索 */
    switch (type) { case 9:/* store */
		      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: addr_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                             else                         *(Uint*)((Uchar*)&reg_ctrl.addr[p_row]+j) = val[0]; break;
			              case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: addr_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
		                             else                         *(Ull *)((Uchar*)&reg_ctrl.addr[p_row]+j) = val[0]; break;
                                      default:printf("%03.3d:emax6_ctl: addr_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
a305 3
                                                  /*           REG_CONF_OFFS    0x00002000 */
                                                  /*           REG_BREG_OFFS    0x00004000 */
                                                  /*           REG_ADDR_OFFS    0x00006000 */
a306 1
                                                  /*           REG_AREA_SIZE    0x0000a000 */
d310 11
a320 14
    for (p_row=0; p_row<EMAX_DEPTH; p_row++)
      if (exring[cid].unit[p_row].l_row == i) break; /* 論理row==iを検索 */
    switch (type) { case 8:/* load */
                      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
                                             else                         val[0] = *(Uint*)((Uchar*)&reg_ctrl.lddmrw[p_row]+j); break;
                                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
                                             else                         val[0] = *(Ull *)((Uchar*)&reg_ctrl.lddmrw[p_row]+j); break;
		                      default:printf("%03.3d:emax6_ctl: lddmrw_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                    case 9:/* store */
		      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                             else                         *(Uint*)((Uchar*)&reg_ctrl.lddmrw[p_row]+j) = val[0]; break;
		                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
				             else                         *(Ull *)((Uchar*)&reg_ctrl.lddmrw[p_row]+j) = val[0]; break;
		                      default:printf("%03.3d:emax6_ctl: lddmrw_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d326 2
a327 5
    for (p_row=0; p_row<EMAX_DEPTH; p_row++) {
      /*printf("%03.3d:emax6_ctl: addr=%08.8x ofs=%08.8x top=%08.8x bot=%08.8x\n", tid, addr, ofs, reg_ctrl.addr[p_row][j].top, reg_ctrl.addr[p_row][j].bot);*/
      if (reg_ctrl.addr[p_row][j].top<=ofs && ofs<=reg_ctrl.addr[p_row][j].bot)
	break; /* range一致を検索 */
    }
d330 10
a339 12
      switch (type) { case 8:/* load */
                        switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                               else                         val[0] = *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]); break;
		                        case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
			  	               else                         val[0] = *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]); break;
		                        default:printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                      case 9:/* store */
	  	        switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                               else                         *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0]; break;
		                        case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
				               else                         *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0]; break;
		                        default:printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d392 1
a392 1
  busy = 0;
d402 11
d419 1
d459 1
d1695 2
a1696 2
      printf("|v%d op%02.2x_%x_%x e1/2/3=%x_%d%d/%x_%d/%x_%d 2i%08.8x%08.8x_%d 3i%02.2x_%d",
             (Uint) reg_ctrl.conf[row][col].cdw0.v,
@


1.264
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.263 2017/08/14 07:55:27 nakashim Exp nakashim $";
d687 7
a693 3
        exring[cid].unit[i].cmd = CMD_EXEC;
        if (exring[cid].unit[i].l_row == 0)
          exring[cid].unit[i].unit1_exec = 1;
d754 1
a754 1
      if (!reg_ctrl.conf[i][0].cdw0.v || exring[cid].unit[i].unit2_stop)
@


1.263
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.262 2017/08/13 13:32:33 nakashim Exp nakashim $";
d750 1
a750 1
      if (exring[cid].unit[i].unit2_stop)
d756 3
a758 3
      unit1_exec_next = exring[cid].unit[i].unit1_exec     | (exring[cid].unit[i].l_row>0 && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_exec);
      unit1_stop_next = exring[cid].unit[i].unit1_arb_prev | (exring[cid].unit[i].l_row>0 && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_stop);
      unit2_exec_next = exring[cid].unit[i].unit1_exec     | (                               exring[cid].unit[ i                         ].unit2_exec);
d1712 2
a1713 1
      printf("|op=%02.2x_%x_%x e1=%x_%d%d e2=%x_%d e3=%x_%d 2i%08.8x%08.8x_%d 3i%02.2x_%d",
@


1.262
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.261 2017/08/13 08:24:57 nakashim Exp nakashim $";
d605 1
a605 1
  /*                                                      Ascon1  Ascon1  Ascon1  Ascon1  Ascon2  Ascon2  Ascon2  Ascon2                                                                    */
d705 1
a705 1
      unit1_exec_next = (exring[cid].unit[i].scon_count == 1) ? 0 : 1;
d708 2
a709 1
	exring[cid].unit[i].l_row--; /* adjust l_row */
d1367 1
a1367 1
  /*                                                      Ascon1  Ascon1  Ascon1  Ascon1  Ascon2  Ascon2  Ascon2  Ascon2                                                                    */
d1933 1
a1933 1
             ||(reg_ctrl.conf[row][0].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[i][1].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[i][2].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[i][3].cdw1.ea0op == OP_STRQ)) {
@


1.261
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.260 2017/08/13 06:34:43 nakashim Exp nakashim $";
d377 1
a377 1
      printf("%03.3d:emax6_ctl: no lmm covers addr=%08.8x\n", tid, addr);
@


1.260
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.259 2017/08/13 06:05:32 nakashim Exp nakashim $";
d1154 2
d1159 4
a1162 8
      exring[cid].unit[i].ex4dr_prev = exring[cid].unit[i].ex4dr; /* siml-loop only */
      exring[cid].unit[i].ex4dr      = exring[cid].unit[i].ex3dr;
      if ((exring[cid].unit[i].cycle & 3) == 3) {
        exring[cid].unit[i].unit1_arb_prev = exring[cid].unit[i].unit1_arbrk;
        exring[cid].unit[i].unit1_arbrk    = exring[cid].unit[i].ex3dbrk;
      }
      else {
        exring[cid].unit[i].unit1_arb_prev = exring[cid].unit[i].unit1_arbrk;
a1163 1
      }
d1179 1
a1190 1
      exring[cid].unit[i].ea04dr_prev = exring[cid].unit[i].ea04dr; /* siml-loop only */
a1207 1
      exring[cid].unit[i].ea04dr_prev = exring[cid].unit[i].ea04dr; /* siml-loop only */
d1288 1
a1299 1
      exring[cid].unit[i].ea14dr_prev = exring[cid].unit[i].ea14dr; /* siml-loop only */
a1311 1
      exring[cid].unit[i].ea14dr_prev = exring[cid].unit[i].ea14dr; /* siml-loop only */
@


1.259
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.258 2017/08/12 08:53:30 nakashim Exp nakashim $";
d1329 10
a1338 6
      if (exring[cid].unit[i].lmlddmqw_ok && br->col == j) {
        exring[cid].unit[i].tx4dr[0] = exring[cid].unit[i].lmwd[0];
        exring[cid].unit[i].tx4dr[1] = exring[cid].unit[i].lmwd[1];
        exring[cid].unit[i].tx4dr[2] = exring[cid].unit[i].lmwd[2];
        exring[cid].unit[i].tx4dr[3] = exring[cid].unit[i].lmwd[3];
        exring[cid].unit[i].tr_valid = 1;
d1340 1
a1340 3
      else if (reg_ctrl.conf[i][j].cdw2.trs0==0) /* no data for OP_LDDMQ */
        exring[cid].unit[i].tr_valid = 0;
      else {
@


1.258
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.257 2017/08/12 02:24:57 nakashim Exp nakashim $";
d91 1
d625 3
d632 1
d708 2
a709 2
        exring[cid].unit[i].l_row--; /* adjust l_row */
        exring[cid].unit[i].scon_count--;
d749 1
a749 1
      if (exring[cid].unit[i].unit1_stop)
d752 1
a752 1
        exring[cid].unit[i].one_shot = 1;
d754 5
a758 5
        exring[cid].unit[i].one_shot = 0;
      unit1_exec_next =                                   exring[cid].unit[i].unit1_exec | exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_exec;
      unit1_stop_next = exring[cid].unit[i].unit1_arbrk | exring[cid].unit[i].unit1_stop | exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_stop;
      unit2_exec_next =                                   exring[cid].unit[i].unit1_exec | exring[cid].unit[ i                         ].unit2_exec;
      unit2_stop_next =                                   exring[cid].unit[i].unit1_stop | exring[cid].unit[ i                         ].unit2_stop;
d1097 1
d1128 24
a1151 23
    exring[cid].unit[i].ex4dr_prev  = 0LL; /* siml-loop only */
    exring[cid].unit[i].ex4dr       = 0LL;
    exring[cid].unit[i].unit1_arbrk = 0;
    exring[cid].unit[i].ea04dr_prev = 0; /* siml-loop only */
    exring[cid].unit[i].ea04dr      = 0;
    exring[cid].unit[i].ea14dr_prev = 0; /* siml-loop only */
    exring[cid].unit[i].ea14dr      = 0;
    exring[cid].unit[i].tx4dr[0]    = 0LL;
    exring[cid].unit[i].tx4dr[1]    = 0LL;
    exring[cid].unit[i].tx4dr[2]    = 0LL;
    exring[cid].unit[i].tx4dr[3]    = 0LL;
    exring[cid].unit[i].tr_valid    = 0;
    exring[cid].unit[i].lmm.en0     = 0;
    exring[cid].unit[i].lmm.en1     = 0;
    exring[cid].unit[i].lmm.rw0     = 0;
    exring[cid].unit[i].lmm.rw1     = 0;
    exring[cid].unit[i].lmm.ma0     = 0;
    exring[cid].unit[i].lmm.ma1     = 0;
    exring[cid].unit[i].lmm.mm0     = 0;
    exring[cid].unit[i].lmm.mw0[0]  = 0LL;
    exring[cid].unit[i].lmm.mw0[1]  = 0LL;
    exring[cid].unit[i].lmm.mw0[2]  = 0LL;
    exring[cid].unit[i].lmm.mw0[3]  = 0LL;
d1159 6
a1164 3
      if ((exring[cid].unit[i].cycle & 3) == 3)
        exring[cid].unit[i].unit1_arbrk  = exring[cid].unit[i].ex3dbrk;
      else
d1166 1
@


1.257
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.256 2017/08/09 14:02:37 nakashim Exp nakashim $";
d352 1
a352 1
    ofs = addr-emax_info.lmm_mmap+emax_info.ddr_mmap; /* LMM_MAP_TOP->membase */
d354 20
a373 15
    for (p_row=0; p_row<EMAX_DEPTH; p_row++)
      if (reg_ctrl.addr[p_row][j].top<=ofs && ofs<=reg_ctrl.addr[p_row][j].bot) break; /* range一致を検索 */
    ofs = ofs % LMEM_SIZE;
    switch (type) { case 8:/* load */
                      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                             else                         val[0] = *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]); break;
		                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
				             else                         val[0] = *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]); break;
		                      default:printf("%03.3d:emax6_ctl: lmm_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd);  break; } break;
                    case 9:/* store */
		      switch (opcd) { case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
		                             else                         *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0]; break;
		                      case 3:if (addr & (sizeof(Ull )-1)) printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
				             else                         *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0]; break;
		                      default:printf("%03.3d:emax6_ctl: lmm_space store: opcd=%d (should be STRW/STR)\n", tid, opcd); break; } break;
d375 2
d1763 1
a1763 1
    printf(" l_row=%02.2d scan_count=%03.3d one_shot=%d u1exec=%d u1stop=%d u2exec=%d u2stop=%d\n",
d1767 4
a1770 4
	   exring[cid].unit[row].unit1_exec,
	   exring[cid].unit[row].unit1_stop,
	   exring[cid].unit[row].unit2_exec,
	   exring[cid].unit[row].unit2_stop);
d1804 1
a1804 1
    printf("-stage2-out: cx2dr=%x ex2dr=%08.8x%08.8x ex2dbrk=%d                         ea12dr=%05.5x                      ea02dr=%05.5x    st3ex=%d",
d1807 1
a1807 1
           exring[cid].unit[row].ex2dbrk,
d1818 1
a1818 1
    printf("-stage3-out: cx3dr=%x ex3dr=%08.8x%08.8x ex3dbrk=%d                         ea13dr=%05.5x                      ea03dr=%05.5x    st4ex=%d",
d1821 1
a1821 1
           exring[cid].unit[row].ex3dbrk,
d1832 1
a1832 1
    printf("-stage4-out:         ex4dr=%08.8x%08.8x u1arbrk=%d",
d1834 1
a1834 1
           exring[cid].unit[row].unit1_arbrk);
d1911 1
a1911 1
	  if (i==0) printf(" lm%d(%d):%08.8x", col, lmm_mode, top);
d1917 1
a1917 1
	  if (i==0) printf(" lm%d(%d):%08.8x", col, lmm_mode, bot);
d1927 1
a1927 1
	  if (i==0) printf(" lm%d(%d):%08.8x", col, lmm_mode, top);
d1933 1
a1933 1
	  if (i==0) printf(" lm%d(%d):%08.8x", col, lmm_mode, bot);
@


1.256
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.255 2017/08/08 22:39:25 nakashim Exp nakashim $";
d1169 1
a1169 1
      switch (conf[i][exring[cid].unit[i].lmco].cdw2.lmm_mode) {
d1187 1
a1187 1
      switch (conf[i][j].cdw2.lmm_mode) {
d1279 1
a1279 1
      switch (conf[i][exring[cid].unit[i].lmco].cdw2.lmm_mode) {
d1292 1
a1292 1
      switch (conf[i][j].cdw2.lmm_mode) {
d1754 1
a1754 1
    /* show exring */
d1796 1
d1810 1
d1824 1
d1889 1
a1890 1

d1892 8
a1899 1
      Uint top, bot; /* 18bits */
d1902 10
a1911 4
	for (i=0; i<16; i++) {
	  printf("-%08.8x%08.8x", *((Ull*)&exring[cid].unit[row].lmm.m[0]+i));
	  if (i%4==3)
	    printf("\n");
d1913 1
d1918 3
a1920 3
	printf(" lmm%d(mode%d):top/bot=%08.8x/%08.8x\n", col, conf[row][col].cdw2.lmm_mode, reg_ctrl.addr[row][col].top, reg_ctrl.addr[row][col].bot);
	for (i=0; i<16; i++) {
	  top = (reg_ctrl.addr[row][col].top+sizeof(Ull)*i)%LMEM_SIZE;
a1921 2
	  if (i%4==3)
	    printf("\n");
d1923 4
a1926 2
	for (i=0; i<16; i++) {
	  bot = (reg_ctrl.addr[row][col].bot+LMEM_SIZE-sizeof(Ull)*(15-i))%LMEM_SIZE;
a1927 2
	  if (i%4==3)
	    printf("\n");
d1929 1
d1948 1
a1948 1
    printf(" lmrd=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1954 1
a1954 3
    printf(" brval=%d ", 
             exring[cid].unit[row].brout_valid);

d1956 1
a1956 1
      printf(" b0%d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1963 2
d1966 1
a1966 1
      printf(" b1%d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1973 1
d1975 1
a1975 1
    printf(" fl2-btop-bbot=%d-%d-%d\n",
d1981 1
@


1.255
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.254 2017/08/04 09:30:02 nakashim Exp nakashim $";
d274 2
a275 2
    i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* 128B*64=8K  */
    j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* 128B/column */
d280 1
a280 1
		                             else                         *(Uint*)((Uchar*)&reg_ctrl.conf[p_row][j]) = val[0]; break;
d282 1
a282 1
		                             else                         *(Ull *)((Uchar*)&reg_ctrl.conf[p_row][j]) = val[0]; break;
d293 2
a294 2
    i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* 128B*64=8K  */
    j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* 128B/column */
d314 2
a315 2
    i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* 128B*64=8K  */
    j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* 128B/column */
d320 1
a320 1
		                             else                         *(Uint*)((Uchar*)&reg_ctrl.addr[p_row][j]) = val[0]; break;
d322 1
a322 1
		                             else                         *(Ull *)((Uchar*)&reg_ctrl.addr[p_row][j]) = val[0]; break;
d333 2
a334 2
    i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* 128B*64=8K  */
    j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH); /* 128B/column */
d339 1
a339 1
                                             else                         val[0] = *(Uint*)((Uchar*)&reg_ctrl.lddmrw[p_row][j]); break;
d341 1
a341 1
                                             else                         val[0] = *(Ull *)((Uchar*)&reg_ctrl.lddmrw[p_row][j]); break;
d345 1
a345 1
		                             else                         *(Uint*)((Uchar*)&reg_ctrl.lddmrw[p_row][j]) = val[0]; break;
d347 1
a347 1
				             else                         *(Ull *)((Uchar*)&reg_ctrl.lddmrw[p_row][j]) = val[0]; break;
d428 7
a434 2
  if ((exring[cid].cycle & 3) == 3 && reg_ctrl.cmd == CMD_RESET)
    exring[cid].cycle = 0;
a437 3
  if ((exring[cid].cycle & 3) == 3)
    reg_ctrl.cmd = CMD_NOP;

@


1.254
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.253 2017/08/03 07:06:38 nakashim Exp nakashim $";
d135 1
a135 1
    Ull   lmco          : 2; /* wire *//* -> conf.lmm_mode */
d996 1
a996 1
  Ull   lmco          : 2; /* wire *//* -> conf.lmm_mode */
d1038 1
a1038 1
  exring[cid].unit[i].lmco    = br->col;  /* wire *//* -> conf.lmm_mode */
d1663 3
a1665 3
  /* show lmring */
  printf("=LMRING[%02.2d] busy=%d            axiarr-arv-arl-ara    =%d-%d-%08.8x-%08.8x          v_d=%d-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         cid, axiif[cid].busy, axiif[cid].axi_arready, axiif[cid].axi_arvalid, (Uint)axiif[cid].axi_arlen, (Uint)axiif[cid].axi_araddr, axiif[cid].axi_rvalid,
d1668 2
a1669 2
  printf("                              axiawr-awv-awl-awa-stb=%d-%d-%08.8x-%08.8x-%08.8x v_d=%d-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         cid, axiif[cid].axi_awready, axiif[cid].axi_awvalid, (Uint)axiif[cid].axi_awlen, (Uint)axiif[cid].axi_awaddr, axiif[cid].axi_wstrb, axiif[cid].axi_wvalid,
d1681 1
a1681 1
    printf(" xbr[%d].rw-ty-col-sq=%d-%d-%d-%04.4x a-dm=%08.8x-%08.8x   d=  %08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
a1687 1
  /* show conf */
d1689 1
d1730 1
a1730 1
      printf("|ts3-0=%x%x%x%x trs3-0=%x%x%x%x mwsa_3-0%d_%x%x%x%x brs3-0=%x%x%x%x md=%d lm=%d",
d1754 1
a1754 1
    printf(" l_row=%02.2d sc=%03.3d os=%d u1ex=%d u1st=%d u2ex=%d u2st=%d\n",
d1762 11
a1772 1
    printf(" cx=%d%d%d%d ex1=%08.8x%08.8x ex2=%08.8x%08.8x ex3=%08.8x%08.8x\n",
d1780 3
a1782 1
    printf(" eab=%08.8x eao=%08.8x ea0b=%08.8x eao0=%08.8x ea1b=%08.8x ea1o=%08.8x st2ex=%d\n",
a1786 2
           exring[cid].unit[row].ea1b,
           exring[cid].unit[row].ea1o,
d1788 1
a1788 1
    printf(" tx3210=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1794 1
a1794 1
    printf("-stage2-out: cx2dr=%x ex2dr=%08.8x%08.8x ex2dbrk=%d ea02dr=%08.8x ea12dr=%08.8x st3ex=%d\n",
d1798 1
a1799 1
           (Uint)exring[cid].unit[row].ea12dr,
d1807 1
a1807 1
    printf("-stage3-out: cx3dr=%x ex3dr=%08.8x%08.8x ex3dbrk=%d ea03dr=%08.8x ea13dr=%08.8x st4ex=%d\n",
d1811 1
a1812 1
           exring[cid].unit[row].ea13dr,
d1820 1
a1820 1
    printf("-stage4-out: ex4dr=%08.8x%08.8x u1arbrk=%d trv=%d\n",
d1822 5
a1826 3
           exring[cid].unit[row].unit1_arbrk,
	   exring[cid].unit[row].tr_valid);
    printf(" ea04um=%x ea04lm=%08.8x ea04dr=%08.8x ea14um=%x ea14lm=%08.8x ea14dr=%08.8x\n",
d1830 1
a1830 3
           exring[cid].unit[row].ea14_umask,
           exring[cid].unit[row].ea14_lmask,
           exring[cid].unit[row].ea14dr);
d1836 14
a1849 1
    printf(" mwmux=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1854 9
a1862 4
    printf(" lmm.en1-rw1-ma1=%d-%d-%08.8x en0-rw0-ma0-mm0=%d-%d-%08.8x-%08.8x\n",
           exring[cid].unit[row].lmm.en1,
           exring[cid].unit[row].lmm.rw1,
           exring[cid].unit[row].lmm.ma1,
d1866 1
a1866 2
           exring[cid].unit[row].lmm.mm0);
    printf(" mw0=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1871 1
a1871 11
    printf(" rrok=%d rwok=%d ddok=%d strq=%d ea1bsy=%d ea0bsy=%d rful=%d deqw=%d ful1=%d\n",
           exring[cid].unit[row].lmranger_ok,
           exring[cid].unit[row].lmrangew_ok,
           exring[cid].unit[row].lmlddmqw_ok,
           exring[cid].unit[row].lmea0strq,
           exring[cid].unit[row].lmring_ea1bsy,
           exring[cid].unit[row].lmring_ea0bsy,
           exring[cid].unit[row].lmring_ful,
           exring[cid].unit[row].deq_wait,
           exring[cid].unit[row].lmring_ful1);
    printf(" lmrtr.rw-ty-col-sq=%d-%d-%d-%04.4x a=%08.8x dm=%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x pass=%d\n",
d1876 1
d1878 1
a1878 1
           exring[cid].unit[row].lmring_tr.dm ,
d1882 32
a1913 10
           (Uint)(exring[cid].unit[row].lmring_tr.d[0]>>32), (Uint)exring[cid].unit[row].lmring_tr.d[0],
           exring[cid].unit[row].lmring_tr.pass);
    printf(" lmco=%d lmca=%08.8x lmwm=%08.8x lmwd=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           exring[cid].unit[row].lmco,
           exring[cid].unit[row].lmca,
           exring[cid].unit[row].lmwm,
           (Uint)(exring[cid].unit[row].lmwd[3]>>32), (Uint)exring[cid].unit[row].lmwd[3],
           (Uint)(exring[cid].unit[row].lmwd[2]>>32), (Uint)exring[cid].unit[row].lmwd[2],
           (Uint)(exring[cid].unit[row].lmwd[1]>>32), (Uint)exring[cid].unit[row].lmwd[1],
           (Uint)(exring[cid].unit[row].lmwd[0]>>32), (Uint)exring[cid].unit[row].lmwd[0]);
d1915 1
a1915 8
    printf("-stage5-out: brv=%d\n", 
             exring[cid].unit[row].brout_valid);
    printf(" mr1mux-mr1d-mr0mux-mr0d=%d-%08.8x%08.8x-%d-%08.8x%08.8x\n",
           exring[cid].unit[row].mr1mux,
           (Uint)(exring[cid].unit[row].mr1d>>32), (Uint)exring[cid].unit[row].mr1d,
           exring[cid].unit[row].mr0mux,
           (Uint)(exring[cid].unit[row].mr0d>>32), (Uint)exring[cid].unit[row].mr0d);
    printf(" mr1=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1920 1
a1920 1
    printf(" mr0=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1925 6
a1930 1
    printf(" lmrd=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
d1935 6
a1940 2
    for (col=EMAX_WIDTH-1; col>=0; col--) {
      printf(" b0%d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
d1947 2
a1948 3
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--) {
      printf(" b1%d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
a1954 1
    printf("\n");
d1956 1
a1956 1
    printf(" ful2-btop-bbot=%d-%d-%d\n",
@


1.253
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.252 2017/07/30 06:25:34 nakashim Exp nakashim $";
d1664 2
a1665 2
  printf("==== LMRING[%02.2d] bsy=%d axiarr-arv-ara-arl=%d-%d-%08.8x-%08.8x rval-rdata=%d-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         cid, axiif[cid].busy, axiif[cid].axi_arready, axiif[cid].axi_arvalid, (Uint)axiif[cid].axi_araddr, (Uint)axiif[cid].axi_arlen, axiif[cid].axi_rvalid,
d1668 2
a1669 2
  printf("     axiawr-awv-awa-awl=%d-%d-%08.8x-%08.8x wstb=%08.8x wval-wdata=%d-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         cid, axiif[cid].axi_awready, axiif[cid].axi_awvalid, (Uint)axiif[cid].axi_awaddr, (Uint)axiif[cid].axi_awlen, axiif[cid].axi_wstrb, axiif[cid].axi_wvalid,
d1673 1
a1673 1
  printf(" ful2-btop-bbot=%d-%d-%d ilen=%08.8x \n",
d1680 2
a1681 1
    printf(" xbr[%d].rw-ty-col-sq=%d-%d-%d-%04.4x a-dm=%08.8x-%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1691 2
a1692 2
      printf("         ---- conf[%d][%d]                                            ", row, col);
    printf("cdw0    ");
d1694 1
a1694 1
      printf("|op123=%02.2x_%x_%x ex1=%x_%d%d ex2=%x_%d ex3=%x_%d e2i%08.8x%08.8x_%d e3i%02.2x_%d",
a1710 1
    printf("cdw1    ");
d1712 1
a1712 1
      printf("|cop=%x%x%x%x_%04.4x ea1=%02.2x_%d_%d_%x ea0=%02.2x_%d_%d_%x eab=%x eao=%x                ",
a1728 1
    printf("cdw2    ");
d1730 1
a1730 1
      printf("|ts3-0=%x%x%x%x trs3-0=%x%x%x%x mwsa%d mws3-0=%x%x%x%x brs3-0=%x%x%x%x mapd=%d lmmm=%d ",
d1753 10
a1762 15
    printf("         ---- cmd=%d cycle=%d\n", exring[cid].unit[row].cmd, exring[cid].unit[row].cycle);
    printf("l_row=%02.2d sc=%03.3d os=%d u1ex=%d u1st=%d trv=%d u2ex=%d u2st=%d brv=%d\n",
             exring[cid].unit[row].l_row,
             exring[cid].unit[row].scon_count,
             exring[cid].unit[row].one_shot,
             exring[cid].unit[row].unit1_exec,
             exring[cid].unit[row].unit1_stop,
             exring[cid].unit[row].tr_valid,
             exring[cid].unit[row].unit2_exec,
             exring[cid].unit[row].unit2_stop,
             exring[cid].unit[row].brout_valid);
    printf("st2ex=%d st3ex=%d st4ex=%d cx=%d%d%d%d cx2dr=%x cx3dr=%x ex1=%08.8x%08.8x ex2=%08.8x%08.8x ex3=%08.8x%08.8x\n",
           exring[cid].unit[row].stage2_exec,
           exring[cid].unit[row].stage3_exec,
           exring[cid].unit[row].stage4_exec,
a1766 2
           exring[cid].unit[row].cx2dr,
           exring[cid].unit[row].cx3dr,
d1770 1
a1770 8
    printf("ex2dr=%08.8x%08.8x ex2dbrk=%d ex3dr=%08.8x%08.8x ex3dbrk=%d ex4dr=%08.8x%08.8x u1arbrk=%d\n",
           (Uint)(exring[cid].unit[row].ex2dr>>32), (Uint)exring[cid].unit[row].ex2dr,
           exring[cid].unit[row].ex2dbrk,
           (Uint)(exring[cid].unit[row].ex3dr>>32), (Uint)exring[cid].unit[row].ex3dr,
           exring[cid].unit[row].ex3dbrk,
           (Uint)(exring[cid].unit[row].ex4dr>>32), (Uint)exring[cid].unit[row].ex4dr,
           exring[cid].unit[row].unit1_arbrk);
    printf("eab=%08.8x eao=%08.8x ea0b=%08.8x eao0=%08.8x ea1b=%08.8x ea1o=%08.8x ea02dr=%08.8x ea12dr=%08.8x ea03dr=%08.8x ea13dr=%08.8x\n",
d1777 2
a1778 12
           (Uint)exring[cid].unit[row].ea02dr,
           (Uint)exring[cid].unit[row].ea12dr,
           exring[cid].unit[row].ea03dr,
           exring[cid].unit[row].ea13dr);
    printf("ea04um=%x ea04lm=%08.8x ea04dr=%08.8x ea14um=%x ea14lm=%08.8x ea14dr=%08.8x\n",
           exring[cid].unit[row].ea04_umask,
           exring[cid].unit[row].ea04_lmask,
           exring[cid].unit[row].ea04dr,
           exring[cid].unit[row].ea14_umask,
           exring[cid].unit[row].ea14_lmask,
           exring[cid].unit[row].ea14dr);
    printf("tx3210=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1783 9
a1791 1
    printf("tx2dr3210=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1796 9
a1804 1
    printf("tx3dr3210=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1809 13
a1821 1
    printf("tx4dr3210=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1826 19
a1844 1
    printf("rrok=%d rwok=%d ddok=%d strq=%d ea1bsy=%d ea0bsy=%d rful=%d deqw=%d ful1=%d\n",
d1854 1
a1854 1
    printf("lmrtr.rw-ty-col-sq=%d-%d-%d-%04.4x a=%08.8x dm=%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x pass=%d\n",
d1866 1
a1866 1
    printf("lmco=%d lmca=%08.8x lmwm=%08.8x lmwd=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
d1874 8
a1881 18
    printf(" lmrd=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
           (Uint)(exring[cid].unit[row].lmrd[3]>>32), (Uint)exring[cid].unit[row].lmrd[3],
           (Uint)(exring[cid].unit[row].lmrd[2]>>32), (Uint)exring[cid].unit[row].lmrd[2],
           (Uint)(exring[cid].unit[row].lmrd[1]>>32), (Uint)exring[cid].unit[row].lmrd[1],
           (Uint)(exring[cid].unit[row].lmrd[0]>>32), (Uint)exring[cid].unit[row].lmrd[0]);
    printf(" mwmux=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           (Uint)(exring[cid].unit[row].mwmux[3]>>32), (Uint)exring[cid].unit[row].mwmux[3],
           (Uint)(exring[cid].unit[row].mwmux[2]>>32), (Uint)exring[cid].unit[row].mwmux[2],
           (Uint)(exring[cid].unit[row].mwmux[1]>>32), (Uint)exring[cid].unit[row].mwmux[1],
           (Uint)(exring[cid].unit[row].mwmux[0]>>32), (Uint)exring[cid].unit[row].mwmux[0]);
    printf("lmm.en1-rw1-ma1=%d-%d-%08.8x en0-rw0-ma0-mm0=%d-%d-%08.8x-%08.8x\n",
           exring[cid].unit[row].lmm.en1,
           exring[cid].unit[row].lmm.rw1,
           exring[cid].unit[row].lmm.ma1,
           exring[cid].unit[row].lmm.en0,
           exring[cid].unit[row].lmm.rw0,
           exring[cid].unit[row].lmm.ma0,
           exring[cid].unit[row].lmm.mm0);
a1886 5
    printf(" mw0=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
           (Uint)(exring[cid].unit[row].lmm.mw0[3]>>32), (Uint)exring[cid].unit[row].lmm.mw0[3],
           (Uint)(exring[cid].unit[row].lmm.mw0[2]>>32), (Uint)exring[cid].unit[row].lmm.mw0[2],
           (Uint)(exring[cid].unit[row].lmm.mw0[1]>>32), (Uint)exring[cid].unit[row].lmm.mw0[1],
           (Uint)(exring[cid].unit[row].lmm.mw0[0]>>32), (Uint)exring[cid].unit[row].lmm.mw0[0]);
d1892 5
a1896 6
    printf("mr1mux-mr1d-mr0mux-mr0d=%d-%08.8x%08.8x-%d-%08.8x%08.8x\n",
           exring[cid].unit[row].mr1mux,
           (Uint)(exring[cid].unit[row].mr1d>>32), (Uint)exring[cid].unit[row].mr1d,
           exring[cid].unit[row].mr0mux,
           (Uint)(exring[cid].unit[row].mr0d>>32), (Uint)exring[cid].unit[row].mr0d);

d1898 1
a1898 1
      printf(" b[0][%d]=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
d1905 1
d1907 1
a1907 1
      printf(" b[1][%d]=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
d1914 1
@


1.252
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.251 2017/07/30 06:21:58 nakashim Exp nakashim $";
d339 1
a339 1
                                             else                         val[0] = *(Uint*)((Uchar*)&reg_ctrl.lddmrw[p_row][j]);
d341 1
a341 1
                                             else                         val[0] = *(Ull *)((Uchar*)&reg_ctrl.lddmrw[p_row][j]);
d359 1
a359 1
		                             else                         val[0] = *((Uint*)&exring[cid].unit[p_row].lmm.m[ofs]);
d361 1
a361 1
				             else                         val[0] = *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]);
d367 1
a367 1
				             else                         *((Ull *)&exring[cid].unit[p_row].lmm.m[ofs]) = val[0];  break;
@


1.251
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.250 2017/07/26 01:28:30 nakashim Exp nakashim $";
d419 1
a419 1
  for (i=(row0+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
@


1.250
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.249 2017/07/25 07:19:12 nakashim Exp nakashim $";
d45 1
d48 1
a48 1
    Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
d54 1
a54 1
  } axring_br[2];          /* reg */
d164 1
d173 1
a173 1
    } lmring_br[3]         ; /* reg */
d231 2
a232 1
  Uint cid    = tid2cid(tid);
d237 132
a368 56
  else if (addr < REG_BASE2_PHYS) { /* dma space */
    switch (type) {
    case 8:/* load */
      switch (opcd) {
      case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
             else                         val[0] = *(Uint*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS));    break;
      case 3:if (addr & (sizeof(Ull)-1))  printf("%03.3d:emax6_ctl: dma_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
             else                         val[0] = *(Ull*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS));     break;
      default:printf("%03.3d:emax6_ctl: dma_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd); break;
      }
      break;
    case 9:/* store */
      switch (opcd) {
      case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: dma_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
             else                         *(Uint*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)) = val[0];    break;
      case 3:if (addr & (sizeof(Ull)-1))  printf("%03.3d:emax6_ctl: dma_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
             else                         *(Ull*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)) = val[0];     break;
      default:printf("%03.3d:emax6_ctl: dma_space store: opcd=%d (should be STRW/STR)\n", tid, opcd);break;
      }
      break;
    }
  }
  else if (addr < REG_BASE2_PHYS+REG_BASE2_SIZE) { /* reg space */
    switch (type) {
    case 8:/* load */
      switch (opcd) {
      case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: reg_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
             else                         val[0] = *(Uint*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS));    break;
      case 3:if (addr & (sizeof(Ull)-1))  printf("%03.3d:emax6_ctl: reg_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
             else                         val[0] = *(Ull*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS));          break;
      default:printf("%03.3d:emax6_ctl: reg_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd); break;
      }
      break;
    case 9:/* store */
      switch (opcd) {
      case 2:if      (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl: reg_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
             else if (addr >= REG_BASE2_PHYS+REG_REGV_BRBASE && addr <= REG_BASE2_PHYS+REG_REGV_BREND) { /* breg write only */
               int ofs = addr-(REG_BASE2_PHYS+REG_REGV_BRBASE);
               int i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
               int j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
               *(Uint*)((Uchar*)&exring[cid].unit[i].b[0]+j) = val[0];
               *(Uint*)((Uchar*)&exring[cid].unit[i].b[1]+j) = val[0];
             }
             else                         *(Uint*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)) = val[0];    break;
      case 3:if      (addr & (sizeof(Ull)-1))  printf("%03.3d:emax6_ctl: reg_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
             else if (addr >= REG_BASE2_PHYS+REG_REGV_BRBASE && addr <= REG_BASE2_PHYS+REG_REGV_BREND) { /* breg write only */
               int ofs = addr-(REG_BASE2_PHYS+REG_REGV_BRBASE);
               int i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
               int j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
               *(Ull*)((Uchar*)&exring[cid].unit[i].b[0]+j) = val[0];
               *(Ull*)((Uchar*)&exring[cid].unit[i].b[1]+j) = val[0];
             }
             else                         *(Ull*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)) = val[0];     break;
      default:printf("%03.3d:emax6_ctl: reg_space store: opcd=%d (should be STRW/STR)\n", tid, opcd);break;
      }
      break;
d399 2
a400 4
  for (row0=0; row0<EMAX_DEPTH; row0++) {
    if (exring[cid].unit[i].l_row == 0)   /* ★★EXRINGは論理row0からsimlする必要があり,LMRINGも合わせる */
      break;                              /* ★★LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */
  }
d447 2
a448 2
  /*                              axiif.axring_br =======  物理#0のpiはaxringに差し替え              *//* axi_arready arvalid araddr arlen */
  /* row0+DEPTH-2              0        |            V                                               */
d456 2
a457 2
  /*                             unit[].lmring_br -------                                            */
  /*                                                 |<--------deq_wait                              */
d460 8
a467 1
  struct axring_br *br = &axiif[cid].axring_br[axiif[cid].axring_b_bot];
d475 3
d481 4
a484 29
  if (axiif[cid].axi_read_busy) {
    /* burst read:  max 256bit*256count = 8KB */
    /*                     256bit_AXI_read   -> 256bit_LMM */
    /*  lmmi.top -> axira  top(256bit align) -> mask       */
    /*  lmmi.len -> axirl  len(256bit align) -> mask       */
    if (axiif[cid].ilen <= axiif[cid].axi_arlen) {
      axiif[cid].axi_arready = 0;
      axiif[cid].axi_rvalid = 1;
      for (k=0; k<UNIT_WIDTH; k++) { /* 32B aligned */
        Ull a = br->a + sizeof(Ull)*(axiif[cid].ilen*UNIT_WIDTH+k);
        axiif[cid].axi_rdata[k] = *(Ull*)(mem + a);
        if (trace)
          printf("%03.3d:siml_axiif: read a=%08.8x_%08.8x rdata[%d]=%08.8x_%08.8x\n",
                 cid, (Uint)(a>>32), (Uint)a, k, (Uint)(axiif[cid].axi_rdata[k]>>32), (Uint)axiif[cid].axi_rdata[k]);
      }
      axiif[cid].ilen++;
    }
    else {
      axiif[cid].axi_arready = 1;
      axiif[cid].axi_rvalid  = 0;
      axiif[cid].axi_read_busy = 0;
    }
  }

  else if (axiif[cid].axi_write_busy) {
    /* burst write */
    /*                            256bit_LMM ->  256iAXI_write          */
    /*  lmmi.top -> lmra (align)  mask       ->  WSTRBtop(256bit align) */
    /*  lmmi.len -> rrdyc(align)                 256bit align           */
a485 1
      axiif[cid].axi_awready = 0;
d487 19
a505 9
        for (k=0; k<UNIT_WIDTH; k++) { /* 32B aligned */
          if (axiif[cid].axi_wstrb & (0xff<<(k*8))) {
            Ull a = br->a + sizeof(Ull)*(axiif[cid].ilen*UNIT_WIDTH+k);
            *(Ull*)(mem + a) = axiif[cid].axi_wdata[k];
            if (trace)
              printf("%03.3d:siml_axiif: write a=%08.8x_%08.8x wdata[%d]=%08.8x_%08.8x\n",
                     cid, (Uint)(a>>32), (Uint)a, k, (Uint)(axiif[cid].axi_wdata[k]>>32), (Uint)axiif[cid].axi_wdata[k]);
          }
        }
d509 1
a509 1
    else {
d515 35
d551 8
a561 1
    br->a = axiif[cid].axi_araddr; /* start read */
d567 5
a571 8
  else if (axiif[cid].axi_awready && axiif[cid].axi_awvalid) { /* new write_req starts */
    axiif[cid].axi_awready = 0;                /* start write */
    axiif[cid].axi_write_busy = 1;
    br->a = axiif[cid].axi_awaddr; /* start write */
    axiif[cid].ilen  = 0;                      /* start write (unit is multiple of 64bits) */
    if (trace)
      printf("%03.3d:siml_axiif: write start awaddr=%08.8x_%08.8x awlen=%08.8x_%08.8x\n",
             cid, (Uint)(axiif[cid].axi_awaddr>>32), (Uint)axiif[cid].axi_awaddr, (Uint)(axiif[cid].axi_awlen>>32), (Uint)axiif[cid].axi_awlen);
d1026 4
a1029 4
  exring[cid].unit[i].lmring_ful     =(exring[cid].unit[i].lmring_ful2==3) || (exring[cid].unit[i].lmring_ful1 && exring[cid].unit[i].lmring_ful2==2); /* assign */
  exring[cid].unit[i].deq_wait       = exring[cid].unit[i].lmring_ful      || (exring[cid].unit[i].lmranger_ok && exring[cid].unit[i].lmring_ea1bsy)
                                                                           || (exring[cid].unit[i].lmrangew_ok && exring[cid].unit[i].lmring_ea0bsy)
                                                                           || (exring[cid].unit[i].lmlddmqw_ok && br->col!=j                       );
d1553 1
a1553 1
      exring[cid].unit[i].lmring_b_top = (exring[cid].unit[i].lmring_b_top + 1)%3;
d1558 1
a1558 1
      exring[cid].unit[i].lmring_b_bot = (exring[cid].unit[i].lmring_b_bot + 1)%3;
@


1.249
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.248 2017/07/24 05:00:36 nakashim Exp nakashim $";
d54 1
d368 14
a381 31
  /* 論理番号                       物理番号                     V<----------ENQ (siml_axiifが先にENQ)             */
  /*                                             axring_br  =========== 物理#0のpiはaxringに差し替え               */
  /* row0+DEPTH-2                          0     │              V                                                 */
  /*                                             lmring_br  ----------- 下からsiml.deq_waitが同一τにドミノ倒し.   */
  /*                                                                    実機と違うがoutputの出方は同じ             */
  /* row0+DEPTH-1                          1     │              V          ↑                                     */
  /*              ★siml起点(broutは定数)        lmring_br  ----------- SIML起点(1τ前の次段deq_waitを使う.正常)   */
  /* row0                                 62     │              V    ★SIML最後(前段brの値が1τ未来になる)        */
  /*                                             lmring_br  -----------     ↑                                     */
  /* row0+1                               63     │              V                                                 */
  /*                                             lmring_br  -----------                                            */
  /*                                                             | <---------deq_wait                              */
  /*                                                             +---------->DEQ (siml_axiifが先にDEQ)             */

  /*                                                                               axi_read_busy                   */
  /*										   axi_arready                     */
  /*										   axi_arvalid                     */
  /*										   axi_araddr                      */
  /*										   axi_arlen                       */
  /*										             axi_rready            */
  /*											     axi_rvalid            */
  /*											     axi_rdata[UNIT_WIDTH] */
  /*                                              axi_write_busy                                                   */
  /*                                              axi_awready                                                      */
  /*                                              axi_awvalid                                                      */
  /*                                              axi_awaddr                                                       */
  /*                                              axi_awlen                                                        */
  /*                                                        axi_wstrb                                              */
  /*                                                        axi_wready                                             */
  /*                                                        axi_wvalid                                             */
  /*                                                        axi_wdata[UNIT_WIDTH]                                  */
d861 1
a861 1
  int             ful2 = (i==0)?axiif[cid].axring_ful2           /* previous ful2 */
d1285 2
d1445 1
a1445 1
    if (exring[cid].unit[i].lmring_ful2 && !exring[cid].unit[ni].deq_wait) { /* dequeued for next cycle */
@


1.248
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.247 2017/07/17 11:44:50 nakashim Exp nakashim $";
d45 9
a53 7
  Ull   axring_rw          : 1; /* 0:read, 1:write */
  Ull   axring_ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
  Ull   axring_col         : 2; /* logical col# for target lmm */
  Ull   axring_sq          :16; /* sequential # for pipelined DMA */
  Ull   axring_a           :31; /* logical addr reg/lmm */
  Ull   axring_dm          :32; /* <- lmm wdata       */
  Ull   axring_d[UNIT_WIDTH]  ; /* <- lmm wdata/rdata */
d367 31
a397 30
  /* 論理番号                             物理番号                       V<----------ENQ (siml_axiifが先にENQ)       */
  /*                                                     axring_br  ----------- 物理#0のpiはaxringに差し替え         */
  /* row0+DEPTH-2                         0              │              V                                           */
  /*                                                     lmring_br  -----------                                      */
  /* row0+DEPTH-1                         1              │              V          ↑                               */
  /*              ★siml起点(broutは定数)                lmring_br  ----------- SIML起点                             */
  /* row0                                 62             │              V    ★SIML最後(前段brの値が1τ未来になる)  */
  /*                                                     lmring_br  -----------     ↑                               */
  /* row0+1                               63             │              V                                           */
  /*                                                     lmring_br  -----------                                      */
  /*                                                                     | <---------deq_wait                        */
  /*                                                                     +---------->DEQ (siml_axiifが先にDEQ)       */

  /*                                                                               axi_read_busy                     */
  /*										   axi_arready                       */
  /*										   axi_arvalid                       */
  /*										   axi_araddr                        */
  /*										   axi_arlen                         */
  /*										             axi_rready              */
  /*											     axi_rvalid              */
  /*											     axi_rdata[UNIT_WIDTH]   */
  /*                                              axi_write_busy                                                     */
  /*                                              axi_awready                                                        */
  /*                                              axi_awvalid                                                        */
  /*                                              axi_awaddr                                                         */
  /*                                              axi_awlen                                                          */
  /*                                                        axi_wstrb                                                */
  /*                                                        axi_wready                                               */
  /*                                                        axi_wvalid                                               */
  /*                                                        axi_wdata[UNIT_WIDTH]                                    */
d399 1
d419 1
a419 1
        Ull a = axiif[cid].axring_a + sizeof(Ull)*(axiif[cid].ilen*UNIT_WIDTH+k);
d444 1
a444 1
            Ull a = axiif[cid].axring_a + sizeof(Ull)*(axiif[cid].ilen*UNIT_WIDTH+k);
d464 1
a464 1
    axiif[cid].axring_a = axiif[cid].axi_araddr; /* start read */
d473 1
a473 1
    axiif[cid].axring_a = axiif[cid].axi_awaddr; /* start write */
d875 4
a878 1
  struct lmring_br *br = &exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot];
d968 1
a968 1
  else if (exring[cid].unit[pi].lmring_ful2 && !exring[cid].unit[i].deq_wait) { /* for next cycle */
d1069 1
a1069 1
      && exring[cid].unit[pi].lmring_ful2 && !exring[cid].unit[i].deq_wait && exring[cid].unit[i].lmrangew_ok) { /* axi->lmm_write */
d1179 1
a1179 1
      && exring[cid].unit[pi].lmring_ful2 && !exring[cid].unit[i].deq_wait && exring[cid].unit[i].lmranger_ok) { /* axi->lmm_read */
d1576 14
a1589 4
  printf("     ilen=%08.8x rw-ty-col-sqi=%d-%d-%d-%d-%04.4x a-dm=%08.8x-%08.8x di=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         axiif[cid].ilen, (Uint)axiif[cid].axring_rw, (Uint)axiif[cid].axring_ty, axiif[cid].axring_col, axiif[cid].axring_sq, axiif[cid].axring_a, axiif[cid].axring_dm,
         (Uint)(axiif[cid].axring_d[3]>>32), (Uint)axiif[cid].axring_d[3], (Uint)(axiif[cid].axring_d[2]>>32), (Uint)axiif[cid].axring_d[2],
         (Uint)(axiif[cid].axring_d[1]>>32), (Uint)axiif[cid].axring_d[1], (Uint)(axiif[cid].axring_d[0]>>32), (Uint)axiif[cid].axring_d[0]);
d1797 6
a1802 8
      for (i=UNIT_WIDTH-1; i>=0; i--) {
        printf(" b[0][%d]=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
               col,
               (Uint)(exring[cid].unit[row].b[0][col].r[i]>>32), (Uint)exring[cid].unit[row].b[0][col].r[i],
               (Uint)(exring[cid].unit[row].b[0][col].r[i]>>32), (Uint)exring[cid].unit[row].b[0][col].r[i],
               (Uint)(exring[cid].unit[row].b[0][col].r[i]>>32), (Uint)exring[cid].unit[row].b[0][col].r[i],
               (Uint)(exring[cid].unit[row].b[0][col].r[i]>>32), (Uint)exring[cid].unit[row].b[0][col].r[i]);
      }
d1805 6
a1810 8
      for (i=UNIT_WIDTH-1; i>=0; i--) {
        printf(" b[1][%d]=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
               col,
               (Uint)(exring[cid].unit[row].b[1][col].r[i]>>32), (Uint)exring[cid].unit[row].b[1][col].r[i],
               (Uint)(exring[cid].unit[row].b[1][col].r[i]>>32), (Uint)exring[cid].unit[row].b[1][col].r[i],
               (Uint)(exring[cid].unit[row].b[1][col].r[i]>>32), (Uint)exring[cid].unit[row].b[1][col].r[i],
               (Uint)(exring[cid].unit[row].b[1][col].r[i]>>32), (Uint)exring[cid].unit[row].b[1][col].r[i]);
      }
d1819 12
a1830 14
      for (i=UNIT_WIDTH-1; i>=0; i--) {
        printf(" rbr[%d].rw-ty-col-sq-a-dm=%d-%d-%d-%04.4x-%08.8x-%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
               col,
               exring[cid].unit[row].lmring_br[col].rw,
               exring[cid].unit[row].lmring_br[col].ty,
               exring[cid].unit[row].lmring_br[col].col,
               exring[cid].unit[row].lmring_br[col].sq,
               exring[cid].unit[row].lmring_br[col].a,
               exring[cid].unit[row].lmring_br[col].dm,
               (Uint)(exring[cid].unit[row].lmring_br[col].d[3]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[3],
               (Uint)(exring[cid].unit[row].lmring_br[col].d[2]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[2],
               (Uint)(exring[cid].unit[row].lmring_br[col].d[1]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[1],
               (Uint)(exring[cid].unit[row].lmring_br[col].d[0]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[0]);
      }
@


1.247
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.246 2017/07/16 23:00:03 nakashim Exp nakashim $";
d18 1
a18 1
struct lmring { /* lmm status of EMAX6 */
d22 1
d27 4
a30 2
  Ull   axi_rvalid         : 1; /* axi -> fsm read-ready                                              */
  Ull   axi_rdata[UNIT_WIDTH] ; /* read-data       of mm    v   v   v   v           v                 */
d32 1
a32 1
  Ull   axi_awvalid        : 1; /* axi -> fsm                                                         */
d36 3
a38 2
  Ull   axi_wvalid         : 1; /* fsm -> axi write-ready                                             */
  Ull   axi_wdata[UNIT_WIDTH] ; /* write-data      of mm                    v                         */
d41 3
d45 8
a52 12
  Ull   dvi           : 1; /* 0:rw/ty/co/sq/a/di/dm無効, 1:rw/ty/co/sq/a/di/dm有効 */
  Ull   rw            : 1; /* 0:read, 1:write */
  Ull   ty            : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
  Ull   col           : 2; /* logical col# for target lmm */
  Ull   sqi           :16; /* sequential # for pipelined DMA */
  Ull   a             :31; /* logical addr reg/lmm */
  Ull   dm            :32; /* <- lmm wdata */
  Ull   di[UNIT_WIDTH]   ; /* <- lmm wdata */
  Ull   dvo           : 1; /* 0:dt/do無効, 1:有効 */
  Ull   sqo           :16; /* sequential # for pipelined DMA */
  Ull   dout[UNIT_WIDTH] ; /* -> dout      */
} lmring[MAXCORE];
d150 1
a150 1
    
d168 1
a168 1
    } lmring_br[3]   ;       /* reg */
a227 5
  printf("%03.3d:emax6_ctl: type=%d opcd=%d addr=%08.8x, mask=%08.8x_%08.8x_%08.8x_%08.8x val=%08.8x_%08.8x_%08.8x_%08.8x\n",
	 tid, type, opcd, addr,
	 (Uint)(mask[1]>>32), (Uint)mask[1], (Uint)(mask[0]>>32), (Uint)mask[0],
	 (Uint)(val[1]>>32), (Uint)val[1], (Uint)(val[0]>>32), (Uint)val[0]);

d236 1
a236 1
 	     else                         val[0] = *(Uint*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS));    break;
d245 1
a245 1
 	     else                         *(Uint*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)) = val[0];    break;
d247 1
a247 1
 	     else                         *(Ull*)((Uchar*)&dma_ctrl+(addr-DMA_BASE2_PHYS)) = val[0];     break;
d258 1
a258 1
	     else                         val[0] = *(Uint*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS));	 break;
d260 1
a260 1
	     else                         val[0] = *(Ull*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS));          break;
d268 5
a272 5
	       int ofs = addr-(REG_BASE2_PHYS+REG_REGV_BRBASE);
	       int i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
	       int j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
	       *(Uint*)((Uchar*)&exring[cid].unit[i].b[0]+j) = val[0];
	       *(Uint*)((Uchar*)&exring[cid].unit[i].b[1]+j) = val[0];
d277 7
a283 7
	       int ofs = addr-(REG_BASE2_PHYS+REG_REGV_BRBASE);
	       int i   = ofs/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
	       int j   = ofs%(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
	       *(Ull*)((Uchar*)&exring[cid].unit[i].b[0]+j) = val[0];
	       *(Ull*)((Uchar*)&exring[cid].unit[i].b[1]+j) = val[0];
	     }
 	     else                         *(Ull*)((Uchar*)&reg_ctrl+(addr-REG_BASE2_PHYS)) = val[0];     break;
d292 5
d302 2
a303 2
siml_emax6(cid, trace, trace_pipe)
     Uint cid; Uint trace, trace_pipe;
d308 5
d316 6
d323 1
a323 1
  siml_axiif(cid, trace);                 /* ★★LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */
a325 4
  for (row0=0; row0<EMAX_DEPTH; row0++) { /* find top_row */
    if (exring[cid].unit[i].l_row == 0)   /* ★★EXRINGは論理row0からsimlする必要があり,LMRINGも合わせる */
      break;                              /* ★★LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */
  }
d343 1
a343 1
  reg_ctrl.stat = (!lmring[cid].busy?LMRING_IDLE:LMRING_BUSY)<<4 | (!busy?EXRING_IDLE:EXRING_BUSY);
d359 1
a359 1
siml_axiif(cid, trace) Uint cid, trace;
d363 32
a394 1
  /* ★★LMRINGは実際には物理row0がfsmに接続されているが,siml時は論理row0が先頭と考えて問題ない */
d398 6
a403 8
  /* start read/write */
  if (lmring[cid].axi_arready && lmring[cid].axi_arvalid) { /* new read_req starts */
    lmring[cid].axi_arready = 0;                /* start read */
    lmring[cid].a = lmring[cid].axi_araddr; /* start read */
    lmring[cid].ilen  = 0;                      /* start read (unit is multople of 64bits) */
    if (trace)
      printf("%03.3d:siml_axiif: read start araddr=%08.8x_%08.8x arlen=%08.8x_%08.8x\n",
	     cid, (Uint)(lmring[cid].axi_araddr>>32), (Uint)lmring[cid].axi_araddr, (Uint)(lmring[cid].axi_arlen>>32), (Uint)lmring[cid].axi_arlen);
d405 9
a413 16
  else if (lmring[cid].axi_awready && lmring[cid].axi_awvalid) { /* new write_req starts */
    lmring[cid].axi_awready = 0;                /* start write */
    lmring[cid].a = lmring[cid].axi_awaddr; /* start write */
    lmring[cid].ilen  = 0;                      /* start write (unit is multiple of 64bits) */
    if (trace)
      printf("%03.3d:siml_axiif: write start awaddr=%08.8x_%08.8x awlen=%08.8x_%08.8x\n",
	     cid, (Uint)(lmring[cid].axi_awaddr>>32), (Uint)lmring[cid].axi_awaddr, (Uint)(lmring[cid].axi_awlen>>32), (Uint)lmring[cid].axi_awlen);
  }
  /* exec_length: max 64bit*1024count = 8KB */
  /* burst read:  max 256bit*256count = 8KB */
  /*                     256bit_AXI_read   -> 256bit_LMM */
  /*  lmmi.top -> axira  top(256bit align) -> mask       */
  /*  lmmi.len -> axirl  len(256bit align) -> mask       */
  else if (!lmring[cid].axi_arready) {
    if (lmring[cid].ilen <= lmring[cid].axi_arlen) {
      lmring[cid].axi_rvalid = 1;
d415 5
a419 5
	Ull a = lmring[cid].a + sizeof(Ull)*(lmring[cid].ilen*UNIT_WIDTH+k);
	lmring[cid].axi_rdata[k] = *(Ull*)(mem + a);
	if (trace)
	  printf("%03.3d:siml_axiif: read a=%08.8x_%08.8x rdata[%d]=%08.8x_%08.8x\n",
		 cid, (Uint)(a>>32), (Uint)a, k, (Uint)(lmring[cid].axi_rdata[k]>>32), (Uint)lmring[cid].axi_rdata[k]);
d421 1
a421 1
      lmring[cid].ilen++;
d424 3
a426 2
      lmring[cid].axi_rvalid  = 0;
      lmring[cid].axi_arready = 1;
d429 19
a447 17
  /* burst write */
  /*                            256bit_LMM ->  256iAXI_write          */
  /*  lmmi.top -> lmra (align)  mask       ->  WSTRBtop(256bit align) */
  /*  lmmi.len -> rrdyc(align)                 256bit align           */
  else if (!lmring[cid].axi_awready) {
    if (lmring[cid].ilen <= lmring[cid].axi_awlen) {
      if (lmring[cid].axi_wvalid) {
	for (k=0; k<UNIT_WIDTH; k++) { /* 32B aligned */
	  if (lmring[cid].axi_wstrb & (0xff<<(k*8))) {
	    Ull a = lmring[cid].a + sizeof(Ull)*(lmring[cid].ilen*UNIT_WIDTH+k);
	    *(Ull*)(mem + a) = lmring[cid].axi_wdata[k];
	    if (trace)
	      printf("%03.3d:siml_axiif: write a=%08.8x_%08.8x wdata[%d]=%08.8x_%08.8x\n",
		     cid, (Uint)(a>>32), (Uint)a, k, (Uint)(lmring[cid].axi_wdata[k]>>32), (Uint)lmring[cid].axi_wdata[k]);
	  }
	}
	lmring[cid].ilen++;
d451 2
a452 1
      lmring[cid].axi_awready = 1;
d456 20
d549 20
a568 20
	exring[cid].unit[i].l_row         = i; /* reset to default */
	exring[cid].unit[i].scon_count    = 0; /* reset to default */
	exring[cid].unit[i].one_shot      = 0; /* reset to default */
	exring[cid].unit[i].unit1_exec    = 0; /* reset to default */
	exring[cid].unit[i].unit1_stop    = 0; /* reset to default */
	exring[cid].unit[i].unit2_exec    = 0; /* reset to default */
	exring[cid].unit[i].unit2_stop    = 0; /* reset to default */
	exring[cid].unit[i].stage2_exec   = 0;
	for (k=0; k<EMAX_WIDTH; k++)
	  exring[cid].unit[i].cx[k]       = 0;
	exring[cid].unit[i].ex1           = 0LL;
	exring[cid].unit[i].ex2           = 0LL;
	exring[cid].unit[i].ex3           = 0LL;
	exring[cid].unit[i].ea0b          = 0;
	exring[cid].unit[i].ea0o          = 0;
	exring[cid].unit[i].ea1b          = 0;
	exring[cid].unit[i].ea1o          = 0;
	for (k=0; k<EMAX_WIDTH; k++)
	  exring[cid].unit[i].tx[k]       = 0LL;
	break;
d570 4
a573 4
	exring[cid].unit[i].cmd = CMD_SCON;
	exring[cid].unit[i].scon_count = reg_ctrl.conf[i][0].cdw2.mapdist<<1;
	exring[cid].unit[i].unit1_exec = 1;
	break;
d575 4
a578 4
	exring[cid].unit[i].cmd = CMD_EXEC;
	if (exring[cid].unit[i].l_row == 0)
	  exring[cid].unit[i].unit1_exec = 1;
	break;
d592 1
a592 1
	exring[cid].unit[i].cmd = CMD_NOP;
d596 2
a597 2
	exring[cid].unit[i].l_row--; /* adjust l_row */
	exring[cid].unit[i].scon_count--;
d616 1
a616 1
							             ? exring[cid].unit[pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH] : exring[cid].unit[i].ex4dr_prev; /* self_loop */
d630 1
a630 1
      
d638 1
a638 1
	exring[cid].unit[i].cmd = CMD_NOP;
d640 1
a640 1
	exring[cid].unit[i].one_shot = 1;
d642 1
a642 1
	exring[cid].unit[i].one_shot = 0;
d680 11
a690 11
	exring[cid].unit[i].stage3_exec = 0;
	exring[cid].unit[i].cx2dr       = 0;
	exring[cid].unit[i].ex2dr       = 0LL;
	exring[cid].unit[i].ex2dbrk     = 0;
	exring[cid].unit[i].ea02dr      = 0;
	exring[cid].unit[i].ea12dr      = 0;
	exring[cid].unit[i].tx2dr[0]    = 0LL;
	exring[cid].unit[i].tx2dr[1]    = 0LL;
	exring[cid].unit[i].tx2dr[2]    = 0LL;
	exring[cid].unit[i].tx2dr[3]    = 0LL;
	break;
d757 11
a767 11
	exring[cid].unit[i].stage4_exec = 0;
	exring[cid].unit[i].cx3dr    = 0;
	exring[cid].unit[i].ex3dr    = 0LL;
	exring[cid].unit[i].ex3dbrk  = 0;
	exring[cid].unit[i].ea03dr   = 0;
	exring[cid].unit[i].ea13dr   = 0;
	exring[cid].unit[i].tx3dr[0] = 0LL;
	exring[cid].unit[i].tx3dr[1] = 0LL;
	exring[cid].unit[i].tx3dr[2] = 0LL;
	exring[cid].unit[i].tx3dr[3] = 0LL;
	break;
d927 1
a927 1
					   			           || (exring[cid].unit[i].lmrangew_ok && exring[cid].unit[i].lmring_ea0bsy)
d1043 1
a1043 1
	exring[cid].unit[i].unit1_arbrk  = exring[cid].unit[i].ex3dbrk;
d1045 1
a1045 1
	exring[cid].unit[i].unit1_arbrk |= exring[cid].unit[i].ex3dbrk;
d1095 2
a1096 2
	                                /* OP_TR   の場合,eag0->WRITE,eag1->READ */
	                                /* OP_LDDMQの場合,eag0->WRITE,eag1->READ */
d1104 13
a1116 13
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfffffff0) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x0000000f : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff0f) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&2)) ? 0x000000f0 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfffff0ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000f00 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff0fff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&2)) ? 0x0000f000 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xfff0ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x000f0000 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff0fffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&2)) ? 0x00f00000 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xf0ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x0f000000 : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x0fffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&2)) ? 0xf0000000 : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]; /* align不要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]; /* align不要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]; /* align不要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]; /* align不要 */
	break;
d1118 9
a1126 9
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x0000000f<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000f00<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x000f0000<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x0f000000<<(exring[cid].unit[i].ea03dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & sizeof(int))*8; /* align必要 */
	break;
d1128 9
a1136 9
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000003<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000300<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00030000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x03000000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	break;
d1138 9
a1146 9
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000001<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000100<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00010000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x01000000<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].ea03dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	break;
d1149 6
a1154 6
	exring[cid].unit[i].lmm.mm0    = 0xffffffff;         /* mask *//* ★★★暫定記述★★★ */
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]; /* ★★★暫定記述★★★ */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]; /* ★★★暫定記述★★★ */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]; /* ★★★暫定記述★★★ */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]; /* ★★★暫定記述★★★ */
	break;
d1157 6
a1162 6
	if (exring[cid].unit[i].lmea0strq) {
	  /* ★★★STRQはSTRを4サイクル分割実行★★★ */
	  exring[cid].unit[i].lmm.mm0 = 0x000000ff << j;
	  exring[cid].unit[i].lmm.mw0[j] = exring[cid].unit[i].mwmux[j]; /* align不要 */
	}
	break;
d1209 5
a1213 5
	exring[cid].unit[i].tx4dr[0] = exring[cid].unit[i].lmwd[0];
	exring[cid].unit[i].tx4dr[1] = exring[cid].unit[i].lmwd[1];
	exring[cid].unit[i].tx4dr[2] = exring[cid].unit[i].lmwd[2];
	exring[cid].unit[i].tx4dr[3] = exring[cid].unit[i].lmwd[3];
	exring[cid].unit[i].tr_valid = 1;
d1216 1
a1216 1
	exring[cid].unit[i].tr_valid = 0;
d1218 5
a1222 5
	exring[cid].unit[i].tx4dr[0] = reg_ctrl.conf[i][j].cdw2.trs0==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[0];
	exring[cid].unit[i].tx4dr[1] = reg_ctrl.conf[i][j].cdw2.trs1==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[1];
	exring[cid].unit[i].tx4dr[2] = reg_ctrl.conf[i][j].cdw2.trs2==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[2];
	exring[cid].unit[i].tx4dr[3] = reg_ctrl.conf[i][j].cdw2.trs3==1 ? exring[cid].unit[i].ex3dr : exring[cid].unit[i].tx3dr[3];
	exring[cid].unit[i].tr_valid = 1;
d1347 1
a1347 1
      exring[cid].unit[i].b[0][j].r[1] = *((Ull*)(&reg_ctrl.conf[i][j])+1); 
d1349 1
a1349 1
      exring[cid].unit[i].b[0][j].r[3] = *((Ull*)(&reg_ctrl.conf[i][j])+3); 
d1397 1
a1397 1
    }    
d1437 4
a1440 4
	br->d[0] = tr->d[0]; /* next cycle */
	br->d[1] = tr->d[1]; /* next cycle */
	br->d[2] = tr->d[2]; /* next cycle */
	br->d[3] = tr->d[3]; /* next cycle */
d1443 2
a1444 2
	br->d[0] = exring[cid].unit[i].lmrd[0]; /* next cycle */
	br->d[1] = exring[cid].unit[i].lmrd[1]; /* next cycle */
d1446 1
a1446 1
	br->d[3] = exring[cid].unit[i].lmrd[3]; /* next cycle */
d1531 1
a1531 1
	exring[cid].unit[i].lmm.mr0[k] = *((Ull*)&exring[cid].unit[i].lmm.m[a0al]+k);
d1535 1
a1535 1
	*((Ull*)&exring[cid].unit[i].lmm.m[a0al]+k) = (*((Ull*)&exring[cid].unit[i].lmm.m[a0al]+k) & ~mm0[k]) | (exring[cid].unit[i].lmm.mw0[k] & mm0[k]);
d1562 3
a1564 3
         cid, lmring[cid].busy, lmring[cid].axi_arready, lmring[cid].axi_arvalid, (Uint)lmring[cid].axi_araddr, (Uint)lmring[cid].axi_arlen, lmring[cid].axi_rvalid,
	 (Uint)(lmring[cid].axi_rdata[3]>>32), (Uint)lmring[cid].axi_rdata[3], (Uint)(lmring[cid].axi_rdata[2]>>32), (Uint)lmring[cid].axi_rdata[2],
	 (Uint)(lmring[cid].axi_rdata[1]>>32), (Uint)lmring[cid].axi_rdata[1], (Uint)(lmring[cid].axi_rdata[0]>>32), (Uint)lmring[cid].axi_rdata[0]);
d1566 7
a1572 11
         cid, lmring[cid].axi_awready, lmring[cid].axi_awvalid, (Uint)lmring[cid].axi_awaddr, (Uint)lmring[cid].axi_awlen, lmring[cid].axi_wstrb, lmring[cid].axi_wvalid,
	 (Uint)(lmring[cid].axi_wdata[3]>>32), (Uint)lmring[cid].axi_wdata[3], (Uint)(lmring[cid].axi_wdata[2]>>32), (Uint)lmring[cid].axi_wdata[2],
	 (Uint)(lmring[cid].axi_wdata[1]>>32), (Uint)lmring[cid].axi_wdata[1], (Uint)(lmring[cid].axi_wdata[0]>>32), (Uint)lmring[cid].axi_wdata[0]);
  printf("     ilen=%08.8x dvi-rw-ty-col-sqi=%d-%d-%d-%d-%04.4x a-dm=%08.8x-%08.8x di=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         lmring[cid].ilen, lmring[cid].dvi, (Uint)lmring[cid].rw, (Uint)lmring[cid].ty, lmring[cid].col, lmring[cid].sqi, lmring[cid].a, lmring[cid].dm,
	 (Uint)(lmring[cid].di[3]>>32), (Uint)lmring[cid].di[3], (Uint)(lmring[cid].di[2]>>32), (Uint)lmring[cid].di[2],
	 (Uint)(lmring[cid].di[1]>>32), (Uint)lmring[cid].di[1], (Uint)(lmring[cid].di[0]>>32), (Uint)lmring[cid].di[0]);
  printf("     dvo-sqo=%d-%04.4x do=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
         lmring[cid].dvo, lmring[cid].sqo,
	 (Uint)(lmring[cid].dout[3]>>32), (Uint)lmring[cid].dout[3], (Uint)(lmring[cid].dout[2]>>32), (Uint)lmring[cid].dout[2],
	 (Uint)(lmring[cid].dout[1]>>32), (Uint)lmring[cid].dout[1], (Uint)(lmring[cid].dout[0]>>32), (Uint)lmring[cid].dout[0]);
d1653 12
a1664 12
	   exring[cid].unit[row].stage2_exec,
	   exring[cid].unit[row].stage3_exec,
	   exring[cid].unit[row].stage4_exec,
	   exring[cid].unit[row].cx[3],
	   exring[cid].unit[row].cx[2],
	   exring[cid].unit[row].cx[1],
	   exring[cid].unit[row].cx[0],
	   exring[cid].unit[row].cx2dr,
	   exring[cid].unit[row].cx3dr,
	   (Uint)(exring[cid].unit[row].ex1>>32), (Uint)exring[cid].unit[row].ex1,
	   (Uint)(exring[cid].unit[row].ex2>>32), (Uint)exring[cid].unit[row].ex2,
	   (Uint)(exring[cid].unit[row].ex3>>32), (Uint)exring[cid].unit[row].ex3);
d1666 6
a1671 6
	   (Uint)(exring[cid].unit[row].ex2dr>>32), (Uint)exring[cid].unit[row].ex2dr,
	   exring[cid].unit[row].ex2dbrk,
	   (Uint)(exring[cid].unit[row].ex3dr>>32), (Uint)exring[cid].unit[row].ex3dr,
	   exring[cid].unit[row].ex3dbrk,
	   (Uint)(exring[cid].unit[row].ex4dr>>32), (Uint)exring[cid].unit[row].ex4dr,
	   exring[cid].unit[row].unit1_arbrk);
d1673 10
a1682 10
	   exring[cid].unit[row].eab,
	   exring[cid].unit[row].eao,
	   exring[cid].unit[row].ea0b,
	   exring[cid].unit[row].ea0o,
	   exring[cid].unit[row].ea1b,
	   exring[cid].unit[row].ea1o,
	   (Uint)exring[cid].unit[row].ea02dr,
	   (Uint)exring[cid].unit[row].ea12dr,
	   exring[cid].unit[row].ea03dr,
	   exring[cid].unit[row].ea13dr);
d1684 6
a1689 6
	   exring[cid].unit[row].ea04_umask,
	   exring[cid].unit[row].ea04_lmask,
	   exring[cid].unit[row].ea04dr,
	   exring[cid].unit[row].ea14_umask,
	   exring[cid].unit[row].ea14_lmask,
	   exring[cid].unit[row].ea14dr);
d1691 4
a1694 4
	   (Uint)(exring[cid].unit[row].tx[3]>>32), (Uint)exring[cid].unit[row].tx[3],
	   (Uint)(exring[cid].unit[row].tx[2]>>32), (Uint)exring[cid].unit[row].tx[2],
	   (Uint)(exring[cid].unit[row].tx[1]>>32), (Uint)exring[cid].unit[row].tx[1],
	   (Uint)(exring[cid].unit[row].tx[0]>>32), (Uint)exring[cid].unit[row].tx[0]);
d1696 4
a1699 4
	   (Uint)(exring[cid].unit[row].tx2dr[3]>>32), (Uint)exring[cid].unit[row].tx2dr[3],
	   (Uint)(exring[cid].unit[row].tx2dr[2]>>32), (Uint)exring[cid].unit[row].tx2dr[2],
	   (Uint)(exring[cid].unit[row].tx2dr[1]>>32), (Uint)exring[cid].unit[row].tx2dr[1],
	   (Uint)(exring[cid].unit[row].tx2dr[0]>>32), (Uint)exring[cid].unit[row].tx2dr[0]);
d1701 4
a1704 4
	   (Uint)(exring[cid].unit[row].tx3dr[3]>>32), (Uint)exring[cid].unit[row].tx3dr[3],
	   (Uint)(exring[cid].unit[row].tx3dr[2]>>32), (Uint)exring[cid].unit[row].tx3dr[2],
	   (Uint)(exring[cid].unit[row].tx3dr[1]>>32), (Uint)exring[cid].unit[row].tx3dr[1],
	   (Uint)(exring[cid].unit[row].tx3dr[0]>>32), (Uint)exring[cid].unit[row].tx3dr[0]);
d1706 4
a1709 4
	   (Uint)(exring[cid].unit[row].tx4dr[3]>>32), (Uint)exring[cid].unit[row].tx4dr[3],
	   (Uint)(exring[cid].unit[row].tx4dr[2]>>32), (Uint)exring[cid].unit[row].tx4dr[2],
	   (Uint)(exring[cid].unit[row].tx4dr[1]>>32), (Uint)exring[cid].unit[row].tx4dr[1],
	   (Uint)(exring[cid].unit[row].tx4dr[0]>>32), (Uint)exring[cid].unit[row].tx4dr[0]);
d1711 9
a1719 9
	   exring[cid].unit[row].lmranger_ok,  
	   exring[cid].unit[row].lmrangew_ok,  
	   exring[cid].unit[row].lmlddmqw_ok,  
	   exring[cid].unit[row].lmea0strq,    
	   exring[cid].unit[row].lmring_ea1bsy,
	   exring[cid].unit[row].lmring_ea0bsy,
	   exring[cid].unit[row].lmring_ful, 
	   exring[cid].unit[row].deq_wait,   
	   exring[cid].unit[row].lmring_ful1);
d1721 11
a1731 11
	   exring[cid].unit[row].lmring_tr.rw,
	   exring[cid].unit[row].lmring_tr.ty,
	   exring[cid].unit[row].lmring_tr.col,
	   exring[cid].unit[row].lmring_tr.sq, 
	   exring[cid].unit[row].lmring_tr.a,  
	   exring[cid].unit[row].lmring_tr.dm ,
	   (Uint)(exring[cid].unit[row].lmring_tr.d[3]>>32), (Uint)exring[cid].unit[row].lmring_tr.d[3],
	   (Uint)(exring[cid].unit[row].lmring_tr.d[2]>>32), (Uint)exring[cid].unit[row].lmring_tr.d[2],
	   (Uint)(exring[cid].unit[row].lmring_tr.d[1]>>32), (Uint)exring[cid].unit[row].lmring_tr.d[1],
	   (Uint)(exring[cid].unit[row].lmring_tr.d[0]>>32), (Uint)exring[cid].unit[row].lmring_tr.d[0],
	   exring[cid].unit[row].lmring_tr.pass);
d1733 7
a1739 7
	   exring[cid].unit[row].lmco,
	   exring[cid].unit[row].lmca,
	   exring[cid].unit[row].lmwm,
	   (Uint)(exring[cid].unit[row].lmwd[3]>>32), (Uint)exring[cid].unit[row].lmwd[3],
	   (Uint)(exring[cid].unit[row].lmwd[2]>>32), (Uint)exring[cid].unit[row].lmwd[2],
	   (Uint)(exring[cid].unit[row].lmwd[1]>>32), (Uint)exring[cid].unit[row].lmwd[1],
	   (Uint)(exring[cid].unit[row].lmwd[0]>>32), (Uint)exring[cid].unit[row].lmwd[0]);
d1741 4
a1744 4
	   (Uint)(exring[cid].unit[row].lmrd[3]>>32), (Uint)exring[cid].unit[row].lmrd[3],
	   (Uint)(exring[cid].unit[row].lmrd[2]>>32), (Uint)exring[cid].unit[row].lmrd[2],
	   (Uint)(exring[cid].unit[row].lmrd[1]>>32), (Uint)exring[cid].unit[row].lmrd[1],
	   (Uint)(exring[cid].unit[row].lmrd[0]>>32), (Uint)exring[cid].unit[row].lmrd[0]);
d1746 4
a1749 4
	   (Uint)(exring[cid].unit[row].mwmux[3]>>32), (Uint)exring[cid].unit[row].mwmux[3],
	   (Uint)(exring[cid].unit[row].mwmux[2]>>32), (Uint)exring[cid].unit[row].mwmux[2],
	   (Uint)(exring[cid].unit[row].mwmux[1]>>32), (Uint)exring[cid].unit[row].mwmux[1],
	   (Uint)(exring[cid].unit[row].mwmux[0]>>32), (Uint)exring[cid].unit[row].mwmux[0]);
d1751 7
a1757 7
	   exring[cid].unit[row].lmm.en1,
	   exring[cid].unit[row].lmm.rw1,
	   exring[cid].unit[row].lmm.ma1,
	   exring[cid].unit[row].lmm.en0,
	   exring[cid].unit[row].lmm.rw0,
	   exring[cid].unit[row].lmm.ma0,
	   exring[cid].unit[row].lmm.mm0);
d1759 4
a1762 4
	   (Uint)(exring[cid].unit[row].lmm.mr1[3]>>32), (Uint)exring[cid].unit[row].lmm.mr1[3],
	   (Uint)(exring[cid].unit[row].lmm.mr1[2]>>32), (Uint)exring[cid].unit[row].lmm.mr1[2],
	   (Uint)(exring[cid].unit[row].lmm.mr1[1]>>32), (Uint)exring[cid].unit[row].lmm.mr1[1],
	   (Uint)(exring[cid].unit[row].lmm.mr1[0]>>32), (Uint)exring[cid].unit[row].lmm.mr1[0]);
d1764 4
a1767 4
	   (Uint)(exring[cid].unit[row].lmm.mw0[3]>>32), (Uint)exring[cid].unit[row].lmm.mw0[3],
	   (Uint)(exring[cid].unit[row].lmm.mw0[2]>>32), (Uint)exring[cid].unit[row].lmm.mw0[2],
	   (Uint)(exring[cid].unit[row].lmm.mw0[1]>>32), (Uint)exring[cid].unit[row].lmm.mw0[1],
	   (Uint)(exring[cid].unit[row].lmm.mw0[0]>>32), (Uint)exring[cid].unit[row].lmm.mw0[0]);
d1769 4
a1772 4
	   (Uint)(exring[cid].unit[row].lmm.mr0[3]>>32), (Uint)exring[cid].unit[row].lmm.mr0[3],
	   (Uint)(exring[cid].unit[row].lmm.mr0[2]>>32), (Uint)exring[cid].unit[row].lmm.mr0[2],
	   (Uint)(exring[cid].unit[row].lmm.mr0[1]>>32), (Uint)exring[cid].unit[row].lmm.mr0[1],
	   (Uint)(exring[cid].unit[row].lmm.mr0[0]>>32), (Uint)exring[cid].unit[row].lmm.mr0[0]);
d1774 4
a1777 4
	   exring[cid].unit[row].mr1mux,
	   (Uint)(exring[cid].unit[row].mr1d>>32), (Uint)exring[cid].unit[row].mr1d,
	   exring[cid].unit[row].mr0mux,
	   (Uint)(exring[cid].unit[row].mr0d>>32), (Uint)exring[cid].unit[row].mr0d);
d1781 6
a1786 6
	printf(" b[0][%d]=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
	       col,
	       (Uint)(exring[cid].unit[row].b[0][col].r[i]>>32), (Uint)exring[cid].unit[row].b[0][col].r[i],
	       (Uint)(exring[cid].unit[row].b[0][col].r[i]>>32), (Uint)exring[cid].unit[row].b[0][col].r[i],
	       (Uint)(exring[cid].unit[row].b[0][col].r[i]>>32), (Uint)exring[cid].unit[row].b[0][col].r[i],
	       (Uint)(exring[cid].unit[row].b[0][col].r[i]>>32), (Uint)exring[cid].unit[row].b[0][col].r[i]);
d1791 6
a1796 6
	printf(" b[1][%d]=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
	       col,
	       (Uint)(exring[cid].unit[row].b[1][col].r[i]>>32), (Uint)exring[cid].unit[row].b[1][col].r[i],
	       (Uint)(exring[cid].unit[row].b[1][col].r[i]>>32), (Uint)exring[cid].unit[row].b[1][col].r[i],
	       (Uint)(exring[cid].unit[row].b[1][col].r[i]>>32), (Uint)exring[cid].unit[row].b[1][col].r[i],
	       (Uint)(exring[cid].unit[row].b[1][col].r[i]>>32), (Uint)exring[cid].unit[row].b[1][col].r[i]);
d1801 3
a1803 3
	   exring[cid].unit[row].lmring_ful2,
	   exring[cid].unit[row].lmring_b_top,
	   exring[cid].unit[row].lmring_b_bot);
d1807 12
a1818 12
	printf(" rbr[%d].rw-ty-col-sq-a-dm=%d-%d-%d-%04.4x-%08.8x-%08.8x d=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
	       col,
	       exring[cid].unit[row].lmring_br[col].rw,
	       exring[cid].unit[row].lmring_br[col].ty,
	       exring[cid].unit[row].lmring_br[col].col,
	       exring[cid].unit[row].lmring_br[col].sq,
	       exring[cid].unit[row].lmring_br[col].a,
	       exring[cid].unit[row].lmring_br[col].dm,
	       (Uint)(exring[cid].unit[row].lmring_br[col].d[3]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[3],
	       (Uint)(exring[cid].unit[row].lmring_br[col].d[2]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[2],
	       (Uint)(exring[cid].unit[row].lmring_br[col].d[1]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[1],
	       (Uint)(exring[cid].unit[row].lmring_br[col].d[0]>>32), (Uint)exring[cid].unit[row].lmring_br[col].d[0]);
a1822 5





@


1.246
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.245 2017/07/10 23:52:17 nakashim Exp nakashim $";
d870 3
a872 3
  exring[cid].unit[i].deq_wait       = exring[cid].unit[i].lmring_ful || (exring[cid].unit[i].lmranger_ok && exring[cid].unit[i].lmring_ea1bsy)
								      || (exring[cid].unit[i].lmrangew_ok && exring[cid].unit[i].lmring_ea0bsy)
                                                                      || (exring[cid].unit[i].lmlddmqw_ok && br->col!=j                       );
d1062 8
a1069 8
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x0000000f<<(exring[cid].unit[i].cx3dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000f00<<(exring[cid].unit[i].cx3dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x000f0000<<(exring[cid].unit[i].cx3dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x0f000000<<(exring[cid].unit[i].cx3dr & sizeof(int)) : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].cx3dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].cx3dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].cx3dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].cx3dr & sizeof(int))*8; /* align必要 */
d1072 8
a1079 8
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000003<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000300<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00030000<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x03000000<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short))) : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
d1082 8
a1089 8
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffffff00) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==0 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000001<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xffff00ff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==1 && (exring[cid].unit[i].cx3dr&1)) ? 0x00000100<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0xff00ffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==2 && (exring[cid].unit[i].cx3dr&1)) ? 0x00010000<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mm0 = (exring[cid].unit[i].lmm.mm0 & 0x00ffffff) | (((exring[cid].unit[i].ea03dr/sizeof(Ull) & (UNIT_WIDTH-1))==3 && (exring[cid].unit[i].cx3dr&1)) ? 0x01000000<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char))) : 0x00000000);
	exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
@


1.245
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.244 2017/07/10 10:05:13 nakashim Exp nakashim $";
d1706 1
a1706 1
    printf(" mr1=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
d1711 1
a1711 1
    printf(" mw0=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
d1716 1
a1716 1
    printf(" mr0=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x",
@


1.244
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.243 2017/07/09 12:49:42 nakashim Exp nakashim $";
a1503 107
#if 0
    Ull   unit1_exec    : 1; /* 次の動作を指示 (cex,exe,eag), 0:wait 1:exec *//* ★★★reg_ctrl.statに直接反映★★★ */
    Ull   unit1_stop    : 1; /* 次の動作を指示 (cex,exe,eag), 0:wait 1:stop */
    Ull   tr_valid      : 1; /* TRの状態を表示 */
    Ull   unit2_exec    : 1; /* 次の動作を指示 (lmm),         0:wait 1:exec *//* ★★★reg_ctrl.statに直接反映★★★ */
    Ull   unit2_stop    : 1; /* 次の動作を指示 (lmm),         0:wait 1:stop */
    Ull   brout_valid   : 1; /* BRの状態を表示 常時tr_validを1τ後に伝搬 */

    Ull   stage2_exec   : 1; /* unit1_exec  -> stage2_exec */
    Ull   stage3_exec   : 1; /* stage2_exec -> stage3_exec */
    Ull   stage4_exec   : 1; /* stage3_exec -> stage4_exec */
    Ull   cx[EMAX_WIDTH]   ; /* reg  */
    Ull   cx2dr         : 2; /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
    Ull   cx3dr         : 2; /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
    Ull   ex1              ; /* reg  *//* in for ALU */
    Ull   ex2              ; /* reg  *//* in for ALU */
    Ull   ex3              ; /* reg  *//* in for ALU */
    Ull   ex2dr            ; /* reg  *//* out for first-stage */
    Ull   ex2dbrk       : 1; /* reg  *//* out for first-stage */
    Ull   ex3dr            ; /* reg  *//* out for second-stage */
    Ull   ex3dbrk       : 1; /* reg  *//* out for second-stage */
    Ull   ex4dr_prev       ; /* reg  *//* for siml-loop only */
    Ull   ex4dr            ; /* reg  *//* out for third-stage */
    Ull   unit1_arbrk   : 1; /* loop最終命令の実行完了を表示 */
    Ull   eab           :18; /* wire *//* in for ALU */
    Ull   eao           :18; /* wire *//* in for ALU */
    Ull   ea0b          :18; /* reg  *//* in for EA0 */
    Ull   ea0o          :18; /* reg  *//* in for EA0 */
    Ull   ea1b          :18; /* reg  *//* in for EA1 */
    Ull   ea1o          :18; /* reg  *//* in for EA1 */
    Ull   ea02dr           ; /* reg  *//* for eag(&addr) */
    Ull   ea12dr           ; /* reg  *//* for eag(&addr) */
    Ull   ea03dr        :18; /* reg  */
    Ull   ea13dr        :18; /* reg  */
    Ull   ea04_lmask    :18; /* wire *//* offset */
    Ull   ea04_umask    : 2; /* wire *//* partition */
    Ull   ea04dr_prev   :18; /* reg  *//* for siml-loop only */
    Ull   ea04dr        :18; /* reg  */
    Ull   ea14_lmask    :18; /* wire *//* offset */
    Ull   ea14_umask    : 2; /* wire *//* partition */
    Ull   ea14dr_prev   :18; /* reg  *//* for siml-loop only */
    Ull   ea14dr        :18; /* reg  */
    Ull   tx[UNIT_WIDTH]   ; /* reg  */
    Ull   tx2dr[UNIT_WIDTH]; /* reg  */
    Ull   tx3dr[UNIT_WIDTH]; /* reg  */
    Ull   tx4dr[UNIT_WIDTH]; /* reg  */

    Ull   lmranger_ok   : 1; /* wire *//* lmring要求がread &ty==1&adr[col]<>lmm_range内 */
    Ull   lmrangew_ok   : 1; /* wire *//* lmring要求がwrite&ty==1&adr[col]<>lmm_range内 */
    Ull   lmlddmqw_ok   : 1; /* wire *//* lmring要求がwrite&ty==2&op1[col]==LDDMQ */
    Ull   lmea0strq     : 1; /* wire *//* ea0.strq存在★★★4サイクルに分けて実行 */
    Ull   lmring_ea0bsy : 1; /* wire *//* ea0有効 */
    Ull   lmring_ea1bsy : 1; /* wire *//* ea1有効 */
    Ull   lmring_ful    : 1; /* wire *//* (ful2==3)|(ful1 & (ful2==2)) */
    Ull   deq_wait      : 1; /* wire *//* lmring_ful|(ranger_ok&ea1)|(rangew_ok&ea0)|(lddmqw_ok&col!=j) */
    Ull   lmring_ful1   : 1; /* 0:rw/ty/co/sq/a/di/dm無効, 1:rw/ty/co/sq/a/di/dm有効 */
    struct lmring_tr {
      Ull   rw          : 1; /* 0:read, 1:write */
      Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
      Ull   col         : 2; /* logical col# for target lmm */
      Ull   sq          :16; /* sequential # for pipelined DMA */
      Ull   a           :31; /* logical addr reg/lmm */
      Ull   dm          :32; /* <- lmm wdata       */
      Ull   d[UNIT_WIDTH]  ; /* <- lmm wdata/rdata */
      Ull   pass        : 1; /* 0:hit, 1:pass */
    } lmring_tr;             /* reg */

    Ull   lmco          : 2; /* wire *//* -> conf.lmm_mode */
    Ull   lmca          :18; /* wire *//* -> ea01dr *//* col#による2bit補正前addr */
    Ull   lmwm          :32; /* wire *//* <- axi   */
    Ull   lmwd[UNIT_WIDTH] ; /* wire *//* <- axi   */
    Ull   lmrd[UNIT_WIDTH] ; /* wire *//* -> axi   */
    Ull   mwmux[UNIT_WIDTH]; /* wire for mw0[] */
    struct lmm {
      Ull   en0         : 1; /* internal reg       */
      Ull   en1         : 1; /* internal reg       */
      Ull   rw0         : 1; /* 0:read, 1:write    */
      Ull   rw1         : 1; /* 0:read,(1:write)   */
      Ull   ma0         :18; /* internal reg  addr(32B aligned)      */
      Ull   ma1         :18; /* internal reg  addr(32B aligned)      */
      Ull   mm0         :32; /* internal reg  mask */
      Ull   mw0[UNIT_WIDTH]; /* internal reg  data */
      Ull   mr0[UNIT_WIDTH]; /* internal wire data */
      Ull   mr1[UNIT_WIDTH]; /* internal wire data */
      Uchar m[LMEM_SIZE]   ; /* local memory       */
    } lmm;
    
    Ull   mr0mux        : 2; /* mr0[3-0] -> brs0     */
    Ull   mr1mux        : 2; /* mr1[3-0] -> brs1     */
    Ull   mr0d             ; /* muxed data for BR[0] */
    Ull   mr1d             ; /* muxed data for BR[1] */
    struct {Ull r[UNIT_WIDTH];} b[2][EMAX_WIDTH]; /* shadow_breg *//* constantは両方にセット */

    Ull   lmring_ful2   : 2; /* 0:empty, 3:full */
    Ull   lmring_b_top  : 2; /* to be enqueued next */
    Ull   lmring_b_bot  : 2; /* to be dequeued next */
    struct lmring_br {
      Ull   rw          : 1; /* 0:read, 1:write */
      Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:,lmm/trans */
      Ull   col         : 2; /* logical col# for target lmm */
      Ull   sq          :16; /* sequential # for pipelined DMA */
      Ull   a           :31; /* logical addr reg/lmm */
      Ull   dm          :32; /* <- lmm wdata       */
      Ull   d[UNIT_WIDTH]  ; /* <- lmm wdata/rdata */
    } lmring_br[3]   ;       /* reg */
#endif

d1513 1
a1513 1
  printf("     ilen=%08.8x dvi-rw-ty-col-sqi=%d-%d-%d-%d-%d a-dm=%08.8x-%08.8x di=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1517 1
a1517 1
  printf("     dvo-sqo=%d-%d do=%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x-%08.8x%08.8x\n",
d1600 169
a1768 1
    printf("\n");
d1771 5
@


1.243
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.242 2017/07/08 14:13:46 nakashim Exp nakashim $";
d170 41
d335 1
a335 1
  if (trace && trace_pipe)
a1490 11
show_emax6_pa(cid, pa_cycle) Uint cid; Ull pa_cycle;
{
  int tid = lmring[cid].tid;
  Ull total;

  printf("%03.3d:PA %08.8x_%08.8x siml_emax6: \033[33mARM%dMHz=%08.8x_%08.8x\033[0m\n", 
         tid,
         (Uint)(t[tid].total_steps>>32),      (Uint)(t[tid].total_steps),
	 2400, (Uint)(pa_cycle>>32), (Uint)pa_cycle);
}

d1504 106
a1609 41
  /* show EMAX6 */
  printf("==== LMRING[%02.2d] v=%d tid=%d stat=%d l_conf=%08.8x_%08.8x l_dist=%d last_row0=%d unit1_exec=%08.8x_%08.8x unit1_stop=%08.8x_%08.8x unit2_exec=%08.8x_%08.8x unit2_stop=%08.8x_%08.8x\n",
         cid, lmring[cid].v, lmring[cid].tid, lmring[cid].status, (Uint)(lmring[cid].last_conf>>32), (Uint)lmring[cid].last_conf, lmring[cid].last_dist, lmring[cid].last_row0,
         (Uint)(lmring[cid].unit1_exec>>32), (Uint)lmring[cid].unit1_exec, (Uint)(lmring[cid].unit1_stop>>32), (Uint)lmring[cid].unit1_stop, (Uint)(lmring[cid].unit2_exec>>32), (Uint)lmring[cid].unit2_exec, (Uint)(lmring[cid].unit2_stop>>32), (Uint)lmring[cid].unit2_stop);

  /* show FSM tables */
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("         ---- LMRING[%d] lmmo[],lmmc[],lmmd[]           ", col);
  printf("\n");
  for (row=0; row<EMAX_DEPTH; row++) {
    printf("lmmo[%02.2d]", row);
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|\033[1;%dmv%d rw%d f%d p%d b%d l%08.8x b%01.1x c%d top%08.8x%08.8x\033[0m",
             (Uint) lmring[cid].lmring[col].lmmo[row].v?36:34,
             (Uint) lmring[cid].lmring[col].lmmo[row].v,
             (Uint) lmring[cid].lmring[col].lmmo[row].rw,
             (Uint) lmring[cid].lmring[col].lmmo[row].f,
             (Uint) lmring[cid].lmring[col].lmmo[row].p,
             (Uint) lmring[cid].lmring[col].lmmo[row].blk,
             (Uint) lmring[cid].lmring[col].lmmo[row].len,
             (Uint) lmring[cid].lmring[col].lmmo[row].bcas,
             (Uint) lmring[cid].lmring[col].lmmo[row].copy,
             (Uint)(lmring[cid].lmring[col].lmmo[row].top>>32),
             (Uint) lmring[cid].lmring[col].lmmo[row].top);
    printf("\n");
    printf("lmmc[%02.2d]", row);
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|\033[1;%dmv%d rw%d f%d p%d b%d l%08.8x b%01.1x c%d top%08.8x%08.8x\033[0m",
             (Uint) lmring[cid].lmring[col].lmmc[row].v?36:34,
             (Uint) lmring[cid].lmring[col].lmmc[row].v,
             (Uint) lmring[cid].lmring[col].lmmc[row].rw,
             (Uint) lmring[cid].lmring[col].lmmc[row].f,
             (Uint) lmring[cid].lmring[col].lmmc[row].p,
             (Uint) lmring[cid].lmring[col].lmmc[row].blk,
             (Uint) lmring[cid].lmring[col].lmmc[row].len,
             (Uint) lmring[cid].lmring[col].lmmc[row].bcas,
             (Uint) lmring[cid].lmring[col].lmmc[row].copy,
             (Uint)(lmring[cid].lmring[col].lmmc[row].top>>32),
             (Uint) lmring[cid].lmring[col].lmmc[row].top);
    printf("\n");
  }
d1611 17
a1627 120
  /* show FSM controllers */
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("         ---- LMRING[%d] status=%02.2d bus_controller                       ", col, lmring[cid].status);
  printf("\n");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("         ---- unit1exec=%08.8x%08.8x unit1stop=%08.8x%08.8x ",
         (Uint)(lmring[cid].unit1_exec>>32), (Uint)lmring[cid].unit1_exec,
         (Uint)(lmring[cid].unit1_stop>>32), (Uint)lmring[cid].unit1_stop);
  printf("\n");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("         ---- unit2exec=%08.8x%08.8x unit2stop=%08.8x%08.8x ",
         (Uint)(lmring[cid].unit2_exec>>32), (Uint)lmring[cid].unit2_exec,
         (Uint)(lmring[cid].unit2_stop>>32), (Uint)lmring[cid].unit2_stop);
  printf("\n");
  printf("ld-ms-rc");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|%d %d rc%02.2d rs%08.8x%08.8x lmen%08.8x%08.8x ardy%04.4d rrdy%04.4d ",
           (Uint) lmring[cid].lmring[col].memif_status,
           (Uint) lmring[cid].lmring[col].last_dist,
           (Uint) lmring[cid].lmring[col].row_count,
           (Uint)(lmring[cid].lmring[col].row_select>>32),
           (Uint) lmring[cid].lmring[col].row_select,
           (Uint)(lmring[cid].lmring[col].row_lmm_en>>32),
           (Uint) lmring[cid].lmring[col].row_lmm_en,
           lmring[cid].lmring[col].ardyc,
           lmring[cid].lmring[col].rrdyc);
  printf("\n");
  printf("aralawal");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
           (Uint)(lmring[cid].lmring[col].araddr>>32),
           (Uint) lmring[cid].lmring[col].araddr,
           (Uint)(lmring[cid].lmring[col].arlen>>32),
           (Uint) lmring[cid].lmring[col].arlen,
           (Uint)(lmring[cid].lmring[col].awaddr>>32),
           (Uint) lmring[cid].lmring[col].awaddr,
           (Uint)(lmring[cid].lmring[col].awlen>>32),
           (Uint) lmring[cid].lmring[col].awlen);
  printf("\n");
  printf("lmwraxrw");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|%08.8x%08.8x %08.8x%08.8x                                  ",
           (Uint)(lmring[cid].lmring[col].lmwa>>32),
           (Uint) lmring[cid].lmring[col].lmwa,
           (Uint)(lmring[cid].lmring[col].lmra>>32),
           (Uint) lmring[cid].lmring[col].lmra);
  printf("\n");
  printf("lmwd3-0 ");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
           (Uint)(lmring[cid].lmring[col].lmwd[3]>>32),
           (Uint) lmring[cid].lmring[col].lmwd[3],
           (Uint)(lmring[cid].lmring[col].lmwd[2]>>32),
           (Uint) lmring[cid].lmring[col].lmwd[2],
           (Uint)(lmring[cid].lmring[col].lmwd[1]>>32),
           (Uint) lmring[cid].lmring[col].lmwd[1],
           (Uint)(lmring[cid].lmring[col].lmwd[0]>>32),
           (Uint) lmring[cid].lmring[col].lmwd[0]);
  printf("\n");
  printf("lmrd3-0 ");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
           (Uint)(lmring[cid].lmring[col].lmrd[3]>>32),
           (Uint) lmring[cid].lmring[col].lmrd[3],
           (Uint)(lmring[cid].lmring[col].lmrd[2]>>32),
           (Uint) lmring[cid].lmring[col].lmrd[2],
           (Uint)(lmring[cid].lmring[col].lmrd[1]>>32),
           (Uint) lmring[cid].lmring[col].lmrd[1],
           (Uint)(lmring[cid].lmring[col].lmrd[0]>>32),
           (Uint) lmring[cid].lmring[col].lmrd[0]);
  printf("\n");
  printf("axistat ");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|arr%d arv%d rv%d awr%d awv%d wst%08.8x wv%d ilen%04.4d idel%04.4d          ",
           (Uint) lmring[cid].lmring[col].axi_arready,
           (Uint) lmring[cid].lmring[col].axi_arvalid,
           (Uint) lmring[cid].lmring[col].axi_rvalid,
           (Uint) lmring[cid].lmring[col].axi_awready,
           (Uint) lmring[cid].lmring[col].axi_awvalid,
           (Uint) lmring[cid].lmring[col].axi_wstrb,
           (Uint) lmring[cid].lmring[col].axi_wvalid,
           (Uint) lmring[cid].lmring[col].ilen,
           (Uint) lmring[cid].lmring[col].idelay);
  printf("\n");
  printf("axaraxaw");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
           (Uint)(lmring[cid].lmring[col].axi_araddr>>32),
           (Uint) lmring[cid].lmring[col].axi_araddr,
           (Uint)(lmring[cid].lmring[col].axi_arlen>>32),
           (Uint) lmring[cid].lmring[col].axi_arlen,
           (Uint)(lmring[cid].lmring[col].axi_awaddr>>32),
           (Uint) lmring[cid].lmring[col].axi_awaddr,
           (Uint)(lmring[cid].lmring[col].axi_awlen>>32),
           (Uint) lmring[cid].lmring[col].axi_awlen);
  printf("\n");
  printf("rdat3-0 ");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
           (Uint)(lmring[cid].lmring[col].axi_rdata[3]>>32),
           (Uint) lmring[cid].lmring[col].axi_rdata[3],
           (Uint)(lmring[cid].lmring[col].axi_rdata[2]>>32),
           (Uint) lmring[cid].lmring[col].axi_rdata[2],
           (Uint)(lmring[cid].lmring[col].axi_rdata[1]>>32),
           (Uint) lmring[cid].lmring[col].axi_rdata[1],
           (Uint)(lmring[cid].lmring[col].axi_rdata[0]>>32),
           (Uint) lmring[cid].lmring[col].axi_rdata[0]);
  printf("\n");
  printf("wdat3-0 ");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
           (Uint)(lmring[cid].lmring[col].axi_wdata[3]>>32),
           (Uint) lmring[cid].lmring[col].axi_wdata[3],
           (Uint)(lmring[cid].lmring[col].axi_wdata[2]>>32),
           (Uint) lmring[cid].lmring[col].axi_wdata[2],
           (Uint)(lmring[cid].lmring[col].axi_wdata[1]>>32),
           (Uint) lmring[cid].lmring[col].axi_wdata[1],
           (Uint)(lmring[cid].lmring[col].axi_wdata[0]>>32),
           (Uint) lmring[cid].lmring[col].axi_wdata[0]);
  printf("\n");
d1629 1
a1629 1
  /* show UNIT status */
d1632 1
a1632 2
      printf("         ---- UNIT[%d][%d]                                            ", row, col);
    printf("\n");
d1635 1
a1635 1
      printf("|op123=%02.2x_%x_%x ex1=%01.1x_%d%d ex2=%01.1x_%d ex3=%01.1x_%d e2i%08.8x%08.8x_%d e3i%02.2x_%d",
d1654 1
a1654 1
      printf("|cop=%01.1x%01.1x%01.1x%01.1x_%04.4x ea1=%02.2x_%d_%d_%01.1x ea0=%02.2x_%d_%d_%01.1x eab=%01.1x eao=%01.1x                ",
d1671 1
a1671 1
    printf("cdw2-3  ");
d1673 1
a1673 3
      printf("|lmls%d lmrs%d ts3-0=%01.1x%01.1x%01.1x%01.1x mwsa%d mws3-0=%d%d%d%d brs3-0=%d%d%d%d xmws%d mapd=%d  ",
             (Uint) reg_ctrl.conf[row][col].cdw2.lmls,
             (Uint) reg_ctrl.conf[row][col].cdw2.lmrs,
d1678 4
d1691 2
a1692 2
             (Uint) reg_ctrl.conf[row][col].cdw2.xmws,
             (Uint) reg_ctrl.conf[row][col].cdw2.mapdist);
d1694 13
a1706 199
    printf("regvea10");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(exring[cid].unit[row][col].regv.ea1br>>32),
             (Uint) exring[cid].unit[row][col].regv.ea1br,
             (Uint)(exring[cid].unit[row][col].regv.ea1or>>32),
             (Uint) exring[cid].unit[row][col].regv.ea1or,
             (Uint)(exring[cid].unit[row][col].regv.ea0br>>32),
             (Uint) exring[cid].unit[row][col].regv.ea0br,
             (Uint)(exring[cid].unit[row][col].regv.ea0or>>32),
             (Uint) exring[cid].unit[row][col].regv.ea0or);
    printf("\n");
    printf("regvbr30");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(exring[cid].unit[row][col].regv.br[3]>>32),
             (Uint) exring[cid].unit[row][col].regv.br[3],
             (Uint)(exring[cid].unit[row][col].regv.br[2]>>32),
             (Uint) exring[cid].unit[row][col].regv.br[2],
             (Uint)(exring[cid].unit[row][col].regv.br[1]>>32),
             (Uint) exring[cid].unit[row][col].regv.br[1],
             (Uint)(exring[cid].unit[row][col].regv.br[0]>>32),
             (Uint) exring[cid].unit[row][col].regv.br[0]);
    printf("\n");
    printf("cexex123");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|os=%d c3-0=%01.1x%01.1x%01.1x%01.1x_%01.1x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint) exring[cid].unit[row][col].one_shot,
             (Uint) exring[cid].unit[row][col].c[3],
             (Uint) exring[cid].unit[row][col].c[2],
             (Uint) exring[cid].unit[row][col].c[1],
             (Uint) exring[cid].unit[row][col].c[0],
             (Uint) exring[cid].unit[row][col].cexdr,
             (Uint)(exring[cid].unit[row][col].ex1>>32),
             (Uint) exring[cid].unit[row][col].ex1,
             (Uint)(exring[cid].unit[row][col].ex2>>32),
             (Uint) exring[cid].unit[row][col].ex2,
             (Uint)(exring[cid].unit[row][col].ex3>>32),
             (Uint) exring[cid].unit[row][col].ex3);
    printf("\n");
    printf("eab eao ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x                                  ",
             (Uint)(exring[cid].unit[row][col].eab>>32),
             (Uint) exring[cid].unit[row][col].eab,
             (Uint)(exring[cid].unit[row][col].eao>>32),
             (Uint) exring[cid].unit[row][col].eao);
    printf("\n");
    printf("ea1 ea0 ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(exring[cid].unit[row][col].ea1b>>32),
             (Uint) exring[cid].unit[row][col].ea1b,
             (Uint)(exring[cid].unit[row][col].ea1o>>32),
             (Uint) exring[cid].unit[row][col].ea1o,
             (Uint)(exring[cid].unit[row][col].ea0b>>32),
             (Uint) exring[cid].unit[row][col].ea0b,
             (Uint)(exring[cid].unit[row][col].ea0o>>32),
             (Uint) exring[cid].unit[row][col].ea0o);
    printf("\n");
    printf("exd ead ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x lmen=%d rrdy=%d   ",
             (Uint)(exring[cid].unit[row][col].exdr>>32),
             (Uint) exring[cid].unit[row][col].exdr,
             (Uint)(exring[cid].unit[row][col].ea1dr>>32),
             (Uint) exring[cid].unit[row][col].ea1dr,
             (Uint)(exring[cid].unit[row][col].ea0dr>>32),
             (Uint) exring[cid].unit[row][col].ea0dr,
             exring[cid].unit[row][col].lmen,
             exring[cid].unit[row][col].rrdy);
    printf("\n");
    printf("lmwalmra");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x                                  ",
             (Uint)(exring[cid].unit[row][col].lmwa>>32),
             (Uint) exring[cid].unit[row][col].lmwa,
             (Uint)(exring[cid].unit[row][col].lmra>>32),
             (Uint) exring[cid].unit[row][col].lmra);
    printf("\n");
    printf("lmwd3-0 ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(exring[cid].unit[row][col].lmwd[3]>>32),
             (Uint) exring[cid].unit[row][col].lmwd[3],
             (Uint)(exring[cid].unit[row][col].lmwd[2]>>32),
             (Uint) exring[cid].unit[row][col].lmwd[2],
             (Uint)(exring[cid].unit[row][col].lmwd[1]>>32),
             (Uint) exring[cid].unit[row][col].lmwd[1],
             (Uint)(exring[cid].unit[row][col].lmwd[0]>>32),
             (Uint) exring[cid].unit[row][col].lmwd[0]);
    printf("\n");
    printf("lmrd3-0 ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(exring[cid].unit[row][col].lmrd[3]>>32),
             (Uint) exring[cid].unit[row][col].lmrd[3],
             (Uint)(exring[cid].unit[row][col].lmrd[2]>>32),
             (Uint) exring[cid].unit[row][col].lmrd[2],
             (Uint)(exring[cid].unit[row][col].lmrd[1]>>32),
             (Uint) exring[cid].unit[row][col].lmrd[1],
             (Uint)(exring[cid].unit[row][col].lmrd[0]>>32),
             (Uint) exring[cid].unit[row][col].lmrd[0]);
    printf("\n");
    printf("t3-0    ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(exring[cid].unit[row][col].t[3]>>32),
             (Uint) exring[cid].unit[row][col].t[3],
             (Uint)(exring[cid].unit[row][col].t[2]>>32),
             (Uint) exring[cid].unit[row][col].t[2],
             (Uint)(exring[cid].unit[row][col].t[1]>>32),
             (Uint) exring[cid].unit[row][col].t[1],
             (Uint)(exring[cid].unit[row][col].t[0]>>32),
             (Uint) exring[cid].unit[row][col].t[0]);
    printf("\n");
    printf("tr3-0   ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(exring[cid].unit[row][col].tr[3]>>32),
             (Uint) exring[cid].unit[row][col].tr[3],
             (Uint)(exring[cid].unit[row][col].tr[2]>>32),
             (Uint) exring[cid].unit[row][col].tr[2],
             (Uint)(exring[cid].unit[row][col].tr[1]>>32),
             (Uint) exring[cid].unit[row][col].tr[1],
             (Uint)(exring[cid].unit[row][col].tr[0]>>32),
             (Uint) exring[cid].unit[row][col].tr[0]);
    printf("\n");
    printf("lmm1-0  ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|en%d rw%d ma%08.8x%08.8x        en%d rw%d ma%08.8x%08.8x       ",
             (Uint) exring[cid].unit[row][col].lmm.en1,
             (Uint) exring[cid].unit[row][col].lmm.rw1,
             (Uint)(exring[cid].unit[row][col].lmm.ma1>>32),
             (Uint) exring[cid].unit[row][col].lmm.ma1,
             (Uint) exring[cid].unit[row][col].lmm.en0,
             (Uint) exring[cid].unit[row][col].lmm.rw0,
             (Uint)(exring[cid].unit[row][col].lmm.ma0>>32),
             (Uint) exring[cid].unit[row][col].lmm.ma0);
    printf("\n");
    printf("mm0[3-0]");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(exring[cid].unit[row][col].lmm.mm0[3]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mm0[3],
             (Uint)(exring[cid].unit[row][col].lmm.mm0[2]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mm0[2],
             (Uint)(exring[cid].unit[row][col].lmm.mm0[1]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mm0[1],
             (Uint)(exring[cid].unit[row][col].lmm.mm0[0]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mm0[0]);
    printf("\n");
    printf("mw0[3-0]");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|\033[1;%dm%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x\033[0m",
	     exring[cid].unit[row][col].lmm.en0 && exring[cid].unit[row][col].lmm.rw0?35:34,
             (Uint)(exring[cid].unit[row][col].lmm.mw0[3]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mw0[3],
             (Uint)(exring[cid].unit[row][col].lmm.mw0[2]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mw0[2],
             (Uint)(exring[cid].unit[row][col].lmm.mw0[1]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mw0[1],
             (Uint)(exring[cid].unit[row][col].lmm.mw0[0]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mw0[0]);
    printf("\n");
    printf("mr0[3-0]");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(exring[cid].unit[row][col].lmm.mr0[3]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mr0[3],
             (Uint)(exring[cid].unit[row][col].lmm.mr0[2]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mr0[2],
             (Uint)(exring[cid].unit[row][col].lmm.mr0[1]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mr0[1],
             (Uint)(exring[cid].unit[row][col].lmm.mr0[0]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mr0[0]);
    printf("\n");
    printf("mr1[3-0]");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|\033[1;%dm%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x\033[0m",
	     exring[cid].unit[row][col].rrdy?36:34,
             (Uint)(exring[cid].unit[row][col].lmm.mr1[3]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mr1[3],
             (Uint)(exring[cid].unit[row][col].lmm.mr1[2]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mr1[2],
             (Uint)(exring[cid].unit[row][col].lmm.mr1[1]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mr1[1],
             (Uint)(exring[cid].unit[row][col].lmm.mr1[0]>>32),
             (Uint) exring[cid].unit[row][col].lmm.mr1[0]);
    printf("\n");
    printf("mr1-0xd ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|mr1mux=%d mr0mux=%d mr1d=%08.8x%08.8x mr0d=%08.8x%08.8x      ",
             (Uint) exring[cid].unit[row][col].mr1mux,
             (Uint) exring[cid].unit[row][col].mr0mux,
             (Uint)(exring[cid].unit[row][col].mr1d>>32),
             (Uint) exring[cid].unit[row][col].mr1d,
             (Uint)(exring[cid].unit[row][col].mr0d>>32),
             (Uint) exring[cid].unit[row][col].mr0d);
@


1.242
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.241 2017/07/08 11:43:28 nakashim Exp nakashim $";
d276 1
d442 1
a442 1
  int j  =  exring[cid].unit[i].cycle % EMAX_WIDTH; /* 0,1,2,3,0,1,2,3 */
d1129 1
d1192 2
a1193 1
  int j = (exring[cid].unit[i].cycle) % EMAX_WIDTH; /* 0,1,2,3,0,1,2,3 */
d1223 8
a1230 1
  exring[cid].unit[i].mr0mux = 
d1255 46
a1300 1
  else {
d1303 3
d1346 4
a1349 4
	br->d[0] = lmrd[0]; /* next cycle */
	br->d[1] = lmrd[1]; /* next cycle */
        br->d[2] = lmrd[2]; /* next cycle */
	br->d[3] = lmrd[3]; /* next cycle */
d1362 2
a1363 6
    if (exring[cid].unit[i].tr_valid) { /* active */
      a0   = exring[cid].unit[i].ea04dr;  /* not aligned (lower bits are user for load-select) */
      a1   = exring[cid].unit[i].ea14dr;  /* not aligned (lower bits are user for load-select) */
      a0al = exring[cid].unit[i].lmm.ma0; /* 64B aligned */
      a1al = exring[cid].unit[i].lmm.ma1; /* 64B aligned */
    }
d1365 4
a1368 2
    if ((exring[cid].unit[i].cycle & 3) == 3) /* final */
      exring[cid].unit[i].brout_valid = exring[cid].unit[i].tr_valid;
d1370 9
d1380 50
d1431 2
a1432 4
  switch (lmring[cid].status) {
  case STATUS_DRAIN:
    if (exring[cid].unit[i][j].lmm.en1 && !exring[cid].unit[i][j].lmm.rw1) { /* lmm read enabled */
      exring[cid].unit[i][j].rrdy = 1; /* rdata valid */
d1434 1
a1434 1
        lmring[cid].lmring[j].lmrd[k] = exring[cid].unit[i][j].lmrd[k] = exring[cid].unit[i][j].lmm.mr1[k] = *((Ull*)&exring[cid].unit[i][j].lmm.m[a1al]+k);
d1436 1
a1436 5
    else
      exring[cid].unit[i][j].rrdy = 0; /* rdata invalid */
    return (0);
  case STATUS_LOAD: /* 水平方向broadcastの受取りもここ */
    if (exring[cid].unit[i][j].lmm.en0 && exring[cid].unit[i][j].lmm.rw0) { /* lmm write enabled */
d1438 1
a1438 4
        *((Ull*)&exring[cid].unit[i][j].lmm.m[a0al]+k) = (*((Ull*)&exring[cid].unit[i][j].lmm.m[a0al]+k) & ~exring[cid].unit[i][j].lmm.mm0[k]) | (exring[cid].unit[i][j].lmm.mw0[k] & exring[cid].unit[i][j].lmm.mm0[k]);
      /*printf("LMM pload row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al,
	(Uint)exring[cid].unit[i][j].lmm.mw0[3], (Uint)exring[cid].unit[i][j].lmm.mm0[3], (Uint)exring[cid].unit[i][j].lmm.mw0[2], (Uint)exring[cid].unit[i][j].lmm.mm0[2],
	(Uint)exring[cid].unit[i][j].lmm.mw0[1], (Uint)exring[cid].unit[i][j].lmm.mm0[1], (Uint)exring[cid].unit[i][j].lmm.mw0[0], (Uint)exring[cid].unit[i][j].lmm.mm0[0]);*/
a1439 103
    return (0);
  case STATUS_EXEC:
    /* store mw    -> lmm[] */
    /* load  lmm[] -> mr    */
    if (reg_ctrl.conf[i][j].cdw1.ea1op == OP_IM_DRAIN
     || reg_ctrl.conf[i][j].cdw1.ea1op == OP_LDDMQ
     || reg_ctrl.conf[i][j].cdw1.ea1op == OP_TR) {
      if (exring[cid].unit[i][j].lmm.en1 && !exring[cid].unit[i][j].lmm.rw1) { /* lmm read enabled */
	exring[cid].unit[i][j].rrdy = 1; /* rdata valid */
	for (k=0; k<UNIT_WIDTH; k++)
	  lmring[cid].lmring[j].lmrd[k] = exring[cid].unit[i][j].lmrd[k] = exring[cid].unit[i][j].lmm.mr1[k] = *((Ull*)&exring[cid].unit[i][j].lmm.m[a1al]+k);
	/*printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al,
	  (Uint)lmring[cid].lmring[j].lmrd[3], (Uint)lmring[cid].lmring[j].lmrd[2], (Uint)lmring[cid].lmring[j].lmrd[1], (Uint)lmring[cid].lmring[j].lmrd[0]);*/
      }
      else
	exring[cid].unit[i][j].rrdy = 0; /* rdata invalid */
    }
    else if (reg_ctrl.conf[i][j].cdw1.ea1op) { /* OP_IM_BUFRD or normal load */
      if (exring[cid].unit[i][j].lmm.en1 && !exring[cid].unit[i][j].lmm.rw1) { /* lmm read enabled */
	for (k=0; k<UNIT_WIDTH; k++)
	  exring[cid].unit[i][j].lmm.mr1[k] = *((Ull*)&exring[cid].unit[i][j].lmm.m[a1al]+k);
	/*printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al,
	  (Uint)exring[cid].unit[i][j].lmm.mr1[3], (Uint)exring[cid].unit[i][j].lmm.mr1[2], (Uint)exring[cid].unit[i][j].lmm.mr1[1], (Uint)exring[cid].unit[i][j].lmm.mr1[0]);*/
      }
    }
    
    if (reg_ctrl.conf[i][j].cdw1.ea0op == OP_IM_PREF) {
      if (exring[cid].unit[i][j].lmm.en0 &&  exring[cid].unit[i][j].lmm.rw0) { /* lmm write enabled */
	for (k=0; k<UNIT_WIDTH; k++)
	  *((Ull*)&exring[cid].unit[i][j].lmm.m[a0al]+k) = (*((Ull*)&exring[cid].unit[i][j].lmm.m[a0al]+k) & ~exring[cid].unit[i][j].lmm.mm0[k]) | (exring[cid].unit[i][j].lmm.mw0[k] & exring[cid].unit[i][j].lmm.mm0[k]);
	/*printf("PRF write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al,
	  (Uint)exring[cid].unit[i][j].lmm.mw0[3], (Uint)exring[cid].unit[i][j].lmm.mm0[3], (Uint)exring[cid].unit[i][j].lmm.mw0[2], (Uint)exring[cid].unit[i][j].lmm.mm0[2],
	  (Uint)exring[cid].unit[i][j].lmm.mw0[1], (Uint)exring[cid].unit[i][j].lmm.mm0[1], (Uint)exring[cid].unit[i][j].lmm.mw0[0], (Uint)exring[cid].unit[i][j].lmm.mm0[0]);*/
      }
    }
    else if (reg_ctrl.conf[i][j].cdw1.ea0op) { /* normal load/store */
      if (exring[cid].unit[i][j].lmm.en0 && !exring[cid].unit[i][j].lmm.rw0) { /* lmm read enabled */
	for (k=0; k<UNIT_WIDTH; k++)
	  exring[cid].unit[i][j].lmm.mr0[k] = *((Ull*)&exring[cid].unit[i][j].lmm.m[a0al]+k);
      }
      if (exring[cid].unit[i][j].lmm.en0 &&  exring[cid].unit[i][j].lmm.rw0) { /* lmm write enabled */
	if (reg_ctrl.conf[i][j].cdw1.ea0op < OP_LDDMQ)
	  exring[cid].unit[i][j].drty = 1; /* mark dirty (OP_LDDMQ,OP_TR,OP_IM_BUFWR,は除外が必要) */
	for (k=0; k<UNIT_WIDTH; k++)
	  *((Ull*)&exring[cid].unit[i][j].lmm.m[a0al]+k) = (*((Ull*)&exring[cid].unit[i][j].lmm.m[a0al]+k) & ~exring[cid].unit[i][j].lmm.mm0[k]) | (exring[cid].unit[i][j].lmm.mw0[k] & exring[cid].unit[i][j].lmm.mm0[k]);
	/*printf("LMM write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al,
	  (Uint)exring[cid].unit[i][j].lmm.mw0[3], (Uint)exring[cid].unit[i][j].lmm.mm0[3], (Uint)exring[cid].unit[i][j].lmm.mw0[2], (Uint)exring[cid].unit[i][j].lmm.mm0[2],
	  (Uint)exring[cid].unit[i][j].lmm.mw0[1], (Uint)exring[cid].unit[i][j].lmm.mm0[1], (Uint)exring[cid].unit[i][j].lmm.mw0[0], (Uint)exring[cid].unit[i][j].lmm.mm0[0]);*/
      }
    }
    
    /* load mr -> br0 */
    switch (reg_ctrl.conf[i][j].cdw2.brs0) {
    case 0:                                                          break; /* off */
    case 1: exring[cid].unit[i][j].regv.br[0] = exring[cid].unit[i][j].lmm.mr1[0]; break; /* 1:mr10 align不要 */
    case 2: exring[cid].unit[i][j].regv.br[0] = exring[cid].unit[i][j].tr[0];      break; /* 2:tr0  align不要 */
    case 3:                                                                 /* 3:mr0  align必要 */
      exring[cid].unit[i][j].mr0mux = (a0/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr0[3-0] -> mr0d */
      exring[cid].unit[i][j].mr0d   = exring[cid].unit[i][j].lmm.mr0[exring[cid].unit[i][j].mr0mux];
      switch (reg_ctrl.conf[i][j].cdw1.ea0op) {
      case OP_LDR :  exring[cid].unit[i][j].regv.br[0] =                exring[cid].unit[i][j].mr0d;                                                                                 break;
      case OP_LDWR:  exring[cid].unit[i][j].regv.br[0] = (Sll)   (int)((exring[cid].unit[i][j].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDUWR: exring[cid].unit[i][j].regv.br[0] = (Ull)  (Uint)((exring[cid].unit[i][j].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDHR:  exring[cid].unit[i][j].regv.br[0] = (Sll) (short)((exring[cid].unit[i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDUHR: exring[cid].unit[i][j].regv.br[0] = (Ull)(Ushort)((exring[cid].unit[i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDBR:  exring[cid].unit[i][j].regv.br[0] = (Sll)  (char)((exring[cid].unit[i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      case OP_LDUBR: exring[cid].unit[i][j].regv.br[0] = (Ull) (Uchar)((exring[cid].unit[i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      }
    }
    /* load mr -> br1 */
    switch (reg_ctrl.conf[i][j].cdw2.brs1) {
    case 0:                                                          break; /* off */
    case 1: exring[cid].unit[i][j].regv.br[1] = exring[cid].unit[i][j].lmm.mr1[1]; break; /* 1:mr11 align不要 */
    case 2: exring[cid].unit[i][j].regv.br[1] = exring[cid].unit[i][j].tr[1];      break; /* 2:tr1  align不要 */
    case 3:                                                                 /* 3:mr1  align必要 */
      exring[cid].unit[i][j].mr1mux = (a1/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr1[3-0] -> mr0d */
      exring[cid].unit[i][j].mr1d   = exring[cid].unit[i][j].lmm.mr1[exring[cid].unit[i][j].mr1mux];
      switch (reg_ctrl.conf[i][j].cdw1.ea1op) {
      case OP_LDR:   exring[cid].unit[i][j].regv.br[1] =                exring[cid].unit[i][j].mr1d;                                                                                 break;
      case OP_LDWR:  exring[cid].unit[i][j].regv.br[1] = (Sll)   (int)((exring[cid].unit[i][j].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDUWR: exring[cid].unit[i][j].regv.br[1] = (Ull)  (Uint)((exring[cid].unit[i][j].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDHR:  exring[cid].unit[i][j].regv.br[1] = (Sll) (short)((exring[cid].unit[i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDUHR: exring[cid].unit[i][j].regv.br[1] = (Ull)(Ushort)((exring[cid].unit[i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDBR:  exring[cid].unit[i][j].regv.br[1] = (Sll)  (char)((exring[cid].unit[i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      case OP_LDUBR: exring[cid].unit[i][j].regv.br[1] = (Ull) (Uchar)((exring[cid].unit[i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      }
    }
    /* load mr -> br2 */
    switch (reg_ctrl.conf[i][j].cdw2.brs2) {
    case 0:                                                          break; /* off */
    case 1: exring[cid].unit[i][j].regv.br[2] = exring[cid].unit[i][j].lmm.mr1[2]; break; /* 1:mr12 align不要 */
    case 2: exring[cid].unit[i][j].regv.br[2] = exring[cid].unit[i][j].tr[2];      break; /* 2:tr2  align不要 */
    case 3: exring[cid].unit[i][j].regv.br[2] = exring[cid].unit[i][j].exdr;       break; /* 3:exdr align不要 */
    }
    /* load mr -> br3 */
    switch (reg_ctrl.conf[i][j].cdw2.brs3) {
    case 0:                                                          break; /* off */
    case 1: exring[cid].unit[i][j].regv.br[3] = exring[cid].unit[i][j].lmm.mr1[3]; break; /* 1:mr13 align不要 */
    case 2: exring[cid].unit[i][j].regv.br[3] = exring[cid].unit[i][j].tr[3];      break; /* 2:tr3  align不要 */
    }
    return (0);
  case STATUS_TERM:
    return (0);
d1441 7
@


1.241
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.240 2017/07/08 05:07:07 nakashim Exp nakashim $";
d148 6
a166 6
    Ull   mr0mux        : 2; /* mr0[3-0] -> brs0     */
    Ull   mr1mux        : 2; /* mr1[3-0] -> brs1     */
    Ull   mr0d             ; /* muxed data for BR[0] */
    Ull   mr1d             ; /* muxed data for BR[1] */
    struct {Ull r[UNIT_WIDTH];} b[2][EMAX_WIDTH]; /* shadow_breg *//* constantは両方にセット */

d773 2
a774 2
  int k  = exring[cid].unit[pi].lmring_b_bot; /* output to lmring_tr */
  struct lmring_br *br = &exring[cid].unit[pi].lmring_br[k];
d851 11
a861 11
    exring[cid].unit[i].lmring_tr.rw   = 0;
    exring[cid].unit[i].lmring_tr.ty   = 0;
    exring[cid].unit[i].lmring_tr.col  = 0;
    exring[cid].unit[i].lmring_tr.sq   = 0;
    exring[cid].unit[i].lmring_tr.a    = 0;
    exring[cid].unit[i].lmring_tr.dm   = 0;
    exring[cid].unit[i].lmring_tr.d[0] = 0LL;
    exring[cid].unit[i].lmring_tr.d[1] = 0LL;
    exring[cid].unit[i].lmring_tr.d[2] = 0LL;
    exring[cid].unit[i].lmring_tr.d[3] = 0LL;
    exring[cid].unit[i].lmring_tr.pass = 0;
d865 11
a875 11
    exring[cid].unit[i].lmring_tr.rw   = br->rw;   /* next cycle */
    exring[cid].unit[i].lmring_tr.ty   = br->ty;   /* next cycle */
    exring[cid].unit[i].lmring_tr.col  = br->col;  /* next cycle */
    exring[cid].unit[i].lmring_tr.sq   = br->sq;   /* next cycle */
    exring[cid].unit[i].lmring_tr.a    = br->a;    /* next cycle */
    exring[cid].unit[i].lmring_tr.dm   = br->dm;   /* next cycle */
    exring[cid].unit[i].lmring_tr.d[0] = br->d[0]; /* next cycle */
    exring[cid].unit[i].lmring_tr.d[1] = br->d[1]; /* next cycle */
    exring[cid].unit[i].lmring_tr.d[2] = br->d[2]; /* next cycle */
    exring[cid].unit[i].lmring_tr.d[3] = br->d[3]; /* next cycle */
    exring[cid].unit[i].lmring_tr.pass = br->ty == 0 || !exring[cid].unit[i].lmranger_ok; /* reg or read (VADDR/LDDMQ/TRANS) in range */
d893 1
a894 1
  Ull   tr_valid      : 1; /* TRの状態を表示 */
d1192 2
d1198 8
a1217 6
  Ull   mr0mux        : 2; /* mr0[3-0] -> brs0     */
  Ull   mr1mux        : 2; /* mr1[3-0] -> brs1     */
  Ull   mr0d             ; /* muxed data for BR[0] */
  Ull   mr1d             ; /* muxed data for BR[1] */
  Ull   lmrd[UNIT_WIDTH] ; /* wire *//* -> axi   */
  struct {Ull r[UNIT_WIDTH];} b[2][EMAX_WIDTH]; /* shadow_breg *//* constantは両方にセット */
d1220 2
a1224 15
    exring[cid].unit[i].lmring_ful2    = 0;
    exring[cid].unit[i].lmring_b_top   = 0;
    exring[cid].unit[i].lmring_b_bot   = 0;
    for (k=0; k<3; k++) {
      exring[cid].unit[i].lmring_br[k].rw   = 0;
      exring[cid].unit[i].lmring_br[k].ty   = 0;
      exring[cid].unit[i].lmring_br[k].col  = 0;
      exring[cid].unit[i].lmring_br[k].sq   = 0;
      exring[cid].unit[i].lmring_br[k].a    = 0;
      exring[cid].unit[i].lmring_br[k].dm   = 0;
      exring[cid].unit[i].lmring_br[k].d[0] = 0LL;
      exring[cid].unit[i].lmring_br[k].d[1] = 0LL;
      exring[cid].unit[i].lmring_br[k].d[2] = 0LL;
      exring[cid].unit[i].lmring_br[k].d[3] = 0LL;
    }
d1245 22
d1271 31
a1301 4
  else if (exring[cid].unit[i].lmring_ful1) { /* enqueue to lmring_br for next cycle */
  }
  else if (exring[cid].unit[i].lmring_ful2 && !exring[cid].unit[ni].deq_wait) { /* dequeued for next cycle */
    /*
@


1.240
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.239 2017/07/08 03:36:55 nakashim Exp nakashim $";
d1189 1
d1216 28
a1243 33
  switch (exring[cid].unit[i].cmd) {
  case CMD_NOP:   /* nop */
    if ((exring[cid].unit[i].cycle & 3) == 3) {
      switch (reg_ctrl.cmd) {
      case CMD_RESET: /* reset */
	exring[cid].unit[i].lmring_ful2    = 0;
	exring[cid].unit[i].lmring_b_top   = 0;
	exring[cid].unit[i].lmring_b_bot   = 0;
	for (k=0; k<3; k++) {
	  exring[cid].unit[i].lmring_br[k].rw   = 0;
	  exring[cid].unit[i].lmring_br[k].ty   = 0;
	  exring[cid].unit[i].lmring_br[k].col  = 0;
	  exring[cid].unit[i].lmring_br[k].sq   = 0;
	  exring[cid].unit[i].lmring_br[k].a    = 0;
	  exring[cid].unit[i].lmring_br[k].dm   = 0;
	  exring[cid].unit[i].lmring_br[k].d[0] = 0LL;
	  exring[cid].unit[i].lmring_br[k].d[1] = 0LL;
	  exring[cid].unit[i].lmring_br[k].d[2] = 0LL;
	  exring[cid].unit[i].lmring_br[k].d[3] = 0LL;
	}
	exring[cid].unit[i].brout_valid      = 0;
	for (k=0; k<EMAX_WIDTH; k++) {
	  exring[cid].unit[i].b[0][k].r[0]   = 0LL;
	  exring[cid].unit[i].b[0][k].r[1]   = 0LL;
	  exring[cid].unit[i].b[0][k].r[2]   = 0LL;
	  exring[cid].unit[i].b[0][k].r[3]   = 0LL;
	  exring[cid].unit[i].b[1][k].r[0]   = 0LL;
	  exring[cid].unit[i].b[1][k].r[1]   = 0LL;
	  exring[cid].unit[i].b[1][k].r[2]   = 0LL;
	  exring[cid].unit[i].b[1][k].r[3]   = 0LL;
	}
	break;
      }
d1245 2
a1246 2
    break;
  case CMD_SCON:  /* scon */
d1253 18
a1270 2
    break;
  case CMD_EXEC:  /* exec */
a1272 3
    break;
  }
}
d1274 1
a1274 4
  a0   = exring[cid].unit[i][j].ea0dr % LMEM_SIZE;
  a1   = exring[cid].unit[i][j].ea1dr % LMEM_SIZE;
  a0al = exring[cid].unit[i][j].lmm.ma0; /* should be aligned by fsm */
  a1al = exring[cid].unit[i][j].lmm.ma1; /* should be aligned by fsm */
@


1.239
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.238 2017/07/07 14:10:41 nakashim Exp nakashim $";
a1214 30
  if (exring[cid].unit[i].cmd == CMD_NOP
      && (exring[cid].unit[i].cycle & 3) == 3
      && reg_ctrl.cmd == CMD_RESET) {
    exring[cid].unit[i].lmring_ful2    = 0;
    exring[cid].unit[i].lmring_b_top   = 0;
    exring[cid].unit[i].lmring_b_bot   = 0;
    for (k=0; k<3; k++) {
      exring[cid].unit[i].lmring_br[k].rw   = 0;
      exring[cid].unit[i].lmring_br[k].ty   = 0;
      exring[cid].unit[i].lmring_br[k].col  = 0;
      exring[cid].unit[i].lmring_br[k].sq   = 0;
      exring[cid].unit[i].lmring_br[k].a    = 0;
      exring[cid].unit[i].lmring_br[k].dm   = 0;
      exring[cid].unit[i].lmring_br[k].d[0] = 0LL;
      exring[cid].unit[i].lmring_br[k].d[1] = 0LL;
      exring[cid].unit[i].lmring_br[k].d[2] = 0LL;
      exring[cid].unit[i].lmring_br[k].d[3] = 0LL;
    }
    exring[cid].unit[i].brout_valid      = 0;
    for (k=0; k<EMAX_WIDTH; k++) {
      exring[cid].unit[i].b[0][k].r[0]   = 0LL;
      exring[cid].unit[i].b[0][k].r[1]   = 0LL;
      exring[cid].unit[i].b[0][k].r[2]   = 0LL;
      exring[cid].unit[i].b[0][k].r[3]   = 0LL;
      exring[cid].unit[i].b[1][k].r[0]   = 0LL;
      exring[cid].unit[i].b[1][k].r[1]   = 0LL;
      exring[cid].unit[i].b[1][k].r[2]   = 0LL;
      exring[cid].unit[i].b[1][k].r[3]   = 0LL;
    }

d1216 1
a1216 1
  case CMD_NOP:   /* nop *//* drain/load */
d1220 26
a1245 1
	exring[cid].unit[i].brout_valid = 0;
@


1.238
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.237 2017/07/07 09:54:39 nakashim Exp nakashim $";
d442 1
d458 12
d582 10
a591 9
	exring[cid].unit[i].cx2dr    = 0;
	exring[cid].unit[i].ex2dr    = 0LL;
	exring[cid].unit[i].ex2dbrk  = 0;
	exring[cid].unit[i].ea02dr   = 0;
	exring[cid].unit[i].ea12dr   = 0;
	exring[cid].unit[i].tx2dr[0] = 0LL;
	exring[cid].unit[i].tx2dr[1] = 0LL;
	exring[cid].unit[i].tx2dr[2] = 0LL;
	exring[cid].unit[i].tx2dr[3] = 0LL;
d659 1
d1190 1
a1191 1
  int k;
d1215 30
@


1.237
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.236 2017/07/07 01:06:37 nakashim Exp nakashim $";
d110 1
a110 1
    Ull   lmlddmqw_ok   : 1; /* wire *//* lmring要求がwrite&ty==2&op0[col]==LDDMQ */
d765 1
a765 1
  Ull   lmlddmqw_ok   : 1; /* wire *//* lmring要求がwrite&ty==2&op0[col]==LDDMQ */
d807 1
a807 1
  exring[cid].unit[i].lmlddmqw_ok    = br->rw==1 && br->ty==2 && reg_ctrl.conf[i][br->col].cdw1.ea0op == OP_LDDMQ; /* lmwd[0]->tr *//* LDDMQは同一slotに高々1が前提 */
d938 1
a938 1
    /* exring[cid].unit[i].lmlddmqw_ok   = rw==1 && ty==2 && [br->col].op0==LDDMQ   */
d1036 1
a1036 1
	exring[cid].unit[i].lmm.mm0 = 0xffffffff;          /* mask *//* ★★★暫定記述★★★ */
d1092 1
a1092 1
    /* tx3dr -> tx4dr */
d1095 16
a1110 13
      exring[cid].unit[i].tx4dr[0] = reg_ctrl.conf[i][j].cdw2.trs0==0 ? exring[cid].unit[i].lmwd[0] :
                                     reg_ctrl.conf[i][j].cdw2.trs0==1 ? exring[cid].unit[i].ex3dr   :
		  	                                                exring[cid].unit[i].tx3dr[0];
      exring[cid].unit[i].tx4dr[1] = reg_ctrl.conf[i][j].cdw2.trs1==0 ? exring[cid].unit[i].lmwd[1] :
	                             reg_ctrl.conf[i][j].cdw2.trs1==1 ? exring[cid].unit[i].ex3dr   :
			                                                exring[cid].unit[i].tx3dr[1];
      exring[cid].unit[i].tx4dr[2] = reg_ctrl.conf[i][j].cdw2.trs2==0 ? exring[cid].unit[i].lmwd[2] :
                                     reg_ctrl.conf[i][j].cdw2.trs2==1 ? exring[cid].unit[i].ex3dr   :
			                                                exring[cid].unit[i].tx3dr[2];
      exring[cid].unit[i].tx4dr[3] = reg_ctrl.conf[i][j].cdw2.trs3==0 ? exring[cid].unit[i].lmwd[3] :
                                     reg_ctrl.conf[i][j].cdw2.trs3==1 ? exring[cid].unit[i].ex3dr   :
			                                                exring[cid].unit[i].tx3dr[3];
      exring[cid].unit[i].tr_valid = 1;
@


1.236
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.235 2017/07/06 22:56:32 nakashim Exp nakashim $";
d40 1
a40 1
  Ull   ty            : 2; /* 0:register, 1:lmm/vaddr, 2:lddmq/trans-r, 3:lddmq-w */
d108 4
a111 4
    Ull   lmrange_ok    : 1; /* wire *//* lmring要求がlmm&lmm_range内 */
    Ull   lmring_lddmqw : 1; /* wire *//* ty==3 & op0==LDDMQ */
    Ull   lmring_ful    : 1; /* wire *//* (ful2==3)|(ful1 & (ful2==2)) */
    Ull   lmring_ea0strq: 1; /* wire *//* ea0.strq存在★★★4サイクルに分けて実行 */
d114 2
a115 1
    Ull   deq_wait      : 1; /* wire *//* lmring_ful | (lmrange_ok & (ea0_conflict | ea1_conflict)) */
d119 1
a119 1
      Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lddmq/trans-r, 3:lddmq-w */
d153 1
a153 1
      Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lddmq/trans-r, 3:lddmq-w */
d763 4
a766 4
  Ull   lmrange_ok    : 1; /* wire *//* lmring要求がlmm&lmm_range内 */
  Ull   lmring_lddmqw : 1; /* wire *//* ty==3 & op0==LDDMQ */
  Ull   lmring_ful    : 1; /* wire *//* (ful2==3)|(ful1 & (ful2==2)) */
  Ull   lmring_ea0strq: 1; /* wire *//* ea0.strq存在★★★4サイクルに分けて実行 */
d769 2
a770 1
  Ull   deq_ok        : 1; /* wire *//* (lmrange_ok & lmring_eabusy)!wait & !ful */
d774 1
a774 1
    Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lddmq/trans-r, 3:lddmq-w */
d805 4
a808 4
  exring[cid].unit[i].lmrange_ok     = br->ty==1 && reg_ctrl.addr[i][br->col].top<=br->a && reg_ctrl.addr[i][br->col].bot>=br->a; /* assign */
  exring[cid].unit[i].lmring_lddmqw  = br->ty==3 && reg_ctrl.conf[i][j].cdw1.ea0op == OP_LDDMQ; /* lmwd[0]->tr *//* LDDMQは同一slotに高々1が前提 */
  exring[cid].unit[i].lmring_ful     = (exring[cid].unit[i].lmring_ful2==3) || (exring[cid].unit[i].lmring_ful1 && exring[cid].unit[i].lmring_ful2==2); /* assign */
  exring[cid].unit[i].lmring_ea0strq = reg_ctrl.conf[i][0].cdw1.ea0op == OP_STRQ || reg_ctrl.conf[i][1].cdw1.ea0op == OP_STRQ
d810 6
a815 3
  exring[cid].unit[i].lmring_ea0bsy  = exring[cid].unit[i].stage4_exec && ((reg_ctrl.conf[i][j].cdw1.ea0op && reg_ctrl.conf[i][j].cdw1.ea0op <= OP_IM_BUFWR)||exring[cid].unit[i].lmring_ea0strq); /* op0 */
  exring[cid].unit[i].lmring_ea1bsy  = exring[cid].unit[i].stage4_exec &&   reg_ctrl.conf[i][j].cdw1.ea1op && reg_ctrl.conf[i][j].cdw1.ea1op <= OP_IM_BUFRD; /* op1 */
  exring[cid].unit[i].deq_wait       = exring[cid].unit[i].lmring_ful || (exring[cid].unit[i].lmrange_ok && ((br->rw == 1 && exring[cid].unit[i].lmring_ea0bsy) || (br->rw == 0 && exring[cid].unit[i].lmring_ea1bsy)));
d860 1
a860 1
    exring[cid].unit[i].lmring_tr.pass = br->ty == 0 || !(br->rw == 0 && exring[cid].unit[i].lmrange_ok); /* reg or read (VADDR/LDDMQ/TRANS) in range */
d936 6
a941 2
    /* exring[cid].unit[i].lmrange_ok    = ty==1 && [br->col].top <= br->a && [br->col].bot >= br->a); */
    /* exring[cid].unit[i].lmring_lddmqw = ty==3 && op0==LDDMQ            */
d943 1
a943 4
    /* exring[cid].unit[i].lmring_ea0strq= STRQ[*];                       */
    /* exring[cid].unit[i].lmring_ea0bsy = EXEC && (normal_op0||STRQ[*]); */
    /* exring[cid].unit[i].lmring_ea1bsy = EXEC && normal_op1;            */
    /* exring[cid].unit[i].deq_wait      = lmring_ful | (range_ok & (prev_br_write_req conflicts w/ normal_op0 | (prev_br_read_req conflicts w/ normal_op1))); */
d946 2
a947 2
    /* (NOP | EXEC) & !deq_wait & lmrange_ok & rw=1の時 lmwa->ea04dr */
    /* lmring_ea0bsy                               の時,ea0d->ea04dr */
d949 1
a949 1
      && exring[cid].unit[pi].lmring_ful2 && !exring[cid].unit[i].deq_wait && exring[cid].unit[i].lmrange_ok && br->rw == 1) { /* axi->lmm_write */
d1044 1
a1044 1
	if (exring[cid].unit[i].lmring_ea0strq) {
d1056 2
a1057 2
    /* (NOP | EXEC) & !deq_wait & lmrange_ok & rw=1の時 lmra->ea14dr */
    /* lmring_ea1bsy                               の時,ea1d->ea14dr */
d1059 1
a1059 1
      && exring[cid].unit[pi].lmring_ful2 && !exring[cid].unit[i].deq_wait && exring[cid].unit[i].lmrange_ok && br->rw == 0) { /* axi->lmm_read */
d1182 1
a1182 1
    Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lddmq/trans-r, 3:lddmq-w */
@


1.235
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.234 2017/07/06 00:11:20 nakashim Exp nakashim $";
d40 1
a40 1
  Ull   ty            : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:lmm/trans */
d109 1
d118 1
a118 1
      Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:lmm/trans */
d152 1
a152 1
      Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:lmm/trans */
d763 1
d772 1
a772 1
    Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:lmm/trans */
d803 2
a804 1
  exring[cid].unit[i].lmrange_ok     = br->ty && reg_ctrl.addr[i][br->col].top <= br->a && reg_ctrl.addr[i][br->col].bot >= br->a; /* assign */
d931 2
a932 1
    /* exring[cid].unit[i].lmrange_ok    = ty && [br->col].top <= br->a && [br->col].bot >= br->a); */
d1176 1
a1176 1
    Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:lmm/trans */
@


1.234
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.233 2017/07/05 23:19:13 nakashim Exp nakashim $";
a131 1
    Ull   mwsft[UNIT_WIDTH]; /* wire for mw0[] */
a872 1
  Ull   mwsft[UNIT_WIDTH]; /* wire for mw0[] */
d929 2
a930 2
    /* exring[cid].unit[i].lmring_ful    = NEXT_TR+NEXT_BR==FULL; */
    /* exring[cid].unit[i].lmring_ea0strq= EXEC && STRQ[*]; */
d932 1
a932 1
    /* exring[cid].unit[i].lmring_ea1bsy = EXEC && normal_op1; */
d989 4
a992 4
	exring[cid].unit[i].mwsft[0] = exring[cid].unit[i].mwmux[0]; /* align不要 */
	exring[cid].unit[i].mwsft[1] = exring[cid].unit[i].mwmux[1]; /* align不要 */
	exring[cid].unit[i].mwsft[2] = exring[cid].unit[i].mwmux[2]; /* align不要 */
	exring[cid].unit[i].mwsft[3] = exring[cid].unit[i].mwmux[3]; /* align不要 */
d999 4
a1002 4
	exring[cid].unit[i].mwsft[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].cx3dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].mwsft[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].cx3dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].mwsft[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].cx3dr & sizeof(int))*8; /* align必要 */
	exring[cid].unit[i].mwsft[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].cx3dr & sizeof(int))*8; /* align必要 */
d1009 4
a1012 4
	exring[cid].unit[i].mwsft[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].mwsft[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].mwsft[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	exring[cid].unit[i].mwsft[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
d1019 4
a1022 4
	exring[cid].unit[i].mwsft[0] = exring[cid].unit[i].mwmux[0]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].mwsft[1] = exring[cid].unit[i].mwmux[1]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].mwsft[2] = exring[cid].unit[i].mwmux[2]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	exring[cid].unit[i].mwsft[3] = exring[cid].unit[i].mwmux[3]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
d1027 4
a1030 4
	exring[cid].unit[i].mwsft[0] = exring[cid].unit[i].mwmux[0]; /* ★★★暫定記述★★★ */
	exring[cid].unit[i].mwsft[1] = exring[cid].unit[i].mwmux[1]; /* ★★★暫定記述★★★ */
	exring[cid].unit[i].mwsft[2] = exring[cid].unit[i].mwmux[2]; /* ★★★暫定記述★★★ */
	exring[cid].unit[i].mwsft[3] = exring[cid].unit[i].mwmux[3]; /* ★★★暫定記述★★★ */
d1032 2
a1033 1
      default: /* case OP_STRQ */
d1035 3
a1037 2
	/* ★★★STRQはSTRを4サイクルに分割実行★★★ */
	  
a1040 5
      exring[cid].unit[i].lmm.mm0     = 
      exring[cid].unit[i].lmm.mw0[0]  = 
      exring[cid].unit[i].lmm.mw0[1]  = 
      exring[cid].unit[i].lmm.mw0[2]  = 
      exring[cid].unit[i].lmm.mw0[3]  = 
a1081 3
    /*********************************************************************************************/
    /*********************************************************************************************/

d1083 17
a1099 27
    exring[cid].unit[i].tx4dr[0] = exring[cid].unit[i].tx3dr[0];
    exring[cid].unit[i].tx4dr[1] = exring[cid].unit[i].tx3dr[1];
    exring[cid].unit[i].tx4dr[2] = exring[cid].unit[i].tx3dr[2];
    exring[cid].unit[i].tx4dr[3] = exring[cid].unit[i].tx3dr[3];
    exring[cid].unit[i].tr_valid = 1;

    /*********************************************************************************************/
    /*********************************************************************************************/

    exring[cid].unit[i][j].lmm.mw0[0] = (reg_ctrl.conf[i][j].cdw2.mws0 > 0) ? mwsft[0] : lmwd[0];
    exring[cid].unit[i][j].lmm.mw0[1] = (reg_ctrl.conf[i][j].cdw2.mws1 > 0) ? mwsft[1] : lmwd[1];
    exring[cid].unit[i][j].lmm.mw0[2] = (reg_ctrl.conf[i][j].cdw2.mws2 > 0) ? mwsft[2] : lmwd[2];
    exring[cid].unit[i][j].lmm.mw0[3] = (reg_ctrl.conf[i][j].cdw2.mws3 > 0) ? mwsft[3] : lmwd[3];

    /* explicit trs[3-0]: 0:exdr[], 1:lmwd[], 2:t[] */
    exring[cid].unit[i][j].tr[0] = reg_ctrl.conf[i][j].cdw2.trs0==0 ? exring[cid].unit[i][0].exdr   :
                                   reg_ctrl.conf[i][j].cdw2.trs0==1 ? exring[cid].unit[i][j].lmwd[0]:
			                                              exring[cid].unit[i][j].t[0]   ;
    exring[cid].unit[i][j].tr[1] = reg_ctrl.conf[i][j].cdw2.trs1==0 ? exring[cid].unit[i][1].exdr   :
                                   reg_ctrl.conf[i][j].cdw2.trs1==1 ? exring[cid].unit[i][j].lmwd[1]:
			                                              exring[cid].unit[i][j].t[1]   ;
    exring[cid].unit[i][j].tr[2] = reg_ctrl.conf[i][j].cdw2.trs2==0 ? exring[cid].unit[i][2].exdr   :
                                   reg_ctrl.conf[i][j].cdw2.trs2==1 ? exring[cid].unit[i][j].lmwd[2]:
			                                              exring[cid].unit[i][j].t[2]   ;
    exring[cid].unit[i][j].tr[3] = reg_ctrl.conf[i][j].cdw2.trs3==0 ? exring[cid].unit[i][3].exdr   :
                                   reg_ctrl.conf[i][j].cdw2.trs3==1 ? exring[cid].unit[i][j].lmwd[3]:
			                                              exring[cid].unit[i][j].t[3]   ;
@


1.233
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.232 2017/07/05 14:28:54 nakashim Exp nakashim $";
d110 1
d764 1
d802 7
a808 5
  exring[cid].unit[i].lmrange_ok    = br->ty && reg_ctrl.addr[i][br->col].top <= br->a && reg_ctrl.addr[i][br->col].bot >= br->a; /* assign */
  exring[cid].unit[i].lmring_ful    = (exring[cid].unit[i].lmring_ful2==3) || (exring[cid].unit[i].lmring_ful1 && exring[cid].unit[i].lmring_ful2==2); /* assign */
  exring[cid].unit[i].lmring_ea0bsy = exring[cid].unit[i].stage4_exec && reg_ctrl.conf[i][j].cdw1.ea0op && reg_ctrl.conf[i][j].cdw1.ea0op <= OP_IM_BUFWR; /* op0 */
  exring[cid].unit[i].lmring_ea1bsy = exring[cid].unit[i].stage4_exec && reg_ctrl.conf[i][j].cdw1.ea1op && reg_ctrl.conf[i][j].cdw1.ea1op <= OP_IM_BUFRD; /* op1 */
  exring[cid].unit[i].deq_wait      = exring[cid].unit[i].lmring_ful || (exring[cid].unit[i].lmrange_ok && ((br->rw == 1 && exring[cid].unit[i].lmring_ea0bsy) || (br->rw == 0 && exring[cid].unit[i].lmring_ea1bsy)));
d932 2
a933 1
    /* exring[cid].unit[i].lmring_ea0bsy = EXEC && normal_op0; */
d997 8
a1004 4
	for (k=0; k<UNIT_WIDTH; k++) {
	  exring[cid].unit[i].lmm.mm0[k] = (exring[cid].unit[i].ea04dr/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((exring[cid].unit[i].cx3dr&1)?0x00000000ffffffffLL:0LL)<<(exring[cid].unit[i].cx3dr & sizeof(int))*8) : 0LL; /* mask */
	  exring[cid].unit[i].mwsft[k] = exring[cid].unit[i].mwmux[k]<<(exring[cid].unit[i].cx3dr & sizeof(int))*8; /* align必要 */
	}
d1007 8
a1014 4
	for (k=0; k<UNIT_WIDTH; k++) {
	  exring[cid].unit[i].lmm.mm0[k] = (exring[cid].unit[i].ea04dr/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((exring[cid].unit[i].cx3dr&1)?0x000000000000ffffLL:0LL)<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)))*8) : 0LL; /* mask */
	  exring[cid].unit[i].mwsft[k] = exring[cid].unit[i].mwmux[k]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)))*8; /* align必要 */
	}
d1017 8
a1024 4
	for (k=0; k<UNIT_WIDTH; k++) {
	  exring[cid].unit[i].lmm.mm0[k] = (exring[cid].unit[i].ea04dr/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((exring[cid].unit[i].cx3dr&1)?0x00000000000000ffLL:0LL)<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8) : 0LL; /* mask */
	  exring[cid].unit[i].mwsft[k] = exring[cid].unit[i].mwmux[k]<<(exring[cid].unit[i].cx3dr & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
	}
a1025 1
      case OP_STRQ:
d1028 10
a1037 3
	for (k=0; k<UNIT_WIDTH; k++) {
	  exring[cid].unit[i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	  exring[cid].unit[i].mwsft[k] = exring[cid].unit[i].mwmux[k];
@


1.232
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.231 2017/07/05 02:36:45 nakashim Exp nakashim $";
d976 47
a1022 6

      exring[cid].unit[i].lmm.mm0     = exring[cid].unit[i].lmwm;    /* ignored if load */
      exring[cid].unit[i].lmm.mw0[0]  = exring[cid].unit[i].lmwd[0]; /* ignored if load */
      exring[cid].unit[i].lmm.mw0[1]  = exring[cid].unit[i].lmwd[1]; /* ignored if load */
      exring[cid].unit[i].lmm.mw0[2]  = exring[cid].unit[i].lmwd[2]; /* ignored if load */
      exring[cid].unit[i].lmm.mw0[3]  = exring[cid].unit[i].lmwd[3]; /* ignored if load */
d1064 3
a1076 35
    switch (reg_ctrl.conf[i][j].cdw1.ea0op) {
    case OP_STR:
      for (k=0; k<UNIT_WIDTH; k++) {
	exring[cid].unit[i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((exring[cid].unit[i][j].cexdr&2)?0xffffffff00000000LL:0LL)|((exring[cid].unit[i][j].cexdr&1)?0x00000000ffffffffLL:0LL)) : 0LL; /* mask */
	mwsft[k] = mwmux[k]; /* align不要 */
      }
      break;
    case OP_STWR:
      for (k=0; k<UNIT_WIDTH; k++) {
	exring[cid].unit[i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((exring[cid].unit[i][j].cexdr&1)?0x00000000ffffffffLL:0LL)<<(a & sizeof(int))*8) : 0LL; /* mask */
	mwsft[k] = mwmux[k]<<(a & sizeof(int))*8; /* align必要 */
      }
      break;
    case OP_STHR:
      for (k=0; k<UNIT_WIDTH; k++) {
	exring[cid].unit[i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((exring[cid].unit[i][j].cexdr&1)?0x000000000000ffffLL:0LL)<<(a & (sizeof(int)|sizeof(short)))*8) : 0LL; /* mask */
	mwsft[k] = mwmux[k]<<(a & (sizeof(int)|sizeof(short)))*8; /* align必要 */
      }
      break;
    case OP_STBR:
      for (k=0; k<UNIT_WIDTH; k++) {
	exring[cid].unit[i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((exring[cid].unit[i][j].cexdr&1)?0x00000000000000ffLL:0LL)<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8) : 0LL; /* mask */
	mwsft[k] = mwmux[k]<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
      }
      break;
    case OP_STRQ:
    case OP_IM_PREF:
    case OP_IM_BUFWR:
      for (k=0; k<UNIT_WIDTH; k++) {
	exring[cid].unit[i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	mwsft[k] = mwmux[k];
      }
      break;
    }

@


1.231
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.230 2017/07/04 15:41:06 nakashim Exp nakashim $";
a94 1
    Ull   ea04_laddr    :18; /* wire *//* address */
a95 1
    Ull   ea04_upart    : 2; /* wire *//* partition */
d99 1
a99 3
    Ull   ea14_laddr    :18; /* wire *//* address */
    Ull   ea14_lmask    :18; /* wire *//* mask */
    Ull   ea14_upart    : 2; /* wire *//* partition */
d130 2
a858 1
  Ull   ea04_laddr    :18; /* wire *//* address */
a859 1
  Ull   ea04_upart    : 2; /* wire *//* partition */
d863 1
a863 3
  Ull   ea14_laddr    :18; /* wire *//* address */
  Ull   ea14_lmask    :18; /* wire *//* mask */
  Ull   ea14_upart    : 2; /* wire *//* partition */
d869 2
d946 2
a947 2
      exring[cid].unit[i].ea04_upart  = exring[cid].unit[i].lmco;
      exring[cid].unit[i].ea04_laddr  = exring[cid].unit[i].lmca;
d950 6
d964 2
a965 2
      exring[cid].unit[i].ea04_upart  = j;
      exring[cid].unit[i].ea04_laddr  = exring[cid].unit[i].ea03dr;
d968 1
d971 11
a986 9
    exring[cid].unit[i].ea04dr_prev = exring[cid].unit[i].ea04dr; /* siml-loop only */
    exring[cid].unit[i].ea04dr      = ((exring[cid].unit[i].ea04_upart & exring[cid].unit[i].ea04_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea04_laddr & exring[cid].unit[i].ea04_lmask);
    exring[cid].unit[i].lmm.ma0     = (exring[cid].unit[i].ea04dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
    exring[cid].unit[i].lmm.mm0     = exring[cid].unit[i].lmwm;
    exring[cid].unit[i].lmm.mw0[0]  = exring[cid].unit[i].lmwd[0];
    exring[cid].unit[i].lmm.mw0[1]  = exring[cid].unit[i].lmwd[1];
    exring[cid].unit[i].lmm.mw0[2]  = exring[cid].unit[i].lmwd[2];
    exring[cid].unit[i].lmm.mw0[3]  = exring[cid].unit[i].lmwd[3];

d1000 2
a1001 2
      exring[cid].unit[i].ea14_upart  = exring[cid].unit[i].lmco;
      exring[cid].unit[i].ea14_laddr  = exring[cid].unit[i].lmca;
d1004 1
d1013 2
a1014 2
      exring[cid].unit[i].ea14_upart  = j;
      exring[cid].unit[i].ea14_laddr  = exring[cid].unit[i].ea13dr;
d1017 1
a1022 4
    exring[cid].unit[i].ea14dr_prev = exring[cid].unit[i].ea14dr; /* siml-loop only */
    exring[cid].unit[i].ea14dr      = ((exring[cid].unit[i].ea14_upart & exring[cid].unit[i].ea14_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea14_laddr & exring[cid].unit[i].ea14_lmask);
    exring[cid].unit[i].lmm.ma1     = (exring[cid].unit[i].ea14dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);

a1032 21
Ull exdmux[UNIT_WIDTH], exdsft[UNIT_WIDTH];

    /* mws[3-0]: 0:exdr, 1:exdr0, 2:ts0, 3:lmli0, 4:lmwd0, 5:lmri0 */
    a = exring[cid].unit[i][j].ea0dr % LMEM_SIZE; /* main-mamory-address -> lmm-address */
    exdmux[0] = reg_ctrl.conf[i][j].cdw2.mws0==0 ? exring[cid].unit[i][j].exdr /* tr[3-0]はalign不要 */
              : reg_ctrl.conf[i][j].cdw2.mws0==1 ? exring[cid].unit[i][0].exdr
              : reg_ctrl.conf[i][j].cdw2.mws0==2 ? exring[cid].unit[i][j].t[0]
              :                                     0LL;
    exdmux[1] = reg_ctrl.conf[i][j].cdw2.mws1==0 ? exring[cid].unit[i][j].exdr
              : reg_ctrl.conf[i][j].cdw2.mws1==1 ? exring[cid].unit[i][1].exdr
              : reg_ctrl.conf[i][j].cdw2.mws1==2 ? exring[cid].unit[i][j].t[1]
              :                                     0LL;
    exdmux[2] = reg_ctrl.conf[i][j].cdw2.mws2==0 ? exring[cid].unit[i][j].exdr
              : reg_ctrl.conf[i][j].cdw2.mws2==1 ? exring[cid].unit[i][2].exdr
              : reg_ctrl.conf[i][j].cdw2.mws2==2 ? exring[cid].unit[i][j].t[2]
              :                                     0LL;
    exdmux[3] = reg_ctrl.conf[i][j].cdw2.mws3==0 ? exring[cid].unit[i][j].exdr
              : reg_ctrl.conf[i][j].cdw2.mws3==1 ? exring[cid].unit[i][3].exdr
              : reg_ctrl.conf[i][j].cdw2.mws3==2 ? exring[cid].unit[i][j].t[3]
              :                                     0LL;

d1037 1
a1037 1
	exdsft[k] = exdmux[k]; /* align不要 */
d1043 1
a1043 1
	exdsft[k] = exdmux[k]<<(a & sizeof(int))*8; /* align必要 */
d1049 1
a1049 1
	exdsft[k] = exdmux[k]<<(a & (sizeof(int)|sizeof(short)))*8; /* align必要 */
d1055 1
a1055 1
	exdsft[k] = exdmux[k]<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
d1063 1
a1063 1
	exdsft[k] = exdmux[k];
d1068 4
a1071 4
    exring[cid].unit[i][j].lmm.mw0[0] = (reg_ctrl.conf[i][j].cdw2.mws0 < 3) ? exdsft[0] : lmwd[0];
    exring[cid].unit[i][j].lmm.mw0[1] = (reg_ctrl.conf[i][j].cdw2.mws1 < 3) ? exdsft[1] : lmwd[1];
    exring[cid].unit[i][j].lmm.mw0[2] = (reg_ctrl.conf[i][j].cdw2.mws2 < 3) ? exdsft[2] : lmwd[2];
    exring[cid].unit[i][j].lmm.mw0[3] = (reg_ctrl.conf[i][j].cdw2.mws3 < 3) ? exdsft[3] : lmwd[3];
@


1.230
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.229 2017/07/04 07:56:04 nakashim Exp nakashim $";
d377 1
d1020 1
a1020 2
--------------------------------------------------
    /* tx */
a1025 2
    /****************************************/
  }
d1027 2
a1028 2
  return (0);
}
d1030 1
a1030 5
siml_unit_trg(cid, i, j) Uint cid, i, j; /* 全bus計算後にtr更新 */
{
  Ull a;
  int k;
  Ull exdmux[UNIT_WIDTH], exdsft[UNIT_WIDTH];
a1031 6
  /* update: exdr,t,lmwd,lmlio/lmrio -> tr,mw */
  switch (lmring[cid].status) {
  case STATUS_EXEC:
    if ((lmring[cid].unit1_exec & (1LL<<i)) && (lmring[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
      exring[cid].unit[i][j].one_shot = 0; /* set one_shot here */
    }
d1104 1
a1104 2
    return (0);
  }
@


1.229
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.228 2017/07/02 15:08:02 nakashim Exp nakashim $";
d95 4
a98 3
    Ull   ea04_lmask    :18; /* wire *//* partition */
    Ull   ea04_umask    :18; /* wire *//* offset */
    Ull   ea04_msked    :18; /* wire *//* address */
d101 4
a104 3
    Ull   ea14_lmask    :18; /* wire *//* partition */
    Ull   ea14_umask    :18; /* wire *//* offset */
    Ull   ea14_msked    :18; /* wire *//* address */
d803 3
a805 6
  exring[cid].unit[i].lmring_ea0bsy = exring[cid].unit[i].cmd == CMD_EXEC && exring[cid].unit[i].unit1_exec && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid
                                      && reg_ctrl.conf[i][j].cdw1.ea0op && reg_ctrl.conf[i][j].cdw1.ea0op <= OP_IM_BUFWR; /* op0 */
  exring[cid].unit[i].lmring_ea1bsy = exring[cid].unit[i].cmd == CMD_EXEC && exring[cid].unit[i].unit1_exec && exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid
                                      && reg_ctrl.conf[i][j].cdw1.ea1op && reg_ctrl.conf[i][j].cdw1.ea1op <= OP_IM_BUFRD; /* op1 */
  exring[cid].unit[i].deq_wait      = exring[cid].unit[i].lmring_ful
                                  || (exring[cid].unit[i].lmrange_ok && ((br->rw == 1 && exring[cid].unit[i].lmring_ea0bsy) || (br->rw == 0 && exring[cid].unit[i].lmring_ea1bsy)));
d860 4
a863 3
  Ull   ea_lmask      :18; /* wire *//* partition */
  Ull   ea_umask      :18; /* wire *//* offset */
  Ull   ea_msked      :18; /* wire *//* address */
d866 4
d949 2
a950 3
      exring[cid].unit[i].ea04_msked  = ((exring[cid].unit[i].lmco & exring[cid].unit[i].ea04_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].lmca & exring[cid].unit[i].ea04_lmask);
      exring[cid].unit[i].ea04dr_prev = exring[cid].unit[i].ea04dr; /* siml-loop only */
      exring[cid].unit[i].ea04dr      = exring[cid].unit[i].ea04_msked;
a952 6
      exring[cid].unit[i].lmm.ma0     = exring[cid].unit[i].ea04_msked;
      exring[cid].unit[i].lmm.mm0     = exring[cid].unit[i].lmwm;
      exring[cid].unit[i].lmm.mw0[0]  = exring[cid].unit[i].lmwd[0];
      exring[cid].unit[i].lmm.mw0[1]  = exring[cid].unit[i].lmwd[1];
      exring[cid].unit[i].lmm.mw0[2]  = exring[cid].unit[i].lmwd[2];
      exring[cid].unit[i].lmm.mw0[3]  = exring[cid].unit[i].lmwd[3];
d961 2
a962 3
      exring[cid].unit[i].ea04_msked  = ((j & exring[cid].unit[i].ea04_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea03dr & exring[cid].unit[i].ea04_lmask);
      exring[cid].unit[i].ea04dr_prev = exring[cid].unit[i].ea04dr; /* siml-loop only */
      exring[cid].unit[i].ea04dr      = exring[cid].unit[i].ea04_msked;
d964 7
a970 1
      /****************************************/
d972 8
a979 11
    else if (reg_ctrl.conf[i][j].cdw1.ea0op) { /* normal load/store */
      if ((lmring[cid].unit1_exec & (1LL<<i)) && (lmring[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
        exring[cid].unit[i][j].ea0dr   = exring[cid].unit[i][j].ea0d;
        exring[cid].unit[i][j].lmm.en0 = 1;
        exring[cid].unit[i][j].lmm.rw0 = (reg_ctrl.conf[i][j].conf.cdw1.ea0op & 0x10)!=0; /* read/write */
	                          /* OP_TR   の場合,eag0->WRITE,eag1->READ */
	                          /* OP_LDDMQの場合,eag0->WRITE,eag1->READ */
        exring[cid].unit[i][j].lmm.ma0 = (exring[cid].unit[i][j].ea0dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
	/*printf("===BUFWR write row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)exring[cid].unit[i][j].ea1d, (Uint)exring[cid].unit[i][j].ea0d);*/
      }
    }
a980 5
      /****************************************/
    }
    else {
      exring[cid].unit[i].lmm.en0     = 0;
    }
d994 2
a995 3
      exring[cid].unit[i].ea14_msked  = ((exring[cid].unit[i].lmco & exring[cid].unit[i].ea14_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].lmca & exring[cid].unit[i].ea14_lmask);
      exring[cid].unit[i].ea14dr_prev = exring[cid].unit[i].ea14dr; /* siml-loop only */
      exring[cid].unit[i].ea14dr      = exring[cid].unit[i].ea14_msked;
a997 1
      exring[cid].unit[i].lmm.ma1     = exring[cid].unit[i].ea14_msked;
d1006 2
a1007 3
      exring[cid].unit[i].ea14_msked  = ((j & exring[cid].unit[i].ea14_umask) * (LMEM_SIZE/4)) | (exring[cid].unit[i].ea13dr & exring[cid].unit[i].ea14_lmask);
      exring[cid].unit[i].ea14dr_prev = exring[cid].unit[i].ea14dr; /* siml-loop only */
      exring[cid].unit[i].ea14dr      = exring[cid].unit[i].ea14_msked;
d1009 2
a1010 10
      /****************************************/

    else if (reg_ctrl.conf[i][j].cdw1.ea1op) { /* normal load */
      if ((lmring[cid].unit1_exec & (1LL<<i)) && (lmring[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
	exring[cid].unit[i][j].ea1dr   = exring[cid].unit[i][j].ea1d;
        exring[cid].unit[i][j].lmm.en1 = 1; /* 同一行にLDDMQがある場合,exring[cid].unit[i][j].lmm.en1の連動が必要(次のsiml_unit_bus2()にて補正) */
        exring[cid].unit[i][j].lmm.rw1 = 0; /* read */
        exring[cid].unit[i][j].lmm.ma1 = (exring[cid].unit[i][j].ea1dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
	/*printf("===NLOAD read row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)exring[cid].unit[i][j].ea1d, (Uint)exring[cid].unit[i][j].ea0d);*/
      }
d1012 2
d1015 3
a1017 6
      /****************************************/

    }
    else {
      exring[cid].unit[i].lmm.en1     = 0;
    }
d1019 2
@


1.228
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.227 2017/06/30 13:32:19 nakashim Exp nakashim $";
a61 1
    Ull   unit1_arbrk   : 1; /* loop最終命令の実行完了を表示 */
d69 3
d84 21
a104 14
    Ull   eab              ; /* wire *//* in for ALU */
    Ull   eao              ; /* wire *//* in for ALU */
    Ull   ea0b             ; /* reg  *//* in for EA0 */
    Ull   ea0o             ; /* reg  *//* in for EA0 */
    Ull   ea02dr           ; /* reg  */
    Ull   ea03dr           ; /* reg  */
    Ull   ea04dr_prev      ; /* reg  *//* for siml-loop only */
    Ull   ea04dr           ; /* reg  */
    Ull   ea1b             ; /* reg  *//* in for EA1 */
    Ull   ea1o             ; /* reg  *//* in for EA1 */
    Ull   ea12dr           ; /* reg  */
    Ull   ea13dr           ; /* reg  */
    Ull   ea14dr_prev      ; /* reg  *//* for siml-loop only */
    Ull   ea14dr           ; /* reg  */
d127 2
a128 2
    Ull   lmwc          : 2; /* wire *//* -> conf.lmm_mode */
    Ull   lmwa             ; /* wire *//* -> ea0dr *//* col#による2bit補正前addr */
a130 2
    Ull   lmrc          : 2; /* wire *//* -> conf.lmm_mode */
    Ull   lmra             ; /* wire *//* -> ea1dr *//* col#による2bit補正前addr */
d137 2
a138 2
      Ull   ma0            ; /* internal reg  addr(32B aligned)      */
      Ull   ma1            ; /* internal reg  addr(32B aligned)      */
d418 4
a421 4
  /* stage2out   ------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2==> */
  /* stage3out   --------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1==> */
  /* ex3dbrk     ------------------------------------------------------------------------------------------<===0===X===1===X===2===X===3==>------------------------------------------------ */
  /* stage4out   -------tx4dr----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0==> */
a449 1
	exring[cid].unit[i].unit1_arbrk   = 0; /* reset to default */
d490 1
a490 1
    if (exring[cid].unit[i].unit1_exec & (exring[cid].unit[i].l_row==0 | exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid)) { /* active */
d516 2
d519 2
d525 1
a525 1
      if (exring[cid].unit[i].unit1_exec & (exring[cid].unit[i].l_row==0 | exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid)) /* active */
d529 4
a532 4
      unit1_exec_next =                                    exring[cid].unit[i].unit1_exec | exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_exec;
      unit1_stop_next =  exring[cid].unit[i].unit1_arbrk | exring[cid].unit[i].unit1_stop | exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_stop;
      unit2_exec_next =                                    exring[cid].unit[i].unit1_exec | exring[cid].unit[ i                         ].unit2_exec;
      unit2_stop_next =                                    exring[cid].unit[i].unit1_stop | exring[cid].unit[ i                         ].unit2_stop;
d582 1
a582 1
    if (exring[cid].unit[i].unit1_exec & exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid) { /* active */
d607 1
a607 1
      exring[cid].unit[i].ex2dbrk |= exe(op_ex1, &exring[cid].unit[i].ex2dr, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5);
d622 2
d625 2
d658 1
a658 1
    if (exring[cid].unit[i].unit1_exec & exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid) { /* active */
d675 2
d678 2
d776 3
a778 4
  Ull   lmwc          : 2; /* wire *//* -> conf.lmm_mode */
  Ull   lmwa             ; /* wire *//* -> ea0dr *//* col#による2bit補正前addr */
  Ull   lmrc          : 2; /* wire *//* -> conf.lmm_mode */
  Ull   lmra             ; /* wire *//* -> ea1dr *//* col#による2bit補正前addr */
d800 5
a804 3
  exring[cid].unit[i].lmring_ful    = (exring[cid].unit[i].lmring_ful2==3) | (exring[cid].unit[i].lmring_ful1 & exring[cid].unit[i].lmring_ful2==2); /* assign */
  exring[cid].unit[i].lmring_ea0bsy = exring[cid].unit[i].cmd == CMD_EXEC && reg_ctrl.conf[i][j].cdw1.ea0op && reg_ctrl.conf[i][j].cdw1.ea0op <= OP_IM_BUFWR; /* op0 */
  exring[cid].unit[i].lmring_ea1bsy = exring[cid].unit[i].cmd == CMD_EXEC && reg_ctrl.conf[i][j].cdw1.ea1op && reg_ctrl.conf[i][j].cdw1.ea1op <= OP_IM_BUFRD; /* op1 */
d806 1
a806 1
                                   | (exring[cid].unit[i].lmrange_ok & ((br->rw == 1 & exring[cid].unit[i].lmring_ea0bsy) | (br->rw == 0 & exring[cid].unit[i].lmring_ea1bsy)));
d815 2
a816 4
  exring[cid].unit[i].lmwc    = br->col;  /* wire *//* -> conf.lmm_mode */
  exring[cid].unit[i].lmwa    = br->a;    /* wire *//* -> ea0dr *//* col#による2bit補正前addr */
  exring[cid].unit[i].lmrc    = br->col;  /* wire *//* -> conf.lmm_mode */
  exring[cid].unit[i].lmra    = br->a;    /* wire *//* -> ea1dr *//* col#による2bit補正前addr *//* ★★★lDDMQ/TRANSは未対応 */
d861 3
d875 3
a877 3
    Ull   ma0            ; /* internal reg  addr(32B aligned)      */
    Ull   ma1            ; /* internal reg  addr(32B aligned)      */
    Ull   mm0[UNIT_WIDTH]; /* internal reg  mask */
d913 1
a913 1
    if (exring[cid].unit[i].cmd == CMD_EXEC) {
d924 1
a924 1
    /* lmra/lmwa/ea3dr -> ea4dr */
d931 48
a978 38
    /* NOP | (EXEC & conf.mwsa=0)の時,lmwa->ea04dr ただしlmwd有効データは,deq_enおよびlmrange_okの時 */
    /*       (EXEC & conf.mwsa=1)の時,ea0d->ea04dr 上位マスクはconf.lmm_modeに従う */
    if (exring[cid].unit[i].cmd == CMD_NOP || (exring[cid].unit[i].cmd == CMD_EXEC && reg_ctrl.conf[i][j].cdw2.mwsa==0)) { /* ea0d空きcycle */
      if (exring[cid].unit[pi].lmring_ful2 && !exring[cid].unit[i].deq_wait && exring[cid].unit[i].lmrange_ok) { /* lmra/lmra->ea04dr */
	/* LMEM_SIZE(128KB)/4 = 32KB... lmm_mode=1:adr=(block=col&0)*(LMEM_SIZE/4) | (ofs=adr&(LMEM_SIZE/1-1)) */
	/*                              lmm_mode=2:adr=(block=col&2)*(LMEM_SIZE/4) | (ofs=adr&(LMEM_SIZE/2-1)) */
	/*                              lmm_mode=3:adr=(block=col&3)*(LMEM_SIZE/4) | (ofs=adr&(LMEM_SIZE/4-1)) */
	if (br->rw == 1) { /* write */
	  exring[cid].unit[i].ea04dr_prev = exring[cid].unit[i].ea04dr; /* siml-loop only */
	  switch (conf[i][exring[cid].unit[i].lmwc].cdw2.lmm_mode) {
	  case 0: exring[cid].unit[i].lmm.ma0 = exring[cid].unit[i].ea04dr = 0; break;
	  case 1: exring[cid].unit[i].lmm.ma0 = exring[cid].unit[i].ea04dr = ((exring[cid].unit[i].lmwc & 0) * (LMEM_SIZE/4)) | (exring[cid].unit[i].lmwa & (LMEM_SIZE/1-1)); break;
	  case 2: exring[cid].unit[i].lmm.ma0 = exring[cid].unit[i].ea04dr = ((exring[cid].unit[i].lmwc & 2) * (LMEM_SIZE/4)) | (exring[cid].unit[i].lmwa & (LMEM_SIZE/2-1)); break;
	  case 3: exring[cid].unit[i].lmm.ma0 = exring[cid].unit[i].ea04dr = ((exring[cid].unit[i].lmwc & 3) * (LMEM_SIZE/4)) | (exring[cid].unit[i].lmwa & (LMEM_SIZE/4-1)); break;
	  }
	  exring[cid].unit[i].lmm.en0    = 1;
	  exring[cid].unit[i].lmm.en1    = 0;
	  exring[cid].unit[i].lmm.rw0    = 1; /* write */
	  exring[cid].unit[i].lmm.rw1    = 0;
	  exring[cid].unit[i].lmm.mm0    = exring[cid].unit[i].lmwm;
	  exring[cid].unit[i].lmm.mw0[0] = exring[cid].unit[i].lmwd[0];
	  exring[cid].unit[i].lmm.mw0[1] = exring[cid].unit[i].lmwd[1];
	  exring[cid].unit[i].lmm.mw0[2] = exring[cid].unit[i].lmwd[2];
	  exring[cid].unit[i].lmm.mw0[3] = exring[cid].unit[i].lmwd[3];
	}
	else { /* read */
	  exring[cid].unit[i].ea14dr_prev = exring[cid].unit[i].ea14dr; /* siml-loop only */
	  switch (conf[i][exring[cid].unit[i].lmrc].cdw2.lmm_mode) {
	  case 0: exring[cid].unit[i].lmm.ma1 = exring[cid].unit[i].ea14dr = 0; break;
	  case 1: exring[cid].unit[i].lmm.ma1 = exring[cid].unit[i].ea14dr = ((exring[cid].unit[i].lmrc & 0) * (LMEM_SIZE/4)) | (exring[cid].unit[i].lmra & (LMEM_SIZE/1-1)); break;
	  case 2: exring[cid].unit[i].lmm.ma1 = exring[cid].unit[i].ea14dr = ((exring[cid].unit[i].lmrc & 2) * (LMEM_SIZE/4)) | (exring[cid].unit[i].lmra & (LMEM_SIZE/2-1)); break;
	  case 3: exring[cid].unit[i].lmm.ma1 = exring[cid].unit[i].ea14dr = ((exring[cid].unit[i].lmrc & 3) * (LMEM_SIZE/4)) | (exring[cid].unit[i].lmra & (LMEM_SIZE/4-1)); break;
	  }
	  exring[cid].unit[i].lmm.en0 = 0;
	  exring[cid].unit[i].lmm.en1 = 1;
	  exring[cid].unit[i].lmm.rw0 = 0;
	  exring[cid].unit[i].lmm.rw1 = 0; /* read */
	}
a980 12
    else if (exring[cid].unit[i].cmd == CMD_EXEC && reg_ctrl.conf[i][j].cdw2.mwsa==1) { /* CMD_EXEC & mwsa=1 *//* ea0dcycle */
      exring[cid].unit[i].ea04dr = exring[cid].unit[i].ea03dr;
      exring[cid].unit[i].ea14dr = exring[cid].unit[i].ea13dr;

      /* lmwd/ex3dr/tx3dr -> tx4dr */
      exring[cid].unit[i].tx4dr[0] = exring[cid].unit[i].tx3dr[0];
      exring[cid].unit[i].tx4dr[1] = exring[cid].unit[i].tx3dr[1];
      exring[cid].unit[i].tx4dr[2] = exring[cid].unit[i].tx3dr[2];
      exring[cid].unit[i].tx4dr[3] = exring[cid].unit[i].tx3dr[3];
      exring[cid].unit[i].tr_valid = 1;
      exring[cid].unit[i].lmm.mm0 = reg_ctrl.conf[i][j].cdw2.mwsa==0 ?	exring[cid].unit[i].lmwa : exring[cid].unit[i].ea03dr;
      exring[cid].unit[i].lmm.mw0[0] = reg_ctrl.conf[i][j].cdw2.mws0==0 ?	exring[cid].unit[i].lmwa : exring[cid].unit[i].ea03dr;
d982 4
a985 2
      /* tc3dr -> 
      
d987 32
a1018 1
  }
a1019 49

  return (0);
}

siml_unit_ead(cid, i, j) Uint cid, i, j; /* 全bus計算後にreg更新 */
{
  Ull base0, offs0;
  Ull base1, offs1;

  case STATUS_DRAIN: /* fsm drain */
    if (exring[cid].unit[i][j].lmen) {
      exring[cid].unit[i][j].lmm.en1 = 1;
      exring[cid].unit[i][j].lmm.rw1 = 0; /* read */
      exring[cid].unit[i][j].ea1dr = exring[cid].unit[i][j].lmra;


      exring[cid].unit[i][j].lmm.ma1 = (exring[cid].unit[i][j].ea1dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
    }
    else
      exring[cid].unit[i][j].lmm.en1 = 0;
    break;
  case STATUS_LOAD: /* fsm pload */
    if (exring[cid].unit[i][j].lmen) {
      exring[cid].unit[i][j].lmm.en0 = 1;
      exring[cid].unit[i][j].lmm.rw0 = 1; /* write */
      exring[cid].unit[i][j].ea0dr = exring[cid].unit[i][j].lmwa;
      exring[cid].unit[i][j].lmm.ma0 = (exring[cid].unit[i][j].ea0dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
      for (k=0; k<UNIT_WIDTH; k++) {
        exring[cid].unit[i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	exring[cid].unit[i][j].lmm.mw0[k] = exring[cid].unit[i][j].lmwd[k];
      }
    }
    else
      exring[cid].unit[i][j].lmm.en0 = 0;
    break;
----------------------------
  /* ea[01][bo] -> ea[01]dr,ma */
  case STATUS_EXEC:
    /* fsm drain */
    if (reg_ctrl.conf[i][j].cdw1.ea1op == OP_IM_DRAIN) {
      if (exring[cid].unit[i][j].lmen) { /* active */
        exring[cid].unit[i][j].ea1dr = exring[cid].unit[i][j].lmra;
        exring[cid].unit[i][j].lmm.en1 = 1;
        exring[cid].unit[i][j].lmm.rw1 = 0; /* read */
        exring[cid].unit[i][j].lmm.ma1 = (exring[cid].unit[i][j].ea1dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
      }
      else
        exring[cid].unit[i][j].lmm.en1 = 0;
    }
a1027 2
      else /* inactive */
        exring[cid].unit[i][j].lmm.en1 = 0;
d1029 3
a1031 3
    else { /* inactive */
      exring[cid].unit[i][j].lmm.ma1 = exring[cid].unit[i][j].ea1dr = 0LL; /* always non-exec */
      exring[cid].unit[i][j].lmm.en1 = 0;
d1033 2
a1034 10
    /* fsm pload */
    if (reg_ctrl.conf[i][j].cdw1.ea0op == OP_IM_PREF) {
      if (exring[cid].unit[i][j].lmen) {
	exring[cid].unit[i][j].ea0dr = exring[cid].unit[i][j].lmwa;
        exring[cid].unit[i][j].lmm.en0 = 1;
        exring[cid].unit[i][j].lmm.rw0 = 1; /* write */
        exring[cid].unit[i][j].lmm.ma0 = (exring[cid].unit[i][j].ea0dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
      }
      else
        exring[cid].unit[i][j].lmm.en0 = 0;
d1036 10
a1045 18
    else if (reg_ctrl.conf[i][j].cdw1.ea0op) { /* normal load/store */
      if ((lmring[cid].unit1_exec & (1LL<<i)) && (lmring[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
        exring[cid].unit[i][j].ea0dr   = exring[cid].unit[i][j].ea0d;
        exring[cid].unit[i][j].lmm.en0 = 1;
        exring[cid].unit[i][j].lmm.rw0 = (reg_ctrl.conf[i][j].conf.cdw1.ea0op & 0x10)!=0; /* read/write */
	                          /* OP_TR   の場合,eag0->WRITE,eag1->READ */
	                          /* OP_LDDMQの場合,eag0->WRITE,eag1->READ */
        exring[cid].unit[i][j].lmm.ma0 = (exring[cid].unit[i][j].ea0dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
	/*printf("===BUFWR write row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)exring[cid].unit[i][j].ea1d, (Uint)exring[cid].unit[i][j].ea0d);*/
      }
      else /* inactive */
        exring[cid].unit[i][j].lmm.en0 = 0;
    }
    else { /* inactive */
      exring[cid].unit[i][j].lmm.ma0 = exring[cid].unit[i][j].ea0dr = 0LL; /* always non-exec */
      exring[cid].unit[i][j].lmm.en0 = 0;
    }
    break;
@


1.227
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.226 2017/06/29 10:35:27 nakashim Exp nakashim $";
d44 1
a45 1
  Ull   dm            :32; /* <- lmm wdata */
d80 1
d88 1
d94 1
d101 1
a101 2
    Ull   deq_en        : 1; /* wire *//* !wait & !ful */
    Ull   lmring_wait   : 1; /* wire *//* (ea0&rw==1) | (ea1 & rw==0)の場合,lmring待機 */
d103 3
d113 1
a114 1
      Ull   dm          :32; /* <- lmm wdata       */
d116 1
a116 1
    } lmring_tr;
d120 1
d132 1
a132 1
      Ull   mm0[UNIT_WIDTH]; /* internal reg  mask */
d148 1
d150 1
a150 2
      Ull   dm          :32; /* <- lmm wdata       */
    } lmring_br[3];
d742 5
a746 3
  Ull   deq_en        : 1; /* wire *//* !wait & !ful */
  Ull   lmring_wait   : 1; /* wire *//* (ea0&rw==1) | (ea1 & rw==0)の場合,lmring待機 */
  Ull   lmring_ful    : 1; /* wire *//* (ful2==3)|(ful1 & ful2==2) */
d754 1
a755 1
    Ull   dm          :32; /* <- lmm wdata       */
a778 7
  exring[cid].unit[i].lmring_wait  = exring[cid].unit[i].cmd == CMD_EXEC
                                  &&((reg_ctrl.conf[i][j].cdw1.ea0op && reg_ctrl.conf[i][j].cdw1.ea0op <= OP_IM_BUFWR /* op0 */
				      && exring[cid].unit[pi].lmring_ful2 && br->rw == 1)  /* write */
                                  || (reg_ctrl.conf[i][j].cdw1.ea1op && reg_ctrl.conf[i][j].cdw1.ea1op <= OP_IM_BUFRD /* op1 */
			 	      && exring[cid].unit[pi].lmring_ful2 && br->rw == 0)); /* read */
  exring[cid].unit[i].lmring_ful   = (exring[cid].unit[i].lmring_ful2==3) | (exring[cid].unit[i].lmring_ful1 & exring[cid].unit[i].lmring_ful2==2); /* assign */
  exring[cid].unit[i].deq_en       = !exring[cid].unit[i].lmring_wait & !exring[cid].unit[i].lmring_ful & exring[cid].unit[pi].lmring_ful2>0; /* assign */
d780 43
a822 1
  if (exring[cid].unit[i].deq_en) { /* for next cycle */
d829 1
d834 1
a834 23
    exring[cid].unit[i].lmring_tr.dm   = br->dm;   /* next cycle */
    exring[cid].unit[i].lmring_tr.pass = br->ty == 0 /* register */
                                     | !(br->rw == 0 /* read (VADDR/LDDMQ/TRANS) */
                                         && reg_ctrl.addr[i][br->col].top <= br->a
                                         && reg_ctrl.addr[i][br->col].bot >= br->a); /* read in range */
  }
  /* 全有効lmmi[i][j]に対し, conf.lmm_modeは, exringからのLD/STが参照すべきLMM範囲をcycle%4毎に指示 */
  /* 全有効lmmi[i][j]に対し, lmmi.bcas/copyは，ARMが当該LMMIをDMA対象とするかを指示 */
  /* lmm_modeとbcas/copyは連動する */
  /* 全有効lmmi[i][j]に対し, lmm_mode/bcas/copyとは独立に, reg_ctrl.addr[i][j].top/botがlmring向けに範囲を提示 */
  /* top/botはcycle%4の間で重複することもあるが，colで指定したcycle%4のtop/botにHITすればlmringから流し込めばよい. */
  /* ただし，書き込み時にはLMMの分割数を判定する必要があり,colに対応するconf.lmm_modeの参照が必要 */
  /* 上位2bitのマスクは，EA04DRに書き込む際に適用する（LMRA/EA1,LMWA/EA0が各々共有）*/

  if (exring[cid].unit[i].deq_en && br->ty) { /* for next cycle */
    exring[cid].unit[i].lmwc    = br->col;  /* wire *//* -> conf.lmm_mode */
    exring[cid].unit[i].lmwa    = br->a;    /* wire *//* -> ea0dr *//* col#による2bit補正前addr */
    exring[cid].unit[i].lmrc    = br->col;  /* wire *//* -> conf.lmm_mode */
    exring[cid].unit[i].lmra    = br->a;    /* wire *//* -> ea1dr *//* col#による2bit補正前addr *//* ★★★lDDMQ/TRANSは未対応 */
    exring[cid].unit[i].lmwd[0] = br->d[0]; /* wire *//* <- axi   */
    exring[cid].unit[i].lmwd[1] = br->d[1]; /* wire *//* <- axi   */
    exring[cid].unit[i].lmwd[2] = br->d[2]; /* wire *//* <- axi   */
    exring[cid].unit[i].lmwd[3] = br->d[3]; /* wire *//* <- axi   */
d836 2
d841 1
d844 1
d846 1
d865 30
a894 46
-------------------------------------------------------------
    
  /* LMRING_BR LMRD BR */
#if 0
  Ull   lmring_ful2   : 2; /* 0:empty, 3:full */
  Ull   lmring_b_top  : 2; /* to be enqueued next */
  Ull   lmring_b_bot  : 2; /* to be dequeued next */
  struct lmring_br {
    Ull   rw          : 1; /* 0:read, 1:write */
    Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:lmm/trans */
    Ull   col         : 2; /* logical col# for target lmm */
    Ull   sq          :16; /* sequential # for pipelined DMA */
    Ull   a           :31; /* logical addr reg/lmm */
    Ull   d[UNIT_WIDTH]  ; /* <- lmm wdata/rdata */
    Ull   dm          :32; /* <- lmm wdata       */
  } lmring_br[3];
  Ull   mr0mux        : 2; /* mr0[3-0] -> brs0     */
  Ull   mr1mux        : 2; /* mr1[3-0] -> brs1     */
  Ull   mr0d             ; /* muxed data for BR[0] */
  Ull   mr1d             ; /* muxed data for BR[1] */
  Ull   lmrd[UNIT_WIDTH] ; /* wire *//* -> axi   */
  struct {Ull r[UNIT_WIDTH];} b[2][EMAX_WIDTH]; /* shadow_breg *//* constantは両方にセット */
#endif

  switch (exring[cid].unit[i].cmd) {
  case CMD_NOP:   /* nop *//* drain/load */
    if ((exring[cid].unit[i].cycle & 3) == 3) {
      switch (reg_ctrl.cmd) {
      case CMD_RESET: /* reset */
	exring[cid].unit[i].ex4dr    = 0LL;
	exring[cid].unit[i].ea04dr   = 0;
	exring[cid].unit[i].ea14dr   = 0;
	exring[cid].unit[i].tx4dr[0] = 0LL;
	exring[cid].unit[i].tx4dr[1] = 0LL;
	exring[cid].unit[i].tx4dr[2] = 0LL;
	exring[cid].unit[i].tx4dr[3] = 0LL;
	break;
      }
    }
    break;
  case CMD_SCON:  /* scon */
    break;
  case CMD_EXEC:  /* exec */
    /* LD/STによるLMM参照はlmm_modeの割り当てcycleを厳密に守る. */
    /* 空きcycleを捕まえてpdrain/ploadを受け付ける.このためLMRINGに行間待ち合わせ機構が必要 */
    if (exring[cid].unit[i].unit1_exec & exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid) { /* active */
d896 2
a897 1
      exring[cid].unit[i].ex4dr = exring[cid].unit[i].ex3dr;
d902 1
d904 50
a953 16
      /* lmra/lmwa/ea3dr -> ea4dr */
      /* mwsa:1; 0:lmwa, 1:ea0d *//* 0:常時lmwd可能, 1,2:EXEC時以外は強制lmwd可能 */
      /*       load/drainの場合,他に動作するものがないので全4slot利用可能         */
      /*       pload/pdrainの場合,load/storeと競合するので,        */
      /*         lmwa=0&lmm_mode=1:pload/pdrainに全4slot利用可能   */
      /*         lmwa=0&lmm_mode=2:pload/pdrainに2slotのみ利用可能 */
      /*         lmwa=0&lmm_mode=3:pload/pdrainに1slotのみ使用可能 */
      /*         slotに合わせてDMAをインタリーブするのは難しいので順番に実行 */
      /*         slotがばらばらに動作するのはgraphが典型なのでOKとする */
      exring[cid].unit[i].ea04dr  = reg_ctrl.conf[i][j].cdw2.mwsa==0 ?	exring[cid].unit[i].lmwa : exring[cid].unit[i].ea03dr;
      exring[cid].unit[i].lmm.en0 = reg_ctrl.conf[i][j].cdw2.mwsa==0 ?	exring[cid].unit[i].lmwa : exring[cid].unit[i].ea03dr;
      exring[cid].unit[i].lmm.en0 = reg_ctrl.conf[i][j].cdw2.mwsa==0 ?	exring[cid].unit[i].lmwa : exring[cid].unit[i].ea03dr;
      exring[cid].unit[i].lmm.ma0 = reg_ctrl.conf[i][j].cdw2.mwsa==0 ?	exring[cid].unit[i].lmwa : exring[cid].unit[i].ea03dr;

      exring[cid].unit[i].ea14dr = reg_ctrl.conf[i][j].cdw2.mwsa==0 ?	exring[cid].unit[i].lmra : exring[cid].unit[i].ea13dr;
      
d965 1
a966 1
    break;
d969 1
d1214 22
@


1.226
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.225 2017/06/26 05:00:40 nakashim Exp nakashim $";
d113 2
a114 1
    Ull   lmwa             ; /* wire *//* -> ea0dr *//* col#による2bit補正後addr */
d116 2
a117 1
    Ull   lmra             ; /* wire *//* -> ea1dr *//* col#による2bit補正後addr */
d731 2
d750 4
a753 2
  Ull   lmwa             ; /* wire *//* -> ea0dr *//* col#による2bit補正後addr */
  Ull   lmra             ; /* wire *//* -> ea1dr *//* col#による2bit補正後addr */
d757 19
a775 18
    /* op0                      */
    /* OP_LDR          0x01 ... */
    /* OP_STR          0x11 ... */
    /* OP_LDDMQ        0x18     */
    /* OP_TR           0x19     */
    /* OP_IM_BUFWR     0x1e ----ここまでeagと干渉 */
    /* OP_IM_PREF      0x1f lmring-write動作 ★自身なので干渉しない */

    /* op1                      */
    /* OP_LDR          0x01 ... */
    /* OP_IM_BUFRD     0x0e ----ここまでeagと干渉 */
    /* OP_IM_DRAIN     0x0f lmring-read動作 ★自身なので干渉しない */
    /* OP_LDDMQ        0x18 lmring-read動作 ★自身なので干渉しない */
    /* OP_TR           0x19 lmring-read動作 ★自身なので干渉しない */
  exring[cid].unit[i].lmring_wait  = ((reg_ctrl.conf[i][j].cdw1.ea0op && reg_ctrl.conf[i][j].cdw1.ea0op <= OP_IM_BUFWR /* op0 */
				    && exring[cid].unit[pi].lmring_ful2 && exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].rw == 1))  /* write */
                                  || ((reg_ctrl.conf[i][j].cdw1.ea1op && reg_ctrl.conf[i][j].cdw1.ea1op <= OP_IM_BUFRD /* op1 */
			 	    && exring[cid].unit[pi].lmring_ful2 && exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].rw == 0)); /* read */
d781 32
a812 9
    exring[cid].unit[i].lmring_tr.rw   = exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].rw;   /* next cycle */
    exring[cid].unit[i].lmring_tr.ty   = exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].ty;   /* next cycle */
    exring[cid].unit[i].lmring_tr.col  = exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].col;  /* next cycle */
    exring[cid].unit[i].lmring_tr.sq   = exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].sq;   /* next cycle */
    exring[cid].unit[i].lmring_tr.a    = exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].a;    /* next cycle */
    exring[cid].unit[i].lmring_tr.d[0] = exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].d[0]; /* next cycle */
    exring[cid].unit[i].lmring_tr.dm   = exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].dm;   /* next cycle */
    exring[cid].unit[i].lmring_tr.pass = reg_ctrl.addr[i][j].top >= exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].a
                                      || reg_ctrl.addr[i][j].bot <= exring[cid].unit[pi].lmring_br[exring[cid].unit[pi].lmring_b_bot].a; /* out of range */
d837 2
@


1.225
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.223 2017/06/19 09:25:50 nakashim Exp nakashim $";
d131 3
a133 3
    Ull   lmmring_ful2  : 2; /* 0:empty, 3:full */
    Ull   lmmring_b_top : 2; /* to be enqueued next */
    Ull   lmmring_b_bot : 2; /* to be dequeued next */
d701 2
a702 2
  /* ful1        ___________________________0_______0_______0______/1~~~~~~\0_______0______/1~~~~~~~1~~~~~~~1~~~~~~~1~~~~~~~1~~~~~~\0_______0______/1~~~~~~\0_______0_______0_______0______ */
  /* ful2                                   3       3       2       2       3       2       1       1       1       1       2       3       2       2       3       2       2       2       */
d704 1
a704 1
  /* dv          __________________________________________________________________________/~~~~~~~\_______/~~~~~~~~~~~~~~~~~~~~~~~\_______________/~~~~~~~\_______________/~~~~~~~~~~~~~~~ */
d706 3
a708 3
  /* ea04dr      --------------------------------------------------<== 2===>---------------<==a0===X== 2===X==a1===X==a2===X==a3===X== 2===>-------<==a4===>-------<== 2===>--------------- */
  /* ia          --------------------------------------------------------------------------<==a0===>-------<==a1===X==a2===X==a3===>---------------<==a4===>------------------------------- */
  /* di          --------------------------------------------------------------------------<==d0===>-------<==d1===X==d2===X==d3===>---------------<==d4===>------------------------------- */
d715 1
a715 1
  /* ful2                                   3       3       2       2       3       2       1       1       1       1       2       3       2       2       3       2       2       2       */
d727 2
a728 1
  int j = (exring[cid].unit[i].cycle+(EMAX_WIDTH-3)) % EMAX_WIDTH; /* 1,2,3,0,1,2,3,0 */
d734 1
a734 1
  Ull   lmring_ful    : 1; /* wire *//* (ful2==3)|(ful1 & (ful2==2)) */
d751 33
a783 2
  exring[cid].unit[i].ful1 = 
  exring[cid].unit[i].deq_en = 
d810 3
a812 3
  Ull   lmmring_ful2  : 2; /* 0:empty, 3:full */
  Ull   lmmring_b_top : 2; /* to be enqueued next */
  Ull   lmmring_b_bot : 2; /* to be dequeued next */
a829 2
------------------------

a834 1
	exring[cid].unit[i].cx4dr    = 0;
a851 3
      /* cx3dr -> cx4dr */
      exring[cid].unit[i].cx4dr = exring[cid].unit[i].cx3dr;

@


1.224
log
@*** empty log message ***
@
text
@d750 1
@


1.223
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.222 2017/06/18 09:52:25 nakashim Exp nakashim $";
a36 1
  Ull   iaddr         :31; /* reg/lmm */
d38 1
a38 1
  Ull   en            : 1; /* 0:rw/ty/a/di/dm無効, 1:rw/ty/a/di/dm有効 */
d41 7
a47 4
  Ull   din[UNIT_WIDTH]  ; /* <- lmm wdata */
  Ull   dmk[UNIT_WIDTH]  ; /* <- lmm wdata */
  Ull   dv            : 1; /* 0:dt/do無効, 1:有効 */
  Ull   dt            : 1; /* 0:addr無効, 1:有効 */
a72 1
    Ull   cx4dr         : 2; /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
d98 19
a116 6
    Ull   lmwa             ; /* wire *//* -> ea0dr */
    Ull   lmwd[UNIT_WIDTH] ; /* wire *//* <- axi */
    Ull   lmra             ; /* wire *//* -> ea1dr */
    Ull   lmrd[UNIT_WIDTH] ; /* wire *//* -> axi */
    Ull   lmen          : 1; /* wire *//* lmm enable for read/write */
    Ull   rrdy          : 1; /* wire *//* LMM data-valid for FSM */
a129 4
    Ull   mr0mux        : 2; /* mr0[3-0] -> brs0     */
    Ull   mr1mux        : 2; /* mr1[3-0] -> brs1     */
    Ull   mr0d             ; /* muxed data for BR[0] */
    Ull   mr1d             ; /* muxed data for BR[1] */
d131 3
a133 11
    struct lmring_tr {
      Ull   en          : 1; /* 0:rw/ty/a/di/dm無効, 1:rw/ty/a/di/dm有効 */
      Ull   rw          : 1; /* 0:read, 1:write */
      Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:lmm/trans */
      Ull   pass        : 1; /* 0:hit, 1:pass */
      Ull   addr        :31; /* reg/lmm */
      Ull   data[UNIT_WIDTH];
      Ull   mask        :32; /* byte mask */
      Ull   dv          : 1; /* 0:dt/do無効, 1:有効 */
      Ull   dt          : 1; /* 0:addr無効, 1:有効 */
    } lmring_tr;
a134 1
      Ull   en          : 1; /* 0:rw/ty/a/di/dm無効, 1:rw/ty/a/di/dm有効 */
d137 6
a142 6
      Ull   addr        :31; /* reg/lmm */
      Ull   data[UNIT_WIDTH];
      Ull   mask        :32; /* byte mask */
      Ull   dv          : 1; /* 0:dt/do無効, 1:有効 */
      Ull   dt          : 1; /* 0:addr無効, 1:有効 */
    } lmring_br;
d144 4
d149 1
d251 1
a251 1
  siml_axiif(cid, trace);
d255 2
a256 2
    if (exring[cid].unit[i].l_row == 0)
      break;
d259 4
a262 4
    siml_unit_stage5(cid, i); /* stage-5 (3DR->BROUT)(LMRING_TR->LMRING_BROUT) */
    siml_unit_stage4(cid, i); /* stage-4 (2DR->3DR)  (LMRING_BRIN->LMRING_TR) */
    siml_unit_stage3(cid, i); /* stage-3 (1DR->2DR) */
    siml_unit_stage2(cid, i); /* stage-2 (EX/TX->1DR) */
d294 1
d301 1
a301 1
    lmring[cid].iaddr = lmring[cid].axi_araddr; /* start read */
d309 1
a309 1
    lmring[cid].iaddr = lmring[cid].axi_awaddr; /* start write */
d324 1
a324 1
	Ull a = lmring[cid].iaddr + sizeof(Ull)*(lmring[cid].ilen*UNIT_WIDTH+k);
d327 1
a327 1
	  printf("%03.3d:siml_axiif: read iaddr=%08.8x_%08.8x rdata[%d]=%08.8x_%08.8x\n",
d346 1
a346 1
	    Ull a = lmring[cid].iaddr + sizeof(Ull)*(lmring[cid].ilen*UNIT_WIDTH+k);
d349 1
a349 1
	      printf("%03.3d:siml_axiif: write iaddr=%08.8x_%08.8x wdata[%d]=%08.8x_%08.8x\n",
d406 1
a406 1
  /* stage4out   -------tx3dr----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0==> */
a437 1
	exring[cid].unit[i].tr_valid      = 0; /* reset to default */
a439 1
	exring[cid].unit[i].brout_valid   = 0; /* reset to default */
d533 1
a533 1
  int    j  = (exring[cid].unit[i].cycle+(EMAX_WIDTH-1)) % EMAX_WIDTH; /* 3,0,1,2,3,0,1,2 */
d613 1
a613 1
  int    j  = (exring[cid].unit[i].cycle+(EMAX_WIDTH-2)) % EMAX_WIDTH; /* 2,3,0,1,2,3,0,1 */
d667 131
a797 1
  int    j  = (exring[cid].unit[i].cycle+(EMAX_WIDTH-3)) % EMAX_WIDTH; /* 1,2,3,0,1,2,3,0 */
d819 2
d875 1
a875 1
      exring[cid].unit[i][j].ea1dr = exring[cid].unit[i][j].lmra;1x/
d1088 1
a1088 1
  /* stage4out   -------tx3dr----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0==> */
d1103 1
a1103 11
  /* write:  cexdr,mw,ma                                -> LMM                      */
  /* read:   cexdr,exdr,mw/tr,ma/ea[01]dr,LMM -> mr[01] -> br,lmrd                  */
  /*        |         |         |         |         |         |         |         | */
  /* clk ___/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/ */
  /* en  ____/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\___________________ */
  /* rw  _______read___/~~~~~~write~~~~~~~~\______read_____________________________ */
  /* ma  -----<   A0  =X   A1   =X   A2   =X   A3   =X   A4   >-------------------- */
  /* mw  --------------<   W1   =X   W2   >---------------------------------------- */
  /* mr  --------------<   R0   >--------------------<   R3   =X   R4   >---------- */

  int j  = (exring[cid].unit[i].cycle) % EMAX_WIDTH; /* 0,1,2,3,0,1,2,3 */
@


1.222
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.221 2017/06/18 00:17:24 nakashim Exp nakashim $";
d37 2
a41 2
  Ull   iaddr         :31; /* reg/lmm */
  Ull   ilen          :31; /* len (internal) */
d57 1
a57 1
    Ull   l_stage       : 6; /* 0..63 *//* 0の物理stageが起動の起点 */
d76 1
a76 1
    Ull   ex2dbrk          ; /* reg  *//* out for first-stage */
d78 1
a78 1
    Ull   ex3dbrk          ; /* reg  *//* out for second-stage */
d244 1
a244 1
  /* axi<->all-stages */
d249 1
a249 1
    if (exring[cid].unit[i].l_stage == 0)
a252 1
    siml_unit_lmm(cid, i);    /* stage-5 lmm */
d278 1
a278 1
  if ((exring[cid].cycle & 3) == 3) /* refer first physical row */
d286 3
d366 1
a366 1
  /* unit1_exec  __________________________________/~~(l_stage==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
d378 2
d387 1
a387 1
  /* brout_valid __/~~(l_stage==row0-1)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
d389 1
a389 1
  /* ---- stage[i]------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
d393 1
a393 1
  /* unit1_exec  __/~~(l_stage==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
d407 1
a407 1
  /* ---- stage[i+1]----------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
d417 1
a417 1
  int k, s, sb, so;
d425 3
a427 1
	exring[cid].unit[i].l_stage       = i; /* reset to default */
a434 1
	exring[cid].unit[i].one_shot      = 0; /* reset to default */
d443 1
a443 1
	if (exring[cid].unit[i].l_stage == 0)
d462 2
a463 1
      if (exring[cid].unit[i].unit1_exec)
d465 1
d471 1
a471 1
    if (exring[cid].unit[i].unit1_exec & (exring[cid].unit[i].l_stage==0 | exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid)) { /* active */
d502 1
a502 1
      if (exring[cid].unit[i].unit1_exec & (exring[cid].unit[i].l_stage==0 | exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid)) /* active */
d528 1
a528 1
  int    j  = (exring[cid].unit[i].cycle+1) % EMAX_WIDTH; /* 1,2,3,0,1,2,3,0 */
d538 1
a538 1
  switch (reg_ctrl.cmd) {
d540 16
a555 1
  case CMD_RESET: /* reset */
d608 1
a608 1
  int    j  = (exring[cid].unit[i].cycle+2) % EMAX_WIDTH; /* 2,3,0,1,2,3,0,1 */
d610 1
a610 1
  switch (reg_ctrl.cmd) {
d612 16
a627 1
  case CMD_RESET: /* reset */
d657 4
a660 21
  /******************************************************************************************************************************************************************************************/
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /* reg_ctrl.cmd -----------------<==EXEC=========X==NOP>================================================================================================================================= */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         ----------------------------------<==EXEC=========================================================================================================================>------- */
  /* one_shot    __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* unit1_exec  __________________________________/~~(l_stage==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* reg_ctrl.stat---------------------------------<==EXRING_BUSY==================================================================================>--------------------------------------- */

  /* reg_ctrl.cmd -----------------<==SCON=========X==NOP>================================================================================================================================= */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         ----------------------------------<==SCON=========================================================================================>--------------------------------------- */
  /* scon_count  ----------------------------------<==conf.mapdist*2===============X==conf.mapdist*2-1=============X==0============================>======================================= */
  /*                                                      Ascon1  Ascon1  Ascon1  Ascon1  Ascon2  Ascon2  Ascon2  Ascon2                                                                    */
  /*                                                      ->br0   ->br1   ->br2   ->br3   br0->   br1->   br2->   br3->                                                                     */
  /* unit1_exec  __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* reg_ctrl.stat---------------------------------<==EXRING_BUSY==================================================>----------------------------------------------------------------------- */
d662 1
a662 6
  /******************************************************************************************************************************************************************************************/
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* brout_valid __/~~(l_stage==row0-1)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
d664 1
a664 28
  /* ---- stage[i]------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         --<==EXEC=========================================================================================================================================================>------- */
  /* one_shot    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* unit1_exec  __/~~(l_stage==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* stage1out** ----------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */
  /* stage2out   ------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2==> */
  /* stage3out   --------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1==> */
  /* ex3dbrk     ------------------------------------------------------------------------------------------<===0===X===1===X===2===X===3==>------------------------------------------------ */
  /* stage4out   -------tx3dr----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0==> */
  /* unit1_arbrk __________________________________________________________________________________________________/~~~~~~~/~~~~~~~/~~~~~~~/~~~~~~~\_______________________________________ */
  /*                                                                                                                                              A確定                                     */
  /* tr_valid    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* stage5out   -------brout------------------------------<==p0===X==p1===X==p2===X==p3===X==q0===X==q1===X==q2===X==q3===X==q0===X==q1===X==q2===X==q3===X==q0===X==q1===X==q2===X==q3==> */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- stage[i+1]----------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         --<==EXEC=========================================================================================================================================================>------- */
  /* one_shot    __________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* stage1out   --------------------------------------------------------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */

  int    j  = (exring[cid].unit[i].cycle+3) % EMAX_WIDTH; /* 3,0,1,2,3,0,1,2 */

  switch (reg_ctrl.cmd) {
d666 13
a678 21
    if (exring[cid].unit[i][j].lmen)

----------------------------
    case STATUS_DRAIN: /* fsm drain */
    if (exring[cid].unit[i][j].lmen) {
      exring[cid].unit[i][j].lmm.en1 = 1;
      exring[cid].unit[i][j].lmm.rw1 = 0; /* read */
      exring[cid].unit[i][j].ea1dr = exring[cid].unit[i][j].lmra;1x/


      exring[cid].unit[i][j].lmm.ma1 = (exring[cid].unit[i][j].ea1dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
    }
    else
      exring[cid].unit[i][j].lmm.en1 = 0;
    return (0);
  case STATUS_LOAD: /* fsm pload */
    if (exring[cid].unit[i][j].lmen) {
      exring[cid].unit[i][j].lmm.en0 = 1;
      exring[cid].unit[i][j].lmm.rw0 = 1; /* write */
      exring[cid].unit[i][j].ea0dr = exring[cid].unit[i][j].lmwa;
      exring[cid].unit[i][j].lmm.ma0 = (exring[cid].unit[i][j].ea0dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
a679 3
    else
      exring[cid].unit[i][j].lmm.en0 = 0;
    return (0);
a680 2
----------------------------
  case CMD_RESET: /* reset */
d734 27
d817 1
a817 2
    return (0);
  }
a827 28
  case STATUS_CONF:
    if (lmring[cid].lmring[j].row_select & (1LL<<i)) {
      for (k=0; k<UNIT_WIDTH; k++)
        *((Ull*)&exring[cid].unit[i][j].conf+k) = exring[cid].unit[i][j].lmwd[k];
    }
    return (0);
  case STATUS_SCON:
    if (!(lmring[cid].lmring[j].row_select & (1LL<<i))) { /* 初回を0と数えて偶数番 */
      for (k=0; k<UNIT_WIDTH; k++)
	exring[cid].unit[i][j].regv.br[k] = *((Ull*)&exring[cid].unit[i][j].conf+k);
    }
    else { /* 初回を0と数えて奇数番 */
      for (k=0; k<UNIT_WIDTH; k++)
	*((Ull*)&exring[cid].unit[i][j].conf+k) = exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].regv.br[k];
    }
    return (0);
  case STATUS_LOAD:
    if (exring[cid].unit[i][j].lmen) {
      /* xmws: 0:off, 1:lmli, 2:lmwd, 3:lmri */
      for (k=0; k<UNIT_WIDTH; k++) {
        exring[cid].unit[i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	exring[cid].unit[i][j].lmm.mw0[k] = exring[cid].unit[i][j].lmwd[k];
      }
    }
    return (0);
  case STATUS_REGV:
    exring[cid].unit[i][j].one_shot   = 0; /* reset one_shot   here */
    return (0);
d908 1
a908 1
siml_unit_lmm(Uint cid,  Uint i) /* 旧TR/旧EADRを使ったLMM動作 & TR更新 */
d910 55
a964 2
  Ull a0, a1, a0al, a1al, d;
  int k;
d976 29
a1010 5
  case STATUS_IDLE:
  case STATUS_CONF:
  case STATUS_SCON:
  case STATUS_LMMI:
    return (0);
a1028 17
  case STATUS_REGV:
    if (lmring[cid].lmring[j].row_select & (1LL<<i)) {
      for (k=0; k<UNIT_WIDTH; k++) {
        switch (exring[cid].unit[i][j].lmwa) {
        case 0: /* lower */
          *((Ull*)&exring[cid].unit[i][j].regv+0+k) = exring[cid].unit[i][j].lmwd[k];
          break;
        case 1: /* upper */
          *((Ull*)&exring[cid].unit[i][j].regv+4+k) = exring[cid].unit[i][j].lmwd[k];
          break;
        }
      }
    }
    return (0);
  case STATUS_START:
    exring[cid].unit[i][j].drty = 0; /* reset dirty */
    return (0);
a1133 24
siml_unit_stage5(Uint cid, Uint i) /* stage-5 (3DR->BROUT)(LMRING_TR->LMRING_BROUT) */
{
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /* stage1out   ----------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */
  /* stage2out   ------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2==> */
  /* stage3out   --------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1==> */
  /* ex3dbrk     --------------------------<===0===X===1===X===2===X===3==>-------------------------------------------------*/
  /* stage4out   -------tx3dr----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0==> */
  /* unit1_arbrk __________________________________/~~~~~~~/~~~~~~~/~~~~~~~/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /*                                                                              A確定                                     */
  /* tr_valid    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* stage5out** -------brout------------------------------<==p0===X==p1===X==p2===X==p3===X==q0===X==q1===X==q2===X==q3==> */
  /*              V-update                        V-update                        V-update                    V-update      */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  if (exring[cid].unit[i].l_stage==(EMAX_DEPTH-1))
    exring[cid].unit[i].brout_valid = 1; /* 最終brout_validは常時1 */
  else if ((exring[cid].unit[i].cycle & 3) == 3) /* final */
    exring[cid].unit[i].brout_valid = exring[cid].unit[i].tr_valid;
}

@


1.221
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.220 2017/06/14 23:49:02 nakashim Exp nakashim $";
a18 1

d50 1
a50 20
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /* reg_ctrl.cmd -----------------<==EXEC=========X==NOP>================================================================================================================================= */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         ----------------------------------<==EXEC=========================================================================================================================>------- */
  /* one_shot    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________________________________________________________________________ */
  /* unit1_exec  __________________________________/~~(l_stage==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______ */
  /* reg_ctrl.stat---------------------------------<==EXRING_BUSY==================================================================================>--------------------------------------- */

  /* reg_ctrl.cmd -----------------<==SCON=========X==NOP>================================================================================================================================= */
  /*              V-update                        V-update                        V-update                        V-update                        V-update                        V-update  */
  /* cmd         ----------------------------------<==SCON=========================================================================================>--------------------------------------- */
  /* scon_count  ----------------------------------<==conf.mapdist*2===============X==conf.mapdist*2-1=============X==0============================>======================================= */
  /*                                                      Ascon1  Ascon1  Ascon1  Ascon1  Ascon2  Ascon2  Ascon2  Ascon2                                                                    */
  /*                                                      ->br0   ->br1   ->br2   ->br3   br0->   br1->   br2->   br3->                                                                     */
  /* unit1_exec  __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________________________________________ */
  /* unit1_stop  __________________________________________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________ */
  /* reg_ctrl.stat---------------------------------<==EXRING_BUSY==================================================>----------------------------------------------------------------------- */
d53 1
a53 1
    Ull   l_stage       : 6; /* 0..63 *//* 0の物理stageが起動の起点 */
d57 3
a59 2
    Ull   cmd           : 2; /* internal copy of reg_ctrl.cmd */
    Ull   one_shot      : 1; /* reg  *//* self_loop_control 1:init 0:self_loop, keep 1 in first 4 cycles */
d147 1
a232 1
/* EMAX6 control */
d263 1
a263 4
  /* update LMRING */
  reg_ctrl.stat = (reg_ctrl.stat & ~0xf0) | ((!lmring[cid].busy?LMRING_IDLE:LMRING_BUSY)<<4);

  /* update EXRING */
d269 1
a269 11
  reg_ctrl.stat = (reg_ctrl.stat & ~0x0f) | (!busy?EXRING_IDLE:EXRING_BUSY);

  if ((exring[cid].unit[i].cycle & 3) == 3) {
    switch (reg_ctrl.cmd) {
    case CMD_RESET: /* reset */
    case CMD_SCON:  /* scon */
    case CMD_EXEC:  /* exec */
      reg_ctrl.cmd = CMD_NOP;
      break;
    }
  }
d274 8
d356 23
d388 1
a388 1
  /* one_shot    __/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________________________________________________________________________________________________________ */
d406 1
a406 1
  /* one_shot    __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\_______________________________________________________________________ */
d421 9
d433 2
d438 1
a438 2
	if (exring[cid].unit[i].l_stage == 0) {
	  exring[cid].unit[i].one_shot = 1;
a439 1
	}
d444 6
a449 12
  case CMD_RESET: /* reset */
    if ((exring[cid].unit[i].cycle & 3) == 3) {
      exring[cid].unit[i].l_stage       = i; /* reset to default */
      exring[cid].unit[i].cycle         = 0; /* reset to default */
      exring[cid].unit[i].unit1_arbrk   = 0; /* reset to default */
      exring[cid].unit[i].unit1_exec    = 0; /* reset to default */
      exring[cid].unit[i].unit1_stop    = 0; /* reset to default */
      exring[cid].unit[i].tr_valid      = 0; /* reset to default */
      exring[cid].unit[i].unit2_exec    = 0; /* reset to default */
      exring[cid].unit[i].unit2_stop    = 0; /* reset to default */
      exring[cid].unit[i].brout_valid   = 0; /* reset to default */
      exring[cid].unit[i].one_shot      = 0; /* reset to default */
d451 1
a451 2
    break;
  case CMD_SCON:  /* scon */
d453 7
a459 2
      unit1_stop_next = exring[cid].unit[i].unit1_stop;scon_count
      unit1_exec_next = exring[cid].unit[i].unit1_exec;
a460 1
      exring[cid].unit[i].unit1_exec = unit1_exec_next & ~unit1_stop_next;
d475 1
a475 1
      s = reg_ctrl.conf[i][j].cdw0.ex1brs; exring[cid].unit[i].ex1   = (reg_ctrl.conf[i][j].cdw0.ex1s!=1 || exring[cid].unit[i].one_shot)
d484 2
a485 2
      sb = reg_ctrl.conf[i][j].cdw1.ea0bs; exring[cid].unit[i].ea0b  = (!(sb&1)|| exring[cid].unit[i].one_shot)?((sb&2)?exring[cid].unit[i].eab:reg_ctrl.addr[i][j].ea0b) : exring[cid].unit[i].ea04dr_prev;
      so = reg_ctrl.conf[i][j].cdw1.ea0os; exring[cid].unit[i].ea0o  = (!(sb&1)||!exring[cid].unit[i].one_shot)?((so&1)?exring[cid].unit[i].eao:reg_ctrl.addr[i][j].ea0o) : 0LL;
d488 2
a489 5
      sb = reg_ctrl.conf[i][j].cdw1.ea1bs; exring[cid].unit[i].ea1b  = (!(sb&1)|| exring[cid].unit[i].one_shot)?((sb&2)?exring[cid].unit[i].eab:reg_ctrl.addr[i][j].ea1b) : exring[cid].unit[i].ea14dr_prev;
      so = reg_ctrl.conf[i][j].cdw1.ea1os; exring[cid].unit[i].ea1o  = (!(sb&1)||!exring[cid].unit[i].one_shot)?((so&1)?exring[cid].unit[i].eao:reg_ctrl.addr[i][j].ea1o) : 0LL;

      if ((exring[cid].unit[i].cycle & 3) == 3)
	exring[cid].unit[i].one_shot = 0;
d493 7
d501 1
a501 1
      unit1_exec_next =                                    exring[cid].unit[i].unit1_exec | exring[cid].unit[(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_exec;
d503 1
a503 1
      unit2_exec_next =                                    exring[cid].unit[i].unit1_exec | exring[cid].unit[ i                         ].unit2_exec;
d505 1
a505 1
      exring[cid].unit[i].unit1_exec = unit1_exec_next & ~unit1_stop_next;
a506 1
      exring[cid].unit[i].unit2_exec = unit2_exec_next & ~unit2_stop_next;
d511 5
a515 1
  exring[cid].unit[i].cycle++;
a520 12
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /* stage1out   ----------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */
  /* stage2out** ------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2==> */
  /* stage3out   --------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1==> */
  /* stage4out   -------tx3dr----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0==> */
  /* stage5out   -------brout------------------------------<==p0===X==p1===X==p2===X==p3===X==q0===X==q1===X==q2===X==q3==> */
  /*              V-update                        V-update                        V-update                    V-update      */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

a585 12
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /* stage1out   ----------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */
  /* stage2out   ------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2==> */
  /* stage3out** --------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1==> */
  /* stage4out   -------tx3dr----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0==> */
  /* stage5out   -------brout------------------------------<==p0===X==p1===X==p2===X==p3===X==q0===X==q1===X==q2===X==q3==> */
  /*              V-update                        V-update                        V-update                    V-update      */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

d620 53
a672 15
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /* stage1out   ----------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3==> */
  /* stage2out   ------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2==> */
  /* stage3out   --------------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0===X== 1==> */
  /* ex3dbrk     --------------------------<===0===X===1===X===2===X===3==>-------------------------------------------------*/
  /* stage4out** -------tx3dr----------------------<== 0===X== 1===X== 2===X== 3===X== 0===X== 1===X== 2===X== 3===X== 0==> */
  /* unit1_arbrk __________________________________/~~~~~~~/~~~~~~~/~~~~~~~/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /*                                                                              A確定                                     */
  /* tr_valid    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* stage5out   -------brout------------------------------<==p0===X==p1===X==p2===X==p3===X==q0===X==q1===X==q2===X==q3==> */
  /*              V-update                        V-update                        V-update                    V-update      */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
d762 1
a762 1
    if (exring[cid].unit[i][j].conf.cdw1.ea1op == OP_IM_DRAIN) {
d772 1
a772 1
    else if (exring[cid].unit[i][j].conf.cdw1.ea1op) { /* normal load */
d788 1
a788 1
    if (exring[cid].unit[i][j].conf.cdw1.ea0op == OP_IM_PREF) {
d798 1
a798 1
    else if (exring[cid].unit[i][j].conf.cdw1.ea0op) { /* normal load/store */
d802 1
a802 1
        exring[cid].unit[i][j].lmm.rw0 = (exring[cid].unit[i][j].conf.cdw1.ea0op & 0x10)!=0; /* read/write */
d861 3
a863 3
    exdmux[0] = exring[cid].unit[i][j].conf.cdw2.mws0==0 ? exring[cid].unit[i][j].exdr /* tr[3-0]はalign不要 */
              : exring[cid].unit[i][j].conf.cdw2.mws0==1 ? exring[cid].unit[i][0].exdr
              : exring[cid].unit[i][j].conf.cdw2.mws0==2 ? exring[cid].unit[i][j].t[0]
d865 3
a867 3
    exdmux[1] = exring[cid].unit[i][j].conf.cdw2.mws1==0 ? exring[cid].unit[i][j].exdr
              : exring[cid].unit[i][j].conf.cdw2.mws1==1 ? exring[cid].unit[i][1].exdr
              : exring[cid].unit[i][j].conf.cdw2.mws1==2 ? exring[cid].unit[i][j].t[1]
d869 3
a871 3
    exdmux[2] = exring[cid].unit[i][j].conf.cdw2.mws2==0 ? exring[cid].unit[i][j].exdr
              : exring[cid].unit[i][j].conf.cdw2.mws2==1 ? exring[cid].unit[i][2].exdr
              : exring[cid].unit[i][j].conf.cdw2.mws2==2 ? exring[cid].unit[i][j].t[2]
d873 3
a875 3
    exdmux[3] = exring[cid].unit[i][j].conf.cdw2.mws3==0 ? exring[cid].unit[i][j].exdr
              : exring[cid].unit[i][j].conf.cdw2.mws3==1 ? exring[cid].unit[i][3].exdr
              : exring[cid].unit[i][j].conf.cdw2.mws3==2 ? exring[cid].unit[i][j].t[3]
d878 1
a878 1
    switch (exring[cid].unit[i][j].conf.cdw1.ea0op) {
d913 4
a916 4
    exring[cid].unit[i][j].lmm.mw0[0] = (exring[cid].unit[i][j].conf.cdw2.mws0 < 3) ? exdsft[0] : lmwd[0];
    exring[cid].unit[i][j].lmm.mw0[1] = (exring[cid].unit[i][j].conf.cdw2.mws1 < 3) ? exdsft[1] : lmwd[1];
    exring[cid].unit[i][j].lmm.mw0[2] = (exring[cid].unit[i][j].conf.cdw2.mws2 < 3) ? exdsft[2] : lmwd[2];
    exring[cid].unit[i][j].lmm.mw0[3] = (exring[cid].unit[i][j].conf.cdw2.mws3 < 3) ? exdsft[3] : lmwd[3];
d919 12
a930 12
    exring[cid].unit[i][j].tr[0] = exring[cid].unit[i][j].conf.cdw2.trs0==0 ? exring[cid].unit[i][0].exdr   :
                            exring[cid].unit[i][j].conf.cdw2.trs0==1 ? exring[cid].unit[i][j].lmwd[0]:
			                                        exring[cid].unit[i][j].t[0]   ;
    exring[cid].unit[i][j].tr[1] = exring[cid].unit[i][j].conf.cdw2.trs1==0 ? exring[cid].unit[i][1].exdr   :
                            exring[cid].unit[i][j].conf.cdw2.trs1==1 ? exring[cid].unit[i][j].lmwd[1]:
			                                        exring[cid].unit[i][j].t[1]   ;
    exring[cid].unit[i][j].tr[2] = exring[cid].unit[i][j].conf.cdw2.trs2==0 ? exring[cid].unit[i][2].exdr   :
                            exring[cid].unit[i][j].conf.cdw2.trs2==1 ? exring[cid].unit[i][j].lmwd[2]:
			                                        exring[cid].unit[i][j].t[2]   ;
    exring[cid].unit[i][j].tr[3] = exring[cid].unit[i][j].conf.cdw2.trs3==0 ? exring[cid].unit[i][3].exdr   :
                            exring[cid].unit[i][j].conf.cdw2.trs3==1 ? exring[cid].unit[i][j].lmwd[3]:
			                                        exring[cid].unit[i][j].t[3]   ;
d999 3
a1001 3
    if (exring[cid].unit[i][j].conf.cdw1.ea1op == OP_IM_DRAIN
     || exring[cid].unit[i][j].conf.cdw1.ea1op == OP_LDDMQ
     || exring[cid].unit[i][j].conf.cdw1.ea1op == OP_TR) {
d1012 1
a1012 1
    else if (exring[cid].unit[i][j].conf.cdw1.ea1op) { /* OP_IM_BUFRD or normal load */
d1021 1
a1021 1
    if (exring[cid].unit[i][j].conf.cdw1.ea0op == OP_IM_PREF) {
d1030 1
a1030 1
    else if (exring[cid].unit[i][j].conf.cdw1.ea0op) { /* normal load/store */
d1036 1
a1036 1
	if (exring[cid].unit[i][j].conf.cdw1.ea0op < OP_LDDMQ)
d1047 1
a1047 1
    switch (exring[cid].unit[i][j].conf.cdw2.brs0) {
d1054 1
a1054 1
      switch (exring[cid].unit[i][j].conf.cdw1.ea0op) {
d1065 1
a1065 1
    switch (exring[cid].unit[i][j].conf.cdw2.brs1) {
d1072 1
a1072 1
      switch (exring[cid].unit[i][j].conf.cdw1.ea1op) {
d1083 1
a1083 1
    switch (exring[cid].unit[i][j].conf.cdw2.brs2) {
d1090 1
a1090 1
    switch (exring[cid].unit[i][j].conf.cdw2.brs3) {
d1320 15
a1334 15
             (Uint) exring[cid].unit[row][col].conf.cdw0.op1,
             (Uint) exring[cid].unit[row][col].conf.cdw0.op2,
             (Uint) exring[cid].unit[row][col].conf.cdw0.op3,
             (Uint) exring[cid].unit[row][col].conf.cdw0.ex1brs,
             (Uint) exring[cid].unit[row][col].conf.cdw0.ex1s,
             (Uint) exring[cid].unit[row][col].conf.cdw0.ex1exp,
             (Uint) exring[cid].unit[row][col].conf.cdw0.ex2brs,
             (Uint) exring[cid].unit[row][col].conf.cdw0.ex2exp,
             (Uint) exring[cid].unit[row][col].conf.cdw0.ex3brs,
             (Uint) exring[cid].unit[row][col].conf.cdw0.ex3exp,
             (Uint)(exring[cid].unit[row][col].conf.cdw3.e2imm>>32),
             (Uint) exring[cid].unit[row][col].conf.cdw3.e2imm,
             (Uint) exring[cid].unit[row][col].conf.cdw0.e2is,
             (Uint) exring[cid].unit[row][col].conf.cdw0.e3imm,
             (Uint) exring[cid].unit[row][col].conf.cdw0.e3is);
d1339 15
a1353 15
             (Uint) exring[cid].unit[row][col].conf.cdw1.cs3,
             (Uint) exring[cid].unit[row][col].conf.cdw1.cs2,
             (Uint) exring[cid].unit[row][col].conf.cdw1.cs1,
             (Uint) exring[cid].unit[row][col].conf.cdw1.cs0,
             (Uint) exring[cid].unit[row][col].conf.cdw1.cex_tab,
             (Uint) exring[cid].unit[row][col].conf.cdw1.ea1op,
             (Uint) exring[cid].unit[row][col].conf.cdw1.ea1bs,
             (Uint) exring[cid].unit[row][col].conf.cdw1.ea1os,
             (Uint) exring[cid].unit[row][col].conf.cdw1.ea1msk,
             (Uint) exring[cid].unit[row][col].conf.cdw1.ea0op,
             (Uint) exring[cid].unit[row][col].conf.cdw1.ea0bs,
             (Uint) exring[cid].unit[row][col].conf.cdw1.ea0os,
             (Uint) exring[cid].unit[row][col].conf.cdw1.ea0msk,
             (Uint) exring[cid].unit[row][col].conf.cdw1.eabbrs,
             (Uint) exring[cid].unit[row][col].conf.cdw1.eaobrs);
d1358 17
a1374 17
             (Uint) exring[cid].unit[row][col].conf.cdw2.lmls,
             (Uint) exring[cid].unit[row][col].conf.cdw2.lmrs,
             (Uint) exring[cid].unit[row][col].conf.cdw2.ts3,
             (Uint) exring[cid].unit[row][col].conf.cdw2.ts2,
             (Uint) exring[cid].unit[row][col].conf.cdw2.ts1,
             (Uint) exring[cid].unit[row][col].conf.cdw2.ts0,
             (Uint) exring[cid].unit[row][col].conf.cdw2.mwsa,
             (Uint) exring[cid].unit[row][col].conf.cdw2.mws3,
             (Uint) exring[cid].unit[row][col].conf.cdw2.mws2,
             (Uint) exring[cid].unit[row][col].conf.cdw2.mws1,
             (Uint) exring[cid].unit[row][col].conf.cdw2.mws0,
             (Uint) exring[cid].unit[row][col].conf.cdw2.brs3,
             (Uint) exring[cid].unit[row][col].conf.cdw2.brs2,
             (Uint) exring[cid].unit[row][col].conf.cdw2.brs1,
             (Uint) exring[cid].unit[row][col].conf.cdw2.brs0,
             (Uint) exring[cid].unit[row][col].conf.cdw2.xmws,
             (Uint) exring[cid].unit[row][col].conf.cdw2.mapdist);
@


1.220
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.219 2017/06/10 12:51:55 nakashim Exp nakashim $";
d18 4
a21 1
struct fsm { /* lmm status of EMAX6 */
a36 4
  /* physical interface (broadcast) to EMAX6-body */
  Ull   cmd          : 2;  /* wire (broadcast) */
  Ull   busy            ;  /* wire (status) */

d38 127
a164 104
  Ull   en           : 1;  /* 0:rw/ty/a/di/dm無効, 1:rw/ty/a/di/dm有効 */
  Ull   rw           : 1;  /* 0:read, 1:write */
  Ull   ty           : 2;  /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:lmm/trans */
  Ull   iaddr        :31;  /* reg/lmm */
  Ull   ilen         :31;  /* len (internal) */
  Ull   din[UNIT_WIDTH] ;  /* <- lmm wdata */
  Ull   dmk[UNIT_WIDTH] ;  /* <- lmm wdata */
  Ull   dv           : 1;  /* 0:dt/do無効, 1:有効 */
  Ull   dt           : 1;  /* 0:addr無効, 1:有効 */
  Ull   dout[UNIT_WIDTH];  /* -> dout      */
} fsm[MAXCORE];

struct unit { /* hardware status of EMAX6 units */
  Ull   l_stage      : 6;  /* 0..63 *//* 0の物理stageが起動の起点 */
  Ull   cycle        : 3;  /* previous unit1_exec/stop is reffered every 4 cycles */
                           /* previous br[0/1] is switched every 4 cycles */
                           /* brout[cycle-4] is updated */
  Ull   unit1_arbrk  : 1;  /* loop最終命令の実行完了を表示 */
  Ull   unit1_exec   : 1;  /* 次の動作を指示 (cex,exe,eag), 0:wait 1:exec */
  Ull   unit1_stop   : 1;  /* 次の動作を指示 (cex,exe,eag), 0:wait 1:stop */
  Ull   tr_valid     : 1;  /* TRの状態を表示 */
  Ull   unit2_exec   : 1;  /* 次の動作を指示 (lmm),         0:wait 1:exec */
  Ull   unit2_stop   : 1;  /* 次の動作を指示 (lmm),         0:wait 1:stop */
  Ull   brout_valid  : 1;  /* BRの状態を表示 常時tr_validを1τ後に伝搬 */
  Ull   one_shot     : 1;  /* reg  *//* self_loop_control 0:init 1:self_loop, keep 0 in first 4 cycles */

  Ull   cx[EMAX_WIDTH]  ;  /* reg  */
  Ull   cx2dr        : 2;  /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
  Ull   cx3dr        : 2;  /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
  Ull   cx4dr        : 2;  /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
  Ull   ex1             ;  /* reg  *//* in for ALU */
  Ull   ex2             ;  /* reg  *//* in for ALU */
  Ull   ex3             ;  /* reg  *//* in for ALU */
  Ull   ex2dr           ;  /* reg  *//* out for first-stage */
  Ull   ex2dbrk         ;  /* reg  *//* out for first-stage */
  Ull   ex3dr           ;  /* reg  *//* out for second-stage */
  Ull   ex3dbrk         ;  /* reg  *//* out for second-stage */
  Ull   ex4dr           ;  /* reg  *//* out for third-stage */
  Ull   eab             ;  /* wire *//* in for ALU */
  Ull   eao             ;  /* wire *//* in for ALU */
  Ull   ea0b            ;  /* reg  *//* in for EA0 */
  Ull   ea0o            ;  /* reg  *//* in for EA0 */
  Ull   ea02dr          ;  /* reg  */
  Ull   ea03dr          ;  /* reg  */
  Ull   ea04dr          ;  /* reg  */
  Ull   ea1b            ;  /* reg  *//* in for EA1 */
  Ull   ea1o            ;  /* reg  *//* in for EA1 */
  Ull   ea12dr          ;  /* reg  */
  Ull   ea13dr          ;  /* reg  */
  Ull   ea14dr          ;  /* reg  */
  Ull   tx[UNIT_WIDTH]  ;  /* reg  */
  Ull   tx2dr[UNIT_WIDTH]; /* reg  */
  Ull   tx3dr[UNIT_WIDTH]; /* reg  */
  Ull   tx4dr[UNIT_WIDTH]; /* reg  */

  Ull   lmwa            ;  /* wire *//* -> ea0dr */
  Ull   lmwd[UNIT_WIDTH];  /* wire *//* <- axi */
  Ull   lmra            ;  /* wire *//* -> ea1dr */
  Ull   lmrd[UNIT_WIDTH];  /* wire *//* -> axi */
  Ull   lmen         : 1;  /* wire *//* lmm enable for read/write */
  Ull   rrdy         : 1;  /* wire *//* LMM data-valid for FSM */
  struct lmm {
    Ull   en0         : 1; /* internal reg       */
    Ull   en1         : 1; /* internal reg       */
    Ull   rw0         : 1; /* 0:read, 1:write    */
    Ull   rw1         : 1; /* 0:read,(1:write)   */
    Ull   ma0            ; /* internal reg  addr(32B aligned)      */
    Ull   ma1            ; /* internal reg  addr(32B aligned)      */
    Ull   mm0[UNIT_WIDTH]; /* internal reg  mask */
    Ull   mw0[UNIT_WIDTH]; /* internal reg  data */
    Ull   mr0[UNIT_WIDTH]; /* internal wire data */
    Ull   mr1[UNIT_WIDTH]; /* internal wire data */
    Uchar m[LMEM_SIZE]   ; /* local memory       */
  } lmm;
  Ull   mr0mux        : 2; /* mr0[3-0] -> brs0     */
  Ull   mr1mux        : 2; /* mr1[3-0] -> brs1     */
  Ull   mr0d             ; /* muxed data for BR[0] */
  Ull   mr1d             ; /* muxed data for BR[1] */

  struct lmring_tr {
    Ull   en          : 1; /* 0:rw/ty/a/di/dm無効, 1:rw/ty/a/di/dm有効 */
    Ull   rw          : 1; /* 0:read, 1:write */
    Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:lmm/trans */
    Ull   pass        : 1; /* 0:hit, 1:pass */
    Ull   addr        :31; /* reg/lmm */
    Ull   data[UNIT_WIDTH];
    Ull   mask        :32; /* byte mask */
    Ull   dv          : 1; /* 0:dt/do無効, 1:有効 */
    Ull   dt          : 1; /* 0:addr無効, 1:有効 */
  } lmring_tr;
  struct lmring_br {
    Ull   en          : 1; /* 0:rw/ty/a/di/dm無効, 1:rw/ty/a/di/dm有効 */
    Ull   rw          : 1; /* 0:read, 1:write */
    Ull   ty          : 2; /* 0:register, 1:lmm/vaddr, 2:lmm/lddmq, 3:lmm/trans */
    Ull   addr        :31; /* reg/lmm */
    Ull   data[UNIT_WIDTH];
    Ull   mask        :32; /* byte mask */
    Ull   dv          : 1; /* 0:dt/do無効, 1:有効 */
    Ull   dt          : 1; /* 0:addr無効, 1:有効 */
  } lmring_br;

  struct {Ull r[UNIT_WIDTH];} b[2][EMAX_WIDTH]; /* shadow_breg *//* constantは両方にセット */
  
} unit[MAXCORE][EMAX_DEPTH];
d169 1
a169 1
emax6_ctl_reg(tid, type, opcd, addr, mask, val)
d179 1
a179 1
  printf("%03.3d:emax6_ctl_reg: type=%d opcd=%d addr=%08.8x, mask=%08.8x_%08.8x_%08.8x_%08.8x val=%08.8x_%08.8x_%08.8x_%08.8x\n",
d185 1
a185 1
    printf("%03.3d:emax6_ctl_reg: out of range: addr=%08.8x (< DMA_BASE2_PHYS)\n", tid, addr);
d191 1
a191 1
      case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl_reg: dma_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d193 1
a193 1
      case 3:if (addr & (sizeof(Ull)-1))  printf("%03.3d:emax6_ctl_reg: dma_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d195 1
a195 1
      default:printf("%03.3d:emax6_ctl_reg: dma_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd); break;
d200 1
a200 1
      case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl_reg: dma_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d202 1
a202 1
      case 3:if (addr & (sizeof(Ull)-1))  printf("%03.3d:emax6_ctl_reg: dma_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d204 1
a204 1
      default:printf("%03.3d:emax6_ctl_reg: dma_space store: opcd=%d (should be STRW/STR)\n", tid, opcd);break;
d213 1
a213 1
      case 2:if (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl_reg: reg_space load: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d215 1
a215 1
      case 3:if (addr & (sizeof(Ull)-1))  printf("%03.3d:emax6_ctl_reg: reg_space load: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d217 1
a217 1
      default:printf("%03.3d:emax6_ctl_reg: reg_space load: opcd=%d (should be LDRW/LDR)\n", tid, opcd); break;
d222 1
a222 1
      case 2:if      (addr & (sizeof(Uint)-1)) printf("%03.3d:emax6_ctl_reg: reg_space store: opcd=%d addr=%08.8x (should be aligned to Uint)\n", tid, opcd, addr);
d227 2
a228 2
	       *(Uint*)((Uchar*)&unit[cid][i].b[0]+j) = val[0];
	       *(Uint*)((Uchar*)&unit[cid][i].b[1]+j) = val[0];
d231 1
a231 1
      case 3:if      (addr & (sizeof(Ull)-1))  printf("%03.3d:emax6_ctl_reg: reg_space store: opcd=%d addr=%08.8x (should be aligned to Ull)\n", tid, opcd, addr);
d236 2
a237 2
	       *(Ull*)((Uchar*)&unit[cid][i].b[0]+j) = val[0];
	       *(Ull*)((Uchar*)&unit[cid][i].b[1]+j) = val[0];
d240 1
a240 1
      default:printf("%03.3d:emax6_ctl_reg: reg_space store: opcd=%d (should be STRW/STR)\n", tid, opcd);break;
d246 1
a246 1
    printf("%03.3d:emax6_ctl_reg: out of range: addr=%08.8x (>= REG_BASE2_PHYS+REG_BASE2_SIZE)\n", tid, addr);
d257 1
a257 1
  int i, j, k, row0, sync;
d266 1
a266 1
  /* siml EMAX6 body */
d268 1
a268 1
    if (unit[cid][i].l_stage == 0)
d272 6
a277 8
    siml_unit_lmringout(cid, i); /* stage-5 (LMRING_TR->LMRING_BROUT) */
    siml_unit_lmm(cid, i);       /* lmm */
    siml_unit_stage5(cid, i);    /* stage-5 (3DR->BROUT) */
    siml_unit_stage4(cid, i);    /* stage-4 (2DR->3DR) */
    siml_unit_stage3(cid, i);    /* stage-3 (1DR->2DR) */
    siml_unit_stage2(cid, i);    /* stage-2 (EX/TX->1DR) */
    siml_unit_stage1(cid, i);    /* stage-1 (BRIN->EX/TX) */
    siml_unit_lmringin(cid, i);  /* stage-1 (LMRING_BRIN->LMRING_TR) */
d282 19
a300 14
  switch (reg_ctrl.cmd) {
  case CMD_NOP:   /* nop */
    break;
  case CMD_RESET: /* reset */
    reg_ctrl.stat = LMRING_IDLE<<4|EXRING_IDLE;
    reg_ctrl.cmd = 0;
    break;
  case CMD_SCON:  /* scon */
  case CMD_EXEC:  /* exec */
    if (reg_ctrl.stat == EXRING_IDLE)
      reg_ctrl.stat = (reg_ctrl.stat & ~0x0f) | (EXRING_BUSY);
    else
      reg_ctrl.stat = (reg_ctrl.stat & ~0x0f) | ((fsm[cid].busy == 0LL) ? EXRING_IDLE : EXRING_BUSY);
    break;
d305 1
d314 4
a317 4
  if (fsm[cid].axi_arready && fsm[cid].axi_arvalid) { /* new read_req starts */
    fsm[cid].axi_arready = 0;             /* start read */
    fsm[cid].iaddr = fsm[cid].axi_araddr; /* start read */
    fsm[cid].ilen  = 0;                   /* start read (unit is multople of 64bits) */
d320 1
a320 1
	     cid, (Uint)(fsm[cid].axi_araddr>>32), (Uint)fsm[cid].axi_araddr, (Uint)(fsm[cid].axi_arlen>>32), (Uint)fsm[cid].axi_arlen);
d322 4
a325 4
  else if (fsm[cid].axi_awready && fsm[cid].axi_awvalid) { /* new write_req starts */
    fsm[cid].axi_awready = 0;             /* start write */
    fsm[cid].iaddr = fsm[cid].axi_awaddr; /* start write */
    fsm[cid].ilen  = 0;                   /* start write (unit is multiple of 64bits) */
d328 1
a328 1
	     cid, (Uint)(fsm[cid].axi_awaddr>>32), (Uint)fsm[cid].axi_awaddr, (Uint)(fsm[cid].axi_awlen>>32), (Uint)fsm[cid].axi_awlen);
d335 3
a337 3
  else if (!fsm[cid].axi_arready) {
    if (fsm[cid].ilen <= fsm[cid].axi_arlen) {
      fsm[cid].axi_rvalid = 1;
d339 2
a340 2
	Ull a = fsm[cid].iaddr + sizeof(Ull)*(fsm[cid].ilen*UNIT_WIDTH+k);
	fsm[cid].axi_rdata[k] = *(Ull*)(mem + a);
d343 1
a343 1
		 cid, (Uint)(a>>32), (Uint)a, k, (Uint)(fsm[cid].axi_rdata[k]>>32), (Uint)fsm[cid].axi_rdata[k]);
d345 1
a345 1
      fsm[cid].ilen++;
d348 2
a349 2
      fsm[cid].axi_rvalid  = 0;
      fsm[cid].axi_arready = 1;
d356 3
a358 3
  else if (!fsm[cid].axi_awready) {
    if (fsm[cid].ilen <= fsm[cid].axi_awlen) {
      if (fsm[cid].axi_wvalid) {
d360 3
a362 3
	  if (fsm[cid].axi_wstrb & (0xff<<(k*8))) {
	    Ull a = fsm[cid].iaddr + sizeof(Ull)*(fsm[cid].ilen*UNIT_WIDTH+k);
	    *(Ull*)(mem + a) = fsm[cid].axi_wdata[k];
d365 1
a365 1
		     cid, (Uint)(a>>32), (Uint)a, k, (Uint)(fsm[cid].axi_wdata[k]>>32), (Uint)fsm[cid].axi_wdata[k]);
d368 1
a368 1
	fsm[cid].ilen++;
d372 1
a372 1
      fsm[cid].axi_awready = 1;
d378 1
a378 1
siml_unit_stage1(Uint cid, Uint i)    /* stage-1 (BRIN->EX/TX) */
d380 30
a409 22
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /*              V-update                        V-update                        V-update                    V-update      */
  /* brout_valid __/~~(l_stage==row0-1)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- stage[i]--------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                    V-update      */
  /* unit1_exec  __/~~(l_stage==0)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* one_shot    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* stage1out** ----------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==> */
  /* stage2out   ------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==> */
  /* stage3out   --------------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==> */
  /* stage4out   -------tx3dr----------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==> */
  /* stage5out   -------brout------------------------------<==p0==><==p1==><==p2==><==p3==><==q0==><==q1==><==q2==><==q3==> */
  /*              V-update                        V-update                        V-update                    V-update      */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  /* ---- stage[i+1]------------------------------------------------------------------------------------------------------- */
  /*              V-update                        V-update                        V-update                    V-update      */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* stage1out   --------------------------------------------------------------------------<== 0==><== 1==><== 2==><== 3==> */
d412 2
a413 2
  int b  = (unit[cid][i].cycle / EMAX_WIDTH)&1; /* 0,0,0,0,1,1,1,1 */
  int j  =  unit[cid][i].cycle % EMAX_WIDTH; /* 0,1,2,3,0,1,2,3 */
d417 1
a417 1
  switch (reg_ctrl.cmd) {
d419 16
d437 12
a448 10
    unit[cid][i].l_stage       = i; /* reset to default */
    unit[cid][i].cycle         = 0; /* reset to default */
    unit[cid][i].unit1_arbrk   = 0; /* reset to default */
    unit[cid][i].unit1_exec    = 0; /* reset to default */
    unit[cid][i].unit1_stop    = 0; /* reset to default */
    unit[cid][i].tr_valid      = 0; /* reset to default */
    unit[cid][i].unit2_exec    = 0; /* reset to default */
    unit[cid][i].unit2_stop    = 0; /* reset to default */
    unit[cid][i].brout_valid   = 0; /* reset to default */
    unit[cid][i].one_shot      = 0; /* reset to default */
d451 6
d459 15
a473 15
    if (unit[cid][i].unit1_exec & unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid) { /* active */
      s = reg_ctrl.conf[i][j].cdw1.cs0;    unit[cid][i].cx[0] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.conf[i][j].cdw1.cs1;    unit[cid][i].cx[1] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.conf[i][j].cdw1.cs2;    unit[cid][i].cx[2] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
      s = reg_ctrl.conf[i][j].cdw1.cs3;    unit[cid][i].cx[3] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;

      s = reg_ctrl.conf[i][j].cdw2.ts0;    unit[cid][i].tx[0] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw2.ts1;    unit[cid][i].tx[1] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw2.ts2;    unit[cid][i].tx[2] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw2.ts3;    unit[cid][i].tx[3] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];

      s = reg_ctrl.conf[i][j].cdw0.ex1brs; unit[cid][i].ex1   = (reg_ctrl.conf[i][j].cdw0.ex1s!=1 || !unit[cid][i].one_shot)
							      ? unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH] : unit[cid][i].ex3dr_prev; /* self_loop */
      s = reg_ctrl.conf[i][j].cdw0.ex2brs; unit[cid][i].ex2   = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw0.ex3brs; unit[cid][i].ex3   = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
d475 2
a476 2
      s = reg_ctrl.conf[i][j].cdw1.eabbrs; unit[cid][i].eab   = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
      s = reg_ctrl.conf[i][j].cdw1.eaobrs; unit[cid][i].eao   = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
d479 2
a480 2
      sb = reg_ctrl.conf[i][j].cdw1.ea0bs; unit[cid][i].ea0b  = (!(sb&1)||!unit[cid][i].one_shot)?((sb&2)?unit[cid][i].eab:reg_ctrl.addr[i][j].ea0b) : unit[cid][i].ea03dr_prev;
      so = reg_ctrl.conf[i][j].cdw1.ea0os; unit[cid][i].ea0o  = (!(sb&1)|| unit[cid][i].one_shot)?((so&1)?unit[cid][i].eao:reg_ctrl.addr[i][j].ea0o) : 0LL;
d483 2
a484 2
      sb = reg_ctrl.conf[i][j].cdw1.ea1bs; unit[cid][i].ea1b  = (!(sb&1)||!unit[cid][i].one_shot)?((sb&2)?unit[cid][i].eab:reg_ctrl.addr[i][j].ea1b) : unit[cid][i].ea13dr_prev;
      so = reg_ctrl.conf[i][j].cdw1.ea1os; unit[cid][i].ea1o  = (!(sb&1)|| unit[cid][i].one_shot)?((so&1)?unit[cid][i].eao:reg_ctrl.addr[i][j].ea1o) : 0LL;
d486 13
a498 2
      if ((unit[cid][i].cycle & 3) == 3)
	unit[cid][i].one_shot = 1;
d503 1
a503 12
  if ((unit[cid][i].cycle & 3) == 3) {
    unit1_stop_next =  unit[cid][i].unit1_arbrk | unit[cid][i].unit1_stop | unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_stop;
    unit1_exec_next = (unit[cid][i].l_stage==0) | unit[cid][i].unit1_exec | unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH].unit2_exec;
    unit2_stop_next =                        0  | unit[cid][i].unit1_stop | unit[cid][ i                         ].unit2_stop;
    unit2_exec_next =                             unit[cid][i].unit1_exec | unit[cid][ i                         ].unit2_exec;
    unit[cid][i].unit1_stop = unit[cid][i].unit1_stop |                    unit1_stop_next ;
    unit[cid][i].unit1_exec = unit[cid][i].unit1_exec |(unit1_exec_next & ~unit1_stop_next);
    unit[cid][i].unit2_stop = unit[cid][i].unit2_stop |                    unit2_stop_next ;
    unit[cid][i].unit2_exec = unit[cid][i].unit2_exec |(unit2_exec_next & ~unit2_stop_next);
  }

  unit[cid][i].cycle++;
d507 1
a507 1
siml_unit_stage2(Uint cid, Uint i)    /* stage-2 (EX/TX->1DR) */
d512 5
a516 5
  /* stage1out   ----------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==> */
  /* stage2out** ------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==> */
  /* stage3out   --------------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==> */
  /* stage4out   -------tx3dr----------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==> */
  /* stage5out   -------brout------------------------------<==p0==><==p1==><==p2==><==p3==><==q0==><==q1==><==q2==><==q3==> */
d521 1
a521 1
  int    j  = (unit[cid][i].cycle+1) % EMAX_WIDTH; /* 1,2,3,0,1,2,3,0 */
d537 1
a537 1
    if (unit[cid][i].unit1_exec & unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid) { /* active */
d539 4
a542 4
      c0      = unit[cid][i].cx[0];
      c1      = unit[cid][i].cx[1];
      c2      = unit[cid][i].cx[2];
      c3      = unit[cid][i].cx[3];
d545 1
a545 1
      unit[cid][i].cx2dr = cxd;
d551 3
a553 3
      r1     = unit[cid][i].ex1;
      r2     = unit[cid][i].ex2;
      r3     = unit[cid][i].ex3;
d555 2
a556 2
             : reg_ctrl.conf[i][j].cdw0.e2is==1 ? unit[cid][i].ex2
             :                                    unit[cid][i].ex3;
d558 1
a558 1
             :                                    unit[cid][i].ex3;
d562 1
a562 1
      unit[cid][i].ex2dbrk |= exe(op_ex1, &unit[cid][i].ex2dr, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5);
d565 6
a570 6
      base0 = unit[cid][i].ea0b;
      offs0 = unit[cid][i].ea0o;
      base1 = unit[cid][i].ea1b;
      offs1 = unit[cid][i].ea1o;
      eag(&unit[cid][i].ea02dr, base0, offs0, reg_ctrl.conf[i][j].cdw1.ea0msk);
      eag(&unit[cid][i].ea12dr, base1, offs1, reg_ctrl.conf[i][j].cdw1.ea1msk);
d573 4
a576 4
      unit[cid][i].tx2dr[0] = unit[cid][i].tx[0];
      unit[cid][i].tx2dr[1] = unit[cid][i].tx[1];
      unit[cid][i].tx2dr[2] = unit[cid][i].tx[2];
      unit[cid][i].tx2dr[3] = unit[cid][i].tx[3];
d584 1
a584 1
siml_unit_stage3(Uint cid, Uint i)    /* stage-3 (1DR->2DR) */
d589 5
a593 5
  /* stage1out   ----------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==> */
  /* stage2out   ------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==> */
  /* stage3out** --------------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==> */
  /* stage4out   -------tx3dr----------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==> */
  /* stage5out   -------brout------------------------------<==p0==><==p1==><==p2==><==p3==><==q0==><==q1==><==q2==><==q3==> */
d598 1
a598 1
  int    j  = (unit[cid][i].cycle+2) % EMAX_WIDTH; /* 2,3,0,1,2,3,0,1 */
d606 1
a606 1
    if (unit[cid][i].unit1_exec & unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid) { /* active */
d608 1
a608 1
      unit[cid][i].cx3dr = unit[cid][i].cx2dr;
d611 2
a612 2
      unit[cid][i].ex3dr   = unit[cid][i].ex2dr;
      unit[cid][i].ex3dbrk = unit[cid][i].ex2dbrk;
d615 2
a616 2
      unit[cid][i].ea03dr = unit[cid][i].ea02dr;
      unit[cid][i].ea13dr = unit[cid][i].ea12dr;
d619 4
a622 4
      unit[cid][i].tx3dr[0] = unit[cid][i].tx2dr[0];
      unit[cid][i].tx3dr[1] = unit[cid][i].tx2dr[1];
      unit[cid][i].tx3dr[2] = unit[cid][i].tx2dr[2];
      unit[cid][i].tx3dr[3] = unit[cid][i].tx2dr[3];
d630 1
a630 1
siml_unit_stage4(Uint cid, Uint i)    /* stage-4 (2DR->3DR) */
d635 5
a639 5
  /* stage1out   ----------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==> */
  /* stage2out   ------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==> */
  /* stage3out   --------------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==> */
  /* ex3dbrk     --------------------------<===0==><===1==><===2==><===3==>-------------------------------------------------*/
  /* stage4out** -------tx3dr----------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==> */
d643 1
a643 1
  /* stage5out   -------brout------------------------------<==p0==><==p1==><==p2==><==p3==><==q0==><==q1==><==q2==><==q3==> */
d648 1
a648 1
  int    j  = (unit[cid][i].cycle+3) % EMAX_WIDTH; /* 3,0,1,2,3,0,1,2 */
d651 28
a678 1
  case CMD_NOP:   /* nop */
d683 1
a683 1
    if (unit[cid][i].unit1_exec & unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH].brout_valid) { /* active */
d685 1
a685 1
      unit[cid][i].cx4dr = unit[cid][i].cx3dr;
d688 3
a690 3
      unit[cid][i].ex4dr = unit[cid][i].ex3dr;
      if ((unit[cid][i].cycle & 3) == 3)
	unit[cid][i].unit1_arbrk  = unit[cid][i].ex3dbrk;
d692 1
a692 1
	unit[cid][i].unit1_arbrk |= unit[cid][i].ex3dbrk;
d694 1
a694 1
      /* ea3dr -> ea4dr */
d696 25
a720 15
      /*         lmwa=0&lmm_mode=1:pload/pdrainに全4サイクル利用可能 */
      /*         lmwa=0&lmm_mode=2:pload/pdrainに2サイクルのみ利用可能 */
      /*         lmwa=0&lmm_mode=3:pload/pdrainに1サイクルのみ使用可能 */
      unit[cid][i].ea04dr = unit[cid][i][j].conf.cdw2.mwsa==0 ?
	unit[cid][i][j].lmwa

unit[cid][i].ea03dr;----------------------
      unit[cid][i].ea14dr = unit[cid][i].ea13dr;----------------------

      /* tx3dr -> tx4dr */
      unit[cid][i].tx4dr[0] = unit[cid][i].tx3dr[0];
      unit[cid][i].tx4dr[1] = unit[cid][i].tx3dr[1];
      unit[cid][i].tx4dr[2] = unit[cid][i].tx3dr[2];
      unit[cid][i].tx4dr[3] = unit[cid][i].tx3dr[3];
      unit[cid][i].tr_valid = 1;
a727 36
siml_unit_stage5(Uint cid, Uint i)    /* stage-5 (3DR->BROUT) */
{
  /*      |       |       |       |       |       |       |       |       |       |       |       |       |       |       | */
  /* clk _/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/~~~\___/ */
  /* cycle  7       0       1       2       3       4       5       6       7       0       1       2       3       4       */
  /* stage1out   ----------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==> */
  /* stage2out   ------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==> */
  /* stage3out   --------------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==><== 1==> */
  /* ex3dbrk     --------------------------<===0==><===1==><===2==><===3==>-------------------------------------------------*/
  /* stage4out   -------tx3dr----------------------<== 0==><== 1==><== 2==><== 3==><== 0==><== 1==><== 2==><== 3==><== 0==> */
  /* unit1_arbrk __________________________________/~~~~~~~/~~~~~~~/~~~~~~~/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /*                                                                              A確定                                     */
  /* tr_valid    __________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* stage5out** -------brout------------------------------<==p0==><==p1==><==p2==><==p3==><==q0==><==q1==><==q2==><==q3==> */
  /*              V-update                        V-update                        V-update                    V-update      */
  /* brout_valid __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
  /* unit1_exec  __________________________________________________________________/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

  if (unit[cid][i].l_stage==(EMAX_DEPTH-1))
    unit[cid][i].brout_valid = 1; /* 最終brout_validは常時1 */
  else if ((unit[cid][i].cycle & 3) == 3) /* final */
    unit[cid][i].brout_valid = unit[cid][i].tr_valid;
}

siml_unit_lmringin(Uint cid, Uint i) /* stage-1 (LMRING_BRIN->LMRING_TR) */
{
}

siml_unit_lmringout(Uint cid, Uint i) /* stage-5 (LMRING_TR->LMRING_BROUT) */
{
}

siml_unit_lmm(Uint cid, Uint i)       /* lmm */
{
}

a733 32
  switch (fsm[cid].status) {
  case STATUS_IDLE:
  case STATUS_CONF:
  case STATUS_SCON:
  case STATUS_LMMI:
    return (0);
  case STATUS_DRAIN: /* fsm drain */
    if (unit[cid][i][j].lmen) {
      unit[cid][i][j].lmm.en1 = 1;
      unit[cid][i][j].lmm.rw1 = 0; /* read */
      unit[cid][i][j].ea1dr = unit[cid][i][j].lmra;
      unit[cid][i][j].lmm.ma1 = (unit[cid][i][j].ea1dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
    }
    else
      unit[cid][i][j].lmm.en1 = 0;
    return (0);
  case STATUS_LOAD: /* fsm pload */
    if (unit[cid][i][j].lmen) {
      unit[cid][i][j].lmm.en0 = 1;
      unit[cid][i][j].lmm.rw0 = 1; /* write */
      unit[cid][i][j].ea0dr = unit[cid][i][j].conf.cdw2.xmws==1 ? unit[cid][i][j].lmlia
                            : unit[cid][i][j].conf.cdw2.xmws==2 ? unit[cid][i][j].lmwa
                            : unit[cid][i][j].conf.cdw2.xmws==3 ? unit[cid][i][j].lmria
                            :                                     0LL;
      unit[cid][i][j].lmm.ma0 = (unit[cid][i][j].ea0dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
    }
    else
      unit[cid][i][j].lmm.en0 = 0;
    return (0);
  case STATUS_REGV:
  case STATUS_START:
    return (0);
d736 6
a741 6
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_DRAIN) {
      if (unit[cid][i][j].lmen) { /* active */
        unit[cid][i][j].ea1dr = unit[cid][i][j].lmra;
        unit[cid][i][j].lmm.en1 = 1;
        unit[cid][i][j].lmm.rw1 = 0; /* read */
        unit[cid][i][j].lmm.ma1 = (unit[cid][i][j].ea1dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
d744 1
a744 1
        unit[cid][i][j].lmm.en1 = 0;
d746 7
a752 8
#ifndef IGNORE_LDDMQ_HANDSHAKE
    else if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) { /* eag0->WRITE,eag1->READ *//* 読み出し側はbase+offsを使用 */
      if (fsm[cid].unit2_eag_aen & (1LL<<i)) { /* active */
	unit[cid][i][j].ea1dr   = unit[cid][i][j].ea1d;
        unit[cid][i][j].lmm.en1 = 1;
        unit[cid][i][j].lmm.rw1 = 0; /* read */
        unit[cid][i][j].lmm.ma1 = (unit[cid][i][j].ea1dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
	/*printf("===LDDMQ read row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);*/
d755 1
a755 35
        unit[cid][i][j].lmm.en1 = 0;
    }
    else if (unit[cid][i][j].conf.cdw1.ea1op == OP_TR) { /* eag0->WRITE,eag1->READ *//* 読み出し側はbase+offsを使用 */
      if (fsm[cid].unit2_eag_aen & (1LL<<i)) { /* active */
	unit[cid][i][j].ea1dr   = unit[cid][i][j].ea1d;
        unit[cid][i][j].lmm.en1 = 1;
        unit[cid][i][j].lmm.rw1 = 0; /* read */
        unit[cid][i][j].lmm.ma1 = (unit[cid][i][j].ea1dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
	/*printf("===TR read row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);*/
      }
      else /* inactive */
        unit[cid][i][j].lmm.en1 = 0;
    }
    else if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_BUFRD) { /* eag0->WRITE,eag1->READ *//* 読み出し側はbase+offsを使用 */
      if (fsm[cid].unit2_eag_den & (1LL<<i)) { /* active */
	unit[cid][i][j].ea1dr   = unit[cid][i][j].ea1d;
        unit[cid][i][j].lmm.en1 = 1;
        unit[cid][i][j].lmm.rw1 = 0; /* read */
        unit[cid][i][j].lmm.ma1 = (unit[cid][i][j].ea1dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
	/*printf("===BUFRD read row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);*/
      }
      else /* inactive */
        unit[cid][i][j].lmm.en1 = 0;
    }
#endif
    else if (unit[cid][i][j].conf.cdw1.ea1op) { /* normal load */
      if ((fsm[cid].unit1_exec & (1LL<<i)) && (fsm[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
	unit[cid][i][j].ea1dr   = unit[cid][i][j].ea1d;
        unit[cid][i][j].lmm.en1 = 1; /* 同一行にLDDMQがある場合,unit[cid][i][j].lmm.en1の連動が必要(次のsiml_unit_bus2()にて補正) */
        unit[cid][i][j].lmm.rw1 = 0; /* read */
        unit[cid][i][j].lmm.ma1 = (unit[cid][i][j].ea1dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
	/*printf("===NLOAD read row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);*/
      }
      else /* inactive */
        unit[cid][i][j].lmm.en1 = 0;
d758 2
a759 2
      unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = 0LL; /* always non-exec */
      unit[cid][i][j].lmm.en1 = 0;
d762 6
a767 9
    if (unit[cid][i][j].conf.cdw1.ea0op == OP_IM_PREF) {
      if (unit[cid][i][j].lmen) {
	unit[cid][i][j].ea0dr = unit[cid][i][j].conf.cdw2.mwsa==1 ? unit[cid][i][j].lmlia
	                      : unit[cid][i][j].conf.cdw2.mwsa==2 ? unit[cid][i][j].lmwa
                              : unit[cid][i][j].conf.cdw2.mwsa==3 ? unit[cid][i][j].lmria
                              :                                     0LL;
        unit[cid][i][j].lmm.en0 = 1;
        unit[cid][i][j].lmm.rw0 = 1; /* write */
        unit[cid][i][j].lmm.ma0 = (unit[cid][i][j].ea0dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
d770 1
a770 1
        unit[cid][i][j].lmm.en0 = 0;
d772 5
a776 5
    else if (unit[cid][i][j].conf.cdw1.ea0op) { /* normal load/store */
      if ((fsm[cid].unit1_exec & (1LL<<i)) && (fsm[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
        unit[cid][i][j].ea0dr   = unit[cid][i][j].ea0d;
        unit[cid][i][j].lmm.en0 = 1;
        unit[cid][i][j].lmm.rw0 = (unit[cid][i][j].conf.cdw1.ea0op & 0x10)!=0; /* read/write */
d779 2
a780 2
        unit[cid][i][j].lmm.ma0 = (unit[cid][i][j].ea0dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
	/*printf("===BUFWR write row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);*/
d783 1
a783 1
        unit[cid][i][j].lmm.en0 = 0;
d786 2
a787 2
      unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = 0LL; /* always non-exec */
      unit[cid][i][j].lmm.en0 = 0;
a789 2
  case STATUS_TERM:
    return (0);
d797 1
a797 1
  Ull exdmux[UNIT_WIDTH], exdsft[UNIT_WIDTH], lmwlwr[UNIT_WIDTH];
d800 1
a800 3
  switch (fsm[cid].status) {
  case STATUS_IDLE:
    return (0);
d802 1
a802 1
    if (fsm[cid].fsm[j].row_select & (1LL<<i)) {
d804 1
a804 1
        *((Ull*)&unit[cid][i][j].conf+k) = unit[cid][i][j].lmwd[k];
d808 1
a808 1
    if (!(fsm[cid].fsm[j].row_select & (1LL<<i))) { /* 初回を0と数えて偶数番 */
d810 1
a810 1
	unit[cid][i][j].regv.br[k] = *((Ull*)&unit[cid][i][j].conf+k);
d814 1
a814 1
	*((Ull*)&unit[cid][i][j].conf+k) = unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].regv.br[k];
a816 3
  case STATUS_LMMI:
  case STATUS_DRAIN:
    return (0);
d818 1
a818 1
    if (unit[cid][i][j].lmen) {
d821 2
a822 5
        unit[cid][i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].conf.cdw2.xmws==1 ? unit[cid][i][j].lmli[k]
                                   : unit[cid][i][j].conf.cdw2.xmws==2 ? unit[cid][i][j].lmwd[k]
                                   : unit[cid][i][j].conf.cdw2.xmws==3 ? unit[cid][i][j].lmri[k]
                                   :                                     0LL;
d827 1
a827 7
    unit[cid][i][j].one_shot   = 0; /* reset one_shot   here */
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].one_shot_a = 0; /* reset one_shot_a here */
    unit[cid][i][j].one_shot_d = 0; /* reset one_shot_d here */
#endif
    return (0);
  case STATUS_START:
d830 2
a831 7
    if ((fsm[cid].unit1_exec & (1LL<<i)) && (fsm[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
      if (unit[cid][i][j].conf.cdw1.ea0op == OP_TR) {
	if (unit[cid][i][j].cexdr&1)
	  unit[cid][i][j].one_shot = 1; /* set one_shot here */
      }
      else
	unit[cid][i][j].one_shot = 1; /* set one_shot here */
a832 6
#ifndef IGNORE_LDDMQ_HANDSHAKE
    if (fsm[cid].unit2_eag_aen & (1LL<<i)) /* first active eneq */
      unit[cid][i][j].one_shot_a = 1; 
    if (fsm[cid].unit2_eag_den & (1LL<<i)) /* first active lmwd_valid */
      unit[cid][i][j].one_shot_d = 1; 
#endif
d834 4
a837 4
    a = unit[cid][i][j].ea0dr % LMEM_SIZE; /* main-mamory-address -> lmm-address */
    exdmux[0] = unit[cid][i][j].conf.cdw2.mws0==0 ? unit[cid][i][j].exdr /* tr[3-0]はalign不要 */
              : unit[cid][i][j].conf.cdw2.mws0==1 ? unit[cid][i][0].exdr
              : unit[cid][i][j].conf.cdw2.mws0==2 ? unit[cid][i][j].t[0]
d839 3
a841 3
    exdmux[1] = unit[cid][i][j].conf.cdw2.mws1==0 ? unit[cid][i][j].exdr
              : unit[cid][i][j].conf.cdw2.mws1==1 ? unit[cid][i][1].exdr
              : unit[cid][i][j].conf.cdw2.mws1==2 ? unit[cid][i][j].t[1]
d843 3
a845 3
    exdmux[2] = unit[cid][i][j].conf.cdw2.mws2==0 ? unit[cid][i][j].exdr
              : unit[cid][i][j].conf.cdw2.mws2==1 ? unit[cid][i][2].exdr
              : unit[cid][i][j].conf.cdw2.mws2==2 ? unit[cid][i][j].t[2]
d847 3
a849 3
    exdmux[3] = unit[cid][i][j].conf.cdw2.mws3==0 ? unit[cid][i][j].exdr
              : unit[cid][i][j].conf.cdw2.mws3==1 ? unit[cid][i][3].exdr
              : unit[cid][i][j].conf.cdw2.mws3==2 ? unit[cid][i][j].t[3]
d852 1
a852 1
    switch (unit[cid][i][j].conf.cdw1.ea0op) {
d855 1
a855 1
	unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&2)?0xffffffff00000000LL:0LL)|((unit[cid][i][j].cexdr&1)?0x00000000ffffffffLL:0LL)) : 0LL; /* mask */
d861 1
a861 1
	unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&1)?0x00000000ffffffffLL:0LL)<<(a & sizeof(int))*8) : 0LL; /* mask */
d867 1
a867 1
	unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&1)?0x000000000000ffffLL:0LL)<<(a & (sizeof(int)|sizeof(short)))*8) : 0LL; /* mask */
d873 1
a873 1
	unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&1)?0x00000000000000ffLL:0LL)<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8) : 0LL; /* mask */
d881 1
a881 1
	unit[cid][i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
a884 16
#ifndef IGNORE_LDDMQ_HANDSHAKE
    case OP_LDDMQ: /* ●●● mws=0 */
      unit[cid][i][j].lmm.mm0[0] = 0xffffffffffffffffLL; /* mask */
      exdsft[0] = exdmux[0]; /* LDDMQ addr */
      for (k=1; k<UNIT_WIDTH; k++) {
	unit[cid][i][j].lmm.mm0[k] = 0LL; /* mask */
	exdsft[k] = exdmux[k]; /* LDDMQ addr */
      }
      break;
    case OP_TR: /* ●●● mws=1 */
      for (k=0; k<UNIT_WIDTH; k++) {
	unit[cid][i][j].lmm.mm0[k] = (unit[cid][i][j].cexdr&1)?0xffffffffffffffffLL:0LL; /* mask */
	exdsft[k] = exdmux[k]; /* not used */
      }
      break;
#endif
d887 4
a890 24
    lmwlwr[0] = unit[cid][i][j].conf.cdw2.mws0==3 ? unit[cid][i][j].lmli[0] :
                unit[cid][i][j].conf.cdw2.mws0==4 ? unit[cid][i][j].lmwd[0] :
		unit[cid][i][j].conf.cdw2.mws0==5 ? unit[cid][i][j].lmri[0] :
		                                    0LL;    

    lmwlwr[1] = unit[cid][i][j].conf.cdw2.mws1==3 ? unit[cid][i][j].lmli[1] :
                unit[cid][i][j].conf.cdw2.mws1==4 ? unit[cid][i][j].lmwd[1] :
                unit[cid][i][j].conf.cdw2.mws1==5 ? unit[cid][i][j].lmri[1] :
		                                    0LL;    

    lmwlwr[2] = unit[cid][i][j].conf.cdw2.mws2==3 ? unit[cid][i][j].lmli[2] :
                unit[cid][i][j].conf.cdw2.mws2==4 ? unit[cid][i][j].lmwd[2] :
                unit[cid][i][j].conf.cdw2.mws2==5 ? unit[cid][i][j].lmri[2] :
		                                    0LL;    

    lmwlwr[3] = unit[cid][i][j].conf.cdw2.mws3==3 ? unit[cid][i][j].lmli[3] :
                unit[cid][i][j].conf.cdw2.mws3==4 ? unit[cid][i][j].lmwd[3] :
                unit[cid][i][j].conf.cdw2.mws3==5 ? unit[cid][i][j].lmri[3] :
		                                    0LL;    

    unit[cid][i][j].lmm.mw0[0] = (unit[cid][i][j].conf.cdw2.mws0 < 3) ? exdsft[0] : lmwlwr[0];
    unit[cid][i][j].lmm.mw0[1] = (unit[cid][i][j].conf.cdw2.mws1 < 3) ? exdsft[1] : lmwlwr[1];
    unit[cid][i][j].lmm.mw0[2] = (unit[cid][i][j].conf.cdw2.mws2 < 3) ? exdsft[2] : lmwlwr[2];
    unit[cid][i][j].lmm.mw0[3] = (unit[cid][i][j].conf.cdw2.mws3 < 3) ? exdsft[3] : lmwlwr[3];
d893 12
a904 14
    unit[cid][i][j].tr[0] = unit[cid][i][j].conf.cdw2.trs0==0 ? unit[cid][i][0].exdr   :
                            unit[cid][i][j].conf.cdw2.trs0==1 ? unit[cid][i][j].lmwd[0]:
			                                        unit[cid][i][j].t[0]   ;
    unit[cid][i][j].tr[1] = unit[cid][i][j].conf.cdw2.trs1==0 ? unit[cid][i][1].exdr   :
                            unit[cid][i][j].conf.cdw2.trs1==1 ? unit[cid][i][j].lmwd[1]:
			                                        unit[cid][i][j].t[1]   ;
    unit[cid][i][j].tr[2] = unit[cid][i][j].conf.cdw2.trs2==0 ? unit[cid][i][2].exdr   :
                            unit[cid][i][j].conf.cdw2.trs2==1 ? unit[cid][i][j].lmwd[2]:
			                                        unit[cid][i][j].t[2]   ;
    unit[cid][i][j].tr[3] = unit[cid][i][j].conf.cdw2.trs3==0 ? unit[cid][i][3].exdr   :
                            unit[cid][i][j].conf.cdw2.trs3==1 ? unit[cid][i][j].lmwd[3]:
			                                        unit[cid][i][j].t[3]   ;
    return (0);
  case STATUS_TERM:
d909 1
a909 1
siml_unit_lmm(cid,  i, j) Uint cid, i, j; /* 旧TR/旧EADRを使ったLMM動作 & TR更新 */
d920 8
a927 8
  /* ma  -----<   A0  ><   A1   ><   A2   ><   A3   ><   A4   >-------------------- */
  /* mw  --------------<   W1   ><   W2   >---------------------------------------- */
  /* mr  --------------<   R0   >--------------------<   R3   ><   R4   >---------- */

  a0   = unit[cid][i][j].ea0dr % LMEM_SIZE;
  a1   = unit[cid][i][j].ea1dr % LMEM_SIZE;
  a0al = unit[cid][i][j].lmm.ma0; /* should be aligned by fsm */
  a1al = unit[cid][i][j].lmm.ma1; /* should be aligned by fsm */
d929 1
a929 1
  switch (fsm[cid].status) {
d936 2
a937 2
    if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
      unit[cid][i][j].rrdy = 1; /* rdata valid */
d939 1
a939 1
        fsm[cid].fsm[j].lmrd[k] = unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
d942 1
a942 1
      unit[cid][i][j].rrdy = 0; /* rdata invalid */
d945 1
a945 1
    if (unit[cid][i][j].lmm.en0 && unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
d947 4
a950 2
        *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
      /*printf("LMM pload row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al, (Uint)unit[cid][i][j].lmm.mw0[3], (Uint)unit[cid][i][j].lmm.mm0[3], (Uint)unit[cid][i][j].lmm.mw0[2], (Uint)unit[cid][i][j].lmm.mm0[2], (Uint)unit[cid][i][j].lmm.mw0[1], (Uint)unit[cid][i][j].lmm.mm0[1], (Uint)unit[cid][i][j].lmm.mw0[0], (Uint)unit[cid][i][j].lmm.mm0[0]);*/
d954 1
a954 1
    if (fsm[cid].fsm[j].row_select & (1LL<<i)) {
d956 1
a956 1
        switch (unit[cid][i][j].lmwa) {
d958 1
a958 1
          *((Ull*)&unit[cid][i][j].regv+0+k) = unit[cid][i][j].lmwd[k];
d961 1
a961 1
          *((Ull*)&unit[cid][i][j].regv+4+k) = unit[cid][i][j].lmwd[k];
d968 1
a968 1
    unit[cid][i][j].drty = 0; /* reset dirty */
d973 5
a977 5
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_DRAIN
     || unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ
     || unit[cid][i][j].conf.cdw1.ea1op == OP_TR) {
      if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
	unit[cid][i][j].rrdy = 1; /* rdata valid */
d979 3
a981 2
	  fsm[cid].fsm[j].lmrd[k] = unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
	/*printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al, (Uint)fsm[cid].fsm[j].lmrd[3], (Uint)fsm[cid].fsm[j].lmrd[2], (Uint)fsm[cid].fsm[j].lmrd[1], (Uint)fsm[cid].fsm[j].lmrd[0]);*/
d984 1
a984 1
	unit[cid][i][j].rrdy = 0; /* rdata invalid */
d986 2
a987 2
    else if (unit[cid][i][j].conf.cdw1.ea1op) { /* OP_IM_BUFRD or normal load */
      if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
d989 3
a991 2
	  unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
	/*printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al, (Uint)unit[cid][i][j].lmm.mr1[3], (Uint)unit[cid][i][j].lmm.mr1[2], (Uint)unit[cid][i][j].lmm.mr1[1], (Uint)unit[cid][i][j].lmm.mr1[0]);*/
d995 2
a996 2
    if (unit[cid][i][j].conf.cdw1.ea0op == OP_IM_PREF) {
      if (unit[cid][i][j].lmm.en0 &&  unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
d998 4
a1001 2
	  *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
	/*printf("PRF write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al, (Uint)unit[cid][i][j].lmm.mw0[3], (Uint)unit[cid][i][j].lmm.mm0[3], (Uint)unit[cid][i][j].lmm.mw0[2], (Uint)unit[cid][i][j].lmm.mm0[2], (Uint)unit[cid][i][j].lmm.mw0[1], (Uint)unit[cid][i][j].lmm.mm0[1], (Uint)unit[cid][i][j].lmm.mw0[0], (Uint)unit[cid][i][j].lmm.mm0[0]);*/
d1004 2
a1005 2
    else if (unit[cid][i][j].conf.cdw1.ea0op) { /* normal load/store */
      if (unit[cid][i][j].lmm.en0 && !unit[cid][i][j].lmm.rw0) { /* lmm read enabled */
d1007 1
a1007 1
	  unit[cid][i][j].lmm.mr0[k] = *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k);
d1009 3
a1011 3
      if (unit[cid][i][j].lmm.en0 &&  unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
	if (unit[cid][i][j].conf.cdw1.ea0op < OP_LDDMQ)
	  unit[cid][i][j].drty = 1; /* mark dirty (OP_LDDMQ,OP_TR,OP_IM_BUFWR,は除外が必要) */
d1013 4
a1016 2
	  *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
	/*printf("LMM write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al, (Uint)unit[cid][i][j].lmm.mw0[3], (Uint)unit[cid][i][j].lmm.mm0[3], (Uint)unit[cid][i][j].lmm.mw0[2], (Uint)unit[cid][i][j].lmm.mm0[2], (Uint)unit[cid][i][j].lmm.mw0[1], (Uint)unit[cid][i][j].lmm.mm0[1], (Uint)unit[cid][i][j].lmm.mw0[0], (Uint)unit[cid][i][j].lmm.mm0[0]);*/
d1021 1
a1021 1
    switch (unit[cid][i][j].conf.cdw2.brs0) {
d1023 2
a1024 2
    case 1: unit[cid][i][j].regv.br[0] = unit[cid][i][j].lmm.mr1[0]; break; /* 1:mr10 align不要 */
    case 2: unit[cid][i][j].regv.br[0] = unit[cid][i][j].tr[0];      break; /* 2:tr0  align不要 */
d1026 10
a1035 10
      unit[cid][i][j].mr0mux = (a0/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr0[3-0] -> mr0d */
      unit[cid][i][j].mr0d   = unit[cid][i][j].lmm.mr0[unit[cid][i][j].mr0mux];
      switch (unit[cid][i][j].conf.cdw1.ea0op) {
      case OP_LDR :  unit[cid][i][j].regv.br[0] =                unit[cid][i][j].mr0d;                                                                                 break;
      case OP_LDWR:  unit[cid][i][j].regv.br[0] = (Sll)   (int)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDUWR: unit[cid][i][j].regv.br[0] = (Ull)  (Uint)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDHR:  unit[cid][i][j].regv.br[0] = (Sll) (short)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDUHR: unit[cid][i][j].regv.br[0] = (Ull)(Ushort)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDBR:  unit[cid][i][j].regv.br[0] = (Sll)  (char)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      case OP_LDUBR: unit[cid][i][j].regv.br[0] = (Ull) (Uchar)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
d1039 1
a1039 1
    switch (unit[cid][i][j].conf.cdw2.brs1) {
d1041 2
a1042 2
    case 1: unit[cid][i][j].regv.br[1] = unit[cid][i][j].lmm.mr1[1]; break; /* 1:mr11 align不要 */
    case 2: unit[cid][i][j].regv.br[1] = unit[cid][i][j].tr[1];      break; /* 2:tr1  align不要 */
d1044 10
a1053 10
      unit[cid][i][j].mr1mux = (a1/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr1[3-0] -> mr0d */
      unit[cid][i][j].mr1d   = unit[cid][i][j].lmm.mr1[unit[cid][i][j].mr1mux];
      switch (unit[cid][i][j].conf.cdw1.ea1op) {
      case OP_LDR:   unit[cid][i][j].regv.br[1] =                unit[cid][i][j].mr1d;                                                                                 break;
      case OP_LDWR:  unit[cid][i][j].regv.br[1] = (Sll)   (int)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDUWR: unit[cid][i][j].regv.br[1] = (Ull)  (Uint)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDHR:  unit[cid][i][j].regv.br[1] = (Sll) (short)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDUHR: unit[cid][i][j].regv.br[1] = (Ull)(Ushort)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDBR:  unit[cid][i][j].regv.br[1] = (Sll)  (char)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      case OP_LDUBR: unit[cid][i][j].regv.br[1] = (Ull) (Uchar)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
d1057 1
a1057 1
    switch (unit[cid][i][j].conf.cdw2.brs2) {
d1059 3
a1061 3
    case 1: unit[cid][i][j].regv.br[2] = unit[cid][i][j].lmm.mr1[2]; break; /* 1:mr12 align不要 */
    case 2: unit[cid][i][j].regv.br[2] = unit[cid][i][j].tr[2];      break; /* 2:tr2  align不要 */
    case 3: unit[cid][i][j].regv.br[2] = unit[cid][i][j].exdr;       break; /* 3:exdr align不要 */
d1064 1
a1064 1
    switch (unit[cid][i][j].conf.cdw2.brs3) {
d1066 2
a1067 2
    case 1: unit[cid][i][j].regv.br[3] = unit[cid][i][j].lmm.mr1[3]; break; /* 1:mr13 align不要 */
    case 2: unit[cid][i][j].regv.br[3] = unit[cid][i][j].tr[3];      break; /* 2:tr3  align不要 */
d1075 24
d1101 1
a1101 1
  int tid = fsm[cid].tid;
d1124 3
a1126 3
  printf("==== FSM[%02.2d] v=%d tid=%d stat=%d l_conf=%08.8x_%08.8x l_dist=%d last_row0=%d unit1_exec=%08.8x_%08.8x unit1_stop=%08.8x_%08.8x unit2_exec=%08.8x_%08.8x unit2_stop=%08.8x_%08.8x\n",
         cid, fsm[cid].v, fsm[cid].tid, fsm[cid].status, (Uint)(fsm[cid].last_conf>>32), (Uint)fsm[cid].last_conf, fsm[cid].last_dist, fsm[cid].last_row0,
         (Uint)(fsm[cid].unit1_exec>>32), (Uint)fsm[cid].unit1_exec, (Uint)(fsm[cid].unit1_stop>>32), (Uint)fsm[cid].unit1_stop, (Uint)(fsm[cid].unit2_exec>>32), (Uint)fsm[cid].unit2_exec, (Uint)(fsm[cid].unit2_stop>>32), (Uint)fsm[cid].unit2_stop);
d1130 1
a1130 1
    printf("         ---- FSM[%d] lmmo[],lmmc[],lmmd[]           ", col);
d1136 11
a1146 11
             (Uint) fsm[cid].fsm[col].lmmo[row].v?36:34,
             (Uint) fsm[cid].fsm[col].lmmo[row].v,
             (Uint) fsm[cid].fsm[col].lmmo[row].rw,
             (Uint) fsm[cid].fsm[col].lmmo[row].f,
             (Uint) fsm[cid].fsm[col].lmmo[row].p,
             (Uint) fsm[cid].fsm[col].lmmo[row].blk,
             (Uint) fsm[cid].fsm[col].lmmo[row].len,
             (Uint) fsm[cid].fsm[col].lmmo[row].bcas,
             (Uint) fsm[cid].fsm[col].lmmo[row].copy,
             (Uint)(fsm[cid].fsm[col].lmmo[row].top>>32),
             (Uint) fsm[cid].fsm[col].lmmo[row].top);
d1151 11
a1161 11
             (Uint) fsm[cid].fsm[col].lmmc[row].v?36:34,
             (Uint) fsm[cid].fsm[col].lmmc[row].v,
             (Uint) fsm[cid].fsm[col].lmmc[row].rw,
             (Uint) fsm[cid].fsm[col].lmmc[row].f,
             (Uint) fsm[cid].fsm[col].lmmc[row].p,
             (Uint) fsm[cid].fsm[col].lmmc[row].blk,
             (Uint) fsm[cid].fsm[col].lmmc[row].len,
             (Uint) fsm[cid].fsm[col].lmmc[row].bcas,
             (Uint) fsm[cid].fsm[col].lmmc[row].copy,
             (Uint)(fsm[cid].fsm[col].lmmc[row].top>>32),
             (Uint) fsm[cid].fsm[col].lmmc[row].top);
d1167 1
a1167 1
    printf("         ---- FSM[%d] status=%02.2d bus_controller                       ", col, fsm[cid].status);
d1171 2
a1172 2
         (Uint)(fsm[cid].unit1_exec>>32), (Uint)fsm[cid].unit1_exec,
         (Uint)(fsm[cid].unit1_stop>>32), (Uint)fsm[cid].unit1_stop);
d1176 2
a1177 2
         (Uint)(fsm[cid].unit2_exec>>32), (Uint)fsm[cid].unit2_exec,
         (Uint)(fsm[cid].unit2_stop>>32), (Uint)fsm[cid].unit2_stop);
d1182 9
a1190 9
           (Uint) fsm[cid].fsm[col].memif_status,
           (Uint) fsm[cid].fsm[col].last_dist,
           (Uint) fsm[cid].fsm[col].row_count,
           (Uint)(fsm[cid].fsm[col].row_select>>32),
           (Uint) fsm[cid].fsm[col].row_select,
           (Uint)(fsm[cid].fsm[col].row_lmm_en>>32),
           (Uint) fsm[cid].fsm[col].row_lmm_en,
           fsm[cid].fsm[col].ardyc,
           fsm[cid].fsm[col].rrdyc);
d1195 8
a1202 8
           (Uint)(fsm[cid].fsm[col].araddr>>32),
           (Uint) fsm[cid].fsm[col].araddr,
           (Uint)(fsm[cid].fsm[col].arlen>>32),
           (Uint) fsm[cid].fsm[col].arlen,
           (Uint)(fsm[cid].fsm[col].awaddr>>32),
           (Uint) fsm[cid].fsm[col].awaddr,
           (Uint)(fsm[cid].fsm[col].awlen>>32),
           (Uint) fsm[cid].fsm[col].awlen);
d1207 4
a1210 4
           (Uint)(fsm[cid].fsm[col].lmwa>>32),
           (Uint) fsm[cid].fsm[col].lmwa,
           (Uint)(fsm[cid].fsm[col].lmra>>32),
           (Uint) fsm[cid].fsm[col].lmra);
d1215 8
a1222 8
           (Uint)(fsm[cid].fsm[col].lmwd[3]>>32),
           (Uint) fsm[cid].fsm[col].lmwd[3],
           (Uint)(fsm[cid].fsm[col].lmwd[2]>>32),
           (Uint) fsm[cid].fsm[col].lmwd[2],
           (Uint)(fsm[cid].fsm[col].lmwd[1]>>32),
           (Uint) fsm[cid].fsm[col].lmwd[1],
           (Uint)(fsm[cid].fsm[col].lmwd[0]>>32),
           (Uint) fsm[cid].fsm[col].lmwd[0]);
d1227 8
a1234 8
           (Uint)(fsm[cid].fsm[col].lmrd[3]>>32),
           (Uint) fsm[cid].fsm[col].lmrd[3],
           (Uint)(fsm[cid].fsm[col].lmrd[2]>>32),
           (Uint) fsm[cid].fsm[col].lmrd[2],
           (Uint)(fsm[cid].fsm[col].lmrd[1]>>32),
           (Uint) fsm[cid].fsm[col].lmrd[1],
           (Uint)(fsm[cid].fsm[col].lmrd[0]>>32),
           (Uint) fsm[cid].fsm[col].lmrd[0]);
d1239 9
a1247 9
           (Uint) fsm[cid].fsm[col].axi_arready,
           (Uint) fsm[cid].fsm[col].axi_arvalid,
           (Uint) fsm[cid].fsm[col].axi_rvalid,
           (Uint) fsm[cid].fsm[col].axi_awready,
           (Uint) fsm[cid].fsm[col].axi_awvalid,
           (Uint) fsm[cid].fsm[col].axi_wstrb,
           (Uint) fsm[cid].fsm[col].axi_wvalid,
           (Uint) fsm[cid].fsm[col].ilen,
           (Uint) fsm[cid].fsm[col].idelay);
d1252 8
a1259 8
           (Uint)(fsm[cid].fsm[col].axi_araddr>>32),
           (Uint) fsm[cid].fsm[col].axi_araddr,
           (Uint)(fsm[cid].fsm[col].axi_arlen>>32),
           (Uint) fsm[cid].fsm[col].axi_arlen,
           (Uint)(fsm[cid].fsm[col].axi_awaddr>>32),
           (Uint) fsm[cid].fsm[col].axi_awaddr,
           (Uint)(fsm[cid].fsm[col].axi_awlen>>32),
           (Uint) fsm[cid].fsm[col].axi_awlen);
d1264 8
a1271 8
           (Uint)(fsm[cid].fsm[col].axi_rdata[3]>>32),
           (Uint) fsm[cid].fsm[col].axi_rdata[3],
           (Uint)(fsm[cid].fsm[col].axi_rdata[2]>>32),
           (Uint) fsm[cid].fsm[col].axi_rdata[2],
           (Uint)(fsm[cid].fsm[col].axi_rdata[1]>>32),
           (Uint) fsm[cid].fsm[col].axi_rdata[1],
           (Uint)(fsm[cid].fsm[col].axi_rdata[0]>>32),
           (Uint) fsm[cid].fsm[col].axi_rdata[0]);
d1276 8
a1283 8
           (Uint)(fsm[cid].fsm[col].axi_wdata[3]>>32),
           (Uint) fsm[cid].fsm[col].axi_wdata[3],
           (Uint)(fsm[cid].fsm[col].axi_wdata[2]>>32),
           (Uint) fsm[cid].fsm[col].axi_wdata[2],
           (Uint)(fsm[cid].fsm[col].axi_wdata[1]>>32),
           (Uint) fsm[cid].fsm[col].axi_wdata[1],
           (Uint)(fsm[cid].fsm[col].axi_wdata[0]>>32),
           (Uint) fsm[cid].fsm[col].axi_wdata[0]);
d1294 15
a1308 15
             (Uint) unit[cid][row][col].conf.cdw0.op1,
             (Uint) unit[cid][row][col].conf.cdw0.op2,
             (Uint) unit[cid][row][col].conf.cdw0.op3,
             (Uint) unit[cid][row][col].conf.cdw0.ex1brs,
             (Uint) unit[cid][row][col].conf.cdw0.ex1s,
             (Uint) unit[cid][row][col].conf.cdw0.ex1exp,
             (Uint) unit[cid][row][col].conf.cdw0.ex2brs,
             (Uint) unit[cid][row][col].conf.cdw0.ex2exp,
             (Uint) unit[cid][row][col].conf.cdw0.ex3brs,
             (Uint) unit[cid][row][col].conf.cdw0.ex3exp,
             (Uint)(unit[cid][row][col].conf.cdw3.e2imm>>32),
             (Uint) unit[cid][row][col].conf.cdw3.e2imm,
             (Uint) unit[cid][row][col].conf.cdw0.e2is,
             (Uint) unit[cid][row][col].conf.cdw0.e3imm,
             (Uint) unit[cid][row][col].conf.cdw0.e3is);
d1313 15
a1327 15
             (Uint) unit[cid][row][col].conf.cdw1.cs3,
             (Uint) unit[cid][row][col].conf.cdw1.cs2,
             (Uint) unit[cid][row][col].conf.cdw1.cs1,
             (Uint) unit[cid][row][col].conf.cdw1.cs0,
             (Uint) unit[cid][row][col].conf.cdw1.cex_tab,
             (Uint) unit[cid][row][col].conf.cdw1.ea1op,
             (Uint) unit[cid][row][col].conf.cdw1.ea1bs,
             (Uint) unit[cid][row][col].conf.cdw1.ea1os,
             (Uint) unit[cid][row][col].conf.cdw1.ea1msk,
             (Uint) unit[cid][row][col].conf.cdw1.ea0op,
             (Uint) unit[cid][row][col].conf.cdw1.ea0bs,
             (Uint) unit[cid][row][col].conf.cdw1.ea0os,
             (Uint) unit[cid][row][col].conf.cdw1.ea0msk,
             (Uint) unit[cid][row][col].conf.cdw1.eabbrs,
             (Uint) unit[cid][row][col].conf.cdw1.eaobrs);
d1332 17
a1348 17
             (Uint) unit[cid][row][col].conf.cdw2.lmls,
             (Uint) unit[cid][row][col].conf.cdw2.lmrs,
             (Uint) unit[cid][row][col].conf.cdw2.ts3,
             (Uint) unit[cid][row][col].conf.cdw2.ts2,
             (Uint) unit[cid][row][col].conf.cdw2.ts1,
             (Uint) unit[cid][row][col].conf.cdw2.ts0,
             (Uint) unit[cid][row][col].conf.cdw2.mwsa,
             (Uint) unit[cid][row][col].conf.cdw2.mws3,
             (Uint) unit[cid][row][col].conf.cdw2.mws2,
             (Uint) unit[cid][row][col].conf.cdw2.mws1,
             (Uint) unit[cid][row][col].conf.cdw2.mws0,
             (Uint) unit[cid][row][col].conf.cdw2.brs3,
             (Uint) unit[cid][row][col].conf.cdw2.brs2,
             (Uint) unit[cid][row][col].conf.cdw2.brs1,
             (Uint) unit[cid][row][col].conf.cdw2.brs0,
             (Uint) unit[cid][row][col].conf.cdw2.xmws,
             (Uint) unit[cid][row][col].conf.cdw2.mapdist);
d1353 8
a1360 8
             (Uint)(unit[cid][row][col].regv.ea1br>>32),
             (Uint) unit[cid][row][col].regv.ea1br,
             (Uint)(unit[cid][row][col].regv.ea1or>>32),
             (Uint) unit[cid][row][col].regv.ea1or,
             (Uint)(unit[cid][row][col].regv.ea0br>>32),
             (Uint) unit[cid][row][col].regv.ea0br,
             (Uint)(unit[cid][row][col].regv.ea0or>>32),
             (Uint) unit[cid][row][col].regv.ea0or);
d1365 8
a1372 8
             (Uint)(unit[cid][row][col].regv.br[3]>>32),
             (Uint) unit[cid][row][col].regv.br[3],
             (Uint)(unit[cid][row][col].regv.br[2]>>32),
             (Uint) unit[cid][row][col].regv.br[2],
             (Uint)(unit[cid][row][col].regv.br[1]>>32),
             (Uint) unit[cid][row][col].regv.br[1],
             (Uint)(unit[cid][row][col].regv.br[0]>>32),
             (Uint) unit[cid][row][col].regv.br[0]);
d1377 12
a1388 12
             (Uint) unit[cid][row][col].one_shot,
             (Uint) unit[cid][row][col].c[3],
             (Uint) unit[cid][row][col].c[2],
             (Uint) unit[cid][row][col].c[1],
             (Uint) unit[cid][row][col].c[0],
             (Uint) unit[cid][row][col].cexdr,
             (Uint)(unit[cid][row][col].ex1>>32),
             (Uint) unit[cid][row][col].ex1,
             (Uint)(unit[cid][row][col].ex2>>32),
             (Uint) unit[cid][row][col].ex2,
             (Uint)(unit[cid][row][col].ex3>>32),
             (Uint) unit[cid][row][col].ex3);
d1393 4
a1396 4
             (Uint)(unit[cid][row][col].eab>>32),
             (Uint) unit[cid][row][col].eab,
             (Uint)(unit[cid][row][col].eao>>32),
             (Uint) unit[cid][row][col].eao);
d1401 8
a1408 8
             (Uint)(unit[cid][row][col].ea1b>>32),
             (Uint) unit[cid][row][col].ea1b,
             (Uint)(unit[cid][row][col].ea1o>>32),
             (Uint) unit[cid][row][col].ea1o,
             (Uint)(unit[cid][row][col].ea0b>>32),
             (Uint) unit[cid][row][col].ea0b,
             (Uint)(unit[cid][row][col].ea0o>>32),
             (Uint) unit[cid][row][col].ea0o);
d1413 8
a1420 8
             (Uint)(unit[cid][row][col].exdr>>32),
             (Uint) unit[cid][row][col].exdr,
             (Uint)(unit[cid][row][col].ea1dr>>32),
             (Uint) unit[cid][row][col].ea1dr,
             (Uint)(unit[cid][row][col].ea0dr>>32),
             (Uint) unit[cid][row][col].ea0dr,
             unit[cid][row][col].lmen,
             unit[cid][row][col].rrdy);
d1425 4
a1428 4
             (Uint)(unit[cid][row][col].lmwa>>32),
             (Uint) unit[cid][row][col].lmwa,
             (Uint)(unit[cid][row][col].lmra>>32),
             (Uint) unit[cid][row][col].lmra);
d1433 8
a1440 8
             (Uint)(unit[cid][row][col].lmwd[3]>>32),
             (Uint) unit[cid][row][col].lmwd[3],
             (Uint)(unit[cid][row][col].lmwd[2]>>32),
             (Uint) unit[cid][row][col].lmwd[2],
             (Uint)(unit[cid][row][col].lmwd[1]>>32),
             (Uint) unit[cid][row][col].lmwd[1],
             (Uint)(unit[cid][row][col].lmwd[0]>>32),
             (Uint) unit[cid][row][col].lmwd[0]);
d1445 8
a1452 8
             (Uint)(unit[cid][row][col].lmrd[3]>>32),
             (Uint) unit[cid][row][col].lmrd[3],
             (Uint)(unit[cid][row][col].lmrd[2]>>32),
             (Uint) unit[cid][row][col].lmrd[2],
             (Uint)(unit[cid][row][col].lmrd[1]>>32),
             (Uint) unit[cid][row][col].lmrd[1],
             (Uint)(unit[cid][row][col].lmrd[0]>>32),
             (Uint) unit[cid][row][col].lmrd[0]);
d1457 8
a1464 8
             (Uint)(unit[cid][row][col].t[3]>>32),
             (Uint) unit[cid][row][col].t[3],
             (Uint)(unit[cid][row][col].t[2]>>32),
             (Uint) unit[cid][row][col].t[2],
             (Uint)(unit[cid][row][col].t[1]>>32),
             (Uint) unit[cid][row][col].t[1],
             (Uint)(unit[cid][row][col].t[0]>>32),
             (Uint) unit[cid][row][col].t[0]);
d1469 8
a1476 8
             (Uint)(unit[cid][row][col].tr[3]>>32),
             (Uint) unit[cid][row][col].tr[3],
             (Uint)(unit[cid][row][col].tr[2]>>32),
             (Uint) unit[cid][row][col].tr[2],
             (Uint)(unit[cid][row][col].tr[1]>>32),
             (Uint) unit[cid][row][col].tr[1],
             (Uint)(unit[cid][row][col].tr[0]>>32),
             (Uint) unit[cid][row][col].tr[0]);
d1481 8
a1488 8
             (Uint) unit[cid][row][col].lmm.en1,
             (Uint) unit[cid][row][col].lmm.rw1,
             (Uint)(unit[cid][row][col].lmm.ma1>>32),
             (Uint) unit[cid][row][col].lmm.ma1,
             (Uint) unit[cid][row][col].lmm.en0,
             (Uint) unit[cid][row][col].lmm.rw0,
             (Uint)(unit[cid][row][col].lmm.ma0>>32),
             (Uint) unit[cid][row][col].lmm.ma0);
d1493 8
a1500 8
             (Uint)(unit[cid][row][col].lmm.mm0[3]>>32),
             (Uint) unit[cid][row][col].lmm.mm0[3],
             (Uint)(unit[cid][row][col].lmm.mm0[2]>>32),
             (Uint) unit[cid][row][col].lmm.mm0[2],
             (Uint)(unit[cid][row][col].lmm.mm0[1]>>32),
             (Uint) unit[cid][row][col].lmm.mm0[1],
             (Uint)(unit[cid][row][col].lmm.mm0[0]>>32),
             (Uint) unit[cid][row][col].lmm.mm0[0]);
d1505 9
a1513 9
	     unit[cid][row][col].lmm.en0 && unit[cid][row][col].lmm.rw0?35:34,
             (Uint)(unit[cid][row][col].lmm.mw0[3]>>32),
             (Uint) unit[cid][row][col].lmm.mw0[3],
             (Uint)(unit[cid][row][col].lmm.mw0[2]>>32),
             (Uint) unit[cid][row][col].lmm.mw0[2],
             (Uint)(unit[cid][row][col].lmm.mw0[1]>>32),
             (Uint) unit[cid][row][col].lmm.mw0[1],
             (Uint)(unit[cid][row][col].lmm.mw0[0]>>32),
             (Uint) unit[cid][row][col].lmm.mw0[0]);
d1518 8
a1525 8
             (Uint)(unit[cid][row][col].lmm.mr0[3]>>32),
             (Uint) unit[cid][row][col].lmm.mr0[3],
             (Uint)(unit[cid][row][col].lmm.mr0[2]>>32),
             (Uint) unit[cid][row][col].lmm.mr0[2],
             (Uint)(unit[cid][row][col].lmm.mr0[1]>>32),
             (Uint) unit[cid][row][col].lmm.mr0[1],
             (Uint)(unit[cid][row][col].lmm.mr0[0]>>32),
             (Uint) unit[cid][row][col].lmm.mr0[0]);
d1530 9
a1538 9
	     unit[cid][row][col].rrdy?36:34,
             (Uint)(unit[cid][row][col].lmm.mr1[3]>>32),
             (Uint) unit[cid][row][col].lmm.mr1[3],
             (Uint)(unit[cid][row][col].lmm.mr1[2]>>32),
             (Uint) unit[cid][row][col].lmm.mr1[2],
             (Uint)(unit[cid][row][col].lmm.mr1[1]>>32),
             (Uint) unit[cid][row][col].lmm.mr1[1],
             (Uint)(unit[cid][row][col].lmm.mr1[0]>>32),
             (Uint) unit[cid][row][col].lmm.mr1[0]);
d1543 6
a1548 6
             (Uint) unit[cid][row][col].mr1mux,
             (Uint) unit[cid][row][col].mr0mux,
             (Uint)(unit[cid][row][col].mr1d>>32),
             (Uint) unit[cid][row][col].mr1d,
             (Uint)(unit[cid][row][col].mr0d>>32),
             (Uint) unit[cid][row][col].mr0d);
@


1.219
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.218 2017/06/05 15:07:59 nakashim Exp nakashim $";
d52 1
a52 1
  Ull   logical_stage: 6;  /* 0..63 *//* 0の物理stageが起動の起点 */
d63 1
d65 1
a65 3
  Ull   one_shot     : 1;  /* reg  *//* self_loop_control 0:init 1:self_loop, keep 0 in first 4 cycles */
  Ull   cx[UNIT_WIDTH]  ;  /* reg  */
  Ull   cx1dr        : 2;  /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
d68 1
d72 5
a76 3
  Ull   ex1dr           ;  /* reg  *//* out for first-stage */
  Ull   ex2dr           ;  /* reg  *//* out for second-stage */
  Ull   ex3dr           ;  /* reg  *//* out for third-stage */
a80 1
  Ull   ea01dr          ;  /* reg  */
d83 1
a85 1
  Ull   ea11dr          ;  /* reg  */
d88 1
a89 1
  Ull   tx1dr[UNIT_WIDTH]; /* reg  */
d92 1
d246 1
a246 1
    if (unit[cid][i].logical_stage == 0)
d263 1
a263 1
  case CMD_NOP: /* nop */
d269 2
a270 2
  case CMD_SCON: /* scon */
  case CMD_EXEC: /* exec */
d349 1
d354 23
d378 2
a379 2
  int b  = unit[cid][i].cycle / UNIT_WIDTH; /* 0,0,0,0,1,1,1,1 */
  int j  = unit[cid][i].cycle % UNIT_WIDTH; /* 0,1,2,3,0,1,2,3 */
d381 1
d383 44
a426 14
  /* regv(br,ea[01][bo]r) -> c,t,ex[123],ea[bo],ea[01][bo] */
  s = reg_ctrl.conf[i][j].cdw1.cs0;    unit[cid][i].cx[0] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
  s = reg_ctrl.conf[i][j].cdw1.cs1;    unit[cid][i].cx[1] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
  s = reg_ctrl.conf[i][j].cdw1.cs2;    unit[cid][i].cx[2] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;
  s = reg_ctrl.conf[i][j].cdw1.cs3;    unit[cid][i].cx[3] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH]&3;

  s = reg_ctrl.conf[i][j].cdw2.ts0;    unit[cid][i].tx[0] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
  s = reg_ctrl.conf[i][j].cdw2.ts1;    unit[cid][i].tx[1] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
  s = reg_ctrl.conf[i][j].cdw2.ts2;    unit[cid][i].tx[2] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
  s = reg_ctrl.conf[i][j].cdw2.ts3;    unit[cid][i].tx[3] = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];

  s = reg_ctrl.conf[i][j].cdw0.ex1brs; unit[cid][i].ex1   = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
  s = reg_ctrl.conf[i][j].cdw0.ex2brs; unit[cid][i].ex2   = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
  s = reg_ctrl.conf[i][j].cdw0.ex3brs; unit[cid][i].ex3   = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
d428 5
a432 2
  s = reg_ctrl.conf[i][j].cdw1.eabbrs; unit[cid][i].eab   = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
  s = reg_ctrl.conf[i][j].cdw1.eaobrs; unit[cid][i].eao   = unit[cid][pi].b[b][s/UNIT_WIDTH].r[s%UNIT_WIDTH];
d434 10
a443 5
  sb = reg_ctrl.conf[i][j].cdw1.ea0bs;  unit[cid][i].ea0b  = ((sb&1)&& unit[cid][i].one_shot)?unit[cid][i].ea03dr:((sb&2)?unit[cid][i].eab:reg_ctrl.addr[i][j].ea0b);
  so = reg_ctrl.conf[i][j].cdw1.ea0os;  unit[cid][i].ea0o  = ((sb&1)&&!unit[cid][i].one_shot)?0LL                :((so&1)?unit[cid][i].eao:reg_ctrl.addr[i][j].ea0o);

  sb = reg_ctrl.conf[i][j].cdw1.ea1bs;  unit[cid][i].ea1b  = ((sb&1)&& unit[cid][i].one_shot)?unit[cid][i].ea13dr:((sb&2)?unit[cid][i].eab:reg_ctrl.addr[i][j].ea1b);
  so = reg_ctrl.conf[i][j].cdw1.ea1os;  unit[cid][i].ea1o  = ((sb&1)&&!unit[cid][i].one_shot)?0LL                :((so&1)?unit[cid][i].eao:reg_ctrl.addr[i][j].ea1o);
d446 1
d451 73
d528 42
d574 34
a607 2
    if ((fsm[cid].cycle & 3)==3) /* final */
      fsm[cid].unit1_arbrk &= ~(1LL<<i); /* reset arbrk */
d609 19
a627 4
  emax5[cid].tr_valid &= ~(1LL<<i);
  { /* including OP_TR */
    if ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) /* active */
      emax5[cid].tr_valid |= (1LL<<i);
d630 1
d635 20
a654 4
    if (i==(row0+EMAX_DEPTH-1)%EMAX_DEPTH)
      fsm[cid].brout_valid = (fsm[cid].brout_valid &~(1LL<<i)) | (1LL<<i); /* 最終brout_validは常時1 */
    else if ((fsm[cid].cycle & 3)==3) /* final */
      fsm[cid].brout_valid = (fsm[cid].brout_valid &~(1LL<<i)) | (fsm[cid].tr_valid & (1LL<<i));
a656 23

    for (i=0; i<EMAX_DEPTH; i++) {
      unit[cid][i].logical_stage = i; /* reset to default */
      unit[cid][i].cycle         = 0; /* reset to default */
      unit[cid][i].unit1_arbrk   = 0; /* reset to default */
      unit[cid][i].unit1_exec    = 0; /* reset to default */
      unit[cid][i].unit1_stop    = 0; /* reset to default */
      unit[cid][i].tr_valid      = 0; /* reset to default */
      unit[cid][i].unit2_exec    = 0; /* reset to default */
      unit[cid][i].unit2_stop    = 0; /* reset to default */
      unit[cid][i].brout_valid   = 0; /* reset to default */
      unit[cid][i].one_shot      = 0; /* reset to default */
    }

	unit1_stop_next = ((fsm[cid].unit1_arbrk &(1LL<<i))||(fsm[cid].unit1_stop                        &(1LL<<i))||(fsm[cid].unit2_stop&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))?(1LL<<i):0;
	unit1_exec_next = (                                    (fsm[cid].unit1_exec                        &(1LL<<i))||(fsm[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))?(1LL<<i):0;
	unit2_stop_next = ((                              0 )||(fsm[cid].unit1_stop                        &(1LL<<i))||(fsm[cid].unit2_stop&(1LL<<((i             )           ))))?(1LL<<i):0;
	unit2_exec_next = (                                    (fsm[cid].unit1_exec                        &(1LL<<i))||(fsm[cid].unit2_exec&(1LL<<((i             )           ))))?(1LL<<i):0;
        fsm[cid].unit1_stop = (fsm[cid].unit1_stop &~(1LL<<i)) |                    unit1_stop_next;
        fsm[cid].unit1_exec = (fsm[cid].unit1_exec &~(1LL<<i)) |(unit1_exec_next & ~unit1_stop_next);
        fsm[cid].unit2_stop = (fsm[cid].unit2_stop &~(1LL<<i)) |                    unit2_stop_next;
        fsm[cid].unit2_exec = (fsm[cid].unit2_exec &~(1LL<<i)) |(unit2_exec_next & ~unit2_stop_next);

a668 130
siml_unit_cex(cid, i, j) Uint cid, i, j; /* reg更新がないので最初に実行 */
{
  Ull c3, c2, c1, c0;
  Ushort pattern;
  Ull ex;

  /* c -> cexdr */
  switch (fsm[cid].status) {
  case STATUS_IDLE:
  case STATUS_CONF:
  case STATUS_SCON:
  case STATUS_LMMI:
  case STATUS_DRAIN:
  case STATUS_LOAD:
  case STATUS_REGV:
  case STATUS_START:
    return (0);
  case STATUS_EXEC:
    if ((fsm[cid].unit1_exec & (1LL<<i)) && (fsm[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
      c0      = unit[cid][i][j].c[0];
      c1      = unit[cid][i][j].c[1];
      c2      = unit[cid][i][j].c[2];
      c3      = unit[cid][i][j].c[3];
      pattern = unit[cid][i][j].conf.cdw1.cex_tab;
      cex(OP_CEXE, &ex, c3, c2, c1, c0, pattern);
      unit[cid][i][j].cexdr = ex;
    }
    return (0);
  case STATUS_TERM:
    return (0);
  }
}

siml_unit_exe(cid, i, j) Uint cid, i, j; /* 全bus計算後にreg更新 */
{
  Uint op_ex1, op_ex2, op_ex3;
  Ull  r1, r2, r3, r4, r5;
  Uint exp1, exp2, exp3;
  Ull  d;
  int retval;

  /* ex[123] -> exdr */
  switch (fsm[cid].status) {
  case STATUS_IDLE:
  case STATUS_CONF:
  case STATUS_SCON:
  case STATUS_LMMI:
  case STATUS_DRAIN:
  case STATUS_LOAD:
  case STATUS_REGV:
  case STATUS_START:
    return (0);
  case STATUS_EXEC:
    if ((fsm[cid].unit1_exec & (1LL<<i)) && (fsm[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
      op_ex1 = unit[cid][i][j].conf.cdw0.op1;
      op_ex2 = unit[cid][i][j].conf.cdw0.op2;
      op_ex3 = unit[cid][i][j].conf.cdw0.op3;
      r1     = (unit[cid][i][j].conf.cdw0.ex1s!=1 || !unit[cid][i][j].one_shot)
             ? unit[cid][i][j].ex1 : unit[cid][i][j].exdr; /* self_loop */
      r2     = unit[cid][i][j].ex2;
      r3     = unit[cid][i][j].ex3;
      r4     = unit[cid][i][j].conf.cdw0.e2is==0 ? unit[cid][i][j].conf.cdw3.e2imm
             : unit[cid][i][j].conf.cdw0.e2is==1 ? unit[cid][i][j].ex2
             :                                     unit[cid][i][j].ex3;
      r5     = unit[cid][i][j].conf.cdw0.e3is==0 ? unit[cid][i][j].conf.cdw0.e3imm
             :                                     unit[cid][i][j].ex3;
      exp1   = unit[cid][i][j].conf.cdw0.ex1exp;
      exp2   = unit[cid][i][j].conf.cdw0.ex2exp;
      exp3   = unit[cid][i][j].conf.cdw0.ex3exp;
      retval = exe(op_ex1, &d, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5);
      unit[cid][i][j].exdr = d;

      fsm[cid].unit1_arbrk |= ((Ull)retval<<i);
    }
    return (0);
  case STATUS_TERM:
    return (0);
  }
}

siml_unit_eas(cid, i, j) Uint cid, i, j; /* 全bus計算後にreg更新 */
{
  Ull base0, offs0;
  Ull base1, offs1;

  /* ea[01][bo] -> ea[01]dr,ma */
  switch (fsm[cid].status) {
  case STATUS_IDLE:
  case STATUS_CONF:
  case STATUS_SCON:
  case STATUS_LMMI:
  case STATUS_DRAIN: /* fsm drain */
  case STATUS_LOAD: /* fsm pload */
    return (0);
  case STATUS_REGV:
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].unit1_eneq  = 0; /* reset */
#endif
  case STATUS_START:
    return (0);
  case STATUS_EXEC:
    base0 = (!(unit[cid][i][j].conf.cdw1.ea0bs&1) || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
    offs0 = (!(unit[cid][i][j].conf.cdw1.ea0bs&1) ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ || unit[cid][i][j].conf.cdw1.ea1op == OP_TR) {
#ifndef IGNORE_LDDMQ_HANDSHAKE
      base1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) || !unit[cid][i][j].one_shot_a)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
      offs1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) ||  unit[cid][i][j].one_shot_a)?unit[cid][i][j].ea1o:0LL;
#endif
    }
    else if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_BUFRD) {
#ifndef IGNORE_LDDMQ_HANDSHAKE
      base1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) || !unit[cid][i][j].one_shot_d)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
      offs1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) ||  unit[cid][i][j].one_shot_d)?unit[cid][i][j].ea1o:0LL;
#endif
    }
    else {
      base1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
      offs1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
    }
    eag(&unit[cid][i][j].ea0d, base0, offs0, unit[cid][i][j].conf.cdw1.ea0msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
    eag(&unit[cid][i][j].ea1d, base1, offs1, unit[cid][i][j].conf.cdw1.ea1msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].unit1_eneq = (unit[cid][i][j].ea1d != unit[cid][i][j].ea0d);
#endif
    return (0);
  case STATUS_TERM:
    return (0);
  }
}

a782 11
    else if (unit[cid][i][j].conf.cdw1.ea0op == OP_TR) { /* write */
      if (((fsm[cid].unit1_exec & (1LL<<i)) && (fsm[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))
	  && (unit[cid][i][j].cexdr&1)) { /* active */
	unit[cid][i][j].ea0dr   = unit[cid][i][j].ea0d;
	unit[cid][i][j].lmm.en0 = 1;
	unit[cid][i][j].lmm.rw0 = (unit[cid][i][j].conf.cdw1.ea0op & 0x10)!=0; /* read/write */
	unit[cid][i][j].lmm.ma0 = (unit[cid][i][j].ea0dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
      }
      else  /* inactive */
	unit[cid][i][j].lmm.en0 = 0;
    }
@


1.218
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.217 2017/04/28 04:09:45 nakashim Exp nakashim $";
a16 2
/*#undef FEATURE_SHIFT_CONF*/
#define FEATURE_SHIFT_CONF
d19 18
a36 7
  Ull   unit1_arbrk;   /* loop最終命令の実行完了を表示 */
  Ull   unit1_exec;    /* 次の動作を指示 (cex,exe,eag), 0:wait 1:exec */
  Ull   unit1_stop;    /* 次の動作を指示 (cex,exe,eag), 0:wait 1:stop */
  Ull   tr_valid;      /* TRの状態を表示 */
  Ull   unit2_exec;    /* 次の動作を指示 (lmm),         0:wait 1:exec */
  Ull   unit2_stop;    /* 次の動作を指示 (lmm),         0:wait 1:stop */
  Ull   brout_valid;   /* BRの状態を表示 常時tr_validを1τ後に伝搬 */
d38 1
d42 2
a43 1
  Ull   addr         :31;  /* reg/lmm */
d52 11
a62 10
  Ull         logical_stage   ; /* 0..63 */
  Ull         cycle           ; /* br[0]/br[1] is switched for every 4 cycles */
  struct conf conf[EMAX_WIDTH];
  Ull         br[2][EMAX_WIDTH][UNIT_WIDTH]; /* bottom-breg */
  Ull         ea0br[EMAX_WIDTH]; /* 18bits */
  Ull         ea0or[EMAX_WIDTH]; /* 18bits */
  Ull         ea1br[EMAX_WIDTH]; /* 18bits */
  Ull         ea1or[EMAX_WIDTH]; /* 18bits */
  Ull         top[EMAX_WIDTH];   /* 31bits *//* LMM-top virtual-address */
  Ull         bot[EMAX_WIDTH];   /* 31bits *//* LMM-bot virtual-address */
d64 1
a64 2
  Ull   one_shot     : 1;  /* reg  *//* for self_loop_control 0:init 1:self_loop */
  Uchar c[UNIT_WIDTH]   ;  /* wire */
a86 1
  Ull   t[UNIT_WIDTH]   ;  /* wire */
d137 3
d142 5
a146 2
emax6_ctl_reg(tid, type, opcd, addr, mask, val, rob)
     Uint tid, type, opcd, addr; Ull *mask; Ull *val; struct rob *rob;
d148 4
d159 66
d230 2
a231 2
siml_emax6(tid, pa_cycle, tic, trace, trace_pipe, base, dma_ctrl, reg_ctrl)
     Uint tid; Ull pa_cycle; int tic; Uint trace, trace_pipe; char *base; struct dma_ctrl *dma_ctrl; struct reg_ctrl *reg_ctrl;
d233 1
a233 3
  /* mode=1:normal_array, 2:drain_dirty_lmm */
  Uint cid = tid2cid(tid);
  int i, j, k, mark, sync, total;
a234 1
  Ull *conf_p, *lmmi_p, *regv_p, *load_p;
d236 5
a240 2
  if (pa_cycle % ARM_EMAX6_RATIO) /* ARM:2.4GHz EMAX6:240MHz */
    return (2); /* busy */
d242 3
a244 76
  while (tic-- > 0) {
    Ull unit1_stop_next, unit1_exec_next, unit2_stop_next, unit2_exec_next;
    /*******************************************************/
    /******************* unit siml start *******************/
    /*******************************************************/
    siml_axiif(cid, trace, base);
    for (i=(fsm[cid].last_row0+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
      siml_unit_bus1(cid, i); /* c,t,ex,ea */
      siml_unit_bus2(cid, i); /* lmw,lmr */
      for (j=EMAX_WIDTH-1; j>=0; j--) /* for each unit */
        siml_unit_lmm(cid, i, j); /* lmm */
      fsm[cid].unit1_arbrk &= ~(1LL<<i); /* reset arbrk */
      if (i==(fsm[cid].last_row0+EMAX_DEPTH-1)%EMAX_DEPTH)
	fsm[cid].brout_valid = (fsm[cid].brout_valid &~(1LL<<i)) | (1LL<<i); /* 最終brout_validは常時1 */
      else
	fsm[cid].brout_valid = (fsm[cid].brout_valid &~(1LL<<i)) | (fsm[cid].tr_valid & (1LL<<i));
      for (j=EMAX_WIDTH-1; j>=0; j--) { /* for each unit */
        /**************************/
        /****** do exe ************/
        /**************************/
        siml_unit_cex(cid, i, j); /* cexdr */
        siml_unit_exe(cid, i, j); /* exdr    (unit1_arbrk) */
        siml_unit_eas(cid, i, j); /* eadr,ma (eneq) */
      }
      for (j=EMAX_WIDTH-1; j>=0; j--) /* for each unit */
        siml_unit_ead(cid, i, j); /* unit2_guard,unit2_lmbrk */
      for (j=EMAX_WIDTH-1; j>=0; j--) /* for each unit */
        siml_unit_trg(cid, i, j); /* tr,mw */
      /* 自stage:stop=1と同時に自stage:exec=0 次cycleから実行停止 */
      switch (fsm[cid].status) {
      case STATUS_REGV:
        fsm[cid].unit1_stop  &= ~(1LL<<i);
        fsm[cid].tr_valid    &= ~(1LL<<i);
        fsm[cid].unit2_stop  &= ~(1LL<<i);
        fsm[cid].brout_valid &= ~(1LL<<i);
        break;
      case STATUS_START:
        fsm[cid].unit1_exec  = fsm[cid].row_select;
        break;
      case STATUS_EXEC:
	unit1_stop_next = ((fsm[cid].unit1_arbrk &(1LL<<i))||(fsm[cid].unit1_stop                        &(1LL<<i))||(fsm[cid].unit2_stop&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))?(1LL<<i):0;
	unit1_exec_next = (                                    (fsm[cid].unit1_exec                        &(1LL<<i))||(fsm[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))?(1LL<<i):0;
	unit2_stop_next = ((                              0 )||(fsm[cid].unit1_stop                        &(1LL<<i))||(fsm[cid].unit2_stop&(1LL<<((i             )           ))))?(1LL<<i):0;
	unit2_exec_next = (                                    (fsm[cid].unit1_exec                        &(1LL<<i))||(fsm[cid].unit2_exec&(1LL<<((i             )           ))))?(1LL<<i):0;
        fsm[cid].unit1_stop = (fsm[cid].unit1_stop &~(1LL<<i)) |                    unit1_stop_next;
        fsm[cid].unit1_exec = (fsm[cid].unit1_exec &~(1LL<<i)) |(unit1_exec_next & ~unit1_stop_next);
        fsm[cid].unit2_stop = (fsm[cid].unit2_stop &~(1LL<<i)) |                    unit2_stop_next;
        fsm[cid].unit2_exec = (fsm[cid].unit2_exec &~(1LL<<i)) |(unit2_exec_next & ~unit2_stop_next);
        break;
      }
      if (i==fsm[cid].last_row0)
        break;
    }
    /*******************************************************/
    /******************* unit siml end *********************/
    /*******************************************************/

    /*******************************************************/
    /******************* FSM siml start ********************/
    /*******************************************************/
    switch (fsm[cid].status) {
    case STATUS_SCON:
      for (j=0; j<EMAX_WIDTH; j++) {
	/* row_countでシフト数制御, row_selectで 0:conf->BR, 1:BR->conf 切替え */
	if (fsm[cid].fsm[j].row_count < fsm[cid].last_dist) { /* last_dist > 0 */
	  if (!(fsm[cid].row_select&1))  /* 1回早くインクリメントし終了タイミングを合わせる */
	    fsm[cid].row_count++;
	  fsm[cid].fsm[j].row_select  = ~fsm[cid].row_select; /* STAT_SCON2回目からall-1 */
	}
	else { /* row_count*2サイクルシフトして終了 */
	  fsm[cid].status = STATUS_LMMI;
	  fsm[cid].memif_status = MEMIF_AREQ;
	  fsm[cid].row_count    = 0LL;
	  fsm[cid].row_select   = 0LL;
	}
      }
d246 11
a256 9
    case STATUS_START:
      fsm[cid].status = STATUS_EXEC;
      for (j=0; j<EMAX_WIDTH; j++) {
	fsm[cid].fsm[j].memif_status = MEMIF_AREQ;
	fsm[cid].fsm[j].row_count    = 0;
	fsm[cid].fsm[j].row_select   = 0LL;
	fsm[cid].fsm[j].axi_first_read = 1; /* simulate pipelined AXI for LDDMQ (1->0) */
	                                      /* same as one_shot */
      }
a257 33
    case STATUS_TERM:
      printf(" EMAX_TERM(%08.8x_%08.8x) retv=%d", (Uint)(pa_cycle>>32), (Uint)pa_cycle, fsm[cid].retval);
      if (trace)
	printf("\n");
      if (mode==1) { /* normal array */
	fsm[cid].last_conf = conf;
	fsm[cid].last_dist = fsm[cid].fsm[0].last_dist;
	fsm[cid].last_row0 = (fsm[cid].last_row0+fsm[cid].last_dist)%EMAX_DEPTH;
      }
      fsm[cid].v = 0; /* unlock */
      fsm[cid].status = STATUS_IDLE;
      for (j=0; j<EMAX_WIDTH; j++) {
	for (i=0; i<EMAX_DEPTH; i++) {
	  if (unit[cid][i][j].drty) fsm[cid].fsm[j].lmmd[i] = 1; /* mark dirty */
	}
	fsm[cid].fsm[j].memif_status = MEMIF_AREQ;
	fsm[cid].fsm[j].row_count    = 0;
	fsm[cid].fsm[j].row_select   = 0LL;
      }
      tic = -1;
      break; /* EMAX6 finished */
    }
    if (trace)
      printf("%03.3d:siml_emax6: final arbrk=%08.8x 1exec=%08.8x_%08.8x 1stop=%08.8x trval=%08.8x 2exec=%08.8x_%08.8x 2stop=%08.8x brout=%08.8x\n",
	     tid,
	     (Uint)fsm[cid].unit1_arbrk,   (Uint)(fsm[cid].unit1_exec>>32), (Uint)fsm[cid].unit1_exec, (Uint)fsm[cid].unit1_stop,
	     (Uint)fsm[cid].tr_valid, (Uint)(fsm[cid].unit2_exec>>32), (Uint)fsm[cid].unit2_exec, (Uint)fsm[cid].unit2_stop,
	     (Uint)fsm[cid].brout_valid);
    /*******************************************************/
    /******************* FSM siml end **********************/
    /*******************************************************/
    if (trace && trace_pipe)
      show_emax6_status(cid);
d259 20
a278 4
  if (tic < -1)
    return (fsm[cid].retval); /* EMAX6 finished 0:normal with transaction, 1:normal with lmm_dirty */
  else
    return (2); /* EMAX6 busy */
d281 1
a281 1
siml_axiif(cid, trace, base) Uint cid, trace; char *base;
a282 1
  int tid = fsm[cid].tid;
d285 37
a321 5
  /* pseudo for resetting arready and awready */
  if (fsm[cid].status==STATUS_IDLE) {
    for (j=EMAX_WIDTH-1; j>=0; j--) { /* for each column */
      fsm[cid].fsm[j].axi_arready = 1; /* reset read */
      fsm[cid].fsm[j].axi_awready = 1; /* reset write */
d324 7
a330 41

#define EMAX6_LDDMQ_MUX 8
  for (j=EMAX_WIDTH-1; j>=0; j--) { /* for each column */
    /* start read/write */
    if (fsm[cid].fsm[j].axi_arready && fsm[cid].fsm[j].axi_arvalid) { /* new read_req starts */
      fsm[cid].fsm[j].axi_arready = 0; /* start read */
      fsm[cid].fsm[j].iaddr = fsm[cid].fsm[j].axi_araddr; /* start read */
      fsm[cid].fsm[j].ilen  = 0;                            /* start read (unit is multople of 64bits) */
      if (fsm[cid].fsm[j].axi_arlen == 0) {
	if (!fsm[cid].fsm[j].axi_first_read) /* LDDMQ is assumed to be multiplexed */
	  fsm[cid].fsm[j].idelay= MMDELAY/ARM_EMAX6_RATIO/EMAX6_LDDMQ_MUX; /* pipelined read */
	else {
	  fsm[cid].fsm[j].idelay= MMDELAY/ARM_EMAX6_RATIO;                 /* sequential read */
	  fsm[cid].fsm[j].axi_first_read = 0;
	}
      }
      else
	fsm[cid].fsm[j].idelay= MMDELAY/ARM_EMAX6_RATIO;                 /* sequential read */
      if (trace)
	printf("%03.3d:siml_axiif: read col=%d start araddr=%08.8x_%08.8x arlen=%08.8x_%08.8x\n",
	       tid, j, (Uint)(fsm[cid].fsm[j].axi_araddr>>32), (Uint)fsm[cid].fsm[j].axi_araddr, (Uint)(fsm[cid].fsm[j].axi_arlen>>32), (Uint)fsm[cid].fsm[j].axi_arlen);
    }
    else if (fsm[cid].fsm[j].axi_awready && fsm[cid].fsm[j].axi_awvalid) { /* new write_req starts */
      fsm[cid].fsm[j].axi_awready = 0; /* start write */
      fsm[cid].fsm[j].iaddr = fsm[cid].fsm[j].axi_awaddr; /* start write */
      fsm[cid].fsm[j].ilen  = 0;                            /* start write (unit is multople of 64bits) */
      fsm[cid].fsm[j].idelay= 0;                            /* start write */
      if (trace)
	printf("%03.3d:siml_axiif: write col=%d start awaddr=%08.8x_%08.8x awlen=%08.8x_%08.8x\n",
	       tid, j, (Uint)(fsm[cid].fsm[j].axi_awaddr>>32), (Uint)fsm[cid].fsm[j].axi_awaddr, (Uint)(fsm[cid].fsm[j].axi_awlen>>32), (Uint)fsm[cid].fsm[j].axi_awlen);
    }
    /* exec_length: max 64bit*1024count = 8KB */
    /* burst read:  max 256bit*256count = 8KB */
    /*                     256bit_AXI_read   -> 256bit_LMM */
    /*  lmmi.top -> axira  top(256bit align) -> mask       */
    /*  lmmi.len -> axirl  len(256bit align) -> mask       */
    else if (!fsm[cid].fsm[j].axi_arready) {
      if (fsm[cid].fsm[j].idelay)
	fsm[cid].fsm[j].idelay--;
      else if (fsm[cid].fsm[j].ilen <= fsm[cid].fsm[j].axi_arlen) {
	fsm[cid].fsm[j].axi_rvalid = 1;
d332 6
a337 30
	  Ull a = fsm[cid].fsm[j].iaddr + sizeof(Ull)*(fsm[cid].fsm[j].ilen*UNIT_WIDTH+k);
	  fsm[cid].fsm[j].axi_rdata[k] = *(Ull*)(base + a);
	  if (trace)
	    printf("%03.3d:siml_axiif: read col=%d iaddr=%08.8x_%08.8x rdata[%d]=%08.8x_%08.8x\n",
		   tid, j, (Uint)(a>>32), (Uint)a, k, (Uint)(fsm[cid].fsm[j].axi_rdata[k]>>32), (Uint)fsm[cid].fsm[j].axi_rdata[k]);
	}
	fsm[cid].fsm[j].ilen++;
      }
      else {
	fsm[cid].fsm[j].axi_rvalid = 0;
	fsm[cid].fsm[j].axi_arready = 1;
      }
    }
    /* burst write */
    /*                            256bit_LMM ->  256iAXI_write          */
    /*  lmmi.top -> lmra (align)  mask       ->  WSTRBtop(256bit align) */
    /*  lmmi.len -> rrdyc(align)                 256bit align           */
    else if (!fsm[cid].fsm[j].axi_awready) {
      if (fsm[cid].fsm[j].idelay)
	fsm[cid].fsm[j].idelay--;
      else if (fsm[cid].fsm[j].ilen <= fsm[cid].fsm[j].axi_awlen) {
	if (fsm[cid].fsm[j].axi_wvalid) {
	  for (k=0; k<UNIT_WIDTH; k++) { /* 32B aligned */
	    if (fsm[cid].fsm[j].axi_wstrb & (0xff<<(k*8))) {
	      Ull a = fsm[cid].fsm[j].iaddr + sizeof(Ull)*(fsm[cid].fsm[j].ilen*UNIT_WIDTH+k);
	      *(Ull*)(base + a) = fsm[cid].fsm[j].axi_wdata[k];
	      if (trace)
		printf("%03.3d:siml_axiif: write col=%d iaddr=%08.8x_%08.8x wdata[%d]=%08.8x_%08.8x\n",
		       tid, j, (Uint)(a>>32), (Uint)a, k, (Uint)(fsm[cid].fsm[j].axi_wdata[k]>>32), (Uint)fsm[cid].fsm[j].axi_wdata[k]);
	    }
a338 1
	  fsm[cid].fsm[j].ilen++;
d340 1
d342 3
a344 3
      else {
	fsm[cid].fsm[j].axi_awready = 1;
      }
d349 1
a349 1
siml_unit_bus1(cid, i) Uint cid, i; /* 演算器入力までを計算 */
a350 1
  int j, k, s;
d352 3
d357 16
a372 14
  for (j=0; j<EMAX_WIDTH; j++) { /* 0:br0_0, 1:br0_1, ... 15:3_3 */
    s = unit[cid][i][j].conf.cdw1.cs0;    unit[cid][i][j].c[0] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;
    s = unit[cid][i][j].conf.cdw1.cs1;    unit[cid][i][j].c[1] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;
    s = unit[cid][i][j].conf.cdw1.cs2;    unit[cid][i][j].c[2] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;
    s = unit[cid][i][j].conf.cdw1.cs3;    unit[cid][i][j].c[3] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;

    s = unit[cid][i][j].conf.cdw2.ts0;    unit[cid][i][j].t[0] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw2.ts1;    unit[cid][i][j].t[1] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw2.ts2;    unit[cid][i][j].t[2] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw2.ts3;    unit[cid][i][j].t[3] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];

    s = unit[cid][i][j].conf.cdw0.ex1brs; unit[cid][i][j].ex1  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw0.ex2brs; unit[cid][i][j].ex2  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw0.ex3brs; unit[cid][i][j].ex3  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
d374 2
a375 2
    s = unit[cid][i][j].conf.cdw1.eabbrs; unit[cid][i][j].eab  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw1.eaobrs; unit[cid][i][j].eao  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
d377 2
a378 2
    s = unit[cid][i][j].conf.cdw1.ea0bs;  unit[cid][i][j].ea0b = (s&2)?unit[cid][i][j].eab:unit[cid][i][j].regv.ea0br;
    s = unit[cid][i][j].conf.cdw1.ea0os;  unit[cid][i][j].ea0o = (s&1)?unit[cid][i][j].eao:unit[cid][i][j].regv.ea0or;
d380 20
a399 2
    s = unit[cid][i][j].conf.cdw1.ea1bs;  unit[cid][i][j].ea1b = (s&2)?unit[cid][i][j].eab:unit[cid][i][j].regv.ea1br;
    s = unit[cid][i][j].conf.cdw1.ea1os;  unit[cid][i][j].ea1o = (s&1)?unit[cid][i][j].eao:unit[cid][i][j].regv.ea1or;
d401 44
a998 1
	/*fsm[cid].fsm[j].lmmd[i] = 1; /* mark dirty */
d1098 1
a1098 1
      printf("|\033[1;%dmd%d v%d rw%d f%d p%d b%d l%08.8x b%01.1x c%d top%08.8x%08.8x\033[0m",
a1099 1
             (Uint) fsm[cid].fsm[col].lmmd[row],
d1113 1
a1113 1
      printf("|\033[1;%dmd%d v%d rw%d f%d p%d b%d l%08.8x b%01.1x c%d top%08.8x%08.8x\033[0m",
a1114 1
             (Uint) fsm[cid].fsm[col].lmmd[row],
@


1.217
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax6.c,v 1.216 2017/04/21 03:29:27 nakashim Exp nakashim $";
d4 1
a4 1
/* EMAX5 Simulator                     */
d9 1
a9 1
/* emax5.c 2012/9/22 */
d20 1
a20 13
enum { FSM_IDLE,    FSM_CONF,    FSM_LMMI,    FSM_DRAIN,    FSM_LOAD,    FSM_REGV,    FSM_START,    FSM_EXEC,    FSM_TERM };
enum { MEMIF_IDLE,  MEMIF_AREQ,  MEMIF_DREQ,  MEMIF_TERM };

struct emax5 { /* lmm status of EMAX5 */
  Ull   v                 : 1; /* 0:empty, 1:unuse */
  Ull   tid               :12; /* owner thread of EMAX */
  Ull   mode              : 2; /* 1:normal array, 2:drain_dirty_lmm */
  Ull   status            : 4;
  Ull   retval            : 2; /* 0:normal_end, 1:require L2$invalidation, 2:busy */
  Ull   last_conf            ; /* for insn_reuse */
  Ull   last_dist         : 6; /* latest map_dist */
  Ull   last_row0         : 6; /* physical top of logical unit[][0] */

a24 7
#ifndef IGNORE_LDDMQ_HANDSHAKE
  Ull   unit2_eag_aen; /* for LDDMQ    lmm->addr */
  Ull   unit2_eag_den; /* for IM_BUFRD lmm->data */
  Ull   unit2_guard;   /* LDDMQ位置に1 (gnore unit1_stop) */
  Ull   unit2_lmbrk;   /* lmm finish */
  Ull   unit2_lmbusy;  /* unit1_exec|fsm_busy|eneq */
#endif
d29 22
a50 84
  Uint  cycles_tinit_part;
  Uint  cycles_conf_part;
  Uint  cycles_scon_part;
  Uint  cycles_lmmi_part;
  Uint  cycles_drain_part;
  Uint  cycles_load_part;
  Uint  cycles_regv_part;
  Uint  cycles_start_part;
  Uint  cycles_exec_part;
  Uint  cycles_term_part;
  Uint  cycles_trans_part;
  Ull   cycles_tinit;
  Ull   cycles_conf;
  Ull   cycles_scon;
  Ull   cycles_lmmi;
  Ull   cycles_drain;
  Ull   cycles_load;
  Ull   cycles_regv;
  Ull   cycles_start;
  Ull   cycles_exec;
  Ull   cycles_term;
  Ull   cycles_trans;
                                /* dirtyが残っている場合,lmmiの前にdrain               */
                                /*  conf  | drain | load | lmmi | regv | exec        | */
                                /*        |       |             |      | pload       | */
                                /* 残っていない場合,execと同時にdrain開始              */
                                /*  conf  |       |      | lmmi | regv | exec        | */
                                /*                       |      |      | drain pload | */

                                /* 1 :conf  fsm_way毎に,last_row0から順にEMAX本体に格納                */
                                /*          4wayが全て完了するまで待機                                 */
                                /* 2 :lmmi  fsm_way毎に,fsm内部のlmmiへ読み込み                        */
                                /*          4wayが全て完了するまで待機                                 */
                                /*(3):drain fsm_way毎に,lmmoにdirtyがあるか検査                        */
                                /*          dirtyは,fsm_way毎にdrain                                   */
                                /*          4wayが全て完了するまで待機                                 */
                                /*(4):load  fsm_way毎に,lmmiにpreload以外の未loadLMMがあるか検査       */
                                /*          未loadLMMが存在する場合,fsm_way毎にload                    */
                                /*          4wayが全て完了するまで待機                                 */
                                /* 5 :regv  全fsm_wayに,start準備をセット                              */
                                /*          4wayが全て完了するまで待機                                 */
                                /* 6 :start 全fsm_wayに,startをセット                                  */
                                /* 7 :exec  全fsm_wayのlast_row0にflag=1をセット.EMAX5起動             */
                                /*          4wayが全て完了するまで待機                                 */
                                /*          この間,各fsm_wayは全lmmiに未drainがあるか検査              */
                                /*          未drainが存在する場合,fsm_way毎に,last_row0から順にdrain   */
                                /*          drain後,pload開始(drain+ploadは，EMAX5の演算動作と同時)    */
                                /*          EMAX5動作と全fsmのdrain/pload動作完了をもって,8:termへ遷移 */

  struct fsm {                 /* load/drainは,複数rowを同時動作 */
    struct lmmi lmmo[EMAX_DEPTH]; /* previous lmmi */
    struct lmmi lmmc[EMAX_DEPTH]; /* current lmmi */
    Uchar       lmmd[EMAX_DEPTH]; /* 0:clean, 1:dirty,   exec後store箇所に1, drain直後0 */

    Ull   memif_status       : 4;
    Ull   last_dist          : 6; /* latest map_dist */
    Ull   row_count          : 8; /* valid row counter is 6bit */
    Ull   row_select         :64; /* bitmap 0:off 1:selected */
    Ull   row_lmm_en         :64; /* lmm enable for read/write */

#ifndef IGNORE_LMMI_BLKGATHER
    Ull   blkstat            : 1; /* 0:PTRLIST 1:VERTEXLIST */
    Ull   blkcount           : 7; /* active block number */
    Ull   blksize            : 9; /* 1:64 2:128 3:256 dwords */
    Ull   blktop[UNIT_WIDTH]    ; /* block address */
    Ull   lmmblktop             ; /* LMM-addr     for LDRQ(blk>0) */
    Ull   lmmblklen             ; /* total dwords for LDRQ(blk>0) */
#endif

    Uint  ardyc                 ; /* LMM addr-ready(read)                                               */
    Uint  rrdyc                 ; /* LMM data-ready(read), AXI data-ready(rvalid) counter               */
                                  /*                         CF  RV  LI  PF  DR  TR  DM                 */
    Ull   araddr                ; /* read-address  of mm      v   v   v   v           v                 */
    Ull   arlen                 ; /* read-length   of mm      v   v   v   v           1                 */
    Ull   awaddr                ; /* write-address of mm                      v                         */
    Ull   awlen                 ; /* write-length  of mm                      v                         */
    Ull   lmm_fmask          : 4; /* mask for first 32B-chunk                                           */
    Ull   lmm_lmask          : 4; /* mask for last  32B-chunk                                           */
    Ull   lmm_nreq              ; /* number of LMM cycles                                               */

    Ull   lmwa                  ; /* -> ea0dr                     v       v                             */
    Ull   lmwd[UNIT_WIDTH]      ; /* <- lmm wdata                 v       v           v                 */
    Ull   lmra                  ; /* -> ea1dr                                 v                         */
    Ull   lmrd[UNIT_WIDTH]      ; /* -> lmm rdata                             v   v                     */
a51 39
#ifndef IGNORE_LDDMQ_HANDSHAKE
    Ull   fsm_busy           : 1; /* for LDDMQ and TR */
    Ull   lmwd_valid         : 1; /* for LDDMQ */
    Ull   tcureg_valid       : 1; /* fsm->ARM   0 -> 1 -> 1 -> 0 -> 0 -> 0                              */
    Ull   tcureg_ready       : 1; /* fsm<-ARM   0 -> 0 -> 1 -> 0 -> 0 -> 0                              */
    Ull   tcureg_last        : 1; /* fsm->ARM   0 -> 0 -> 0 -> 1 -> 1 -> 0                              */
    Ull   tcureg_term        : 1; /* fsm<-ARM   0 -> 0 -> 0 -> 0 -> 1 -> 0                              */
    Ull   tcureg[UNIT_WIDTH]    ; /* tcu-data        of tcu                       v                     */
                                  /* from ARM:  svc 0x1010 ... tcureg_valid->x0                         */
                                  /* from ARM:  svc 0x1011 ... 1->tcureg_ready                          */
                                  /* from ARM:  svc 0x1012 ... tcureg_last->x0                          */
                                  /* from ARM:  svc 0x1013 ... 1->tcureg_term                           */
                                  /* from ARM:  svc 0x1014 ... tcureg[3:0]->x3,2,1,0                    */
#endif

    Ull   axi_arready        : 1; /* axi -> fsm                                                         */
    Ull   axi_arvalid        : 1; /* axi <- fsm                                                         */
    Ull   axi_first_read     : 1; /* simulate pipelined AXI (1->0) same as one_shot */
    Ull   axi_araddr            ; /* aligned-address of mm    v   v   v   v           v                 */
    Ull   axi_arlen             ; /* aligned-length  of mm    v   v   v   v           1                 */
    Ull   axi_rvalid         : 1; /* axi -> fsm read-ready                                              */
    Ull   axi_rdata[UNIT_WIDTH] ; /* read-data       of mm    v   v   v   v           v                 */
    Ull   axi_awready        : 1; /* axi -> fsm                                                         */
    Ull   axi_awvalid        : 1; /* axi -> fsm                                                         */
    Ull   axi_awaddr            ; /* aligned-address of mm                    v                         */
    Ull   axi_awlen             ; /* aligned-length  of mm                    v                         */
    Ull   axi_wstrb          :32; /* axi byte-enable for 32B                                            */
    Ull   axi_wvalid         : 1; /* fsm -> axi write-ready                                             */
    Ull   axi_wdata[UNIT_WIDTH] ; /* write-data      of mm                    v                         */

    Ull   iaddr                 ; /* fsm internal                                                       */
    Ull   ilen                  ; /* fsm internal                                                       */
    Ull   idelay                ; /* siml MEMORY delay (same as MMDELAY/RATIO)                          */
  } fsm[EMAX_WIDTH];
} emax5[MAXCORE];

struct unit { /* hardware status of EMAX5 units */
  struct conf conf;
  struct regv regv;        /* ea0br,ea0or,ea1br,ea1or,br[UNIT_WIDTH] */
d53 11
a63 11
#ifndef IGNORE_LDDMQ_HANDSHAKE
  Ull   one_shot_a   : 1;  /* reg (internal) *//* for self_loop_control 0:init 1:self_loop for LDDMQ    */
  Ull   one_shot_d   : 1;  /* reg (internal) *//* for self_loop_control 0:init 1:self_loop for LM_BUFRD */
  Ull   unit1_eneq   : 1;  /* wire(internal) *//* for detecting LMM has valid entry */
  Ull   lmwd_valid   : 1;  /* wire(from fsm) */
#endif
  Uchar c[UNIT_WIDTH];     /* wire */
  Ull   cexdr        : 2;  /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
  Ull   ex1             ;  /* wire *//* in for ALU */
  Ull   ex2             ;  /* wire *//* in for ALU */
  Ull   ex3             ;  /* wire *//* in for ALU */
d66 15
a80 13
  Ull   ea0b            ;  /* wire *//* in for EA0 */
  Ull   ea0o            ;  /* wire *//* in for EA0 */
  Ull   ea1b            ;  /* wire *//* in for EA1 */
  Ull   ea1o            ;  /* wire *//* in for EA1 */
  Ull   exdr            ;  /* reg  */
  Ull   ea0dr           ;  /* reg  */
  Ull   ea1dr           ;  /* reg  */
  Ull   ea0d            ;  /* wire */
  Ull   ea1d            ;  /* wire */

  Ull   lmen         : 1;  /* lmm enable for read/write */
  Ull   drty         : 1;  /* lmm mamrked as dirty */
  Ull   rrdy         : 1;  /* wire *//* LMM data-valid for FSM */
d86 2
a87 11

  Ull   lmria           ;  /* wire */
  Ull   lmroa           ;  /* wire */
  Ull   lmlia           ;  /* wire */
  Ull   lmloa           ;  /* wire */
  Ull   lmri[UNIT_WIDTH];  /* wire */
  Ull   lmro[UNIT_WIDTH];  /* wire */
  Ull   lmli[UNIT_WIDTH];  /* wire */
  Ull   lmlo[UNIT_WIDTH];  /* wire */
  Ull   t[UNIT_WIDTH];     /* wire */
  Ull   tr[UNIT_WIDTH];    /* reg  */
a104 25
} unit[MAXCORE][EMAX_DEPTH][EMAX_WIDTH];

/* TCU hardware */
enum { TCU_IDLE, TCU_BUSY };

#define MAX_TRANS_CBL 8
#define MAX_TRANS_REG 8

Uint next_tcu; /* tcb_entry for next tcb registration by trans_start() */
struct tcu { /* final information for EMAX5 hardware */
  Ull   status : 4;
  Ull   tcbid     ; /* 0:invalid, start address of trans */
  struct tconf tconf[TRANS_DEPTH]; /* copy of tconf[] */
  Uint  pc;                 /* program counter */
  Ull   reg[MAX_TRANS_REG]; /* r0-r7 for param/work */
} tcu[MAX_TRANS_CBL];

Ull get_tcureg_valid(cid, col) int cid, col;
{
#ifndef IGNORE_LDDMQ_HANDSHAKE
  return (emax5[cid].fsm[col].tcureg_valid);
#else
  return (0);
#endif
}
d106 26
a131 1
put_tcureg_ready(cid, col) int cid, col;
d133 1
a133 13
#ifndef IGNORE_LDDMQ_HANDSHAKE
  emax5[cid].fsm[col].tcureg_ready = 1;
#endif
}

Ull get_tcureg_last(cid, col) int cid, col;
{
#ifndef IGNORE_LDDMQ_HANDSHAKE
  return (emax5[cid].fsm[col].tcureg_last);
#else
  return (0);
#endif
}
d135 4
a138 5
put_tcureg_term(cid, col) int cid, col;
{
#ifndef IGNORE_LDDMQ_HANDSHAKE
  emax5[cid].fsm[col].tcureg_term = 1;
#endif
d141 2
a142 42
Ull get_tcureg(cid, col, n) int cid, col, n;
{
#ifndef IGNORE_LDDMQ_HANDSHAKE
  return (emax5[cid].fsm[col].tcureg[n]);
#else
  return (0);
#endif
}

/* TCU control */
siml_trans(tid, pa_cycle, tic, trace, trace_pipe, base, start, end, gr2) Uint tid; Ull pa_cycle; int tic; Uint trace, trace_pipe; Uchar *base; Ull start, end, gr2;
{
  Uint cid = tid2cid(tid);
  int i, j, k, a;

  emax5[cid].cycles_tinit_part = 0;

  for (i=0; i<MAX_TRANS_CBL; i++) {
    if (tcu[i].tcbid == start) {
      next_tcu = i;
      break;
    }
  }

  if (tcu[next_tcu].status != TCU_IDLE)
    return (2);

  /* new tcb is stored in tcu.next_tcb */
  tcu[next_tcu].tcbid = start;
  for (i=0; i<TRANS_DEPTH; i++)
    tcu[next_tcu].tconf[i] = *((struct tconf*)(base+start)+i);

  emax5[cid].cycles_tinit_part = sizeof(tconf)/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
  emax5[cid].cycles_tinit += emax5[cid].cycles_tinit_part;

  next_tcu = (next_tcu+1)%MAX_TRANS_CBL;

  return (0);
}

/* EMAX5 control */
//application -> emax5_start((Ull*)emax5_conf_x1, (Ull*)emax5_lmmi_x1, (Ull*)emax5_regv_x1);
d144 2
a145 2
siml_emax5(tid, pa_cycle, tic, trace, trace_pipe, base, conf, lmmi, regv, mode)
     Uint tid; Ull pa_cycle; int tic; Uint trace, trace_pipe; char *base; Ull conf, lmmi, regv; int mode;
d153 1
a153 4
  if (emax5[cid].v && emax5[cid].tid != tid)
    return (2); /* busy */

  if (pa_cycle % ARM_EMAX5_RATIO) /* ARM:2.4GHz EMAX5:240MHz */
a155 14
  if (emax5[cid].status == STATUS_IDLE) {
    emax5[cid].v = 1; /* lock */
    emax5[cid].tid = tid;
    emax5[cid].cycles_conf_part  = 0;
    emax5[cid].cycles_scon_part  = 0;
    emax5[cid].cycles_lmmi_part  = 0;
    emax5[cid].cycles_drain_part = 0;
    emax5[cid].cycles_load_part  = 0;
    emax5[cid].cycles_regv_part  = 0;
    emax5[cid].cycles_start_part = 0;
    emax5[cid].cycles_exec_part  = 0;
    emax5[cid].cycles_term_part  = 0;
    emax5[cid].cycles_trans_part = 0;
  }
d162 1
a162 1
    for (i=(emax5[cid].last_row0+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
d167 3
a169 7
      emax5[cid].unit1_arbrk &= ~(1LL<<i); /* reset arbrk */
#ifndef IGNORE_LDDMQ_HANDSHAKE
      emax5[cid].unit2_guard &= ~(1LL<<i); /* reset guard */
      emax5[cid].unit2_lmbrk &= ~(1LL<<i); /* reset lmbrk */
#endif
      if (i==(emax5[cid].last_row0+EMAX_DEPTH-1)%EMAX_DEPTH)
	emax5[cid].brout_valid = (emax5[cid].brout_valid &~(1LL<<i)) | (1LL<<i); /* 最終brout_validは常時1 */
d171 1
a171 1
	emax5[cid].brout_valid = (emax5[cid].brout_valid &~(1LL<<i)) | (emax5[cid].tr_valid & (1LL<<i));
a179 1
      siml_unit_bus3(cid, i); /* unit2_eag_aen,unit2_eag_den */
a183 1
      siml_unit_bus4(cid, i); /* tr_valid */
d185 1
a185 1
      switch (emax5[cid].status) {
d187 4
a190 4
        emax5[cid].unit1_stop  &= ~(1LL<<i);
        emax5[cid].tr_valid    &= ~(1LL<<i);
        emax5[cid].unit2_stop  &= ~(1LL<<i);
        emax5[cid].brout_valid &= ~(1LL<<i);
d193 1
a193 1
        emax5[cid].unit1_exec  = emax5[cid].fsm[0].row_select;
d196 8
a203 12
	unit1_stop_next = ((emax5[cid].unit1_arbrk &(1LL<<i))||(emax5[cid].unit1_stop                        &(1LL<<i))||(emax5[cid].unit2_stop&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))?(1LL<<i):0;
	unit1_exec_next = (                                    (emax5[cid].unit1_exec                        &(1LL<<i))||(emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))?(1LL<<i):0;
#ifndef IGNORE_LDDMQ_HANDSHAKE
	unit2_stop_next = ((emax5[cid].unit2_lmbrk &(1LL<<i))||(emax5[cid].unit1_stop&~emax5[cid].unit2_guard&(1LL<<i))||(emax5[cid].unit2_stop&(1LL<<((i             )           ))))?(1LL<<i):0;
#else
	unit2_stop_next = ((                              0 )||(emax5[cid].unit1_stop                        &(1LL<<i))||(emax5[cid].unit2_stop&(1LL<<((i             )           ))))?(1LL<<i):0;
#endif
	unit2_exec_next = (                                    (emax5[cid].unit1_exec                        &(1LL<<i))||(emax5[cid].unit2_exec&(1LL<<((i             )           ))))?(1LL<<i):0;
        emax5[cid].unit1_stop = (emax5[cid].unit1_stop &~(1LL<<i)) |                    unit1_stop_next;
        emax5[cid].unit1_exec = (emax5[cid].unit1_exec &~(1LL<<i)) |(unit1_exec_next & ~unit1_stop_next);
        emax5[cid].unit2_stop = (emax5[cid].unit2_stop &~(1LL<<i)) |                    unit2_stop_next;
        emax5[cid].unit2_exec = (emax5[cid].unit2_exec &~(1LL<<i)) |(unit2_exec_next & ~unit2_stop_next);
d206 1
a206 1
      if (i==emax5[cid].last_row0)
a214 1
    /******** 全unit 1cycle動作後,FSMは次のcmdを用意 *******/
d216 1
a216 75
    switch (emax5[cid].status) {
    case STATUS_IDLE:
      if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
	printf("\n");
	if ((fp_conf = fopen("conf.dat", "w"))==NULL) {
	  printf(" cannot open conf.dat for DUMP_DDR\n");
	  exit(1);
	}
	if ((fp_lmmi = fopen("lmmi.dat", "w"))==NULL) {
	  printf(" cannot open lmmi.dat for DUMP_DDR\n");
	  exit(1);
	}
	if ((fp_regv = fopen("regv.dat", "w"))==NULL) {
	  printf(" cannot open regv.dat for DUMP_DDR\n");
	  exit(1);
	}
	if ((fp_load = fopen("load.dat", "w"))==NULL) {
	  printf(" cannot open load.dat for DUMP_DDR\n");
	  exit(1);
	}
      }
      printf(" EMAX_START(%08.8x_%08.8x)", (Uint)(pa_cycle>>32), (Uint)pa_cycle);
      if (trace || ((flag & DUMP_DDR) && !dump_ddr_done)) /* dump once */
	printf("\n");
      if (mode==2) { /* drain_dirty_lmm */
        if (trace)
          printf("%03.3d:siml_emax5: drain_dirty_lmm start\n", tid);
        emax5[cid].status = STATUS_DRAIN;
      }
      else if (emax5[cid].last_conf != conf) {
        if (trace)
          printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (load)\n", tid, (Uint)(conf>>32), (Uint)conf);
        emax5[cid].status = STATUS_CONF;
      }
      else if (emax5[cid].last_dist > 0) {
#ifdef FEATURE_SHIFT_CONF
        if (trace)
          printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (shift)\n", tid, (Uint)(conf>>32), (Uint)conf);
        emax5[cid].status = STATUS_SCON;
#else
        if (trace)
          printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (load)\n", tid, (Uint)(conf>>32), (Uint)conf);
        emax5[cid].status = STATUS_CONF;
#endif
      }
      else {
        if (trace)
          printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (reuse)\n", tid, (Uint)(conf>>32), (Uint)conf);
        emax5[cid].status = STATUS_LMMI;
      }
      {
	int found = 0;
	for (j=0; j<EMAX_WIDTH; j++) {
	  for (i=0; i<EMAX_DEPTH; i++) {
	    /* transaction有りと,lmm_dirty有りは,1つのEMAXカーネルでは混在禁止とする */
	    /* START時にlmm_dirtyがある場合,次のEXECにて主記憶を更新する.            */
	    /*   transactionはないものとし,EMAX実行から復帰時に,L2$を無効化する      */
	    /* START時にlmm_dirtyがない場合,transactionのみが含まれると考える.       */
	    /*   transactionがある場合,L1$とL2$は使用されているためL2$は無効化しない */
	    if (emax5[cid].fsm[j].lmmd[i]) /* mark dirty */
	      found = 1;
	  }
	}
	emax5[cid].retval = (found)? 1 : 0; /* dirty有りの場合,EMAX完了時にARM-L2$無効化 */
      }
      for (j=0; j<EMAX_WIDTH; j++) {
        emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
        emax5[cid].fsm[j].row_count    = 0;
        emax5[cid].fsm[j].row_select   = 0LL;
#ifndef IGNORE_LMMI_BLKGATHER
	emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
#endif
      }
      break;
a217 1
      emax5[cid].cycles_scon_part++;
d220 4
a223 4
	if (emax5[cid].fsm[j].row_count < emax5[cid].fsm[j].last_dist) { /* last_dist > 0 */
	  if (!(emax5[cid].fsm[j].row_select&1))  /* 1回早くインクリメントし終了タイミングを合わせる */
	    emax5[cid].fsm[j].row_count++;
	  emax5[cid].fsm[j].row_select  = ~emax5[cid].fsm[j].row_select; /* STAT_SCON2回目からall-1 */
d226 4
a229 8
	  emax5[cid].status = STATUS_LMMI;
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0LL;
	  emax5[cid].fsm[j].row_select   = 0LL;
#ifndef IGNORE_LMMI_BLKGATHER
	  emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	  emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
#endif
a232 753
      /*******************************************************************************************************************************************************/
      /* ●lmmi指示ルール (copy from conv-c2c/emac6.c)                                                                  lmmi-loc  v  top  blk  len  rw  f  p */
      /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  len   0  0  0 */
      /* LD with force-read=1 and ptop==NULL generates current(lmf) and !reuse LMM. same as lmf in EMAX4                    curr  1  top  blk  len   0  1  0 */
      /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist!=0                               curr  1  top  blk  len   0  0  0 */
      /*                                                                                                       ofs=0      c+dist  1 ptop  blk  len   0  0  1 */
      /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   0  0  1 */
      /*                                                                                                               p=1の場合,pref-addrは常にlmmi.top+ofs */
      /* LDDMQ set f=1 and p=1 in lmmc automatically                                                                        curr  1  top  -    -     0  1  1 */
      /*******************************************************************************************************************************************************/
      /* ST with force-read=0 and ptop==NULL generates current(lmw) and reuse+wback LMM. same as lmw in EMAX4               curr  1  top  blk  len   1  0  0 */
      /* ST with force-read=1 and ptop==NULL generates current(lmx) and !reuse+wback LMM. same as lmx in EMAX4              curr  1  top  blk  len   1  1  0 */
      /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist!=0                               curr  1  top  blk  len   1  0  0 */
      /*                                                                                                       ofs=0      c-dist  1 ptop  blk  len   1  0  1 */
      /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   1  0  1 */
      /*                                                                                                              p=1の場合,drain-addrは常にlmmi.top+ofs */
      /* TR    set f=1 and p=1 in lmmc automatically                                                                        curr  1  top  -    -     1  1  1 */
      /*******************************************************************************************************************************************************/
      /* Example of Load+Store **************************************************************************/
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
      /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
      /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
      /*                        ●1 lmmc=lmr,lmmo.top!=lmmc.top,の場合, load before next exec           */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                                           */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmw (store)                    */
      /*                        ●2 lmmo=lmw,lmmc!=lmd,dirty=1の場合, writeback before next exec        */
      /* }                                                                                              */
      /* Example of Accumulate **************************************************************************/
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(LDRQ,  1, src1, D[y], x, msk, D[y], 0, XSIZE, 1, NULL);   lmf (load)                     */
      /*                        ●3 lmmc=lmfの場合, load always before next exec                        */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                (accumulate)               */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmw (store)                    */
      /*                        ●2 lmmo=lmw,lmmc!=lmd,dirty=1の場合, writeback before next exec        */
      /*                   (lmfとlmwが重なるケースでも一旦memに追い出すことで単純化. lmfは再利用しない) */
      /* }                                                                                              */
      /* Example of Partial Update **********************************************************************/
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(STRQ, ex, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmx (read-&-conditional-write) */
      /*                        ●3 lmmc=lmxの場合, load always before next exec                        */
      /*                        ●4 lmmc=lmx,dirty=1の場合, writeback before next exec                  */
      /*                                        (lmxも一旦memに追い出すことで単純化. lmxも再利用しない) */
      /* }                                                                                              */
      /* Example of Prefetch+Drain (mapdist>0)***********************************************************/
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, A[y+1]); lmr+lmp prefetch               */
      /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, B[y+1]); lmr+lmp prefetch               */
      /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, C[y+1]); lmr+lmp prefetch               */
      /*                        ●1 lmmc=lmr,lmmo.top!=lmmc.topの場合, load before next exec            */
      /*                        ●5 lmmc=lmpの場合, load top+ofs(ofs=0) with next exec                  */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                                           */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, NULL, 0, XSIZE, 0, D[y-1]); lmd explicit late drain        */
      /*                        ●6 lmmc=lmd,dirty=1の場合, drain top+ofs(ofs=0) with next exec         */
      /* }                                                                                              */
      /* Example of Prefetch+Drain (mapdist=0)***********************************************************/
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, A[y+1]); lmr+lmp prefetch               */
      /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, B[y+1]); lmr+lmp prefetch               */
      /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, C[y+1]); lmr+lmp prefetch               */
      /*                        ●7 lmmc=lmp,lmmo.top+ofs!=lmmc.topの場合, load top+ofs before next exec*/
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                                           */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, NULL, 0, XSIZE, 0, D[y-1]); lmd explicit late drain        */
      /*                        ●6 lmmc=lmd,dirty=1の場合, drain top+ofs with next exec                */
      /* }                                                                                              */
      /*************************************************************************************************************************************/
      /* 【FSM_DRAIN】                                                                                                                     */
      /* lmmo.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
      /*      1  1  0  0 ... lmw       lmmd=1のみ,必ず,regv前にdrain.終了時にlmmd=0                     store:d=1     --                   */
      /*      1  1  1  0 ... lmx       lmmd=1のみ,必ず,regv前にdrain.終了時にlmmd=0                     store:d=1     --                   */
      /*      1  1  0  1 ... lmd       drainは完了(dirty=0)しているので無視してよい                     drain済       --                   */
      /* 【FSM_LOAD】                                                                                                                      */
      /* lmmi.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
      /*      1  0  0  0 ... lmr       lmmoとlmmiが不一致ならdrainとregvの間にload(top)                 prefetch/--   reuse/mload          */
      /*      1  0  1  0 ... lmf       必ずdrainとregvの間にload                                        --            mload(always)        */
      /*      1  1  1  0 ... lmx       必ずdrainとregvの間にload                                        --            store:d=1            */
      /* 【FSM_EXEC】lmm_store開始と同時にlmmd=1                                                                                           */
      /* lmmi.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
      /*      1  0  0  1 ... lmp       必ずexecと同時にloadする(top+ofs)                                prefetch/--   reuse/prefetch       */
      /*      1  1  0  0 ... lmw                                                                        --            store:d=1            */
      /*      1  1  0  1 ... lmd       lmmd=1のみ,execと同時にdrain.終了時にlmmd=0                      store:d=1     d=1時のみdrain       */
      /*                               最後のlmdを追い出すためには明示的drain指示(startとは別コマンド)が必要                               */
      /*      1  0  1  1 ... LDDMQ                                                                      --            lddmq                */
      /*      1  1  1  1 ... TR                                                                         --            tr                   */
      /*************************************************************************************************************************************/
    case STATUS_CONF:
    case STATUS_REGV:
    case STATUS_LMMI:
    case STATUS_DRAIN:
    case STATUS_LOAD:
    case STATUS_EXEC: /* simulate from stage15 to stage0, from col=3 to col=0 */
      switch (emax5[cid].status) {
      case STATUS_CONF:  emax5[cid].cycles_conf_part++;  break;
      case STATUS_REGV:  emax5[cid].cycles_regv_part++;  break;
      case STATUS_LMMI:  emax5[cid].cycles_lmmi_part++;  break;
      case STATUS_DRAIN: emax5[cid].cycles_drain_part++; break;
      case STATUS_LOAD:  emax5[cid].cycles_load_part++;  break;
      case STATUS_EXEC:  emax5[cid].cycles_exec_part++;  break;
      }
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
#ifndef IGNORE_LDDMQ_HANDSHAKE
        if (emax5[cid].unit1_exec || emax5[cid].unit2_exec || emax5[cid].unit2_lmbusy) /* exec not finished */
#else
        if (emax5[cid].unit1_exec || emax5[cid].unit2_exec                           ) /* exec not finished */
#endif
          sync = 0; /* not finished */
        i = emax5[cid].fsm[j].row_count;
        if (i < EMAX_DEPTH) {
	  int lmmc_topz =  (emax5[cid].fsm[j].lmmc[i].top == 0);
	  int lmmc_ofsz =  (emax5[cid].fsm[j].lmmc[i].ofs == 0);
          int lmmo_stat = ((emax5[cid].fsm[j].lmmo[i].v                                  )<<3)
	                  |(emax5[cid].fsm[j].lmmo[i].rw<<2)|(emax5[cid].fsm[j].lmmo[i].f<<1)|(emax5[cid].fsm[j].lmmo[i].p); /* v|rw|f|p */
          int lmmc_stat = ((emax5[cid].fsm[j].lmmc[i].v & ~emax5[cid].fsm[j].lmmc[i].copy & ((emax5[cid].fsm[j].lmmc[i].f&emax5[cid].fsm[j].lmmc[i].p) | !lmmc_topz))<<3)
                                                                                       	                                     /* v= ~copy & (OP_LDDMQ/OP_TR または ptop!=NULL) */
	                  |(emax5[cid].fsm[j].lmmc[i].rw<<2)|(emax5[cid].fsm[j].lmmc[i].f<<1)|(emax5[cid].fsm[j].lmmc[i].p); /* v|rw|f|p */
          int lmm_ready =  (emax5[cid].fsm[j].lmmo[i].v && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
	                                                && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
	                                                && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top);
	  int lmm_readz =  (emax5[cid].fsm[j].lmmo[i].v && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
                                                        && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
                                                        &&(emax5[cid].fsm[j].lmmo[i].top+(Sll)(int)emax5[cid].fsm[j].lmmo[i].ofs) == emax5[cid].fsm[j].lmmc[i].top);
	  Ull ofs;
	  switch (emax5[cid].status) {
	  case STATUS_CONF:                                      mark = 1; break; /* load */
	  case STATUS_REGV:                                      mark = 1; break; /* load */
	  case STATUS_LMMI:                                      mark = 1; break; /* load */
          case STATUS_DRAIN:
            if      (mode==1 && (lmmo_stat==12 && lmmc_stat!=13) && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ●2 lmw&!lmd drain */
            else if (mode==1 && (lmmo_stat==14                 ) && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ●4 lmx      drain */
            else if (mode==2 &&                                     emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ☆  drain_dirty_lmm */
            else                                                                               mark = 0; /* skip drain */
	    break;
	  case STATUS_LOAD:
            if      (lmmc_stat== 8               && !lmm_ready)  mark = 1; /* ●1 lmr & !ready */
            else if (lmmc_stat== 9 && !lmmc_ofsz && !lmm_readz)  mark = 1; /* ●7 lmr & !readz */
            else if (lmmc_stat==10 || lmmc_stat==14)             mark = 1; /* ●3 lmf/lmx always load */
            else                                                 mark = 0; /* skip load */
	    break;
	  case STATUS_EXEC:
	    /* ●●● OP_IM_PREF,OP_IM_DRAIN,OP_LDDMQ,OP_TRが処理対象 ●●● */
	    /*  OP_IM_PREF:  ofsz=0,v=1,rw=0,f=0,p=1 lmmc_stat==9  */
	    /*  OP_IM_PREF:  ofsz=1,v=1,rw=0,f=0,p=1 lmmc_stat==9  */
	    /*  OP_IM_DRAIN: ofsz=0,v=1,rw=1,f=0,p=1 lmmc_stat==13 */
	    /*  OP_IM_DRAIN: ofsz=1,v=1,rw=1,f=0,p=1 lmmc_stat==13 */
	    /*  OP_LDDMQ:           v=1,rw=0,f=1,p=1 lmmc_stat==11 */
	    /*  OP_TR:              v=1,rw=1,f=1,p=1 lmmc_stat==15 */
	    /* ●●● 同一列に複数リクエストがある場合は当面考えない ●●● */
	    /*  PREFとDRAINはEXEC以外でもよいが,LDDMQとTR(f=1,p=1)はEXEC時に要対応 */
	    /*    ・LDDMQはAXIにRead-req送出,Data受取り,lmwd書き込み */
	    /*    ・TRはEMAX制御Regにストア,ARM引き継ぎ              */
            if      (lmmc_stat== 9                             ) mark = 1; /* ●5 lmp */
            else if (lmmc_stat==13 && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ●6 lmd & dirty */
#ifndef IGNORE_LDDMQ_HANDSHAKE
	    else if (lmmc_stat==11                             ) mark = 1; /*     LDDMQ */
	    else if (lmmc_stat==15                             ) mark = 1; /*     TR */
#endif
            else                                                 mark = 0; /* skip pdrain/pload */
	    break;
          }
#if 0
	  switch (emax5[cid].status) {
	  case STATUS_DRAIN:
	  case STATUS_LOAD:
	  case STATUS_EXEC:
	    printf("status=%d lmm[row=%d][col=%d]: lmmo_stat=%d lmmc_stat=%d lmm_ready=%d mark=%d\n",
		   emax5[cid].status, i, j, lmmo_stat, lmmc_stat, lmm_ready, mark);
	    break;
	  }
#endif
	  /* UNIT <=> 主記憶転送対象検出 */
          if (mark) {
            switch (emax5[cid].fsm[j].memif_status) {
            case MEMIF_AREQ:
	      if (!emax5[cid].fsm[j].axi_awvalid && !emax5[cid].fsm[j].axi_arvalid) {
		/*****************************************/
		/* AXI用加工前アドレスおよび長さをセット */
		/*****************************************/
		if (emax5[cid].status==STATUS_CONF) {
		  emax5[cid].fsm[j].axi_arvalid = 1;
		  emax5[cid].fsm[j].araddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*j; /* address should be 32B-aligned */
		  emax5[cid].fsm[j].arlen  =                  UNIT_WIDTH*EMAX_DEPTH-1; /* length should be # of dwords */
		  if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		    int i;
		    conf_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		    printf(" EMAX_DUMP_DDR(conf=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		    if (emax5[cid].fsm[j].araddr == conf)
		      fprintf(fp_conf, "ddr_conf_top = 40\'h%08.8x;\n", (Uint)emax5[cid].fsm[j].araddr);
		    for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),conf_p++)
		      fprintf(fp_conf, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)((*conf_p)>>32), (Uint)(*conf_p));
		  }
		}
		else if (emax5[cid].status==STATUS_REGV) {
		  emax5[cid].fsm[j].axi_arvalid = 1;
		  emax5[cid].fsm[j].araddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*j; /* address should be 32B-aligned */
		  emax5[cid].fsm[j].arlen  =                  UNIT_WIDTH*2*EMAX_DEPTH-1; /* length should be # of dwords */
		  if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		    int i;
		    regv_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		    printf(" EMAX_DUMP_DDR(regv=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		    if (emax5[cid].fsm[j].araddr == regv)
		      fprintf(fp_regv, "ddr_regv_top = 40\'h%08.8x;\n", (Uint)emax5[cid].fsm[j].araddr);
		    for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),regv_p++)
		      fprintf(fp_regv, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)((*regv_p)>>32), (Uint)(*regv_p));
		  }
		}
		else if (emax5[cid].status==STATUS_LMMI) {
		  emax5[cid].fsm[j].axi_arvalid = 1;
		  emax5[cid].fsm[j].araddr = lmmi+sizeof(Ull)*UNIT_WIDTH/2*EMAX_DEPTH*j; /* address should be 32B-aligned */
		  emax5[cid].fsm[j].arlen  =                  UNIT_WIDTH/2*EMAX_DEPTH-1; /* length should be # of dwords */
		  if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		    int i;
		    lmmi_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		    printf(" EMAX_DUMP_DDR(lmmi=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		    if (emax5[cid].fsm[j].araddr == lmmi)
		      fprintf(fp_lmmi, "ddr_lmmi_top = 40\'h%08.8x;\n", (Uint)emax5[cid].fsm[j].araddr);
		    for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),lmmi_p++)
		      fprintf(fp_lmmi, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)(*(lmmi_p)>>32), (Uint)(*lmmi_p));
		  }
		}
#ifndef IGNORE_LDDMQ_HANDSHAKE
		else if (emax5[cid].status==STATUS_EXEC && lmmc_stat==11) { /* LDDMQ lmm->lmrd(addr) */
                  if (unit[cid][i][j].rrdy) {
		    emax5[cid].fsm[j].axi_arvalid = 1;
		    emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmrd[0]; /* lmm->lmrd(addr) */
		    emax5[cid].fsm[j].arlen  = UNIT_WIDTH-1; /* length should be # of dwords */
		    if (trace)
		      printf("%03.3d:siml_emax5: LDDMQ AREQ1 row=%d col=%d araddr=%08.8x\n", tid, i, j, (Uint)emax5[cid].fsm[j].araddr);
		  }
		}
		else if (emax5[cid].status==STATUS_EXEC && lmmc_stat==15) { /* TR lmm->lmrd(addr) */
                  if (unit[cid][i][j].rrdy) {
		    emax5[cid].fsm[j].tcureg_valid = 1;
		    for (k=0; k<UNIT_WIDTH; k++)
		      emax5[cid].fsm[j].tcureg[k] = emax5[cid].fsm[j].lmrd[k]; /* lmm->lmrd(addr) */
		    if (trace)
		      printf("%03.3d:siml_emax5: TR RRDY row=%d col=%d tcureg[3:0]=%08.8x %08.8x %08.8x %08.8x\n", tid, i, j, (Uint)emax5[cid].fsm[j].tcureg[3], (Uint)emax5[cid].fsm[j].tcureg[2], (Uint)emax5[cid].fsm[j].tcureg[1], (Uint)emax5[cid].fsm[j].tcureg[0]);
		  }
		  else if (emax5[cid].fsm[j].tcureg_ready) {
		    emax5[cid].fsm[j].tcureg_valid = 0;
		    emax5[cid].fsm[j].tcureg_ready = 0;
		    emax5[cid].fsm[j].fsm_busy     = 0;
		  }
		  if (!(emax5[cid].unit1_exec || emax5[cid].unit2_exec || (emax5[cid].unit2_lmbusy & (1LL<<i)))) { /* if last transaction */
		    if (trace && emax5[cid].fsm[j].tcureg_last==0)
		      printf("%03.3d:siml_emax5: TR TCUREG_LAST=1 row=%d col=%d\n", tid, i, j);
		    emax5[cid].fsm[j].tcureg_last = 1;
		  }
		}
#endif
		else if (emax5[cid].status==STATUS_DRAIN) { /* drain */
		  emax5[cid].fsm[j].axi_awvalid = 1;
		  emax5[cid].fsm[j].awaddr = (mode==1)?emax5[cid].fsm[j].lmmo[i].top:emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
		  emax5[cid].fsm[j].awlen  = (mode==1)?emax5[cid].fsm[j].lmmo[i].len:emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		}
		else if (emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1) { /* pdrain */
		  emax5[cid].fsm[j].axi_awvalid = 1;
		  emax5[cid].fsm[j].awaddr = emax5[cid].fsm[j].lmmc[i].top+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* address should be 8B-aligned */
		  emax5[cid].fsm[j].awlen  = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		}
		/*** NORMAL ************/
		/* --- single-load --- : fsmが1回のみburst起動                              */
		/* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
		/* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
		/* align=32B, block=0, blocking=none             ... align済      4倍幅load */
		
		/*** GATHER ************/
		/* --- blocking-load --- : fsmがblock単位にburst起動                        */
		/* align=32B, block=1, blocksize=8*4*16=512B *MAXPAGE_PVE = 64KB  for LMM   */
		/* align=32B, block=2, blocksize=8*4*32=1KB  *MAXPAGE_PVE = 128KB for LMM   */
		/* align=32B, block=3, blocksize=8*4*64=2KB  *MAXPAGE_PVE = 256KB for LMM   */ 
		
		/* 総転送topは,emax5[cid].fsm[j].lmmc[i].top                                */
		/*  pref_topは,emax5[cid].fsm[j].lmmc[i].top+emax5[cid].fsm[j].lmmc[i].ofs  */
		/* 総転送lenは,emax5[cid].fsm[j].lmmc[i].len                                */
		/*                blkstat    = 0                                            */
		/*                blkcount   = 0                                            */
		/*                             emax5[cid].fsm[j].lmmc[i].len/blksize 7bit   */
		/*                                                 MAX= 64KB/MAX=512 7bit   */
		/*                                                 MAX=128KB/MAX=1KB 7bit   */
		/*                                                 MAX=256KB/MAX=2KB 7bit   */
		/*                blktop[4]    (ddr-data -> ddr-addr)                       */
		/*                lmmblktop  = 0                                            */
		/*                lmmblklen  = emax5[cid].fsm[j].lmmc[i].len #dwords        */
		/* MEMIF_AREQ:                                                              */
		/*                  memif_status = MEMIF_DREQ                               */
		/*                  ardyc     = 0                             #4dwords      */
		/*                  rrdyc     = 0                             #4dwords      */
		/*  FSM_BLKSTAT=0:  araddr    = emax5[cid].fsm[j].lmmc[i].top(+ofs)+blkcount/4*32 */
		/*                  arlen     = 3 (64bit*4) 使用dataは64bit*4               */
		/*                  blksize   = 32<<lmm.blk                   #dwords       */
		/*  FSM_BLKSTAT=1:  araddr    = blktop[blkcount%4]                          */
		/*                  arlen     = (lmmblklen<blksize)?lmmblklen:blksize       */
		/*                  lmmblklen = (lmmblklen<blksize)?0:(lmmblklen-blksize)   */
		/*                lmm_nreq  = arlen/UNIT_WIDTH                              */
		/* MEMIF_DREQ:                                                              */
		/*  FSM_BLKSTAT=0: blktop[3:0]  = axi_rdata[3:0] .. 有効ptrが最大4個        */
		/*                 FSM_BLKSTAT  = 1                                         */
		/*                 memif_status = MEMIF_AREQ                                */
		/*  FSM_BLKSTAT=1: if (rrdyc<lmm_nreq)                                      */
		/*                   lmwa    = lmmblktop+rrdyc*32                           */
		/*                 else                                                     */
		/*                   if ((blkcount&3)==3 || lmmblklen==0) FSM_BLKSTAT = 0   */
		/*                   if (lmmblklen==0) { row_count++; blkcount=0}           */
		/*                   else              { blkcount++ }                       */
		/*                   lmmblktop += blksize*8                                 */
		/*                   memif_status = MEMIF_AREQ                              */
		/*                 if (axi_rvalid)                                          */
		/*                   lmwd[4] = axi_rdata[4]                                 */
		/*                   rrdyc++                                                */
		else if (emax5[cid].status==STATUS_LOAD                                        /* load */
                      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload *//* address should be 8B-aligned *//* length should be # of dwords */
		  emax5[cid].fsm[j].axi_arvalid = 1;
		  if (emax5[cid].fsm[j].lmmc[i].blk==0) { /* inf */
		    if (emax5[cid].status==STATUS_LOAD)
		      emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
		    else
		      emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* address should be 8B-aligned */
		    emax5[cid].fsm[j].arlen      = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
#ifndef IGNORE_LMMI_BLKGATHER
		    emax5[cid].fsm[j].blksize    = 0; /* max:10bit */
#endif
		  }
#ifndef IGNORE_LMMI_BLKGATHER
		  else { /* 16,32,64 */
		    switch (emax5[cid].fsm[j].blkstat) {
		    case 0: /* PTRLIST */
		      if (emax5[cid].status==STATUS_LOAD)
			emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+emax5[cid].fsm[j].blkcount/4*32; /* address should be 8B-aligned */
		      else
			emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+emax5[cid].fsm[j].blkcount/4*32+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* address should be 8B-aligned */
		      emax5[cid].fsm[j].arlen     = 3; /* 4 dwords */
		      emax5[cid].fsm[j].blksize   = 32<<emax5[cid].fsm[j].lmmc[i].blk; /* max:10bit */
		      if (emax5[cid].fsm[j].blkcount==0) {
			emax5[cid].fsm[j].lmmblktop = 0;
			emax5[cid].fsm[j].lmmblklen = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		      }
		      break;
		    case 1: /* VERTEXLIST */
		      emax5[cid].fsm[j].araddr    = emax5[cid].fsm[j].blktop[emax5[cid].fsm[j].blkcount%4]; /* address should be 8B-aligned */
		      emax5[cid].fsm[j].arlen     = (emax5[cid].fsm[j].lmmblklen<emax5[cid].fsm[j].blksize)?emax5[cid].fsm[j].lmmblklen:emax5[cid].fsm[j].blksize-1;
		      emax5[cid].fsm[j].lmmblklen = (emax5[cid].fsm[j].lmmblklen<emax5[cid].fsm[j].blksize)?0:(emax5[cid].fsm[j].lmmblklen-emax5[cid].fsm[j].blksize);
		      break;
		    }
		  }
#endif
		  if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		    int i;
		    load_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		    printf(" EMAX_DUMP_DDR(load=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		    for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),load_p++)
		      fprintf(fp_load, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)(*(load_p)>>32), (Uint)(*load_p));
		  }
		}
		/*************************************/
		/* check align and set mask/lmm_nreq */
		/*************************************/
		if      (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV || emax5[cid].status==STATUS_LMMI) { /* address should be 32B-aligned *//* length should be # of dwords */
		  emax5[cid].fsm[j].lmm_nreq   = emax5[cid].fsm[j].arlen/UNIT_WIDTH;
		  emax5[cid].fsm[j].axi_araddr = emax5[cid].fsm[j].araddr;
		  emax5[cid].fsm[j].axi_arlen  = emax5[cid].fsm[j].lmm_nreq;
		}
#ifndef IGNORE_LDDMQ_HANDSHAKE
		else if (emax5[cid].status==STATUS_EXEC && lmmc_stat==11) { /* LDDMQ lmm->lmrd(addr) */
		  emax5[cid].fsm[j].lmm_nreq   = emax5[cid].fsm[j].arlen/UNIT_WIDTH;
		  emax5[cid].fsm[j].axi_araddr = emax5[cid].fsm[j].araddr;
		  emax5[cid].fsm[j].axi_arlen  = emax5[cid].fsm[j].lmm_nreq;
		}
		else if (emax5[cid].status==STATUS_EXEC && lmmc_stat==15) { /* TR lmm->lmrd(addr) */
		  emax5[cid].fsm[j].lmm_nreq   = 0;
                  /* do nothing */
		}
#endif
		else if (emax5[cid].status==STATUS_DRAIN                                       /* drain */
		      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1)) { /* pdrain *//* address should be 8B-aligned *//* length should be # of dwords */
		  emax5[cid].fsm[j].lmm_fmask = 0xf << ( (emax5[cid].fsm[j].awaddr/sizeof(Ull)                        ) & (UNIT_WIDTH-1));
		  emax5[cid].fsm[j].lmm_lmask = 0xf >> (~(emax5[cid].fsm[j].awaddr/sizeof(Ull)+emax5[cid].fsm[j].awlen) & (UNIT_WIDTH-1));
		  emax5[cid].fsm[j].lmm_nreq  = ((emax5[cid].fsm[j].awaddr/sizeof(Ull)+emax5[cid].fsm[j].awlen)/UNIT_WIDTH) - ((emax5[cid].fsm[j].awaddr/sizeof(Ull))/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
		  emax5[cid].fsm[j].axi_awaddr = emax5[cid].fsm[j].awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1);
		  emax5[cid].fsm[j].axi_awlen  = emax5[cid].fsm[j].lmm_nreq;
		  if (emax5[cid].fsm[j].lmm_nreq==0) {
		    emax5[cid].fsm[j].lmm_fmask &= emax5[cid].fsm[j].lmm_lmask;
		    emax5[cid].fsm[j].lmm_lmask &= emax5[cid].fsm[j].lmm_fmask;
		  }
		}
		else if (emax5[cid].status==STATUS_LOAD                                        /* load */
                      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload *//* address should be 8B-aligned *//* length should be # of dwords */
		  emax5[cid].fsm[j].lmm_fmask = 0xf << ( (emax5[cid].fsm[j].araddr/sizeof(Ull)                        ) & (UNIT_WIDTH-1));
		  emax5[cid].fsm[j].lmm_lmask = 0xf >> (~(emax5[cid].fsm[j].araddr/sizeof(Ull)+emax5[cid].fsm[j].arlen) & (UNIT_WIDTH-1));
		  emax5[cid].fsm[j].lmm_nreq  = ((emax5[cid].fsm[j].araddr/sizeof(Ull)+emax5[cid].fsm[j].arlen)/UNIT_WIDTH) - ((emax5[cid].fsm[j].araddr/sizeof(Ull))/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
		  emax5[cid].fsm[j].axi_araddr = emax5[cid].fsm[j].araddr & ~(sizeof(Ull)*UNIT_WIDTH-1);
		  emax5[cid].fsm[j].axi_arlen  = emax5[cid].fsm[j].lmm_nreq;
		  if (emax5[cid].fsm[j].lmm_nreq==0) {
		    emax5[cid].fsm[j].lmm_fmask &= emax5[cid].fsm[j].lmm_lmask;
		    emax5[cid].fsm[j].lmm_lmask &= emax5[cid].fsm[j].lmm_fmask;
		  }
		}
		if (emax5[cid].fsm[j].lmm_nreq >= LMEM_SIZE/(sizeof(Ull)*UNIT_WIDTH)) { /* LMM overflow */
		  printf("%03.3d:siml_emax5: row=%d col=%d LMM overflow lmm_nreq=%d (>= %d)\n",
			 tid, i, j, emax5[cid].fsm[j].lmm_nreq, LMEM_SIZE/(sizeof(Ull)*UNIT_WIDTH));
		  exit(1);
		}
	      }
	      else if (emax5[cid].fsm[j].axi_awready || emax5[cid].fsm[j].axi_arready) {
		emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
		emax5[cid].fsm[j].ardyc = 0; /* LMM addr-ready(read)                                 */
		emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read), AXI data-ready(rvalid) counter */
		if      (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV || emax5[cid].status==STATUS_LMMI)
		  emax5[cid].fsm[j].axi_arvalid = 0;
#ifndef IGNORE_LDDMQ_HANDSHAKE
		else if (emax5[cid].status==STATUS_EXEC && lmmc_stat==11) { /* LDDMQ lmm->lmrd(addr) */
                  emax5[cid].fsm[j].axi_arvalid = 0;
		}
		else if (emax5[cid].status==STATUS_EXEC && lmmc_stat==15) { /* TR lmm->lmrd(addr) */
                  /* do nothing */
		}
#endif
		else if (emax5[cid].status==STATUS_DRAIN                                     /* drain */
                      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1)) /* pdrain */
		  emax5[cid].fsm[j].axi_awvalid = 0;
		else /* STATUS_LOAD, STATUS_EXEC&rw==0 */
		  emax5[cid].fsm[j].axi_arvalid = 0;
	      }
              break;
            case MEMIF_DREQ:
#ifndef IGNORE_LDDMQ_HANDSHAKE
	      /************************************************************************/
	      /************************************************************************/
	      if (emax5[cid].status==STATUS_EXEC && lmmc_stat==11) { /* LDDMQ lmm->lmwd(data) */
		if (emax5[cid].fsm[j].rrdyc <= emax5[cid].fsm[j].lmm_nreq) {
		  /* do nothing */
		}		
		else {
		  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		}
		if (emax5[cid].fsm[j].axi_rvalid) {
		  emax5[cid].fsm[j].fsm_busy = 0;
		  for (k=0; k<UNIT_WIDTH; k++) {
		    emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].axi_rdata[k];
		    if (trace)
		      printf("%03.3d:siml_emax5: load row=%d col=%d lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
		  }
		  emax5[cid].fsm[j].lmwd_valid = 1;
		  emax5[cid].fsm[j].rrdyc++;
		}
		else {
		  emax5[cid].fsm[j].lmwd_valid = 0;
		}
	      }
	      /************************************************************************/
	      /************************************************************************/
	      else if (emax5[cid].status==STATUS_EXEC && lmmc_stat==15) { /* TR lmm->lmwd(addr) */
		/* do nothing */
	      }
	      else
#endif
	      /************************************************************************/
	      /************************************************************************/
              if (emax5[cid].status==STATUS_DRAIN                                       /* drain */
                    ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1)) { /* pdrain */
		if (emax5[cid].fsm[j].ardyc <= emax5[cid].fsm[j].lmm_nreq) {
		  /**********************/
		  /* row_selectをセット */
		  /**********************/
		  switch (emax5[cid].status) {
		  case STATUS_DRAIN: case STATUS_EXEC:
		    emax5[cid].fsm[j].row_select |= (1LL<<i);
		    emax5[cid].fsm[j].row_lmm_en |= (1LL<<i);
		    break;
		  }
		  /************************/
		  /* generate lmm address */
		  /************************/
		  emax5[cid].fsm[j].lmra = (emax5[cid].fsm[j].awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) + emax5[cid].fsm[j].ardyc*sizeof(Ull)*UNIT_WIDTH;
		  if (trace) {
		    printf("%03.3d:siml_emax5: drain row=%d col=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, (Uint)(emax5[cid].fsm[j].lmra>>32), (Uint)emax5[cid].fsm[j].lmra, emax5[cid].fsm[j].ardyc, emax5[cid].fsm[j].lmm_nreq);
		  }
		  emax5[cid].fsm[j].ardyc++;
		}
		else { /* バースト転送終了#1 */
		  emax5[cid].fsm[j].row_lmm_en &= ~(1LL<<i);
		}
		if (emax5[cid].fsm[j].rrdyc <= emax5[cid].fsm[j].lmm_nreq) {
		  /*********************************************/
		  /* LMMからのrrdy到着データを主記憶へ書き込み */
		  /*********************************************/
		  if (unit[cid][i][j].rrdy) { /* ack from lmm */
		    if (emax5[cid].fsm[j].rrdyc == 0)
		      emax5[cid].fsm[j].axi_wstrb = ((emax5[cid].fsm[j].lmm_fmask&8)?0xff000000:0)
		                                  | ((emax5[cid].fsm[j].lmm_fmask&4)?0x00ff0000:0)
		                                  | ((emax5[cid].fsm[j].lmm_fmask&2)?0x0000ff00:0)
		                                  | ((emax5[cid].fsm[j].lmm_fmask&1)?0x000000ff:0);
		    else if (emax5[cid].fsm[j].rrdyc == emax5[cid].fsm[j].lmm_nreq)
		      emax5[cid].fsm[j].axi_wstrb = ((emax5[cid].fsm[j].lmm_lmask&8)?0xff000000:0)
		                                  | ((emax5[cid].fsm[j].lmm_lmask&4)?0x00ff0000:0)
		                                  | ((emax5[cid].fsm[j].lmm_lmask&2)?0x0000ff00:0)
		                                  | ((emax5[cid].fsm[j].lmm_lmask&1)?0x000000ff:0);
		    else
		      emax5[cid].fsm[j].axi_wstrb = 0xffffffff;
		    emax5[cid].fsm[j].axi_wvalid = 1;
		    for (k=0; k<UNIT_WIDTH; k++) { /* 32B aligned */
		      emax5[cid].fsm[j].axi_wdata[k] = emax5[cid].fsm[j].lmrd[k];
		      if (trace)
			printf("%03.3d:siml_emax5: drain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			       tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
		    }
		    emax5[cid].fsm[j].rrdyc++;		
		  }
		  else
		    emax5[cid].fsm[j].axi_wvalid = 0;
		}
		else { /* バースト転送終了#2 */
		  emax5[cid].fsm[j].axi_wvalid = 0;
		  emax5[cid].fsm[j].lmmd[i] = 0;
		  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		  emax5[cid].fsm[j].row_count++;
		  emax5[cid].fsm[j].row_select   = 0LL;
#ifndef IGNORE_LMMI_BLKGATHER
		  emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
		  emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
#endif
		}
	      }
	      /************************************************************************/
	      /************************************************************************/
	      else { /* STATUS_CONF, STATUS_REGV, STATUS_LMMI, STATUS_LOAD, STATUS_EXEC&rw==0 */
		if (emax5[cid].fsm[j].rrdyc <= emax5[cid].fsm[j].lmm_nreq) {
#if 0
		  /**********************/
		  /* row_selectをセット */
		  /**********************/
		  switch (emax5[cid].status) {
		  case STATUS_CONF: case STATUS_REGV: case STATUS_LMMI:
		    emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH); /* units ignore row_select in STATUS_LMMI */
		    break;
		  case STATUS_LOAD: case STATUS_EXEC:
		    /*emax5[cid].fsm[j].row_select |= (1LL<<i);*/
		    /*emax5[cid].fsm[j].row_lmm_en |= (1LL<<i);*//* wait for data arrived from MEM */
		    break;
		  }
#endif
		  /************************/
		  /* generate lmm address */
		  /************************/
		  if (emax5[cid].status==STATUS_CONF)
		    emax5[cid].fsm[j].lmwa = 0LL; /* fixed */
		  else if (emax5[cid].status==STATUS_REGV)
		    emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].rrdyc&1; /* even/odd */
		  else if (emax5[cid].status==STATUS_LOAD                                        /* load */
			||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
		    if (emax5[cid].fsm[j].lmmc[i].blk==0) { /* inf */
		      emax5[cid].fsm[j].lmwa = (emax5[cid].fsm[j].araddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) + emax5[cid].fsm[j].rrdyc*sizeof(Ull)*UNIT_WIDTH;
		      if (trace) {
			printf("%03.3d:siml_emax5: load0 row=%d col=%d lmwa=%08.8x_%08.8x (%d/%d)\n",
			       tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa, emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
		      }
		    }
#ifndef IGNORE_LMMI_BLKGATHER
		    else { /* 16,32,64 */
		      switch (emax5[cid].fsm[j].blkstat) {
		      case 0: /* PTRLIST */
			/* no write to lmm */
			break;
		      case 1: /* VERTEXLIST */
			emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].lmmblktop + emax5[cid].fsm[j].rrdyc*sizeof(Ull)*UNIT_WIDTH;
			if (trace) {
			  printf("%03.3d:siml_emax5: load1 row=%d col=%d lmwa=%08.8x_%08.8x (%d/%d)\n",
				 tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa, emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
			}
			break;
		      }
		    }
#endif
		  }
		}
		else { /* バースト転送終了#3 */
		  if      (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV || emax5[cid].status==STATUS_LMMI) {
		    emax5[cid].fsm[j].memif_status = MEMIF_TERM;
		  //emax5[cid].fsm[j].row_select   = 0LL;
		  }
		  else if (emax5[cid].status==STATUS_LOAD                                        /* load */
                        ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
		    if (emax5[cid].fsm[j].lmmc[i].blk==0) { /* inf */
		      emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		      emax5[cid].fsm[j].row_count++;
		      emax5[cid].fsm[j].row_select &= ~(1LL<<i);
		      /*emax5[cid].fsm[j].row_lmm_en &= ~(1LL<<i);*//* wait for data arrived from MEM */
#ifndef IGNORE_LMMI_BLKGATHER
		      emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
		      emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
#endif
		    }
#ifndef IGNORE_LMMI_BLKGATHER
		    else { /* 16,32,64 */
		      switch (emax5[cid].fsm[j].blkstat) {
		      case 0: /* PTRLIST */
			emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
			emax5[cid].fsm[j].blkstat = 1;
			break;
		      case 1: /* VERTEXLIST */
			if ((emax5[cid].fsm[j].blkcount&(UNIT_WIDTH-1))==(UNIT_WIDTH-1)
			  || emax5[cid].fsm[j].lmmblklen==0) /* current_row is finished */
			  emax5[cid].fsm[j].blkstat = 0; /* restart with new pointer */

			if (emax5[cid].fsm[j].lmmblklen==0) {
			  emax5[cid].fsm[j].blkcount = 0;
			  emax5[cid].fsm[j].row_count++; /* current_row is finished */
			}
			else
			  emax5[cid].fsm[j].blkcount++; /* continue */
			emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
			emax5[cid].fsm[j].lmmblktop += emax5[cid].fsm[j].blksize*sizeof(Ull);
			break;
		      }
		    }
#endif
		  }
		}
		/**************************************************/
		/* MMEMからのrvalid到着データをUNIT/FSMへ書き込み */
		/**************************************************/
		if (emax5[cid].fsm[j].axi_rvalid) {
		  switch (emax5[cid].status) {
		  case STATUS_CONF:
		    emax5[cid].fsm[j].last_dist = ((struct conf*)&emax5[cid].fsm[j].axi_rdata)->cdw2.mapdist; /* mapdist */
		    emax5[cid].fsm[j].row_count++;
		    emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH); /* units ignore row_select in STATUS_LMMI */
		    break;
		  case STATUS_REGV:
		    emax5[cid].fsm[j].row_count+=(emax5[cid].fsm[j].rrdyc&1); /* even/odd */
		    emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH); /* units ignore row_select in STATUS_LMMI */
		    break;
		  case STATUS_LMMI:
		    emax5[cid].fsm[j].row_count+=2;
		    emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH); /* units ignore row_select in STATUS_LMMI */
		    break;
		  }
		  if (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV
		   || emax5[cid].status==STATUS_LOAD                                        /* load */
                   ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
		    for (k=0; k<UNIT_WIDTH; k++) {
		      emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].axi_rdata[k];
		      if (trace)
			printf("%03.3d:siml_emax5: load row=%d col=%d lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			       tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
		    }
		    if (emax5[cid].status==STATUS_LOAD                                        /* load */
                     ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
		      if (emax5[cid].fsm[j].lmmc[i].blk==0) { /* inf */
			emax5[cid].fsm[j].row_lmm_en |= (1LL<<i); /* 水平方向broadcastの送出はここ */
			for (k=0; k<EMAX_WIDTH; k++) {
			  if (emax5[cid].fsm[j].lmmc[i].bcas & (1<<k))
			    emax5[cid].fsm[k].row_lmm_en |= (1LL<<i);
			}
		      }
#ifndef IGNORE_LMMI_BLKGATHER
		      else { /* 16,32,64 */
			switch (emax5[cid].fsm[j].blkstat) {
			case 0: /* PTRLIST */
			  for (k=0; k<UNIT_WIDTH; k++)
			    emax5[cid].fsm[j].blktop[k] = emax5[cid].fsm[j].axi_rdata[k];
			  break;
			case 1: /* VERTEXLIST */
			  emax5[cid].fsm[j].row_lmm_en |= (1LL<<i);
			  break;
			}
		      }
#endif
		    }
		  }
		  else if (emax5[cid].status==STATUS_LMMI) {
		    for (k=0; k<UNIT_WIDTH; k++) {
		      /* copy a pair of lmmo <- lmmc */
		      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1)) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1));
		      /* copy a pair of lmmc <- rdata */
		      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1)) = emax5[cid].fsm[j].axi_rdata[k];
		    }
		  }
		  emax5[cid].fsm[j].rrdyc++;		
		}
		else {
		  if      (emax5[cid].status == STATUS_CONF) emax5[cid].fsm[j].row_select = 0LL;
		  else if (emax5[cid].status == STATUS_REGV) emax5[cid].fsm[j].row_select = 0LL;
		  else if (emax5[cid].status == STATUS_LMMI) emax5[cid].fsm[j].row_select = 0LL;
		  emax5[cid].fsm[j].row_lmm_en &= ~(1LL<<i);
		  for (k=0; k<EMAX_WIDTH; k++) {
		    if (emax5[cid].fsm[j].lmmc[i].bcas & (1<<k))
		      emax5[cid].fsm[k].row_lmm_en &= ~(1LL<<i);
		  }
		}
	      }
              break;
            } /* end of case AREQ/DREQ */
          } /* end of if (mark) */
          else { /* for STATUS_DRAIN, STATUS_LOAD, STATUS_EXEC */
	    /* 次の候補を粗く探索 */
	    while (++emax5[cid].fsm[j].row_count < EMAX_DEPTH) {
	      i = emax5[cid].fsm[j].row_count;
	      if (emax5[cid].fsm[j].lmmd[i])                                     break; /* rough condition for next STATUS_DRAIN */
	      if (emax5[cid].fsm[j].lmmc[i].v & ~emax5[cid].fsm[j].lmmc[i].copy) break; /* rough condition for next STATUS_LOAD/EXEC  */
	    }
          }
          if (!(emax5[cid].status == STATUS_EXEC && (lmmc_stat==11 || lmmc_stat==15))) /* LDDMQ/TRの場合,sync=0対象外 */
	    sync = 0; /* not finished */
        }
      }

      if (sync) { /* all FSM_DRAIN/FSM_LOAD/FSM_EXEC finished */
	switch (emax5[cid].status) {
	case STATUS_CONF:
          emax5[cid].status = STATUS_LMMI;
	  break;
	case STATUS_REGV:
          emax5[cid].status = STATUS_START;
	  goto transit_to_start;
        case STATUS_LMMI:
          emax5[cid].status = STATUS_DRAIN;
	  break;
        case STATUS_DRAIN:
	  if      (mode==1) emax5[cid].status = STATUS_LOAD; /* normal_array */
	  else if (mode==2) emax5[cid].status = STATUS_TERM; /* drain_dirty_lmm */
	  break;
	case STATUS_LOAD:
          emax5[cid].status = STATUS_REGV;
	  break;
	case STATUS_EXEC:
          emax5[cid].status = STATUS_TERM;
	  break;
	}
        for (j=0; j<EMAX_WIDTH; j++) {
          emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
          emax5[cid].fsm[j].row_count    = 0;
          emax5[cid].fsm[j].row_select   = 0LL;
#ifndef IGNORE_LMMI_BLKGATHER
	  emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	  emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
#endif
        }
	break;
      transit_to_start:
	for (j=0; j<EMAX_WIDTH; j++) {
          emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
          emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 1LL<<emax5[cid].last_row0; /* start row */
#ifndef IGNORE_LMMI_BLKGATHER
	  emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	  emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
#endif
	}
	break;
      }
      break; /* never reached */
d234 1
a234 2
      emax5[cid].cycles_start_part++;
      emax5[cid].status = STATUS_EXEC;
d236 4
a239 8
	emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	emax5[cid].fsm[j].row_count    = 0;
	emax5[cid].fsm[j].row_select   = 0LL;
#ifndef IGNORE_LMMI_BLKGATHER
	emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
#endif
	emax5[cid].fsm[j].axi_first_read = 1; /* simulate pipelined AXI for LDDMQ (1->0) */
d244 1
a244 18
      emax5[cid].cycles_term_part++;
#ifndef IGNORE_LDDMQ_HANDSHAKE
      {
	int found = 0;
	for (j=0; j<EMAX_WIDTH; j++) {
	  if (emax5[cid].fsm[j].tcureg_last) { /* TR exists */
	    found = 1;
	    if (emax5[cid].fsm[j].tcureg_term) { /* ARM response */
	      emax5[cid].fsm[j].tcureg_last = 0;
	      emax5[cid].fsm[j].tcureg_term = 0;
	    }
	  }
	}
	if (found)
	  break; /* keep STATUS_TERM */
      }
#endif
      printf(" EMAX_TERM(%08.8x_%08.8x) retv=%d", (Uint)(pa_cycle>>32), (Uint)pa_cycle, emax5[cid].retval);
a246 7
      if ((flag & DUMP_DDR) && !dump_ddr_done) {
	fclose(fp_conf);
	fclose(fp_lmmi);
	fclose(fp_regv);
	fclose(fp_load);
	dump_ddr_done = 1;
      }
d248 3
a250 3
	emax5[cid].last_conf = conf;
	emax5[cid].last_dist = emax5[cid].fsm[0].last_dist;
	emax5[cid].last_row0 = (emax5[cid].last_row0+emax5[cid].last_dist)%EMAX_DEPTH;
d252 2
a253 2
      emax5[cid].v = 0; /* unlock */
      emax5[cid].status = STATUS_IDLE;
d256 1
a256 1
	  if (unit[cid][i][j].drty) emax5[cid].fsm[j].lmmd[i] = 1; /* mark dirty */
d258 3
a260 11
	emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	emax5[cid].fsm[j].row_count    = 0;
	emax5[cid].fsm[j].row_select   = 0LL;
#ifndef IGNORE_LMMI_BLKGATHER
	emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
#endif
#ifndef IGNORE_LDDMQ_HANDSHAKE
	emax5[cid].fsm[j].tcureg_last = 0;
	emax5[cid].fsm[j].tcureg_term = 0;
#endif
a261 14
      total = emax5[cid].cycles_tinit_part+emax5[cid].cycles_conf_part+emax5[cid].cycles_scon_part+emax5[cid].cycles_lmmi_part+emax5[cid].cycles_drain_part+emax5[cid].cycles_load_part+emax5[cid].cycles_regv_part+emax5[cid].cycles_start_part+emax5[cid].cycles_exec_part+emax5[cid].cycles_term_part+emax5[cid].cycles_trans_part;
      printf(" c%d s%d i%d d%d l%d r%d s%d e%d z%d t%d total=%d\n",
             emax5[cid].cycles_conf_part, emax5[cid].cycles_scon_part,  emax5[cid].cycles_lmmi_part, emax5[cid].cycles_drain_part, emax5[cid].cycles_load_part,
             emax5[cid].cycles_regv_part, emax5[cid].cycles_start_part, emax5[cid].cycles_exec_part, emax5[cid].cycles_term_part,  emax5[cid].cycles_trans_part, total);
      emax5[cid].cycles_conf  += emax5[cid].cycles_conf_part;
      emax5[cid].cycles_scon  += emax5[cid].cycles_scon_part;
      emax5[cid].cycles_lmmi  += emax5[cid].cycles_lmmi_part;
      emax5[cid].cycles_drain += emax5[cid].cycles_drain_part;
      emax5[cid].cycles_load  += emax5[cid].cycles_load_part;
      emax5[cid].cycles_regv  += emax5[cid].cycles_regv_part;
      emax5[cid].cycles_start += emax5[cid].cycles_start_part;
      emax5[cid].cycles_exec  += emax5[cid].cycles_exec_part;
      emax5[cid].cycles_term  += emax5[cid].cycles_term_part;
      emax5[cid].cycles_trans += emax5[cid].cycles_trans_part;
d263 1
a263 1
      break; /* EMAX5 finished */
d266 1
a266 2
#ifndef IGNORE_LDDMQ_HANDSHAKE
      printf("%03.3d:siml_emax5: final arbrk=%08.8x 1exec=%08.8x_%08.8x 1stop=%08.8x eagaen=%08.8x eagden=%08.8x guard=%08.8x lmbrk=%08.8x trval=%08.8x 2exec=%08.8x_%08.8x 2stop=%08.8x fsmbusy=%d%d%d%d lmbusy=%08.8x brout=%08.8x\n",
d268 3
a270 11
	     (Uint)emax5[cid].unit1_arbrk,   (Uint)(emax5[cid].unit1_exec>>32), (Uint)emax5[cid].unit1_exec, (Uint)emax5[cid].unit1_stop,
	     (Uint)emax5[cid].unit2_eag_aen, (Uint)emax5[cid].unit2_eag_den, (Uint)emax5[cid].unit2_guard,
	     (Uint)emax5[cid].unit2_lmbrk,   (Uint)emax5[cid].tr_valid, (Uint)(emax5[cid].unit2_exec>>32), (Uint)emax5[cid].unit2_exec, (Uint)emax5[cid].unit2_stop,
	     emax5[cid].fsm[3].fsm_busy, emax5[cid].fsm[2].fsm_busy, emax5[cid].fsm[1].fsm_busy, emax5[cid].fsm[0].fsm_busy, (Uint)emax5[cid].unit2_lmbusy, (Uint)emax5[cid].brout_valid);
#else
      printf("%03.3d:siml_emax5: final arbrk=%08.8x 1exec=%08.8x_%08.8x 1stop=%08.8x trval=%08.8x 2exec=%08.8x_%08.8x 2stop=%08.8x brout=%08.8x\n",
	     tid,
	     (Uint)emax5[cid].unit1_arbrk,   (Uint)(emax5[cid].unit1_exec>>32), (Uint)emax5[cid].unit1_exec, (Uint)emax5[cid].unit1_stop,
	     (Uint)emax5[cid].tr_valid, (Uint)(emax5[cid].unit2_exec>>32), (Uint)emax5[cid].unit2_exec, (Uint)emax5[cid].unit2_stop,
	     (Uint)emax5[cid].brout_valid);
#endif
d275 1
a275 1
      show_emax5_status(cid);
d278 1
a278 1
    return (emax5[cid].retval); /* EMAX5 finished 0:normal with transaction, 1:normal with lmm_dirty */
d280 1
a280 1
    return (2); /* EMAX5 busy */
d285 1
a285 1
  int tid = emax5[cid].tid;
d289 1
a289 1
  if (emax5[cid].status==STATUS_IDLE) {
d291 2
a292 2
      emax5[cid].fsm[j].axi_arready = 1; /* reset read */
      emax5[cid].fsm[j].axi_awready = 1; /* reset write */
d296 1
a296 1
#define EMAX5_LDDMQ_MUX 8
d299 7
a305 7
    if (emax5[cid].fsm[j].axi_arready && emax5[cid].fsm[j].axi_arvalid) { /* new read_req starts */
      emax5[cid].fsm[j].axi_arready = 0; /* start read */
      emax5[cid].fsm[j].iaddr = emax5[cid].fsm[j].axi_araddr; /* start read */
      emax5[cid].fsm[j].ilen  = 0;                            /* start read (unit is multople of 64bits) */
      if (emax5[cid].fsm[j].axi_arlen == 0) {
	if (!emax5[cid].fsm[j].axi_first_read) /* LDDMQ is assumed to be multiplexed */
	  emax5[cid].fsm[j].idelay= MMDELAY/ARM_EMAX5_RATIO/EMAX5_LDDMQ_MUX; /* pipelined read */
d307 2
a308 2
	  emax5[cid].fsm[j].idelay= MMDELAY/ARM_EMAX5_RATIO;                 /* sequential read */
	  emax5[cid].fsm[j].axi_first_read = 0;
d312 1
a312 1
	emax5[cid].fsm[j].idelay= MMDELAY/ARM_EMAX5_RATIO;                 /* sequential read */
d315 1
a315 1
	       tid, j, (Uint)(emax5[cid].fsm[j].axi_araddr>>32), (Uint)emax5[cid].fsm[j].axi_araddr, (Uint)(emax5[cid].fsm[j].axi_arlen>>32), (Uint)emax5[cid].fsm[j].axi_arlen);
d317 5
a321 5
    else if (emax5[cid].fsm[j].axi_awready && emax5[cid].fsm[j].axi_awvalid) { /* new write_req starts */
      emax5[cid].fsm[j].axi_awready = 0; /* start write */
      emax5[cid].fsm[j].iaddr = emax5[cid].fsm[j].axi_awaddr; /* start write */
      emax5[cid].fsm[j].ilen  = 0;                            /* start write (unit is multople of 64bits) */
      emax5[cid].fsm[j].idelay= 0;                            /* start write */
d324 1
a324 1
	       tid, j, (Uint)(emax5[cid].fsm[j].axi_awaddr>>32), (Uint)emax5[cid].fsm[j].axi_awaddr, (Uint)(emax5[cid].fsm[j].axi_awlen>>32), (Uint)emax5[cid].fsm[j].axi_awlen);
d331 5
a335 5
    else if (!emax5[cid].fsm[j].axi_arready) {
      if (emax5[cid].fsm[j].idelay)
	emax5[cid].fsm[j].idelay--;
      else if (emax5[cid].fsm[j].ilen <= emax5[cid].fsm[j].axi_arlen) {
	emax5[cid].fsm[j].axi_rvalid = 1;
d337 2
a338 2
	  Ull a = emax5[cid].fsm[j].iaddr + sizeof(Ull)*(emax5[cid].fsm[j].ilen*UNIT_WIDTH+k);
	  emax5[cid].fsm[j].axi_rdata[k] = *(Ull*)(base + a);
d341 1
a341 1
		   tid, j, (Uint)(a>>32), (Uint)a, k, (Uint)(emax5[cid].fsm[j].axi_rdata[k]>>32), (Uint)emax5[cid].fsm[j].axi_rdata[k]);
d343 1
a343 1
	emax5[cid].fsm[j].ilen++;
d346 2
a347 2
	emax5[cid].fsm[j].axi_rvalid = 0;
	emax5[cid].fsm[j].axi_arready = 1;
d354 5
a358 5
    else if (!emax5[cid].fsm[j].axi_awready) {
      if (emax5[cid].fsm[j].idelay)
	emax5[cid].fsm[j].idelay--;
      else if (emax5[cid].fsm[j].ilen <= emax5[cid].fsm[j].axi_awlen) {
	if (emax5[cid].fsm[j].axi_wvalid) {
d360 3
a362 3
	    if (emax5[cid].fsm[j].axi_wstrb & (0xff<<(k*8))) {
	      Ull a = emax5[cid].fsm[j].iaddr + sizeof(Ull)*(emax5[cid].fsm[j].ilen*UNIT_WIDTH+k);
	      *(Ull*)(base + a) = emax5[cid].fsm[j].axi_wdata[k];
d365 1
a365 1
		       tid, j, (Uint)(a>>32), (Uint)a, k, (Uint)(emax5[cid].fsm[j].axi_wdata[k]>>32), (Uint)emax5[cid].fsm[j].axi_wdata[k]);
d368 1
a368 1
	  emax5[cid].fsm[j].ilen++;
d372 1
a372 1
	emax5[cid].fsm[j].axi_awready = 1;
a409 121
siml_unit_bus2(cid, i) Uint cid, i; /* TR入力を計算 */
{
  int j, k, s;

  /* fsm.lmw[ad],lmra <-> unit.lmw[ad],lmra */
  for (j=0; j<EMAX_WIDTH; j++) {
    unit[cid][i][j].lmen    = emax5[cid].fsm[j].row_lmm_en>>i&1;
    unit[cid][i][j].lmwa    = emax5[cid].fsm[j].lmwa;
    unit[cid][i][j].lmwd[0] = emax5[cid].fsm[j].lmwd[0];
    unit[cid][i][j].lmwd[1] = emax5[cid].fsm[j].lmwd[1];
    unit[cid][i][j].lmwd[2] = emax5[cid].fsm[j].lmwd[2];
    unit[cid][i][j].lmwd[3] = emax5[cid].fsm[j].lmwd[3];
    unit[cid][i][j].lmra    = emax5[cid].fsm[j].lmra;
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].lmwd_valid   = emax5[cid].fsm[j].lmwd_valid;
#endif
  }
  /* lmw[ad] -> (lmlo <- lmri) */
  for (j=0; j<EMAX_WIDTH; j++) { /* s=0:lmwd, s=1:lmri */
    s = unit[cid][i][j].conf.cdw2.lmls;
    unit[cid][i][j].lmloa   = (s==0)?unit[cid][i][j].lmwa   :unit[cid][i][j].lmria;
    unit[cid][i][j].lmlo[0] = (s==0)?unit[cid][i][j].lmwd[0]:unit[cid][i][j].lmri[0];
    unit[cid][i][j].lmlo[1] = (s==0)?unit[cid][i][j].lmwd[1]:unit[cid][i][j].lmri[1];
    unit[cid][i][j].lmlo[2] = (s==0)?unit[cid][i][j].lmwd[2]:unit[cid][i][j].lmri[2];
    unit[cid][i][j].lmlo[3] = (s==0)?unit[cid][i][j].lmwd[3]:unit[cid][i][j].lmri[3];
    if (j<EMAX_WIDTH-1) { /* 左へ伝搬 */
      unit[cid][i][j+1].lmria   = unit[cid][i][j].lmloa;
      unit[cid][i][j+1].lmri[0] = unit[cid][i][j].lmlo[0];
      unit[cid][i][j+1].lmri[1] = unit[cid][i][j].lmlo[1];
      unit[cid][i][j+1].lmri[2] = unit[cid][i][j].lmlo[2];
      unit[cid][i][j+1].lmri[3] = unit[cid][i][j].lmlo[3];
    }
  }
  /* lmw[ad] -> (lmli -> lmro) */
  for (j=EMAX_WIDTH-1; j>=0; j--) { /* s=0:lmwd, s=1:lmli */
    s = unit[cid][i][j].conf.cdw2.lmrs;
    unit[cid][i][j].lmroa   = (s==0)?unit[cid][i][j].lmwa   :unit[cid][i][j].lmlia;
    unit[cid][i][j].lmro[0] = (s==0)?unit[cid][i][j].lmwd[0]:unit[cid][i][j].lmli[0];
    unit[cid][i][j].lmro[1] = (s==0)?unit[cid][i][j].lmwd[1]:unit[cid][i][j].lmli[1];
    unit[cid][i][j].lmro[2] = (s==0)?unit[cid][i][j].lmwd[2]:unit[cid][i][j].lmli[2];
    unit[cid][i][j].lmro[3] = (s==0)?unit[cid][i][j].lmwd[3]:unit[cid][i][j].lmli[3];
    if (j>0) { /* 右へ伝搬 */
      unit[cid][i][j-1].lmlia   = unit[cid][i][j].lmroa;
      unit[cid][i][j-1].lmli[0] = unit[cid][i][j].lmro[0];
      unit[cid][i][j-1].lmli[1] = unit[cid][i][j].lmro[1];
      unit[cid][i][j-1].lmli[2] = unit[cid][i][j].lmro[2];
      unit[cid][i][j-1].lmli[3] = unit[cid][i][j].lmro[3];
    }
  }
}

siml_unit_bus3(cid, i) Uint cid, i; /* unit2_eag_aen,unit2_eag_denを計算 */
{
  int j, k, s;

#ifndef IGNORE_LDDMQ_HANDSHAKE
  emax5[cid].unit2_eag_aen &= ~(1LL<<i);
  emax5[cid].unit2_eag_den &= ~(1LL<<i);
  for (j=0; j<EMAX_WIDTH; j++) {
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) {
      if (!emax5[cid].fsm[j].fsm_busy && unit[cid][i][j].unit1_eneq) /* inactive */
	emax5[cid].unit2_eag_aen |= (1LL<<i);
      if (unit[cid][i][j].lmwd_valid) /* inactive */
	emax5[cid].unit2_eag_den |= (1LL<<i);
    }
    else if (unit[cid][i][j].conf.cdw1.ea1op == OP_TR) {
      if (!emax5[cid].fsm[j].fsm_busy && unit[cid][i][j].unit1_eneq) /* inactive */
	emax5[cid].unit2_eag_aen |= (1LL<<i);
    }
  }  
#endif
}

siml_unit_bus4(cid, i) Uint cid, i; /* unit2_eag_aen,unit2_eag_denを計算 */
{
  int j, found_lddmq, found_tr, unit2_lmbusy = 0;

#ifndef IGNORE_LDDMQ_HANDSHAKE
  emax5[cid].unit2_lmbusy &= ~(1LL<<i);
  found_lddmq = 0;
  for (j=0; j<EMAX_WIDTH; j++) {
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) {
      found_lddmq = 1;
      unit2_lmbusy = (emax5[cid].unit1_exec & (1LL<<i)) || emax5[cid].fsm[j].fsm_busy || unit[cid][i][j].unit1_eneq;
    }
    else if (unit[cid][i][j].conf.cdw1.ea1op == OP_TR)
      unit2_lmbusy = (emax5[cid].unit1_exec & (1LL<<i)) || emax5[cid].fsm[j].fsm_busy || unit[cid][i][j].unit1_eneq;
  }  
  if (unit2_lmbusy)
    emax5[cid].unit2_lmbusy |= (1LL<<i);
#endif

  emax5[cid].tr_valid &= ~(1LL<<i);
#ifndef IGNORE_LDDMQ_HANDSHAKE
  if (found_lddmq) {
    if (emax5[cid].unit2_eag_den & (1LL<<i))
      emax5[cid].tr_valid |= (1LL<<i);
    emax5[cid].unit2_guard |= (1LL<<i);
    emax5[cid].unit2_lmbrk |= ((Ull)(!unit2_lmbusy && (emax5[cid].brout_valid & (1LL<<i)))<<i);
  }
  else
#endif
  { /* including OP_TR */
    if ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) /* active */
      emax5[cid].tr_valid |= (1LL<<i);
  }

#ifndef IGNORE_LDDMQ_HANDSHAKE
  for (j=0; j<EMAX_WIDTH; j++) {
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) {
      if (!emax5[cid].fsm[j].fsm_busy && unit[cid][i][j].unit1_eneq) /* inactive */
	emax5[cid].fsm[j].fsm_busy = 1;
    }
    else if (unit[cid][i][j].conf.cdw1.ea1op == OP_TR) {
      if (!emax5[cid].fsm[j].fsm_busy && unit[cid][i][j].unit1_eneq) /* inactive */
	emax5[cid].fsm[j].fsm_busy = 1;
    }
  }  
#endif
}

d417 1
a417 1
  switch (emax5[cid].status) {
d428 1
a428 1
    if ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
d452 1
a452 1
  switch (emax5[cid].status) {
d463 1
a463 1
    if ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
d482 1
a482 1
      emax5[cid].unit1_arbrk |= ((Ull)retval<<i);
d496 1
a496 1
  switch (emax5[cid].status) {
d546 1
a546 1
  switch (emax5[cid].status) {
d592 1
a592 1
      if (emax5[cid].unit2_eag_aen & (1LL<<i)) { /* active */
d603 1
a603 1
      if (emax5[cid].unit2_eag_aen & (1LL<<i)) { /* active */
d614 1
a614 1
      if (emax5[cid].unit2_eag_den & (1LL<<i)) { /* active */
d626 1
a626 1
      if ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
d655 1
a655 1
      if (((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))
d666 1
a666 1
      if ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
d695 1
a695 1
  switch (emax5[cid].status) {
d699 1
a699 1
    if (emax5[cid].fsm[j].row_select & (1LL<<i)) {
d705 1
a705 1
    if (!(emax5[cid].fsm[j].row_select & (1LL<<i))) { /* 初回を0と数えて偶数番 */
d739 1
a739 1
    if ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) { /* active */
d748 1
a748 1
    if (emax5[cid].unit2_eag_aen & (1LL<<i)) /* first active eneq */
d750 1
a750 1
    if (emax5[cid].unit2_eag_den & (1LL<<i)) /* first active lmwd_valid */
d887 1
a887 1
  switch (emax5[cid].status) {
d897 1
a897 1
        emax5[cid].fsm[j].lmrd[k] = unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
d910 1
a910 1
    if (emax5[cid].fsm[j].row_select & (1LL<<i)) {
d935 2
a936 2
	  emax5[cid].fsm[j].lmrd[k] = unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
	/*printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al, (Uint)emax5[cid].fsm[j].lmrd[3], (Uint)emax5[cid].fsm[j].lmrd[2], (Uint)emax5[cid].fsm[j].lmrd[1], (Uint)emax5[cid].fsm[j].lmrd[0]);*/
d962 1
a962 1
	/*emax5[cid].fsm[j].lmmd[i] = 1; /* mark dirty */
d1026 1
a1026 1
show_emax5_pa(cid, pa_cycle) Uint cid; Ull pa_cycle;
d1028 1
a1028 1
  int tid = emax5[cid].tid;
d1031 1
a1031 1
  printf("%03.3d:PA %08.8x_%08.8x siml_emax5: tinit=%08.8x_%08.8x  conf=%08.8x_%08.8x scon=%08.8x_%08.8x lmmi=%08.8x_%08.8x drain=%08.8x_%08.8x load=%08.8x_%08.8x\n",
d1034 1
a1034 27
         (Uint)(emax5[cid].cycles_tinit>>32), (Uint)emax5[cid].cycles_tinit,
         (Uint)(emax5[cid].cycles_conf>>32),  (Uint)emax5[cid].cycles_conf,
         (Uint)(emax5[cid].cycles_scon>>32),  (Uint)emax5[cid].cycles_scon,
         (Uint)(emax5[cid].cycles_lmmi>>32),  (Uint)emax5[cid].cycles_lmmi,
         (Uint)(emax5[cid].cycles_drain>>32), (Uint)emax5[cid].cycles_drain,
         (Uint)(emax5[cid].cycles_load>>32),  (Uint)emax5[cid].cycles_load);
  printf("                                      regv=%08.8x_%08.8x start=%08.8x_%08.8x exec=%08.8x_%08.8x term=%08.8x_%08.8x trans=%08.8x_%08.8x\n",
         (Uint)(emax5[cid].cycles_regv>>32),  (Uint)emax5[cid].cycles_regv,
         (Uint)(emax5[cid].cycles_start>>32), (Uint)emax5[cid].cycles_start,
         (Uint)(emax5[cid].cycles_exec>>32),  (Uint)emax5[cid].cycles_exec,
         (Uint)(emax5[cid].cycles_term>>32),  (Uint)emax5[cid].cycles_term,
         (Uint)(emax5[cid].cycles_trans>>32), (Uint)emax5[cid].cycles_trans);
  total = emax5[cid].cycles_tinit+emax5[cid].cycles_conf+emax5[cid].cycles_scon+emax5[cid].cycles_lmmi+emax5[cid].cycles_drain+emax5[cid].cycles_load+emax5[cid].cycles_regv+emax5[cid].cycles_start+emax5[cid].cycles_exec+emax5[cid].cycles_term+emax5[cid].cycles_trans;
  printf("\033[33m%03.3d:EMAX%dMHz=%08.8x_%08.8x(icidlrett)", cid, 2400/ARM_EMAX5_RATIO, (Uint)(total>>32), (Uint)total);
  printf("\033[33m%03.3d:ARM%dMHz=%08.8x_%08.8x\033[0m\n",  cid, 2400, (Uint)(pa_cycle>>32), (Uint)pa_cycle);

  emax5[cid].cycles_tinit = 0LL;
  emax5[cid].cycles_conf  = 0LL;
  emax5[cid].cycles_scon  = 0LL;
  emax5[cid].cycles_lmmi  = 0LL;
  emax5[cid].cycles_drain = 0LL;
  emax5[cid].cycles_load  = 0LL;
  emax5[cid].cycles_regv  = 0LL;
  emax5[cid].cycles_start = 0LL;
  emax5[cid].cycles_exec  = 0LL;
  emax5[cid].cycles_term  = 0LL;
  emax5[cid].cycles_trans = 0LL;
d1037 1
a1037 1
show_emax5_status(cid) Uint cid;
d1050 4
a1053 4
  /* show EMAX5 */
  printf("==== EMAX5[%02.2d] v=%d tid=%d stat=%d l_conf=%08.8x_%08.8x l_dist=%d last_row0=%d unit1_exec=%08.8x_%08.8x unit1_stop=%08.8x_%08.8x unit2_exec=%08.8x_%08.8x unit2_stop=%08.8x_%08.8x\n",
         cid, emax5[cid].v, emax5[cid].tid, emax5[cid].status, (Uint)(emax5[cid].last_conf>>32), (Uint)emax5[cid].last_conf, emax5[cid].last_dist, emax5[cid].last_row0,
         (Uint)(emax5[cid].unit1_exec>>32), (Uint)emax5[cid].unit1_exec, (Uint)(emax5[cid].unit1_stop>>32), (Uint)emax5[cid].unit1_stop, (Uint)(emax5[cid].unit2_exec>>32), (Uint)emax5[cid].unit2_exec, (Uint)(emax5[cid].unit2_stop>>32), (Uint)emax5[cid].unit2_stop);
d1063 12
a1074 12
             (Uint) emax5[cid].fsm[col].lmmo[row].v?36:34,
             (Uint) emax5[cid].fsm[col].lmmd[row],
             (Uint) emax5[cid].fsm[col].lmmo[row].v,
             (Uint) emax5[cid].fsm[col].lmmo[row].rw,
             (Uint) emax5[cid].fsm[col].lmmo[row].f,
             (Uint) emax5[cid].fsm[col].lmmo[row].p,
             (Uint) emax5[cid].fsm[col].lmmo[row].blk,
             (Uint) emax5[cid].fsm[col].lmmo[row].len,
             (Uint) emax5[cid].fsm[col].lmmo[row].bcas,
             (Uint) emax5[cid].fsm[col].lmmo[row].copy,
             (Uint)(emax5[cid].fsm[col].lmmo[row].top>>32),
             (Uint) emax5[cid].fsm[col].lmmo[row].top);
d1079 12
a1090 12
             (Uint) emax5[cid].fsm[col].lmmc[row].v?36:34,
             (Uint) emax5[cid].fsm[col].lmmd[row],
             (Uint) emax5[cid].fsm[col].lmmc[row].v,
             (Uint) emax5[cid].fsm[col].lmmc[row].rw,
             (Uint) emax5[cid].fsm[col].lmmc[row].f,
             (Uint) emax5[cid].fsm[col].lmmc[row].p,
             (Uint) emax5[cid].fsm[col].lmmc[row].blk,
             (Uint) emax5[cid].fsm[col].lmmc[row].len,
             (Uint) emax5[cid].fsm[col].lmmc[row].bcas,
             (Uint) emax5[cid].fsm[col].lmmc[row].copy,
             (Uint)(emax5[cid].fsm[col].lmmc[row].top>>32),
             (Uint) emax5[cid].fsm[col].lmmc[row].top);
d1096 1
a1096 1
    printf("         ---- FSM[%d] status=%02.2d bus_controller                       ", col, emax5[cid].status);
d1100 2
a1101 2
         (Uint)(emax5[cid].unit1_exec>>32), (Uint)emax5[cid].unit1_exec,
         (Uint)(emax5[cid].unit1_stop>>32), (Uint)emax5[cid].unit1_stop);
d1105 2
a1106 2
         (Uint)(emax5[cid].unit2_exec>>32), (Uint)emax5[cid].unit2_exec,
         (Uint)(emax5[cid].unit2_stop>>32), (Uint)emax5[cid].unit2_stop);
d1111 9
a1119 9
           (Uint) emax5[cid].fsm[col].memif_status,
           (Uint) emax5[cid].fsm[col].last_dist,
           (Uint) emax5[cid].fsm[col].row_count,
           (Uint)(emax5[cid].fsm[col].row_select>>32),
           (Uint) emax5[cid].fsm[col].row_select,
           (Uint)(emax5[cid].fsm[col].row_lmm_en>>32),
           (Uint) emax5[cid].fsm[col].row_lmm_en,
           emax5[cid].fsm[col].ardyc,
           emax5[cid].fsm[col].rrdyc);
d1124 8
a1131 8
           (Uint)(emax5[cid].fsm[col].araddr>>32),
           (Uint) emax5[cid].fsm[col].araddr,
           (Uint)(emax5[cid].fsm[col].arlen>>32),
           (Uint) emax5[cid].fsm[col].arlen,
           (Uint)(emax5[cid].fsm[col].awaddr>>32),
           (Uint) emax5[cid].fsm[col].awaddr,
           (Uint)(emax5[cid].fsm[col].awlen>>32),
           (Uint) emax5[cid].fsm[col].awlen);
d1136 4
a1139 4
           (Uint)(emax5[cid].fsm[col].lmwa>>32),
           (Uint) emax5[cid].fsm[col].lmwa,
           (Uint)(emax5[cid].fsm[col].lmra>>32),
           (Uint) emax5[cid].fsm[col].lmra);
d1144 8
a1151 8
           (Uint)(emax5[cid].fsm[col].lmwd[3]>>32),
           (Uint) emax5[cid].fsm[col].lmwd[3],
           (Uint)(emax5[cid].fsm[col].lmwd[2]>>32),
           (Uint) emax5[cid].fsm[col].lmwd[2],
           (Uint)(emax5[cid].fsm[col].lmwd[1]>>32),
           (Uint) emax5[cid].fsm[col].lmwd[1],
           (Uint)(emax5[cid].fsm[col].lmwd[0]>>32),
           (Uint) emax5[cid].fsm[col].lmwd[0]);
d1156 8
a1163 8
           (Uint)(emax5[cid].fsm[col].lmrd[3]>>32),
           (Uint) emax5[cid].fsm[col].lmrd[3],
           (Uint)(emax5[cid].fsm[col].lmrd[2]>>32),
           (Uint) emax5[cid].fsm[col].lmrd[2],
           (Uint)(emax5[cid].fsm[col].lmrd[1]>>32),
           (Uint) emax5[cid].fsm[col].lmrd[1],
           (Uint)(emax5[cid].fsm[col].lmrd[0]>>32),
           (Uint) emax5[cid].fsm[col].lmrd[0]);
d1168 9
a1176 9
           (Uint) emax5[cid].fsm[col].axi_arready,
           (Uint) emax5[cid].fsm[col].axi_arvalid,
           (Uint) emax5[cid].fsm[col].axi_rvalid,
           (Uint) emax5[cid].fsm[col].axi_awready,
           (Uint) emax5[cid].fsm[col].axi_awvalid,
           (Uint) emax5[cid].fsm[col].axi_wstrb,
           (Uint) emax5[cid].fsm[col].axi_wvalid,
           (Uint) emax5[cid].fsm[col].ilen,
           (Uint) emax5[cid].fsm[col].idelay);
d1181 8
a1188 8
           (Uint)(emax5[cid].fsm[col].axi_araddr>>32),
           (Uint) emax5[cid].fsm[col].axi_araddr,
           (Uint)(emax5[cid].fsm[col].axi_arlen>>32),
           (Uint) emax5[cid].fsm[col].axi_arlen,
           (Uint)(emax5[cid].fsm[col].axi_awaddr>>32),
           (Uint) emax5[cid].fsm[col].axi_awaddr,
           (Uint)(emax5[cid].fsm[col].axi_awlen>>32),
           (Uint) emax5[cid].fsm[col].axi_awlen);
d1193 8
a1200 8
           (Uint)(emax5[cid].fsm[col].axi_rdata[3]>>32),
           (Uint) emax5[cid].fsm[col].axi_rdata[3],
           (Uint)(emax5[cid].fsm[col].axi_rdata[2]>>32),
           (Uint) emax5[cid].fsm[col].axi_rdata[2],
           (Uint)(emax5[cid].fsm[col].axi_rdata[1]>>32),
           (Uint) emax5[cid].fsm[col].axi_rdata[1],
           (Uint)(emax5[cid].fsm[col].axi_rdata[0]>>32),
           (Uint) emax5[cid].fsm[col].axi_rdata[0]);
d1205 8
a1212 21
           (Uint)(emax5[cid].fsm[col].axi_wdata[3]>>32),
           (Uint) emax5[cid].fsm[col].axi_wdata[3],
           (Uint)(emax5[cid].fsm[col].axi_wdata[2]>>32),
           (Uint) emax5[cid].fsm[col].axi_wdata[2],
           (Uint)(emax5[cid].fsm[col].axi_wdata[1]>>32),
           (Uint) emax5[cid].fsm[col].axi_wdata[1],
           (Uint)(emax5[cid].fsm[col].axi_wdata[0]>>32),
           (Uint) emax5[cid].fsm[col].axi_wdata[0]);
  printf("\n");
#ifndef IGNORE_LDDMQ_HANDSHAKE
  printf("tcur3-0 ");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
           (Uint)(emax5[cid].fsm[col].tcureg[3]>>32),
           (Uint) emax5[cid].fsm[col].tcureg[3],
           (Uint)(emax5[cid].fsm[col].tcureg[2]>>32),
           (Uint) emax5[cid].fsm[col].tcureg[2],
           (Uint)(emax5[cid].fsm[col].tcureg[1]>>32),
           (Uint) emax5[cid].fsm[col].tcureg[1],
           (Uint)(emax5[cid].fsm[col].tcureg[0]>>32),
           (Uint) emax5[cid].fsm[col].tcureg[0]);
a1213 1
#endif
a1382 60
    printf("lmralmla");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(unit[cid][row][col].lmria>>32),
             (Uint) unit[cid][row][col].lmria,
             (Uint)(unit[cid][row][col].lmroa>>32),
             (Uint) unit[cid][row][col].lmroa,
             (Uint)(unit[cid][row][col].lmlia>>32),
             (Uint) unit[cid][row][col].lmlia,
             (Uint)(unit[cid][row][col].lmloa>>32),
             (Uint) unit[cid][row][col].lmloa);
    printf("\n");
    printf("lmri3-0 ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(unit[cid][row][col].lmri[3]>>32),
             (Uint) unit[cid][row][col].lmri[3],
             (Uint)(unit[cid][row][col].lmri[2]>>32),
             (Uint) unit[cid][row][col].lmri[2],
             (Uint)(unit[cid][row][col].lmri[1]>>32),
             (Uint) unit[cid][row][col].lmri[1],
             (Uint)(unit[cid][row][col].lmri[0]>>32),
             (Uint) unit[cid][row][col].lmri[0]);
    printf("\n");
    printf("lmro3-0 ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(unit[cid][row][col].lmro[3]>>32),
             (Uint) unit[cid][row][col].lmro[3],
             (Uint)(unit[cid][row][col].lmro[2]>>32),
             (Uint) unit[cid][row][col].lmro[2],
             (Uint)(unit[cid][row][col].lmro[1]>>32),
             (Uint) unit[cid][row][col].lmro[1],
             (Uint)(unit[cid][row][col].lmro[0]>>32),
             (Uint) unit[cid][row][col].lmro[0]);
    printf("\n");
    printf("lmli3-0 ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(unit[cid][row][col].lmli[3]>>32),
             (Uint) unit[cid][row][col].lmli[3],
             (Uint)(unit[cid][row][col].lmli[2]>>32),
             (Uint) unit[cid][row][col].lmli[2],
             (Uint)(unit[cid][row][col].lmli[1]>>32),
             (Uint) unit[cid][row][col].lmli[1],
             (Uint)(unit[cid][row][col].lmli[0]>>32),
             (Uint) unit[cid][row][col].lmli[0]);
    printf("\n");
    printf("lmlo3-0 ");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(unit[cid][row][col].lmlo[3]>>32),
             (Uint) unit[cid][row][col].lmlo[3],
             (Uint)(unit[cid][row][col].lmlo[2]>>32),
             (Uint) unit[cid][row][col].lmlo[2],
             (Uint)(unit[cid][row][col].lmlo[1]>>32),
             (Uint) unit[cid][row][col].lmlo[1],
             (Uint)(unit[cid][row][col].lmlo[0]>>32),
             (Uint) unit[cid][row][col].lmlo[0]);
    printf("\n");
@


1.216
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/emax5.c,v 1.217 2017/04/21 02:22:56 nakashim Exp nakashim $";
d13 2
a14 2
#include "../conv-c2e/emax6.h"
#include "../conv-c2e/emax6lib.c"
d521 1
a521 1
      /* ●lmmi指示ルール (copy from conv-c2e/emac6.c)                                                                  lmmi-loc  v  top  blk  len  rw  f  p */
@


1.215
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.214 2017/02/28 07:54:27 nakashim Exp nakashim $";
d12 3
a14 3
#include "bsim.h"
#include "../conv-c2d/emax5.h"
#include "../conv-c2d/emax5lib.c"
d251 1
d253 3
d260 1
d262 1
d267 1
d269 3
d276 1
d278 1
d283 1
d285 3
d368 1
a372 1
#endif
d401 1
d403 3
d493 1
d496 1
d513 1
d516 1
d521 1
a521 1
      /* ●lmmi指示ルール (copy from conv-c2d/emac5.c)                                                                  lmmi-loc  v  top  blk  len  rw  f  p */
d620 1
d622 3
d838 1
d840 1
d974 1
d978 1
a978 1
              else if (emax5[cid].status==STATUS_DRAIN                                       /* drain */
d1038 1
d1041 1
d1108 1
d1111 1
d1254 1
d1257 1
d1265 1
d1268 1
d1280 1
d1283 1
d1290 1
a1290 1
#if 1
d1330 1
d1333 2
d1337 1
d1357 1
d1364 7
d1565 1
a1567 1
#ifndef IGNORE_LDDMQ_HANDSHAKE
d1587 1
a1588 1
#ifndef IGNORE_LDDMQ_HANDSHAKE
d1600 1
d1603 1
d1610 3
a1612 1
  else { /* including OP_TR */
d1617 1
d2461 1
d2474 1
@


1.214
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.213 2017/02/24 13:50:25 nakashim Exp $";
d858 1
d886 5
@


1.213
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.212 2017/02/24 08:18:55 nakashim Exp nakashim $";
d9 1
a9 1
/* emax5.c 2012/9/22 */ 
@


1.212
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.211 2017/02/21 07:58:03 nakashim Exp nakashim $";
d2204 2
a2205 2
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(icidlrett)", 2400/ARM_EMAX5_RATIO, (Uint)(total>>32), (Uint)total);
  printf(" \033[33mARM%dMHz=%08.8x_%08.8x\033[0m\n",  2400, (Uint)(pa_cycle>>32), (Uint)pa_cycle);
@


1.211
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.210 2017/02/14 03:56:45 nakashim Exp nakashim $";
d150 1
d1237 2
d1337 1
d1344 8
a1351 2
      if (emax5[cid].fsm[j].axi_arlen == 0) /* LDDMQ is assumed to be multiplexed */
	emax5[cid].fsm[j].idelay= MMDELAY/ARM_EMAX5_RATIO/EMAX5_LDDMQ_MUX; /* start read */
d1353 1
a1353 1
	emax5[cid].fsm[j].idelay= MMDELAY/ARM_EMAX5_RATIO;      /* start read */
@


1.210
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.209 2017/02/13 02:27:21 nakashim Exp nakashim $";
d1340 4
a1343 1
      emax5[cid].fsm[j].idelay= MMDELAY/ARM_EMAX5_RATIO;      /* start read */
@


1.209
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.208 2017/02/12 23:18:31 nakashim Exp nakashim $";
d733 1
a733 1
		  if (!(emax5[cid].unit1_exec || (emax5[cid].unit2_lmbusy & (1LL<<i)))) { /* if last transaction */
@


1.208
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.207 2017/02/12 22:07:40 nakashim Exp nakashim $";
d136 4
a139 3
    Ull   tcureg_valid       : 1; /* fsm->ARM   0 -> 1 -> 1 -> 0                                        */
    Ull   tcureg_ready       : 1; /* fsm<-ARM   0 -> 0 -> 1 -> 0                                        */
    Ull   tcureg_finish      : 1; /* fsm->ARM   0 -> 0 -> 0 -> 1                                        */
d143 3
a145 2
                                  /* from ARM:  svc 0x1012 ... tcureg_finish->x0                        */
                                  /* from ARM:  svc 0x1013 ... tcureg[3:0]->x3,2,1,0                    */
d258 1
a258 1
Ull get_tcureg_finish(cid, col) int cid, col;
d260 6
a265 1
  return (emax5[cid].fsm[col].tcureg_finish);
a722 4
#undef TRANSACTION_WITH_DUMMY_ARM_THREAD
#ifdef TRANSACTION_WITH_DUMMY_ARM_THREAD
		    emax5[cid].fsm[j].tcureg_ready = 1; /* ★★★ARM-thread無しでtransactionを空simlする場合,コメント解除★★★ */
#endif
d734 3
a736 3
		    if (trace && emax5[cid].fsm[j].tcureg_finish==0)
		      printf("%03.3d:siml_emax5: TR TCUREG_FINISH=1 row=%d col=%d\n", tid, i, j);
		    emax5[cid].fsm[j].tcureg_finish = 1;
d1239 20
a1265 4
      printf(" EMAX_TERM(%08.8x_%08.8x) retv=%d", (Uint)(pa_cycle>>32), (Uint)pa_cycle, emax5[cid].retval);
      if (trace)
	printf("\n");
      emax5[cid].cycles_term_part++;
d1282 2
a1283 1
	emax5[cid].fsm[j].tcureg_finish = 0;
@


1.207
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.206 2017/02/12 22:07:13 nakashim Exp nakashim $";
a32 1
  Ull   unit1_start;   /* 起点を指示     (cex,exe,eag), 0:wait 1:exec */
d344 4
a347 1
      emax5[cid].brout_valid = (emax5[cid].brout_valid &~(1LL<<i)) | (emax5[cid].tr_valid & (1LL<<i));
a371 1
        emax5[cid].unit1_start = emax5[cid].fsm[0].row_select;
d1517 1
a1517 1
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))) /* active */
d1552 1
a1552 1
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))) { /* active */
d1587 1
a1587 1
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))) { /* active */
d1750 1
a1750 1
      if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))) { /* active */
d1779 1
a1779 1
      if (((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))))
d1790 1
a1790 1
      if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))) { /* active */
d1863 1
a1863 1
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))) { /* active */
@


1.206
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.205 2017/02/12 08:41:49 nakashim Exp nakashim $";
d2059 1
a2059 1
	printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al, (Uint)emax5[cid].fsm[j].lmrd[3], (Uint)emax5[cid].fsm[j].lmrd[2], (Uint)emax5[cid].fsm[j].lmrd[1], (Uint)emax5[cid].fsm[j].lmrd[0]);
d2068 1
a2068 1
	printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al, (Uint)unit[cid][i][j].lmm.mr1[3], (Uint)unit[cid][i][j].lmm.mr1[2], (Uint)unit[cid][i][j].lmm.mr1[1], (Uint)unit[cid][i][j].lmm.mr1[0]);
d2090 1
a2090 1
	printf("LMM write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al, (Uint)unit[cid][i][j].lmm.mw0[3], (Uint)unit[cid][i][j].lmm.mm0[3], (Uint)unit[cid][i][j].lmm.mw0[2], (Uint)unit[cid][i][j].lmm.mm0[2], (Uint)unit[cid][i][j].lmm.mw0[1], (Uint)unit[cid][i][j].lmm.mm0[1], (Uint)unit[cid][i][j].lmm.mw0[0], (Uint)unit[cid][i][j].lmm.mm0[0]);
@


1.205
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.204 2017/02/11 14:58:39 nakashim Exp nakashim $";
d1282 1
a1282 1
      printf("%03.3d:siml_emax5: final arbrk=%08.8x 1exec=%08.8x_%08.8x 1stop=%08.8x eagaen=%08.8x eagden=%08.8x guard=%08.8x lmbrk=%08.8x 2exec=%08.8x_%08.8x 2stop=%08.8x fsmbusy=%d%d%d%d lmbusy=%08.8x brout=%08.8x\n",
d1286 1
a1286 1
	     (Uint)emax5[cid].unit2_lmbrk,   (Uint)(emax5[cid].unit2_exec>>32), (Uint)emax5[cid].unit2_exec, (Uint)emax5[cid].unit2_stop,
d1704 1
a1704 1
      if (unit[cid][i][j].lmen) {
d1761 1
d1778 6
a1783 10
      if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))) { /* active */
	/*printf("===TRWR write row=%d col=%d cexdr=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, unit[cid][i][j].cexdr,(Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);*/
	if (unit[cid][i][j].cexdr&1) {
	  unit[cid][i][j].ea0dr   = unit[cid][i][j].ea0d;
	  unit[cid][i][j].lmm.en0 = 1;
	  unit[cid][i][j].lmm.rw0 = (unit[cid][i][j].conf.cdw1.ea0op & 0x10)!=0; /* read/write */
	  unit[cid][i][j].lmm.ma0 = (unit[cid][i][j].ea0dr % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
	}
	else  /* inactive */
	  unit[cid][i][j].lmm.en0 = 0;
d1785 2
a1786 2
      else /* inactive */
        unit[cid][i][j].lmm.en0 = 0;
d1801 1
a1801 1
    else /* inactive */
d1803 2
d2050 10
a2059 14
    if ((emax5[cid].unit2_exec & (1LL<<i)) && (emax5[cid].tr_valid & (1LL<<i))) { /* active */    
      /* store mw    -> lmm[] */
      /* load  lmm[] -> mr    */
      if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_DRAIN
       || unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ
       || unit[cid][i][j].conf.cdw1.ea1op == OP_TR) {
	if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
	  unit[cid][i][j].rrdy = 1; /* rdata valid */
	  for (k=0; k<UNIT_WIDTH; k++)
	    emax5[cid].fsm[j].lmrd[k] = unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
	  /*printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al, (Uint)emax5[cid].fsm[j].lmrd[3], (Uint)emax5[cid].fsm[j].lmrd[2], (Uint)emax5[cid].fsm[j].lmrd[1], (Uint)emax5[cid].fsm[j].lmrd[0]);*/
	}
	else
	  unit[cid][i][j].rrdy = 0; /* rdata invalid */
d2061 8
a2068 6
      else if (unit[cid][i][j].conf.cdw1.ea1op) { /* OP_IM_BUFRD or normal load */
	if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
	  for (k=0; k<UNIT_WIDTH; k++)
	    unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
	  /*printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al, (Uint)unit[cid][i][j].lmm.mr1[3], (Uint)unit[cid][i][j].lmm.mr1[2], (Uint)unit[cid][i][j].lmm.mr1[1], (Uint)unit[cid][i][j].lmm.mr1[0]);*/
	}
d2070 7
a2076 71

      if (unit[cid][i][j].conf.cdw1.ea0op == OP_IM_PREF) {
	if (unit[cid][i][j].lmm.en0 &&  unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
	  for (k=0; k<UNIT_WIDTH; k++)
	    *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
	  /*printf("PRF write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al, (Uint)unit[cid][i][j].lmm.mw0[3], (Uint)unit[cid][i][j].lmm.mm0[3], (Uint)unit[cid][i][j].lmm.mw0[2], (Uint)unit[cid][i][j].lmm.mm0[2], (Uint)unit[cid][i][j].lmm.mw0[1], (Uint)unit[cid][i][j].lmm.mm0[1], (Uint)unit[cid][i][j].lmm.mw0[0], (Uint)unit[cid][i][j].lmm.mm0[0]);*/
	}
      }
      else if (unit[cid][i][j].conf.cdw1.ea0op) { /* normal load/store */
	if (unit[cid][i][j].lmm.en0 && !unit[cid][i][j].lmm.rw0) { /* lmm read enabled */
	  for (k=0; k<UNIT_WIDTH; k++)
	    unit[cid][i][j].lmm.mr0[k] = *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k);
	}
	if (unit[cid][i][j].lmm.en0 &&  unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
	  /*emax5[cid].fsm[j].lmmd[i] = 1; /* mark dirty */
	  if (unit[cid][i][j].conf.cdw1.ea0op < OP_LDDMQ)
	    unit[cid][i][j].drty = 1; /* mark dirty (OP_LDDMQ,OP_TR,OP_IM_BUFWR,は除外が必要) */
	  for (k=0; k<UNIT_WIDTH; k++)
	    *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
	  /*printf("LMM write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al, (Uint)unit[cid][i][j].lmm.mw0[3], (Uint)unit[cid][i][j].lmm.mm0[3], (Uint)unit[cid][i][j].lmm.mw0[2], (Uint)unit[cid][i][j].lmm.mm0[2], (Uint)unit[cid][i][j].lmm.mw0[1], (Uint)unit[cid][i][j].lmm.mm0[1], (Uint)unit[cid][i][j].lmm.mw0[0], (Uint)unit[cid][i][j].lmm.mm0[0]);*/
	}
      }

      /* load mr -> br0 */
      switch (unit[cid][i][j].conf.cdw2.brs0) {
      case 0:                                                          break; /* off */
      case 1: unit[cid][i][j].regv.br[0] = unit[cid][i][j].lmm.mr1[0]; break; /* 1:mr10 align不要 */
      case 2: unit[cid][i][j].regv.br[0] = unit[cid][i][j].tr[0];      break; /* 2:tr0  align不要 */
      case 3:                                                                 /* 3:mr0  align必要 */
	unit[cid][i][j].mr0mux = (a0/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr0[3-0] -> mr0d */
	unit[cid][i][j].mr0d   = unit[cid][i][j].lmm.mr0[unit[cid][i][j].mr0mux];
	switch (unit[cid][i][j].conf.cdw1.ea0op) {
	case OP_LDR :  unit[cid][i][j].regv.br[0] =                unit[cid][i][j].mr0d;                                                                                 break;
	case OP_LDWR:  unit[cid][i][j].regv.br[0] = (Sll)   (int)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
	case OP_LDUWR: unit[cid][i][j].regv.br[0] = (Ull)  (Uint)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
	case OP_LDHR:  unit[cid][i][j].regv.br[0] = (Sll) (short)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
	case OP_LDUHR: unit[cid][i][j].regv.br[0] = (Ull)(Ushort)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
	case OP_LDBR:  unit[cid][i][j].regv.br[0] = (Sll)  (char)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
	case OP_LDUBR: unit[cid][i][j].regv.br[0] = (Ull) (Uchar)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
	}
      }
      /* load mr -> br1 */
      switch (unit[cid][i][j].conf.cdw2.brs1) {
      case 0:                                                          break; /* off */
      case 1: unit[cid][i][j].regv.br[1] = unit[cid][i][j].lmm.mr1[1]; break; /* 1:mr11 align不要 */
      case 2: unit[cid][i][j].regv.br[1] = unit[cid][i][j].tr[1];      break; /* 2:tr1  align不要 */
      case 3:                                                                 /* 3:mr1  align必要 */
	unit[cid][i][j].mr1mux = (a1/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr1[3-0] -> mr0d */
	unit[cid][i][j].mr1d   = unit[cid][i][j].lmm.mr1[unit[cid][i][j].mr1mux];
	switch (unit[cid][i][j].conf.cdw1.ea1op) {
	case OP_LDR:   unit[cid][i][j].regv.br[1] =                unit[cid][i][j].mr1d;                                                                                 break;
	case OP_LDWR:  unit[cid][i][j].regv.br[1] = (Sll)   (int)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
	case OP_LDUWR: unit[cid][i][j].regv.br[1] = (Ull)  (Uint)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
	case OP_LDHR:  unit[cid][i][j].regv.br[1] = (Sll) (short)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
	case OP_LDUHR: unit[cid][i][j].regv.br[1] = (Ull)(Ushort)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
	case OP_LDBR:  unit[cid][i][j].regv.br[1] = (Sll)  (char)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
	case OP_LDUBR: unit[cid][i][j].regv.br[1] = (Ull) (Uchar)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
	}
      }
      /* load mr -> br2 */
      switch (unit[cid][i][j].conf.cdw2.brs2) {
      case 0:                                                          break; /* off */
      case 1: unit[cid][i][j].regv.br[2] = unit[cid][i][j].lmm.mr1[2]; break; /* 1:mr12 align不要 */
      case 2: unit[cid][i][j].regv.br[2] = unit[cid][i][j].tr[2];      break; /* 2:tr2  align不要 */
      case 3: unit[cid][i][j].regv.br[2] = unit[cid][i][j].exdr;       break; /* 3:exdr align不要 */
      }
      /* load mr -> br3 */
      switch (unit[cid][i][j].conf.cdw2.brs3) {
      case 0:                                                          break; /* off */
      case 1: unit[cid][i][j].regv.br[3] = unit[cid][i][j].lmm.mr1[3]; break; /* 1:mr13 align不要 */
      case 2: unit[cid][i][j].regv.br[3] = unit[cid][i][j].tr[3];      break; /* 2:tr3  align不要 */
d2078 64
@


1.204
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.203 2017/02/11 09:04:33 nakashim Exp nakashim $";
d2051 14
a2064 10
    /* store mw    -> lmm[] */
    /* load  lmm[] -> mr    */
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_DRAIN
     || unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ
     || unit[cid][i][j].conf.cdw1.ea1op == OP_TR) {
      if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
        unit[cid][i][j].rrdy = 1; /* rdata valid */
        for (k=0; k<UNIT_WIDTH; k++)
          emax5[cid].fsm[j].lmrd[k] = unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
	/*printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al, (Uint)emax5[cid].fsm[j].lmrd[3], (Uint)emax5[cid].fsm[j].lmrd[2], (Uint)emax5[cid].fsm[j].lmrd[1], (Uint)emax5[cid].fsm[j].lmrd[0]);*/
d2066 6
a2071 8
      else
        unit[cid][i][j].rrdy = 0; /* rdata invalid */
    }
    else if (unit[cid][i][j].conf.cdw1.ea1op) { /* OP_IM_BUFRD or normal load */
      if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
        for (k=0; k<UNIT_WIDTH; k++)
          unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
	/*printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al, (Uint)unit[cid][i][j].lmm.mr1[3], (Uint)unit[cid][i][j].lmm.mr1[2], (Uint)unit[cid][i][j].lmm.mr1[1], (Uint)unit[cid][i][j].lmm.mr1[0]);*/
a2072 1
    }
d2074 6
a2079 5
    if (unit[cid][i][j].conf.cdw1.ea0op == OP_IM_PREF) {
      if (unit[cid][i][j].lmm.en0 &&  unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
        for (k=0; k<UNIT_WIDTH; k++)
          *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
	/*printf("PRF write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al, (Uint)unit[cid][i][j].lmm.mw0[3], (Uint)unit[cid][i][j].lmm.mm0[3], (Uint)unit[cid][i][j].lmm.mw0[2], (Uint)unit[cid][i][j].lmm.mm0[2], (Uint)unit[cid][i][j].lmm.mw0[1], (Uint)unit[cid][i][j].lmm.mm0[1], (Uint)unit[cid][i][j].lmm.mw0[0], (Uint)unit[cid][i][j].lmm.mm0[0]);*/
d2081 13
a2093 13
    }
    else if (unit[cid][i][j].conf.cdw1.ea0op) { /* normal load/store */
      if (unit[cid][i][j].lmm.en0 && !unit[cid][i][j].lmm.rw0) { /* lmm read enabled */
        for (k=0; k<UNIT_WIDTH; k++)
          unit[cid][i][j].lmm.mr0[k] = *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k);
      }
      if (unit[cid][i][j].lmm.en0 &&  unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
        /*emax5[cid].fsm[j].lmmd[i] = 1; /* mark dirty */
	if (unit[cid][i][j].conf.cdw1.ea0op < OP_LDDMQ)
	  unit[cid][i][j].drty = 1; /* mark dirty (OP_LDDMQ,OP_TR,OP_IM_BUFWR,は除外が必要) */
        for (k=0; k<UNIT_WIDTH; k++)
          *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
	/*printf("LMM write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al, (Uint)unit[cid][i][j].lmm.mw0[3], (Uint)unit[cid][i][j].lmm.mm0[3], (Uint)unit[cid][i][j].lmm.mw0[2], (Uint)unit[cid][i][j].lmm.mm0[2], (Uint)unit[cid][i][j].lmm.mw0[1], (Uint)unit[cid][i][j].lmm.mm0[1], (Uint)unit[cid][i][j].lmm.mw0[0], (Uint)unit[cid][i][j].lmm.mm0[0]);*/
a2094 1
    }
d2096 49
a2144 48
    /* load mr -> br0 */
    switch (unit[cid][i][j].conf.cdw2.brs0) {
    case 0:                                                          break; /* off */
    case 1: unit[cid][i][j].regv.br[0] = unit[cid][i][j].lmm.mr1[0]; break; /* 1:mr10 align不要 */
    case 2: unit[cid][i][j].regv.br[0] = unit[cid][i][j].tr[0];      break; /* 2:tr0  align不要 */
    case 3:                                                                 /* 3:mr0  align必要 */
      unit[cid][i][j].mr0mux = (a0/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr0[3-0] -> mr0d */
      unit[cid][i][j].mr0d   = unit[cid][i][j].lmm.mr0[unit[cid][i][j].mr0mux];
      switch (unit[cid][i][j].conf.cdw1.ea0op) {
      case OP_LDR :  unit[cid][i][j].regv.br[0] =                unit[cid][i][j].mr0d;                                                                                 break;
      case OP_LDWR:  unit[cid][i][j].regv.br[0] = (Sll)   (int)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDUWR: unit[cid][i][j].regv.br[0] = (Ull)  (Uint)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDHR:  unit[cid][i][j].regv.br[0] = (Sll) (short)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDUHR: unit[cid][i][j].regv.br[0] = (Ull)(Ushort)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDBR:  unit[cid][i][j].regv.br[0] = (Sll)  (char)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      case OP_LDUBR: unit[cid][i][j].regv.br[0] = (Ull) (Uchar)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      }
    }
    /* load mr -> br1 */
    switch (unit[cid][i][j].conf.cdw2.brs1) {
    case 0:                                                          break; /* off */
    case 1: unit[cid][i][j].regv.br[1] = unit[cid][i][j].lmm.mr1[1]; break; /* 1:mr11 align不要 */
    case 2: unit[cid][i][j].regv.br[1] = unit[cid][i][j].tr[1];      break; /* 2:tr1  align不要 */
    case 3:                                                                 /* 3:mr1  align必要 */
      unit[cid][i][j].mr1mux = (a1/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr1[3-0] -> mr0d */
      unit[cid][i][j].mr1d   = unit[cid][i][j].lmm.mr1[unit[cid][i][j].mr1mux];
      switch (unit[cid][i][j].conf.cdw1.ea1op) {
      case OP_LDR:   unit[cid][i][j].regv.br[1] =                unit[cid][i][j].mr1d;                                                                                 break;
      case OP_LDWR:  unit[cid][i][j].regv.br[1] = (Sll)   (int)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDUWR: unit[cid][i][j].regv.br[1] = (Ull)  (Uint)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
      case OP_LDHR:  unit[cid][i][j].regv.br[1] = (Sll) (short)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDUHR: unit[cid][i][j].regv.br[1] = (Ull)(Ushort)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
      case OP_LDBR:  unit[cid][i][j].regv.br[1] = (Sll)  (char)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      case OP_LDUBR: unit[cid][i][j].regv.br[1] = (Ull) (Uchar)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
      }
    }
    /* load mr -> br2 */
    switch (unit[cid][i][j].conf.cdw2.brs2) {
    case 0:                                                          break; /* off */
    case 1: unit[cid][i][j].regv.br[2] = unit[cid][i][j].lmm.mr1[2]; break; /* 1:mr12 align不要 */
    case 2: unit[cid][i][j].regv.br[2] = unit[cid][i][j].tr[2];      break; /* 2:tr2  align不要 */
    case 3: unit[cid][i][j].regv.br[2] = unit[cid][i][j].exdr;       break; /* 3:exdr align不要 */
    }
    /* load mr -> br3 */
    switch (unit[cid][i][j].conf.cdw2.brs3) {
    case 0:                                                          break; /* off */
    case 1: unit[cid][i][j].regv.br[3] = unit[cid][i][j].lmm.mr1[3]; break; /* 1:mr13 align不要 */
    case 2: unit[cid][i][j].regv.br[3] = unit[cid][i][j].tr[3];      break; /* 2:tr3  align不要 */
@


1.203
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.202 2017/02/08 05:39:39 nakashim Exp nakashim $";
d2055 1
a2055 2
     || unit[cid][i][j].conf.cdw1.ea1op == OP_TR
     || unit[cid][i][j].conf.cdw1.ea1op == OP_IM_BUFRD) {
d2065 1
a2065 1
    else if (unit[cid][i][j].conf.cdw1.ea1op) { /* normal load */
@


1.202
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.201 2017/02/04 16:06:34 nakashim Exp nakashim $";
d817 2
a818 1
		      if (emax5[cid].fsm[j].blkcount==0)
d820 1
d1030 1
a1030 1
			printf("%03.3d:siml_emax5: load row=%d col=%d lmwa=%08.8x_%08.8x (%d/%d)\n",
d1043 1
a1043 1
			  printf("%03.3d:siml_emax5: load row=%d col=%d lmwa=%08.8x_%08.8x (%d/%d)\n",
d1754 1
d2030 1
d2070 1
@


1.201
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.200 2017/02/04 15:56:30 nakashim Exp nakashim $";
d28 1
d445 15
d1240 1
a1240 1
      printf(" EMAX_TERM(%08.8x_%08.8x)", (Uint)(pa_cycle>>32), (Uint)pa_cycle);
d1255 3
a1257 3
        emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
        emax5[cid].fsm[j].row_count    = 0;
        emax5[cid].fsm[j].row_select   = 0LL;
d1293 1
a1293 1
    return (0); /* EMAX5 finished */
@


1.200
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.199 2017/02/04 07:34:14 nakashim Exp nakashim $";
d899 3
a901 3
		    /*if (trace)*/
		    printf("%03.3d:siml_emax5: load row=%d col=%d lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
@


1.199
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.198 2017/02/04 05:00:41 nakashim Exp nakashim $";
a138 1
    Ull   tcureg_done        : 1; /* fsm<-ARM   0 -> 0 -> 0 -> 1                                        */
d143 1
a143 2
                                  /* from ARM:  svc 0x1013 ... 1->tcureg_done                           */
                                  /* from ARM:  svc 0x1014 ... tcureg[3:0]->x3,2,1,0                    */
a252 1
printf("XXXXXXXXXXXXXXXX put_tcureg_ready\n");
a257 1
printf("XXXXXXXXXXXXXXXX get_tcureg_finish=%d\n", emax5[cid].fsm[col].tcureg_finish);
a260 6
put_tcureg_done(cid, col) int cid, col;
{
printf("XXXXXXXXXXXXXXXX put_tcureg_done\n");
  emax5[cid].fsm[col].tcureg_done = 1;
}

a711 7
		    if (trace)
		      printf("%03.3d:siml_emax5: TR TCUREG_READY row=%d col=%d unit1_exec=%08.8x eneq=%d unit2_lmbusy=%08.8x\n", tid, i, j, (Uint)emax5[cid].unit1_exec, unit[cid][i][j].unit1_eneq, (Uint)emax5[cid].unit2_lmbusy);
		    if (!((emax5[cid].unit1_exec & (1LL<<i)) || unit[cid][i][j].unit1_eneq)) { /* if last transaction */
		      if (trace)
			printf("%03.3d:siml_emax5: TR TCUREG_FINISH=1 row=%d col=%d\n", tid, i, j);
		      emax5[cid].fsm[j].tcureg_finish = 1;
		    }
d713 4
a716 5
		  else if (emax5[cid].fsm[j].tcureg_done) {
		    emax5[cid].fsm[j].tcureg_finish = 0;
		    emax5[cid].fsm[j].tcureg_done   = 0;
		    if (trace)
		      printf("%03.3d:siml_emax5: TR TCUREG_DONE row=%d col=%d\n", tid, i, j);
d1244 1
@


1.198
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.197 2017/02/02 22:45:49 nakashim Exp nakashim $";
d255 1
d261 1
d267 1
d722 5
a726 1
		    if (!(emax5[cid].unit2_lmbusy & (1LL<<i)))
d728 1
a728 2
		    if (trace)
		      printf("%03.3d:siml_emax5: TR TCUREG_READY row=%d col=%d unit2_lmbusy=%08.8x\n", tid, i, j, emax5[cid].unit2_lmbusy);
@


1.197
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.196 2017/02/02 03:16:43 nakashim Exp nakashim $";
d42 1
d136 1
a137 1
    Ull   tcureg_valid       : 1; /* fsm->ARM   0 -> 1 -> 1 -> 0                                        */
d139 1
d141 2
a142 2
                                  /* from ARM:  svc 0x1010 ... x0->tcureg_ready                         */
                                  /* from ARM:  svc 0x1011 ... tcureg_valid->x0                         */
d144 2
a145 1
                                  /* from ARM:  svc 0x1013 ... tcureg[3:0]->x3,2,1,0                    */
a176 1
  Ull   tcureg_ready : 1;  /* wire(from fsm) */
d248 5
d258 1
a258 1
Ull get_tcureg_valid(cid, col) int cid, col;
d260 1
a260 1
  return (emax5[cid].fsm[col].tcureg_valid);
d263 1
a263 1
Ull get_tcureg_finish(cid, col) int cid, col;
d265 1
a265 1
  return (emax5[cid].fsm[col].tcureg_finish);
d578 1
a578 1
        if (emax5[cid].unit1_exec || emax5[cid].unit2_exec || emax5[cid].fsm[j].fsm_busy) /* exec not finished */
d713 1
a713 1
		      printf("%03.3d:siml_emax5: TR AREQ1 row=%d col=%d tcureg[3:0]=%08.8x %08.8x %08.8x %08.8x\n", tid, i, j, (Uint)emax5[cid].fsm[j].tcureg[3], (Uint)emax5[cid].fsm[j].tcureg[2], (Uint)emax5[cid].fsm[j].tcureg[1], (Uint)emax5[cid].fsm[j].tcureg[0]);
d719 10
d1275 1
a1275 1
      printf("%03.3d:siml_emax5: final start=%08.8x arbrk=%08.8x 1exec=%08.8x_%08.8x 1stop=%08.8x eagaen=%08.8x eagden=%08.8x guard=%08.8x lmbrk=%08.8x 2exec=%08.8x_%08.8x 2stop=%08.8x fsmbusy=%d%d%d%d brout=%08.8x\n",
a1276 1
	     (Uint)emax5[cid].unit1_start,
d1280 1
a1280 1
	     emax5[cid].fsm[3].fsm_busy, emax5[cid].fsm[2].fsm_busy, emax5[cid].fsm[1].fsm_busy, emax5[cid].fsm[0].fsm_busy, (Uint)emax5[cid].brout_valid);
a1424 1
    unit[cid][i][j].tcureg_ready = emax5[cid].fsm[j].tcureg_ready;
d1467 1
a1468 1
#ifndef IGNORE_LDDMQ_HANDSHAKE
d1479 1
a1480 1
  }  
d1485 1
a1485 1
  int j, found_lddmq, found_tr, unit2_lmbusy;
d1487 1
d1495 2
d1498 3
@


1.196
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.195 2017/02/01 23:24:46 nakashim Exp $";
d137 1
d139 4
a142 3
                                  /* from ARM:  svc 0x1010 ... tcureg_valid->x0                         */
                                  /* from ARM:  svc 0x1011 ... x0->tcureg_ready                         */
                                  /* from ARM:  svc 0x1012 ... tcureg[3:0]->x3,2,1,0                    */
d246 5
d256 1
a256 1
Ull get_tcureg(cid, col, n) int cid, col, n;
d258 1
a258 1
  return (emax5[cid].fsm[col].tcureg[n]);
d261 1
a261 1
put_tcureg_ready(cid, col) int cid, col;
d263 1
a263 1
  emax5[cid].fsm[col].tcureg_ready = 1;
@


1.195
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.194 2017/02/01 23:16:07 nakashim Exp nakashim $";
d244 15
@


1.194
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.193 2017/02/01 12:13:53 nakashim Exp nakashim $";
d140 1
a140 1
                                  /* from ARM:  svc 0x1100 ... tcureg[3:0]->x3,2,1,0                    */
@


1.193
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.192 2017/02/01 10:23:02 nakashim Exp nakashim $";
d138 3
@


1.192
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.191 2017/02/01 09:38:15 nakashim Exp nakashim $";
d667 2
a668 1
printf("===LDDMQ AREQ1 in row=%d col=%d araddr=%08.8x\n", i, j, (Uint)emax5[cid].fsm[j].araddr);
d674 1
a674 1
#define TRANSACTION_WITH_DUMMY_ARM_THREAD
d680 2
a681 1
printf("===TR AREQ1 in row=%d col=%d tcureg[3..0]=%08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)emax5[cid].fsm[j].tcureg[3], (Uint)emax5[cid].fsm[j].tcureg[2], (Uint)emax5[cid].fsm[j].tcureg[1], (Uint)emax5[cid].fsm[j].tcureg[0]);
d1232 8
a1239 3
printf("==start=%08.8x arbrk=%08.8x 1exec=%08.8x_%08.8x 1stop=%08.8x eagaen=%08.8x eagden=%08.8x fsmbusy=%d%d%d%d guard=%08.8x brout=%08.8x lmbrk=%08.8x 2exec=%08.8x_%08.8x 2stop=%08.8x\n",
       (Uint)emax5[cid].unit1_start,(Uint)emax5[cid].unit1_arbrk,(Uint)(emax5[cid].unit1_exec>>32),(Uint)emax5[cid].unit1_exec,(Uint)emax5[cid].unit1_stop,
       (Uint)emax5[cid].unit2_eag_aen,(Uint)emax5[cid].unit2_eag_den,emax5[cid].fsm[3].fsm_busy,emax5[cid].fsm[2].fsm_busy,emax5[cid].fsm[1].fsm_busy,emax5[cid].fsm[0].fsm_busy,(Uint)emax5[cid].unit2_guard,(Uint)emax5[cid].brout_valid, (Uint)emax5[cid].unit2_lmbrk,(Uint)(emax5[cid].unit2_exec>>32),(Uint)emax5[cid].unit2_exec,(Uint)emax5[cid].unit2_stop);
d1667 1
a1667 1
printf("===LDDMQ read row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1678 1
a1678 1
printf("===TR read row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1689 1
a1689 1
printf("===BUFRD read row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1724 1
a1724 1
printf("===TRWR write row=%d col=%d cexdr=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, unit[cid][i][j].cexdr,(Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1745 1
a1745 1
printf("===BUFWR write row=%d col=%d ea1d=%08.8x ea0d=%08.8x\n", i, j, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d2006 1
a2006 1
printf("LMM read row=%d col=%d: A=%08.8x %08.8x %08.8x %08.8x %08.8x\n", i, j, (Uint)a1al, (Uint)emax5[cid].fsm[j].lmrd[3], (Uint)emax5[cid].fsm[j].lmrd[2], (Uint)emax5[cid].fsm[j].lmrd[1], (Uint)emax5[cid].fsm[j].lmrd[0]);
d2022 1
a2022 1
printf("PRF write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al, (Uint)unit[cid][i][j].lmm.mw0[3], (Uint)unit[cid][i][j].lmm.mm0[3], (Uint)unit[cid][i][j].lmm.mw0[2], (Uint)unit[cid][i][j].lmm.mm0[2], (Uint)unit[cid][i][j].lmm.mw0[1], (Uint)unit[cid][i][j].lmm.mm0[1], (Uint)unit[cid][i][j].lmm.mw0[0], (Uint)unit[cid][i][j].lmm.mm0[0]);
d2036 1
a2036 1
printf("LMM write row=%d col=%d: A=%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x %08.8x/%08.8x\n", i, j, (Uint)a0al, (Uint)unit[cid][i][j].lmm.mw0[3], (Uint)unit[cid][i][j].lmm.mm0[3], (Uint)unit[cid][i][j].lmm.mw0[2], (Uint)unit[cid][i][j].lmm.mm0[2], (Uint)unit[cid][i][j].lmm.mw0[1], (Uint)unit[cid][i][j].lmm.mm0[1], (Uint)unit[cid][i][j].lmm.mw0[0], (Uint)unit[cid][i][j].lmm.mm0[0]);
@


1.191
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.190 2017/01/31 23:15:54 nakashim Exp nakashim $";
d546 1
a546 1
        if (emax5[cid].unit1_exec | emax5[cid].unit2_exec) /* exec not finished */
d673 2
a674 2
#if 1
//TRANSACTION_WITH_DUMMY_ARM_THREAD
@


1.190
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.189 2017/01/31 13:26:01 nakashim Exp nakashim $";
d673 4
a676 2
		    /*emax5[cid].fsm[j].tcureg_ready = 1; /*★★★DUMMY ARMが解除すべき★★★*/
		    /*emax5[cid].fsm[j].fsm_busy     = 0; /*★★★DUMMY ARMが解除すべき★★★*/
d681 5
d1230 1
a1230 1
printf("==start=%08.8x arbrk=%08.8x 1exec=%08.8x_%08.8x 1stop=%08.8x eagaen=%08.8x eagden=%08.8x guard=%08.8x lmbrk=%08.8x 2exec=%08.8x_%08.8x 2stop=%08.8x\n",
d1232 1
a1232 1
       (Uint)emax5[cid].unit2_eag_aen,(Uint)emax5[cid].unit2_eag_den,(Uint)emax5[cid].unit2_guard,(Uint)emax5[cid].unit2_lmbrk,(Uint)(emax5[cid].unit2_exec>>32),(Uint)emax5[cid].unit2_exec,(Uint)emax5[cid].unit2_stop);
a1441 1
  found_tr    = 0;
a1446 4
    else if (unit[cid][i][j].conf.cdw1.ea1op == OP_TR) {
      found_tr = 1;
      unit2_lmbusy = (emax5[cid].unit1_exec & (1LL<<i)) || emax5[cid].fsm[j].fsm_busy || unit[cid][i][j].unit1_eneq;
    }
d1455 1
a1455 7
  else if (found_tr) {
    if (emax5[cid].unit2_eag_aen & (1LL<<i))
      emax5[cid].tr_valid |= (1LL<<i);
    emax5[cid].unit2_guard |= (1LL<<i);
    emax5[cid].unit2_lmbrk |= ((Ull)(!unit2_lmbusy && (emax5[cid].brout_valid & (1LL<<i)))<<i);
  }
  else {
@


1.189
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.188 2017/01/31 12:10:58 nakashim Exp nakashim $";
d673 2
a674 2
		    emax5[cid].fsm[j].tcureg_ready = 1; /*★★★DUMMY ARMが解除すべき★★★*/
		    emax5[cid].fsm[j].fsm_busy     = 0; /*★★★DUMMY ARMが解除すべき★★★*/
d1431 1
a1431 1
  int j, found, unit2_lmbusy;
d1434 2
a1435 1
  found = 0;
d1438 5
a1442 1
      found = 1;
d1447 1
a1447 1
  if (found) {
d1453 6
@


1.188
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.187 2017/01/31 10:09:52 nakashim Exp nakashim $";
d1416 1
a1416 2
      if (!emax5[cid].fsm[j].fsm_busy && unit[cid][i][j].unit1_eneq) { /* inactive */
	emax5[cid].fsm[j].fsm_busy = 1;
a1417 1
      }
d1422 1
a1422 2
      if (!emax5[cid].fsm[j].fsm_busy && unit[cid][i][j].unit1_eneq) { /* inactive */
	emax5[cid].fsm[j].fsm_busy = 1;
a1423 1
      }
d1438 1
a1438 2
      unit2_lmbusy = emax5[cid].fsm[j].fsm_busy || unit[cid][i][j].unit1_eneq;
      break;
d1452 11
d1795 8
a1808 7
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && (emax5[cid].brout_valid & (1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))) /* active */
      if (unit[cid][i][j].conf.cdw1.ea0op == OP_TR) {
	if (unit[cid][i][j].cexdr&1)
	  unit[cid][i][j].one_shot = 1; /* set one_shot here */
      }
      else
	unit[cid][i][j].one_shot = 1; /* set one_shot here */
@


1.187
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.186 2017/01/31 04:35:43 nakashim Exp nakashim $";
d1435 1
a1435 1
  int j, found, eneq;
a1438 1
  eneq  = 0;
d1442 1
a1442 1
      eneq  = unit[cid][i][j].unit1_eneq;
d1451 1
a1451 1
    emax5[cid].unit2_lmbrk |= ((Ull)(!(emax5[cid].fsm[j].fsm_busy || eneq) && (emax5[cid].brout_valid & (1LL<<i)))<<i);
@


1.186
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.185 2017/01/30 23:44:08 nakashim Exp nakashim $";
a167 1
  Ull   unit2_lmblast: 1;  /* reg (to   fsm) */
d1435 1
a1435 1
  int j, found;
d1439 1
d1441 1
a1441 1
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ || unit[cid][i][j].conf.cdw1.ea1op == OP_IM_BUFRD) {
d1443 1
d1451 2
a1784 1
    unit[cid][i][j].unit2_lmblast = 0;
a1910 6
#ifndef IGNORE_LDDMQ_HANDSHAKE
    emax5[cid].unit2_guard |= ((Ull)(unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ)<<i);
    emax5[cid].unit2_lmbrk |= ((Ull)(unit[cid][i][j].unit2_lmblast && (emax5[cid].brout_valid & (1LL<<i)))<<i);              /* 最後のbrout_valid ★★★ */
    if ((unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) && (emax5[cid].brout_valid & (1LL<<i)) && !unit[cid][i][j].unit1_eneq) /* 最後から2つ目のbrout_valid ★★★ */
      unit[cid][i][j].unit2_lmblast = 1;
#endif
@


1.185
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.184 2017/01/30 05:35:28 nakashim Exp nakashim $";
d32 5
a36 5
  Ull   unit1_start;   /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:exec */
  Ull   unit1_arbrk;   /* exe finish */
  Ull   unit1_exec;    /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:exec */
  Ull   unit1_stop;    /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:stop */
  Ull   tr_valid;      /* 1bit corresponds to each row */
d40 1
a40 1
  Ull   unit2_guard;   /* LDDMQ should ignore unit1_stop */
d43 3
a45 3
  Ull   unit2_exec;    /* 1bit corresponds to each row (lmm),         0:wait 1:exec */
  Ull   unit2_stop;    /* 1bit corresponds to each row (lmm),         0:wait 1:stop */
  Ull   brout_valid;   /* 1bit corresponds to each row */
d133 2
a134 1
    Ull   lmwd_valid         : 1;
d674 2
d850 1
a850 1
	      if (emax5[cid].status==STATUS_EXEC && lmmc_stat==11) { /* LDDMQ lmm->lmrd(addr) */
d858 1
d874 1
a874 1
	      else if (emax5[cid].status==STATUS_EXEC && lmmc_stat==15) { /* TR lmm->lmrd(addr) */
d1412 2
a1413 2
  emax5[cid].unit2_eag_aen |= (1LL<<i);
  emax5[cid].unit2_eag_den |= (1LL<<i);
d1417 6
a1422 4
      if (!((!unit[cid][i][j].one_shot_a || unit[cid][i][j].lmwd_valid) && unit[cid][i][j].unit1_eneq)) /* inactive */
	emax5[cid].unit2_eag_aen &= ~(1LL<<i);
      if (!unit[cid][i][j].lmwd_valid) /* inactive */
	emax5[cid].unit2_eag_den &= ~(1LL<<i);
d1425 4
a1428 2
      if (!((!unit[cid][i][j].one_shot_a || unit[cid][i][j].tcureg_ready) && unit[cid][i][j].unit1_eneq)) /* inactive */
	emax5[cid].unit2_eag_aen &= ~(1LL<<i);
d1911 2
a1912 2
    emax5[cid].unit2_lmbrk |= ((Ull)(unit[cid][i][j].unit2_lmblast && (emax5[cid].brout_valid & (1LL<<i)))<<i);        /* 最後のbrout_valid */
    if ((unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) && (emax5[cid].brout_valid & (1LL<<i)) && !unit[cid][i][j].unit1_eneq) /* 最後から2つ目のbrout_valid */
@


1.184
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.183 2017/01/30 01:42:30 nakashim Exp nakashim $";
d169 1
a169 1
  Ull   tcureg_valid : 1;  /* wire(from fsm) */
d1367 1
a1367 1
    unit[cid][i][j].tcureg_valid = emax5[cid].fsm[j].tcureg_valid;
d1419 1
a1419 1
      if (!((!unit[cid][i][j].one_shot_a || unit[cid][i][j].tcureg_valid) && unit[cid][i][j].unit1_eneq)) /* inactive */
d1902 2
a1903 2
    emax5[cid].unit2_guard       |= ((Ull)(unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ)<<i);
    emax5[cid].unit2_lmbrk       |= ((Ull)(unit[cid][i][j].unit2_lmblast && (emax5[cid].brout_valid & (1LL<<i)))<<i);        /* 最後のbrout_valid */
@


1.183
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.182 2017/01/29 16:24:11 nakashim Exp nakashim $";
d1998 1
@


1.182
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.181 2017/01/29 14:23:53 nakashim Exp nakashim $";
d1117 2
a1118 1
          sync = 0; /* not finished */
@


1.181
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.180 2017/01/29 14:00:23 nakashim Exp nakashim $";
d1219 3
a1221 3
printf("==start=%08.8x arbrk=%08.8x 1exec=%08.8x 1stop=%08.8x eagaen=%08.8x eagden=%08.8x guard=%08.8x lmbrk=%08.8x 2exec=%08.8x 2stop=%08.8x\n",
       (Uint)emax5[cid].unit1_start,(Uint)emax5[cid].unit1_arbrk,(Uint)emax5[cid].unit1_exec,(Uint)emax5[cid].unit1_stop,
       (Uint)emax5[cid].unit2_eag_aen,(Uint)emax5[cid].unit2_eag_den,(Uint)emax5[cid].unit2_guard,(Uint)emax5[cid].unit2_lmbrk,(Uint)emax5[cid].unit2_exec,(Uint)emax5[cid].unit2_stop);
d1902 3
a1904 2
    emax5[cid].unit2_lmbrk       |= ((Ull)(unit[cid][i][j].unit2_lmblast && (emax5[cid].brout_valid & (1LL<<i)))<<i);
    unit[cid][i][j].unit2_lmblast = ((unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) && (emax5[cid].brout_valid & (1LL<<i)) && ~unit[cid][i][j].unit1_eneq); /* raackは全stageに対し1のため,unit毎にop比較が必要 */
@


1.180
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.179 2017/01/29 11:50:50 nakashim Exp nakashim $";
a1221 2
printf(">>tr_valid=%08.8x\n", (Uint)emax5[cid].tr_valid);
printf(">>br_valid=%08.8x\n", (Uint)emax5[cid].brout_valid);
a1419 2
printf("bus3: row=%d col=%d OP_TR: one_shot_a=%d tcureg_valid=%d eneq=%d eag_aen=%08.8x\n", 
       i, j, unit[cid][i][j].one_shot_a, unit[cid][i][j].tcureg_valid, unit[cid][i][j].unit1_eneq, (Uint)emax5[cid].unit2_eag_aen);
a1522 3
if (i==3 && j==0)
printf("row3,col0,ADD r1=%08.8x d=%08.8x unit1_exec=%08.8x brout_valid=%08.8x\n", (Uint)r1, (Uint)d,
       (Uint)emax5[cid].unit1_exec, (Uint)emax5[cid].brout_valid);
a1571 3
if (i==5 && j==3) {
printf("XXXXeas row=5,col=3 ea1d=%08.8x, ea0d=%08.8x \n", (Uint)unit[cid][i][j].ea1d,(Uint)unit[cid][i][j].ea0d);
}
d1786 6
a1791 1
      unit[cid][i][j].one_shot = 1; /* set one_shot here */
a1810 3
if (i==3 && j==2)
printf("row3,col2,mws0=%d exdr0=%08.8x exdmux0=%08.8x\n", unit[cid][i][j].conf.cdw2.mws0, (Uint)unit[cid][i][0].exdr, (Uint)exdmux[0]);

a1886 3
if (i==3 && j==2)
printf("row3,col2,mws0=%d exdsft=%08.8x mw00=%08.8x\n", unit[cid][i][j].conf.cdw2.mws0, (Uint)exdsft[0], (Uint)unit[cid][i][j].lmm.mw0[0]);

a2030 2
if (i==2 && j==0)
printf("row2,col0,brs0=%d tr0=%08.8x br0=%08.8x\n", unit[cid][i][j].conf.cdw2.brs0, (Uint)unit[cid][i][j].tr[0], (Uint)unit[cid][i][j].regv.br[0]);
@


1.179
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.178 2017/01/28 02:00:22 nakashim Exp nakashim $";
d1422 2
d1579 3
d1701 15
@


1.178
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.177 2017/01/26 23:10:37 nakashim Exp nakashim $";
d36 1
d45 1
a169 2
  Ull   tr_valid     : 1;  /* reg (internal) */
  Ull   brout_valid  : 1;  /* reg (internal) */
d319 1
d334 1
d339 1
d341 1
d1219 5
d1427 24
d1469 1
a1469 1
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) { /* active */
d1504 1
a1504 1
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) { /* active */
d1525 3
d1670 1
a1670 1
      if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) { /* active */
d1697 1
a1697 1
      if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) { /* active */
a1710 5
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].unit2_lmblast = (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) & unit[cid][i][j].lmwd_valid & unit[cid][i][j].unit1_eneq; /* raackは全stageに対し1のため,unit毎にop比較が必要 */
    emax5[cid].unit2_guard       |= ((Ull)(unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ)<<i);
    emax5[cid].unit2_lmbrk       |= ((Ull)(unit[cid][i][j].unit2_lmblast & unit[cid][i][j].tr_valid)<<i);
#endif
d1763 1
a1763 1
    unit[cid][i][j].tr_valid = 0;
d1775 1
a1775 1
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) /* active */
d1796 3
d1875 3
d1892 3
a1894 12
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ || unit[cid][i][j].conf.cdw1.ea1op == OP_IM_BUFRD) {
      if (!unit[cid][i][j].tr_valid)
	unit[cid][i][j].tr_valid = (emax5[cid].unit2_eag_den>>i&1);
      else
	unit[cid][i][j].tr_valid = 0;
    }
    else {
      if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) /* active */
	unit[cid][i][j].tr_valid = 1;
      else
	unit[cid][i][j].tr_valid = 0;
    }
a1955 3
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].brout_valid = 0;
#endif
d2022 2
a2054 3
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].brout_valid = unit[cid][i][j].tr_valid;
#endif
@


1.177
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.176 2017/01/26 22:47:46 nakashim Exp nakashim $";
d668 1
a668 1
		    emax5[cid].fsm[j].tcureg_valid = 1; /*★★★*/
d1359 1
a1359 1
    unit[cid][i][j].tcureg_valid = emax5[cid].fsm[j].tcureg_valid; /*★★★*/
d1411 1
a1411 1
      if (!((!unit[cid][i][j].one_shot_a || unit[cid][i][j].tcureg_valid) && unit[cid][i][j].unit1_eneq)) /* inactive */ /*★★★*/
d1668 1
d1855 1
a1855 1
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) {
d1857 1
a1857 1
	unit[cid][i][j].tr_valid = unit[cid][i][j].lmwd_valid;
@


1.176
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.175 2017/01/26 07:49:58 nakashim Exp nakashim $";
d668 1
a668 1
		    emax5[cid].fsm[j].tcureg_valid = 1;
d1359 1
a1359 1
    unit[cid][i][j].tcureg_valid = emax5[cid].fsm[j].tcureg_valid;
d1411 1
a1411 1
      if (!((!unit[cid][i][j].one_shot_a || unit[cid][i][j].tcureg_valid) && unit[cid][i][j].unit1_eneq)) /* inactive */
d1436 1
a1436 1
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) { /* ★★★active */
d1471 1
a1471 1
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) { /* ★★★active */
d1600 1
a1600 1
      if (emax5[cid].unit2_eag_aen & (1LL<<i)) { /* ★★★active */
d1611 1
a1611 1
      if (emax5[cid].unit2_eag_aen & (1LL<<i)) { /* ★★★active */
d1622 1
a1622 1
      if (emax5[cid].unit2_eag_den & (1LL<<i)) { /* ★★★active */
d1634 1
a1634 1
      if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) { /* ★★★active */
d1661 1
a1661 1
      if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) { /* ★★★active */
d1743 1
a1743 1
    if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) /* ★★★active */
d1861 1
a1861 1
      if ((emax5[cid].unit1_start & (1LL<<i)) || ((emax5[cid].unit1_exec & (1LL<<i)) && unit[cid][(i+EMAX_DEPTH-1)%EMAX_DEPTH][j].brout_valid)) /* ★★★active */
@


1.175
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.174 2017/01/26 05:48:35 nakashim Exp nakashim $";
d32 4
a35 3
  Ull   unit1_arbrk;/* exe finish */
  Ull   unit1_exec; /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:exec */
  Ull   unit1_stop; /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:stop */
d39 2
a40 2
  Ull   unit2_guard;/* LDDMQ should ignore unit1_stop */
  Ull   unit2_lmbrk;/* lmm finish */
d42 2
a43 2
  Ull   unit2_exec; /* 1bit corresponds to each row (lmm),         0:wait 1:exec */
  Ull   unit2_stop; /* 1bit corresponds to each row (lmm),         0:wait 1:stop */
d132 3
a153 2

    Ull   tcureg[UNIT_WIDTH]    ; /* tcu-data      of tcu                         v                     */
d167 1
d340 2
a341 1
        emax5[cid].unit1_exec |= emax5[cid].fsm[0].row_select;
d668 1
d1358 2
a1359 1
    unit[cid][i][j].lmwd_valid = emax5[cid].fsm[j].lmwd_valid;
d1411 1
a1411 1
      if (!((!unit[cid][i][j].one_shot_a /* ★★★ARMのACK追加要★★★*/) && unit[cid][i][j].unit1_eneq)) /* inactive */
d1436 1
a1436 3
    if (!(emax5[cid].unit1_exec & (1LL<<i))) /* ★★★non-active */
      unit[cid][i][j].cexdr = 0; /* always non-exec */
    else { /* active */
d1471 1
a1471 3
    if (!(emax5[cid].unit1_exec & (1LL<<i))) /* ★★★non-active */
      unit[cid][i][j].exdr = 0LL; /* always non-exec */
    else { /* active */
d1634 1
a1634 1
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* ★★★active */
d1661 1
a1661 1
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* ★★★active */
d1743 1
a1743 1
    if (emax5[cid].unit1_exec & (1LL<<i)) /* ★★★active */
d1861 1
a1861 1
      if (emax5[cid].unit1_exec & (1LL<<i)) /* ★★★active */
@


1.174
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.173 2017/01/25 23:00:29 nakashim Exp nakashim $";
d1405 1
a1405 1
      if (!((!unit[cid][i][j].one_shot_a                              ) && unit[cid][i][j].unit1_eneq)) /* inactive */
d1430 1
a1430 1
    if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active */
d1467 1
a1467 1
    if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active */
d1598 1
a1598 1
      if (emax5[cid].unit2_eag_aen & (1LL<<i)) { /* active */
d1609 1
a1609 1
      if (emax5[cid].unit2_eag_aen & (1LL<<i)) { /* active */
d1620 1
a1620 1
      if (emax5[cid].unit2_eag_den & (1LL<<i)) { /* active */
d1632 1
a1632 1
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
d1659 1
a1659 1
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
d1741 1
a1741 1
    if (emax5[cid].unit1_exec & (1LL<<i)) /* active */
d1859 1
a1859 1
      if (emax5[cid].unit1_exec & (1LL<<i))
d2026 1
a2026 6
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) {
      unit[cid][i][j].brout_valid = unit[cid][i][j].tr_valid;
    }
    else {
      unit[cid][i][j].brout_valid = 1;
    }
@


1.173
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.172 2017/01/25 15:07:58 nakashim Exp nakashim $";
d36 2
a37 1
  Ull   unit2_row_en1;
d160 2
a161 1
  Ull   one_shot_d   : 1;  /* reg (internal) *//* for self_loop_control 0:init 1:self_loop */
d325 1
a325 1
      siml_unit_bus3(cid, i); /* unit2_row_en1 */
d1390 1
a1390 1
siml_unit_bus3(cid, i) Uint cid, i; /* unit2_row_en1を計算 */
d1394 2
d1398 9
a1406 7
    if ((unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ)
      && !((!unit[cid][i][j].one_shot_d || unit[cid][i][j].lmwd_valid) && unit[cid][i][j].unit1_eneq)) { /* inactive */
      break;
    }
    else if ((unit[cid][i][j].conf.cdw1.ea1op == OP_TR)
      && !((!unit[cid][i][j].one_shot_d                              ) && unit[cid][i][j].unit1_eneq)) { /* inactive */
      break;
a1409 4
  if (j < EMAX_WIDTH) /* suspend row */
    emax5[cid].unit2_row_en1 &= ~(1LL<<i);
  else /* normal */
    emax5[cid].unit2_row_en1 |= (1LL<<i);
d1496 50
d1598 1
a1598 1
      if (emax5[cid].unit2_row_en1 & (1LL<<i)) { /* active */
d1609 1
a1609 1
      if (emax5[cid].unit2_row_en1 & (1LL<<i)) { /* active */
d1620 1
a1620 1
      if (emax5[cid].unit2_row_en1 & (1LL<<i)) { /* active */
a1682 44
siml_unit_eas(cid, i, j) Uint cid, i, j; /* 全bus計算後にreg更新 */
{
  Ull base0, offs0;
  Ull base1, offs1;

  /* ea[01][bo] -> ea[01]dr,ma */
  switch (emax5[cid].status) {
  case STATUS_IDLE:
  case STATUS_CONF:
  case STATUS_SCON:
  case STATUS_LMMI:
  case STATUS_DRAIN: /* fsm drain */
  case STATUS_LOAD: /* fsm pload */
    return (0);
  case STATUS_REGV:
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].unit1_eneq  = 0; /* reset */
#endif
  case STATUS_START:
    return (0);
  case STATUS_EXEC:
    base0 = (!(unit[cid][i][j].conf.cdw1.ea0bs&1) || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
    offs0 = (!(unit[cid][i][j].conf.cdw1.ea0bs&1) ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ || unit[cid][i][j].conf.cdw1.ea1op == OP_TR || unit[cid][i][j].conf.cdw1.ea1op == OP_IM_BUFRD) {
#ifndef IGNORE_LDDMQ_HANDSHAKE
      base1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) || !unit[cid][i][j].one_shot_d)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
      offs1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) ||  unit[cid][i][j].one_shot_d)?unit[cid][i][j].ea1o:0LL;
#endif
    }
    else {
      base1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
      offs1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
    }
    eag(&unit[cid][i][j].ea0d, base0, offs0, unit[cid][i][j].conf.cdw1.ea0msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
    eag(&unit[cid][i][j].ea1d, base1, offs1, unit[cid][i][j].conf.cdw1.ea1msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].unit1_eneq = (unit[cid][i][j].ea1d != unit[cid][i][j].ea0d);
#endif
    return (0);
  case STATUS_TERM:
    return (0);
  }
}

d1727 1
d1736 4
a1739 1
    unit[cid][i][j].one_shot_d = unit[cid][i][j].one_shot; 
@


1.172
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.170 2017/01/23 21:43:13 nakashim Exp nakashim $";
d584 1
d587 1
d651 1
d667 1
d776 1
d785 1
a818 1
printf("===LDDMQ AREQ3 ->MEMIF_DREQ in row=%d col=%d\n", i, j);
d1393 1
d1402 1
a1545 1
printf("===LDDMQ one_shot_d=%d lmwd_valid=%d eneq=%d ea1d=%08.8x ea0d=%08.8x\n", unit[cid][i][j].one_shot_d, unit[cid][i][j].lmwd_valid, unit[cid][i][j].unit1_eneq, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1551 1
a1551 1
printf("===LDDMQ row=%d col=%d one_shot_d=%d lmwd_valid=%d eneq=%d ea1d=%08.8x ea0d=%08.8x en1=1\n", i, j, unit[cid][i][j].one_shot_d, unit[cid][i][j].lmwd_valid, unit[cid][i][j].unit1_eneq, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
a1556 1
printf("===TR one_shot_d=%d lmwd_valid=%d eneq=%d ea1d=%08.8x ea0d=%08.8x\n", unit[cid][i][j].one_shot_d, unit[cid][i][j].lmwd_valid, unit[cid][i][j].unit1_eneq, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1562 1
a1562 1
printf("===TR row=%d col=%d one_shot_d=%d lmwd_valid=%d eneq=%d ea1d=%08.8x ea0d=%08.8x en1=1\n", i, j, unit[cid][i][j].one_shot_d, unit[cid][i][j].lmwd_valid, unit[cid][i][j].unit1_eneq, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
a1567 1
printf("===BUFRD one_shot_d=%d lmwd_valid=%d eneq=%d ea1d=%08.8x ea0d=%08.8x\n", unit[cid][i][j].one_shot_d, unit[cid][i][j].lmwd_valid, unit[cid][i][j].unit1_eneq, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1573 1
a1573 1
printf("===BUFRD row=%d col=%d one_shot_d=%d lmwd_valid=%d eneq=%d ea1d=%08.8x ea0d=%08.8x en1=1\n", i, j, unit[cid][i][j].one_shot_d, unit[cid][i][j].lmwd_valid, unit[cid][i][j].unit1_eneq, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1777 1
d1783 1
d1798 1
d1931 1
d1960 1
@


1.171
log
@*** empty log message ***
@
text
@d36 1
d308 1
a308 4
      for (j=EMAX_WIDTH-1; j>=0; j--) { /* for each unit */
        /**************************/
        /****** do lmm ************/
        /**************************/
a309 1
      }
d321 1
a321 1
        siml_unit_eag(cid, i, j); /* eadr,ma (unit2_guard,unit2_lmbrk) */
d323 3
d812 2
a813 1
		else if (emax5[cid].status==STATUS_EXEC && lmmc_stat==11) /* LDDMQ lmm->lmrd(addr) */
d815 1
a831 3
		/*-----------------------------------------------------------------------*/
		/*---ここから ★★★ ここにLDDMQを追加 ★★★ ---------------------------*/
		/*-----------------------------------------------------------------------*/
d842 2
a843 2
		      printf("%03.3d:siml_emax5: load row=%d col=%d lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
d1383 20
d1487 1
a1487 1
siml_unit_eag(cid, i, j) Uint cid, i, j; /* 全bus計算後にreg更新 */
a1522 3
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].unit1_eneq  = 0; /* reset */
#endif
a1525 17
    base0 = (!(unit[cid][i][j].conf.cdw1.ea0bs&1) || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
    offs0 = (!(unit[cid][i][j].conf.cdw1.ea0bs&1) ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ || unit[cid][i][j].conf.cdw1.ea1op == OP_TR) {
#ifndef IGNORE_LDDMQ_HANDSHAKE
      base1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) || !unit[cid][i][j].one_shot_d)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
      offs1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) ||  unit[cid][i][j].one_shot_d)?unit[cid][i][j].ea1o:0LL;
#endif
    }
    else {
      base1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
      offs1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
    }
    eag(&unit[cid][i][j].ea0d, base0, offs0, unit[cid][i][j].conf.cdw1.ea0msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
    eag(&unit[cid][i][j].ea1d, base1, offs1, unit[cid][i][j].conf.cdw1.ea1msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
#ifndef IGNORE_LDDMQ_HANDSHAKE
    unit[cid][i][j].unit1_eneq = (unit[cid][i][j].ea1d != unit[cid][i][j].ea0d);
#endif
d1538 3
a1540 3
    else if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ /* eag0->WRITE,eag1->READ *//* 読み出し側はbase+offsを使用 */
          || unit[cid][i][j].conf.cdw1.ea1op == OP_TR) { /* eag0->WRITE,eag1->READ *//* 読み出し側はbase+offsを使用 */
      if ((!unit[cid][i][j].one_shot_d || unit[cid][i][j].lmwd_valid) && unit[cid][i][j].unit1_eneq) { /* active */
d1545 25
a1569 1
printf("===LDDMQ/TR row=%d col=%d one_shot_d=%d lmwd_valid=%d eneq=%d ea1d=%08.8x ea0d=%08.8x en1=1\n", i, j, unit[cid][i][j].one_shot_d, unit[cid][i][j].lmwd_valid, unit[cid][i][j].unit1_eneq, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1627 44
a1777 12
    case OP_TR: /* ●●● mws=1 */
      for (k=0; k<UNIT_WIDTH; k++) {
	unit[cid][i][j].lmm.mm0[k] = (unit[cid][i][j].cexdr&1)?0xffffffffffffffffLL:0LL; /* mask */
	exdsft[k] = exdmux[k]; /* not used */
      }
printf("OP_TR: mws=%d%d%d%d exdsft=%08.8x %08.8x %08.8x %08.8x\n",
       unit[cid][i][j].conf.cdw2.mws3,
       unit[cid][i][j].conf.cdw2.mws2,
       unit[cid][i][j].conf.cdw2.mws1,
       unit[cid][i][j].conf.cdw2.mws0,
       (Uint)exdmux[3], (Uint)exdmux[2], (Uint)exdmux[1], (Uint)exdmux[0]);
      break;
d1786 6
d1918 2
a1919 1
     || unit[cid][i][j].conf.cdw1.ea1op == OP_TR) {
a1931 2
if (unit[cid][i][j].conf.cdw1.ea1op == OP_LDRQ)
printf("LDRQ: LMM->mr1 %08.8x %08.8x %08.8x %08.8x\n",(Uint)unit[cid][i][j].lmm.mr1[3],(Uint)unit[cid][i][j].lmm.mr1[2],(Uint)unit[cid][i][j].lmm.mr1[1],(Uint)unit[cid][i][j].lmm.mr1[0]);
@


1.170
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.169 2017/01/23 06:57:35 nakashim Exp nakashim $";
d658 5
a662 1
printf("===TR AREQ1 in row=%d col=%d\n", i, j);
d778 1
a778 1
printf("===TR AREQ2 in row=%d col=%d\n", i, j);
d812 1
a812 2
		else if (emax5[cid].status==STATUS_EXEC && lmmc_stat==11) { /* LDDMQ lmm->lmrd(addr) */
printf("===LDDMQ AREQ3 ->MEMIF_DREQ in row=%d col=%d\n", i, j);
a813 1
		}
d815 1
a815 1
printf("===TR AREQ3 in row=%d col=%d\n", i, j);
d834 1
a837 1
printf("===LDDMQ DREQ1 ->MEMIF_AREQ in row=%d col=%d\n", i, j);
a838 1
printf("===LDDMQ DREQ1 in row=%d col=%d\n", i, j);
a841 1
		    emax5[cid].fsm[j].lmwd_valid = 1;
d843 2
a844 2
		    printf("%03.3d:siml_emax5: load row=%d col=%d lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
d846 1
a850 1
printf("===LDDMQ DREQ1 in row=%d col=%d lmwd_valid=0\n", i, j);
d856 1
a856 1
printf("===TR DREQ1 in row=%d col=%d\n", i, j);
a1540 1
printf("===LDDMQ/TR one_shot_d=%d lmwd_valid=%d eneq=%d ea1d=%08.8x ea0d=%08.8x\n", unit[cid][i][j].one_shot_d, unit[cid][i][j].lmwd_valid, unit[cid][i][j].unit1_eneq, (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1546 1
a1546 1
printf("===LDDMQ/TR en1=1\n");
d1555 1
a1555 1
        unit[cid][i][j].lmm.en1 = 1;
d1716 6
d1870 2
@


1.169
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.168 2017/01/23 01:34:57 nakashim Exp nakashim $";
a768 1
printf("===LDDMQ AREQ2 in row=%d col=%d\n", i, j);
@


1.168
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.167 2017/01/22 12:40:29 nakashim Exp nakashim $";
a1854 1
printf("===LMM row=%d col=%d rrdy=1\n", i, j);
@


1.167
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.166 2017/01/22 11:25:43 nakashim Exp nakashim $";
d128 1
a128 1
    Ull   raack              : 1;
a159 1
  Ull   fsm_raack    : 1;  /* reg (from fsm) */
d810 1
a810 1
printf("===LDDMQ AREQ3 in row=%d col=%d\n", i, j);
a811 1
		  emax5[cid].fsm[j].raack = 1;
a828 3
printf("===LDDMQ DREQ1 in row=%d col=%d\n", i, j);
		if (emax5[cid].fsm[j].raack)
		  emax5[cid].fsm[j].raack = 0;
d830 1
a830 1
		/*---ここから------------------------------------------------------------*/
d832 21
a863 1
		/* ★★★ ここにLDDMQを追加 ★★★ */
d1348 1
a1348 1
    unit[cid][i][j].fsm_raack = emax5[cid].fsm[j].raack;
d1542 2
a1543 2
      if ((!unit[cid][i][j].one_shot_d || unit[cid][i][j].fsm_raack) && unit[cid][i][j].unit1_eneq) { /* active */
printf("===LDDMQ/TR ea1d=%08.8x ea0d=%08.8x\n", (Uint)unit[cid][i][j].ea1d, (Uint)unit[cid][i][j].ea0d);
d1548 1
d1596 1
a1596 1
    unit[cid][i][j].unit2_lmblast = (unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ) & unit[cid][i][j].fsm_raack & unit[cid][i][j].unit1_eneq; /* raackは全stageに対し1のため,unit毎にop比較が必要 */
d1855 1
@


1.166
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.165 2017/01/22 09:30:22 nakashim Exp nakashim $";
d651 6
a656 2
printf("===LDDMQ AREQ1 in row=%d col=%d\n", i, j);

d771 3
d807 1
a807 1
		if (emax5[cid].status==STATUS_CONF)
a808 4
		else if (emax5[cid].status==STATUS_REGV)
		  emax5[cid].fsm[j].axi_arvalid = 0;	
		else if (emax5[cid].status==STATUS_LMMI)
		  emax5[cid].fsm[j].axi_arvalid = 0;	
d834 3
@


1.165
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.164 2017/01/22 08:11:07 nakashim Exp nakashim $";
d816 2
a817 2
		else if (emax5[cid].status==STATUS_DRAIN                                /* drain */
                 ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1)) /* pdrain */
@


1.164
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.163 2017/01/22 07:09:59 nakashim Exp nakashim $";
d585 2
a586 8
	    else if (lmmc_stat==11                             ) {         /*     LDDMQ */
	      mark = 1;
printf("===LDDMQ detected in row=%d col=%d\n", i, j);
	    }
	    else if (lmmc_stat==15                             ) {         /*     TR */
	      mark = 1;
printf("===TR detected in row=%d col=%d\n", i, j);
	    }
d652 1
d825 2
d832 2
d838 2
d905 2
d1071 3
a1073 2
            }
          }
@


1.163
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.162 2017/01/22 06:18:36 nakashim Exp nakashim $";
d777 1
a777 1
			 ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1)) { /* pdrain *//* address should be 8B-aligned *//* length should be # of dwords */
d805 1
a805 4
		if (emax5[cid].status==STATUS_DRAIN                                     /* drain */
                 ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1)) /* pdrain */
		  emax5[cid].fsm[j].axi_awvalid = 0;
		else /* STATUS_CONF, STATUS_REGV, STATUS_LMMI, STATUS_LOAD, STATUS_EXEC&rw==0 */
d807 4
d812 3
a814 1
		if (lmmc_stat==11 && emax5[cid].fsm[j].axi_arready)
d816 4
d821 5
d830 3
a832 1
		if (lmmc_stat==11 && emax5[cid].fsm[j].raack)
d834 4
d839 2
a840 2
              if (emax5[cid].status==STATUS_DRAIN                                       /* drain */
               ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1)) { /* pdrain */
d959 2
a960 2
		  else if (emax5[cid].status==STATUS_LOAD                                          /* load */
                        ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw == 0)) { /* pload */
@


1.162
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.161 2017/01/22 02:34:45 nakashim Exp nakashim $";
d614 1
a614 11
		if      (emax5[cid].status==STATUS_DRAIN) { /* drain */
		  emax5[cid].fsm[j].axi_awvalid = 1;
		  emax5[cid].fsm[j].awaddr = (mode==1)?emax5[cid].fsm[j].lmmo[i].top:emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
		  emax5[cid].fsm[j].awlen  = (mode==1)?emax5[cid].fsm[j].lmmo[i].len:emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		}
		else if (emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1) { /* pdrain */
		  emax5[cid].fsm[j].axi_awvalid = 1;
		  emax5[cid].fsm[j].awaddr = emax5[cid].fsm[j].lmmc[i].top+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* address should be 8B-aligned */
		  emax5[cid].fsm[j].awlen  = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		}
		else if (emax5[cid].status==STATUS_CONF) {
d656 16
d770 6
@


1.161
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.160 2017/01/21 13:55:14 nakashim Exp nakashim $";
d1459 1
d1462 1
@


1.160
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.159 2017/01/21 13:49:04 nakashim Exp nakashim $";
a159 1
  Ull   unit1_eneqr  : 1;  /* reg (internal) */
a161 1
  Ull   lmrd_valid   : 1;  /* wire(from fsm) */
d180 2
d587 1
a587 1
	      printf("===LDDMQ detected in row=%d col=%d\n", i, j);
d591 1
a591 1
	      printf("===TR detected in row=%d col=%d\n", i, j);
a1451 1
    unit[cid][i][j].unit1_eneqr = 0; /* reset */
d1456 15
d1472 1
a1472 5
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_DRAIN
     || unit[cid][i][j].conf.cdw1.ea1op == OP_LDDMQ
     || unit[cid][i][j].conf.cdw1.ea1op == OP_TR) {
	                          /* OP_TR   の場合,eag0->WRITE,eag1->READ *//* ★★★読み出し側をbase+offsを使うよう要修正★★★ */
	                          /* OP_LDDMQの場合,eag0->WRITE,eag1->READ *//* ★★★読み出し側をbase+offsを使うよう要修正★★★ */
d1474 1
a1476 1
        unit[cid][i][j].ea1dr = unit[cid][i][j].lmra;
d1482 14
d1498 1
a1498 3
        base1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
        offs1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
        eag(&unit[cid][i][j].ea1dr, base1, offs1, unit[cid][i][j].conf.cdw1.ea1msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
a1511 2
        unit[cid][i][j].lmm.en0 = 1;
        unit[cid][i][j].lmm.rw0 = 1; /* write */
d1516 2
d1525 1
a1525 3
        base0 = (!(unit[cid][i][j].conf.cdw1.ea0bs&1) || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
        offs0 = (!(unit[cid][i][j].conf.cdw1.ea0bs&1) ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
        eag(&unit[cid][i][j].ea0dr, base0, offs0, unit[cid][i][j].conf.cdw1.ea0msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
a1537 1
    /* update unit1_eneq */
a1540 2
    unit[cid][i][j].unit1_eneqr   = unit[cid][i][j].unit1_eneq;
    unit[cid][i][j].unit1_eneq    = (unit[cid][i][j].ea1dr != unit[cid][i][j].ea0dr);
@


1.159
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.158 2017/01/21 09:56:16 nakashim Exp nakashim $";
d1348 1
a1348 1
    if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active *//* ★★★ */
d1385 1
a1385 1
    if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active *//* ★★★ */
d1473 1
a1473 1
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active *//* ★★★ */
d1502 1
a1502 1
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active *//* ★★★ */
d1585 1
a1585 1
    if (emax5[cid].unit1_exec & (1LL<<i)) /* active *//* ★★★ */
@


1.158
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.157 2017/01/21 09:53:09 nakashim Exp nakashim $";
d332 2
a333 2
        emax5[cid].unit1_stop  &= ~(1LL<<i); /* ★★★ */
        emax5[cid].unit2_stop  &= ~(1LL<<i); /* ★★★ */
d336 1
a336 1
        emax5[cid].unit1_exec |= emax5[cid].fsm[0].row_select; /* ★★★ */
d339 4
a342 4
	unit1_stop_next = ((emax5[cid].unit1_arbrk &(1LL<<i))||(emax5[cid].unit1_stop                        &(1LL<<i))||(emax5[cid].unit2_stop&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))?(1LL<<i):0; /* ★★★ */
	unit1_exec_next = (                                    (emax5[cid].unit1_exec                        &(1LL<<i))||(emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))))?(1LL<<i):0; /* ★★★ */
	unit2_stop_next = ((emax5[cid].unit2_lmbrk &(1LL<<i))||(emax5[cid].unit1_stop&~emax5[cid].unit2_guard&(1LL<<i))||(emax5[cid].unit2_stop&(1LL<<((i             )           ))))?(1LL<<i):0; /* ★★★ */
	unit2_exec_next = (                                    (emax5[cid].unit1_exec                        &(1LL<<i))||(emax5[cid].unit2_exec&(1LL<<((i             )           ))))?(1LL<<i):0; /* ★★★ */
d537 1
a537 1
        if (emax5[cid].unit1_exec | emax5[cid].unit2_exec) /* exec not finished *//* ★★★ */
d579 1
a579 1
	    /* ★★★ 同一列に複数リクエストがある場合どうするか ★★★ */
d582 1
a582 3
	    /*    ・TRは(案1)AXIにWrite-req(固定アドレスストア),ARM引渡し */
	    /*          (案2)EMAX制御Regにストア,ARM引き継ぎ              */

@


1.157
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.156 2017/01/21 09:30:09 nakashim Exp nakashim $";
d1866 6
a1871 1
    unit[cid][i][j].brout_valid = unit[cid][i][j].tr_valid;
@


1.156
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.155 2017/01/21 06:24:51 nakashim Exp nakashim $";
d1578 1
a1579 12
    if (emax5[cid].fsm[j].row_select & (1LL<<i)) {
      for (k=0; k<UNIT_WIDTH; k++) {
        switch (unit[cid][i][j].lmwa) {
        case 0: /* lower */
          *((Ull*)&unit[cid][i][j].regv+0+k) = unit[cid][i][j].lmwd[k];
          break;
        case 1: /* upper */
          *((Ull*)&unit[cid][i][j].regv+4+k) = unit[cid][i][j].lmwd[k];
          break;
        }
      }
    }
d1756 16
d1865 3
@


1.155
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.154 2017/01/20 04:32:03 nakashim Exp nakashim $";
d35 1
d38 1
d315 1
d318 1
d1705 14
@


1.154
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.153 2017/01/19 15:50:07 nakashim Exp nakashim $";
d32 1
a32 1
  Ull   unit1_arbrk;
d35 2
d159 1
a161 1
  Ull   fsm_raack    : 1;  /* reg (from fsm) */
d313 2
d320 2
a321 2
        siml_unit_exe(cid, i, j); /* exdr */
        siml_unit_eag(cid, i, j); /* eadr,ma */
d328 2
a329 2
        emax5[cid].unit1_stop &= ~(1LL<<i); /* ★★★ */
        emax5[cid].unit2_stop &= ~(1LL<<i); /* ★★★ */
d335 4
a338 4
	unit1_stop_next = ((emax5[cid].unit1_arbrk &(1LL<<i)) || (emax5[cid].unit1_stop&(1LL<<i)) || (emax5[cid].unit2_stop&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) ? (1LL<<i): 0; /* ★★★ */
	unit1_exec_next = (                                      (emax5[cid].unit1_exec&(1LL<<i)) || (emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))) ? (1LL<<i): 0; /* ★★★ */
	unit2_stop_next = (                                      (emax5[cid].unit1_stop&(1LL<<i)) || (emax5[cid].unit2_stop&(1LL<<((i             )           )))) ? (1LL<<i): 0; /* ★★★ */
	unit2_exec_next = (                                      (emax5[cid].unit1_exec&(1LL<<i)) || (emax5[cid].unit2_exec&(1LL<<((i             )           )))) ? (1LL<<i): 0; /* ★★★ */
d1517 3
a1519 1
    unit[cid][i][j].unit2_lmblast = unit[cid][i][j].fsm_raack & unit[cid][i][j].unit1_eneq;
@


1.153
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.152 2017/01/19 05:06:52 nakashim Exp nakashim $";
d123 4
d792 4
d799 4
d1285 4
a1288 1
    unit[cid][i][j].lmra = emax5[cid].fsm[j].lmra;
d1444 4
d1511 6
d1565 4
a1568 1
    unit[cid][i][j].one_shot = 0; /* reset one_shot here */
d1585 3
@


1.152
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.151 2017/01/07 02:53:39 nakashim Exp nakashim $";
d32 1
d292 1
a292 1
    Ull prev1_stop, prev2_stop;
a295 2
    prev1_stop =  emax5[cid].unit1_stop; /* ★★★ */
    prev2_stop =  emax5[cid].unit2_stop; /* ★★★ */
d306 1
d327 8
a334 6
        emax5[cid].unit2_stop |= ( prev1_stop           &(1LL<<  i                          ))                                      ? (1LL<<i): 0; /* ★★★ */
        emax5[cid].unit1_stop |= ( prev2_stop           &(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))                                      ? (1LL<<i): 0; /* ★★★ */
        emax5[cid].unit2_exec &= (                                                                  emax5[cid].unit2_stop&(1LL<<i) )?~(1LL<<i):~0; /* ★★★ */
        emax5[cid].unit2_exec |= ((emax5[cid].unit1_exec&(1LL<<  i                          )) && !(emax5[cid].unit2_stop&(1LL<<i)))? (1LL<<i): 0; /* ★★★ */
        emax5[cid].unit1_exec &= (                                                                  emax5[cid].unit1_stop&(1LL<<i) )?~(1LL<<i):~0; /* ★★★ */
        emax5[cid].unit1_exec |= ((emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))) && !(emax5[cid].unit1_stop&(1LL<<i)))? (1LL<<i): 0; /* ★★★ */
d1385 1
a1385 1
      if (retval) emax5[cid].unit1_stop |= (1LL<<i);/* ★★★ */
@


1.151
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.150 2016/12/26 13:54:57 nakashim Exp nakashim $";
d148 11
d295 2
a296 2
    prev1_stop =  emax5[cid].unit1_stop;
    prev2_stop =  emax5[cid].unit2_stop;
d320 2
a321 2
        emax5[cid].unit1_stop &= ~(1LL<<i);
        emax5[cid].unit2_stop &= ~(1LL<<i);
d324 1
a324 1
        emax5[cid].unit1_exec |= emax5[cid].fsm[0].row_select;
d327 6
a332 6
        emax5[cid].unit2_stop |= ( prev1_stop           &(1LL<<  i                          ))                                      ? (1LL<<i): 0;
        emax5[cid].unit1_stop |= ( prev2_stop           &(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))                                      ? (1LL<<i): 0;
        emax5[cid].unit2_exec &= (                                                                  emax5[cid].unit2_stop&(1LL<<i) )?~(1LL<<i):~0;
        emax5[cid].unit2_exec |= ((emax5[cid].unit1_exec&(1LL<<  i                          )) && !(emax5[cid].unit2_stop&(1LL<<i)))? (1LL<<i): 0;
        emax5[cid].unit1_exec &= (                                                                  emax5[cid].unit1_stop&(1LL<<i) )?~(1LL<<i):~0;
        emax5[cid].unit1_exec |= ((emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))) && !(emax5[cid].unit1_stop&(1LL<<i)))? (1LL<<i): 0;
d446 1
a446 1
      /*                        ★1 lmmc=lmr,lmmo.top!=lmmc.top,の場合, load before next exec           */
d449 1
a449 1
      /*                        ★2 lmmo=lmw,lmmc!=lmd,dirty=1の場合, writeback before next exec        */
d454 1
a454 1
      /*                        ★3 lmmc=lmfの場合, load always before next exec                        */
d457 1
a457 1
      /*                        ★2 lmmo=lmw,lmmc!=lmd,dirty=1の場合, writeback before next exec        */
d463 2
a464 2
      /*                        ★3 lmmc=lmxの場合, load always before next exec                        */
      /*                        ★4 lmmc=lmx,dirty=1の場合, writeback before next exec                  */
d472 2
a473 2
      /*                        ★1 lmmc=lmr,lmmo.top!=lmmc.topの場合, load before next exec            */
      /*                        ★5 lmmc=lmpの場合, load top+ofs(ofs=0) with next exec                  */
d476 1
a476 1
      /*                        ★6 lmmc=lmd,dirty=1の場合, drain top+ofs(ofs=0) with next exec         */
d483 1
a483 1
      /*                        ★7 lmmc=lmp,lmmo.top+ofs!=lmmc.topの場合, load top+ofs before next exec*/
d486 1
a486 1
      /*                        ★6 lmmc=lmd,dirty=1の場合, drain top+ofs with next exec                */
d523 1
a523 1
        if (emax5[cid].unit1_exec | emax5[cid].unit2_exec) /* exec not finished */
d546 2
a547 2
            if      (mode==1 && (lmmo_stat==12 && lmmc_stat!=13) && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ★2 lmw&!lmd drain */
            else if (mode==1 && (lmmo_stat==14                 ) && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ★4 lmx      drain */
d552 3
a554 3
            if      (lmmc_stat== 8               && !lmm_ready)  mark = 1; /* ★1 lmr & !ready */
            else if (lmmc_stat== 9 && !lmmc_ofsz && !lmm_readz)  mark = 1; /* ★7 lmr & !readz */
            else if (lmmc_stat==10 || lmmc_stat==14)             mark = 1; /* ★3 lmf/lmx always load */
d558 1
a558 1
	    /* ★★★ OP_IM_PREF,OP_IM_DRAIN,OP_LDDMQ,OP_TRが処理対象 ★★★ */
d571 2
a572 2
            if      (lmmc_stat== 9                             ) mark = 1; /* ★5 lmp */
            else if (lmmc_stat==13 && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ★6 lmd & dirty */
d574 1
a574 1
	      mark = 0;
d578 1
a578 1
	      mark = 0;
d1325 1
a1325 1
    if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active */
d1362 1
a1362 1
    if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active */
d1383 1
a1383 1
      if (retval) emax5[cid].unit1_stop |= (1LL<<i);
d1434 2
a1435 2
	                          /* OP_TR   の場合,eag0->WRITE,eag1->READ */
	                          /* OP_LDDMQの場合,eag0->WRITE,eag1->READ */
d1446 1
a1446 1
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
d1475 1
a1475 1
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
d1555 1
a1555 1
    if (emax5[cid].unit1_exec & (1LL<<i)) /* active */
d1608 1
a1608 1
    case OP_TR: /* ★★★ mws=1 */
d1614 1
a1614 1
    case OP_LDDMQ: /* ★★★ mws=0 */
@


1.150
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.149 2016/12/26 10:44:19 nakashim Exp nakashim $";
d100 1
a100 1
    Ull   blksize            :10; /* 1:128 2:256 3:512 dwords */
@


1.149
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.148 2016/12/25 06:18:10 nakashim Exp nakashim $";
d912 1
a913 1
			emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
d926 1
a927 1
			emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
@


1.148
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.146 2016/12/23 08:02:35 nakashim Exp nakashim $";
d587 8
a594 28
	      /*****************************************/
	      /* AXI用加工前アドレスおよび長さをセット */
	      /*****************************************/
              emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[j].ardyc = 0; /* LMM addr-ready(read)                                 */
	      emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read), AXI data-ready(rvalid) counter */
              if      (emax5[cid].status==STATUS_DRAIN) { /* drain */
		emax5[cid].fsm[j].axi_awvalid = 1;
                emax5[cid].fsm[j].awaddr = (mode==1)?emax5[cid].fsm[j].lmmo[i].top:emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
                emax5[cid].fsm[j].awlen  = (mode==1)?emax5[cid].fsm[j].lmmo[i].len:emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
              }
              else if (emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1) { /* pdrain */
		emax5[cid].fsm[j].axi_awvalid = 1;
                emax5[cid].fsm[j].awaddr = emax5[cid].fsm[j].lmmc[i].top+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* address should be 8B-aligned */
                emax5[cid].fsm[j].awlen  = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
              }
              else if (emax5[cid].status==STATUS_CONF) {
		emax5[cid].fsm[j].axi_arvalid = 1;
                emax5[cid].fsm[j].araddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*j; /* address should be 32B-aligned */
                emax5[cid].fsm[j].arlen  =                  UNIT_WIDTH*EMAX_DEPTH-1; /* length should be # of dwords */
		if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		  int i;
		  conf_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		  printf(" EMAX_DUMP_DDR(conf=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		  if (emax5[cid].fsm[j].araddr == conf)
		    fprintf(fp_conf, "ddr_conf_top = 40\'h%08.8x;\n", (Uint)emax5[cid].fsm[j].araddr);
		  for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),conf_p++)
		    fprintf(fp_conf, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)((*conf_p)>>32), (Uint)(*conf_p));
d596 18
a613 13
	      }
              else if (emax5[cid].status==STATUS_REGV) {
		emax5[cid].fsm[j].axi_arvalid = 1;
                emax5[cid].fsm[j].araddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*j; /* address should be 32B-aligned */
                emax5[cid].fsm[j].arlen  =                  UNIT_WIDTH*2*EMAX_DEPTH-1; /* length should be # of dwords */
		if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		  int i;
		  regv_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		  printf(" EMAX_DUMP_DDR(regv=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		  if (emax5[cid].fsm[j].araddr == regv)
		    fprintf(fp_regv, "ddr_regv_top = 40\'h%08.8x;\n", (Uint)emax5[cid].fsm[j].araddr);
		  for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),regv_p++)
		    fprintf(fp_regv, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)((*regv_p)>>32), (Uint)(*regv_p));
d615 13
a627 13
              }
              else if (emax5[cid].status==STATUS_LMMI) {
		emax5[cid].fsm[j].axi_arvalid = 1;
                emax5[cid].fsm[j].araddr = lmmi+sizeof(Ull)*UNIT_WIDTH/2*EMAX_DEPTH*j; /* address should be 32B-aligned */
                emax5[cid].fsm[j].arlen  =                  UNIT_WIDTH/2*EMAX_DEPTH-1; /* length should be # of dwords */
		if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		  int i;
		  lmmi_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		  printf(" EMAX_DUMP_DDR(lmmi=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		  if (emax5[cid].fsm[j].araddr == lmmi)
		    fprintf(fp_lmmi, "ddr_lmmi_top = 40\'h%08.8x;\n", (Uint)emax5[cid].fsm[j].araddr);
		  for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),lmmi_p++)
		    fprintf(fp_lmmi, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)(*(lmmi_p)>>32), (Uint)(*lmmi_p));
d629 13
a641 61
              }
	      /*** NORMAL ************/
	      /* --- single-load --- : fsmが1回のみburst起動                              */
	      /* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	      /* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	      /* align=32B, block=0, blocking=none             ... align済      4倍幅load */

	      /*** GATHER ************/
	      /* --- blocking-load --- : fsmがblock単位にburst起動                        */
	      /* align=32B, block=1, blocksize=8*4*16=512B *MAXPAGE_PVE = 64KB  for LMM   */
	      /* align=32B, block=2, blocksize=8*4*32=1KB  *MAXPAGE_PVE = 128KB for LMM   */
	      /* align=32B, block=3, blocksize=8*4*64=2KB  *MAXPAGE_PVE = 256KB for LMM   */ 

	      /* 総転送topは,emax5[cid].fsm[j].lmmc[i].top                                */
	      /*  pref_topは,emax5[cid].fsm[j].lmmc[i].top+emax5[cid].fsm[j].lmmc[i].ofs  */
	      /* 総転送lenは,emax5[cid].fsm[j].lmmc[i].len                                */
	      /*                blkstat    = 0                                            */
	      /*                blkcount   = 0                                            */
	      /*                             emax5[cid].fsm[j].lmmc[i].len/blksize 7bit   */
	      /*                                                 MAX= 64KB/MAX=512 7bit   */
	      /*                                                 MAX=128KB/MAX=1KB 7bit   */
	      /*                                                 MAX=256KB/MAX=2KB 7bit   */
	      /*                blktop[4]    (ddr-data -> ddr-addr)                       */
	      /*                lmmblktop  = 0                                            */
	      /*                lmmblklen  = emax5[cid].fsm[j].lmmc[i].len #dwords        */
	      /* MEMIF_AREQ:                                                              */
	      /*                  memif_status = MEMIF_DREQ                               */
	      /*                  ardyc     = 0                             #4dwords      */
	      /*                  rrdyc     = 0                             #4dwords      */
	      /*  FSM_BLKSTAT=0:  araddr    = emax5[cid].fsm[j].lmmc[i].top(+ofs)+blkcount/4*32 */
	      /*                  arlen     = 3 (64bit*4) 使用dataは64bit*4               */
	      /*                  blksize   = 32<<lmm.blk                   #dwords       */
	      /*  FSM_BLKSTAT=1:  araddr    = blktop[blkcount%4]                          */
	      /*                  arlen     = (lmmblklen<blksize)?lmmblklen:blksize       */
	      /*                  lmmblklen = (lmmblklen<blksize)?0:(lmmblklen-blksize)   */
	      /*                lmm_nreq  = arlen/UNIT_WIDTH                              */
	      /* MEMIF_DREQ:                                                              */
	      /*  FSM_BLKSTAT=0: blktop[3:0]  = axi_rdata[3:0] .. 有効ptrが最大4個        */
	      /*                 FSM_BLKSTAT  = 1                                         */
              /*                 memif_status = MEMIF_AREQ                                */
	      /*  FSM_BLKSTAT=1: if (rrdyc<lmm_nreq)                                      */
	      /*                   lmwa    = lmmblktop+rrdyc*32                           */
	      /*                 else                                                     */
	      /*                   if ((blkcount&3)==3 || lmmblklen==0) FSM_BLKSTAT = 0   */
	      /*                   if (lmmblklen==0) { row_count++; blkcount=0}           */
	      /*                   else              { blkcount++ }                       */
	      /*                   lmmblktop += blksize*8                                 */
              /*                   memif_status = MEMIF_AREQ                              */
	      /*                 if (axi_rvalid)                                          */
	      /*                   lmwd[4] = axi_rdata[4]                                 */
	      /*                   rrdyc++                                                */
	      else if (emax5[cid].status==STATUS_LOAD                                        /* load */
                    ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload *//* address should be 8B-aligned *//* length should be # of dwords */
		emax5[cid].fsm[j].axi_arvalid = 1;
		if (emax5[cid].fsm[j].lmmc[i].blk==0) { /* inf */
		  if (emax5[cid].status==STATUS_LOAD)
		    emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
		  else
		    emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* address should be 8B-aligned */
		  emax5[cid].fsm[j].arlen      = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		  emax5[cid].fsm[j].blksize    = 0; /* max:10bit */
d643 54
a696 4
#ifndef IGNORE_LMMI_BLKGATHER
		else { /* 16,32,64 */
		  switch (emax5[cid].fsm[j].blkstat) {
		  case 0: /* PTRLIST */
d698 1
a698 1
		      emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+emax5[cid].fsm[j].blkcount/4*32; /* address should be 8B-aligned */
d700 31
a730 11
		      emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+emax5[cid].fsm[j].blkcount/4*32+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* address should be 8B-aligned */
		    emax5[cid].fsm[j].arlen     = 3; /* 4 dwords */
		    emax5[cid].fsm[j].blksize   = 32<<emax5[cid].fsm[j].lmmc[i].blk; /* max:10bit */
		    if (emax5[cid].fsm[j].blkcount==0)
		      emax5[cid].fsm[j].lmmblklen = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		    break;
		  case 1: /* VERTEXLIST */
		    emax5[cid].fsm[j].araddr    = emax5[cid].fsm[j].blktop[emax5[cid].fsm[j].blkcount%4]; /* address should be 8B-aligned */
		    emax5[cid].fsm[j].arlen     = (emax5[cid].fsm[j].lmmblklen<emax5[cid].fsm[j].blksize)?emax5[cid].fsm[j].lmmblklen:emax5[cid].fsm[j].blksize-1;
		    emax5[cid].fsm[j].lmmblklen = (emax5[cid].fsm[j].lmmblklen<emax5[cid].fsm[j].blksize)?0:(emax5[cid].fsm[j].lmmblklen-emax5[cid].fsm[j].blksize);
		    break;
d733 19
a751 7
#endif
		if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		  int i;
		  load_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		  printf(" EMAX_DUMP_DDR(load=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		  for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),load_p++)
		    fprintf(fp_load, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)(*(load_p)>>32), (Uint)(*load_p));
d753 11
a763 19
              }
	      /*************************************/
	      /* check align and set mask/lmm_nreq */
	      /*************************************/
	      if      (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV || emax5[cid].status==STATUS_LMMI) { /* address should be 32B-aligned *//* length should be # of dwords */
		emax5[cid].fsm[j].lmm_nreq   = emax5[cid].fsm[j].arlen/UNIT_WIDTH;
		emax5[cid].fsm[j].axi_araddr = emax5[cid].fsm[j].araddr;
		emax5[cid].fsm[j].axi_arlen  = emax5[cid].fsm[j].lmm_nreq;
	      }
              else if (emax5[cid].status==STATUS_DRAIN                                       /* drain */
                    ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1)) { /* pdrain *//* address should be 8B-aligned *//* length should be # of dwords */
		emax5[cid].fsm[j].lmm_fmask = 0xf << ( (emax5[cid].fsm[j].awaddr/sizeof(Ull)                        ) & (UNIT_WIDTH-1));
		emax5[cid].fsm[j].lmm_lmask = 0xf >> (~(emax5[cid].fsm[j].awaddr/sizeof(Ull)+emax5[cid].fsm[j].awlen) & (UNIT_WIDTH-1));
		emax5[cid].fsm[j].lmm_nreq  = ((emax5[cid].fsm[j].awaddr/sizeof(Ull)+emax5[cid].fsm[j].awlen)/UNIT_WIDTH) - ((emax5[cid].fsm[j].awaddr/sizeof(Ull))/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
		emax5[cid].fsm[j].axi_awaddr = emax5[cid].fsm[j].awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1);
		emax5[cid].fsm[j].axi_awlen  = emax5[cid].fsm[j].lmm_nreq;
		if (emax5[cid].fsm[j].lmm_nreq==0) {
		  emax5[cid].fsm[j].lmm_fmask &= emax5[cid].fsm[j].lmm_lmask;
		  emax5[cid].fsm[j].lmm_lmask &= emax5[cid].fsm[j].lmm_fmask;
d766 9
a774 11
	      else if (emax5[cid].status==STATUS_LOAD                                        /* load */
                    ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload *//* address should be 8B-aligned *//* length should be # of dwords */
		emax5[cid].fsm[j].lmm_fmask = 0xf << ( (emax5[cid].fsm[j].araddr/sizeof(Ull)                        ) & (UNIT_WIDTH-1));
		emax5[cid].fsm[j].lmm_lmask = 0xf >> (~(emax5[cid].fsm[j].araddr/sizeof(Ull)+emax5[cid].fsm[j].arlen) & (UNIT_WIDTH-1));
		emax5[cid].fsm[j].lmm_nreq  = ((emax5[cid].fsm[j].araddr/sizeof(Ull)+emax5[cid].fsm[j].arlen)/UNIT_WIDTH) - ((emax5[cid].fsm[j].araddr/sizeof(Ull))/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
		emax5[cid].fsm[j].axi_araddr = emax5[cid].fsm[j].araddr & ~(sizeof(Ull)*UNIT_WIDTH-1);
		emax5[cid].fsm[j].axi_arlen  = emax5[cid].fsm[j].lmm_nreq;
		if (emax5[cid].fsm[j].lmm_nreq==0) {
		  emax5[cid].fsm[j].lmm_fmask &= emax5[cid].fsm[j].lmm_lmask;
		  emax5[cid].fsm[j].lmm_lmask &= emax5[cid].fsm[j].lmm_fmask;
		}
a780 1
		emax5[cid].fsm[j].axi_awvalid = 0;
d801 1
a801 1
		else { /* バースト転送終了 */
d833 1
a833 1
		else { /* バースト転送終了 */
a843 1
		emax5[cid].fsm[j].axi_arvalid = 0;
d845 1
d858 1
d893 1
a893 1
		else { /* バースト転送終了 */
d896 1
a896 1
		    emax5[cid].fsm[j].row_select   = 0LL;
d903 1
a903 1
		      /*emax5[cid].fsm[j].row_select &= ~(1LL<<i);*/
d942 1
d946 1
d950 1
d997 3
@


1.147
log
@*** empty log message ***
@
text
@d9 1
a9 1
/* emax5.c 2012/9/22 */
@


1.146
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.145 2016/12/22 09:47:51 nakashim Exp nakashim $";
d516 2
d520 1
a520 1
          int lmmc_stat = ((emax5[cid].fsm[j].lmmc[i].v & ~emax5[cid].fsm[j].lmmc[i].copy & ((emax5[cid].fsm[j].lmmc[i].f&emax5[cid].fsm[j].lmmc[i].p) | emax5[cid].fsm[j].lmmc[i].top!=0))<<3)
a522 1
	  int lmmc_ofsz =  (emax5[cid].fsm[j].lmmc[i].ofs == 0);
@


1.145
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.144 2016/12/21 03:12:42 nakashim Exp nakashim $";
a385 2
	emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
d389 2
a403 2
	  emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	  emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
d407 2
a826 2
		  emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
		  emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
d830 2
a890 2
		      emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
		      emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
d895 2
a1027 2
	  emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	  emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
d1031 2
a1036 2
	  emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	  emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
d1040 2
a1049 2
	emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
d1053 2
a1079 2
	emax5[cid].fsm[j].blkstat  = 0; /* ptrlist */
	emax5[cid].fsm[j].blkcount = 0; /* dword/dword: 7bit */
d1083 2
@


1.144
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.143 2016/12/21 02:49:30 nakashim Exp nakashim $";
d1622 1
a1622 1
    /* explicit trs[3-0]: 0:exdr[], 1:t[], 2:lmwd[] */
@


1.143
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.142 2016/12/21 00:09:13 nakashim Exp nakashim $";
d1689 3
a1691 1
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_DRAIN) {
@


1.142
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.141 2016/12/18 21:28:13 nakashim Exp nakashim $";
d1405 2
a1406 2
     || unit[cid][i][j].conf.cdw1.ea0op == OP_LDDMQ
     || unit[cid][i][j].conf.cdw1.ea0op == OP_TR) {
@


1.141
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.140 2016/12/18 12:14:22 nakashim Exp nakashim $";
a120 2
    Ull   axra                  ; /* <- ea0dr                     -       -           v                 */
    Ull   axwa                  ; /* <- ea1dr (not used)                      -                         */
a170 2
  Ull   axra            ;  /* wire *//* <- ea0dr */
  Ull   axwa            ;  /* wire *//* <- ea1dr .. not used */
d518 2
a519 1
          int lmmc_stat = ((emax5[cid].fsm[j].lmmc[i].v & ~emax5[cid].fsm[j].lmmc[i].copy & (emax5[cid].fsm[j].lmmc[i].top!=0))<<3)
d546 13
d561 8
d770 1
a1425 1
        unit[cid][i][j].axwa    = unit[cid][i][j].ea1dr;
a1456 2
        unit[cid][i][j].axra    = unit[cid][i][j].ea0dr;
	                          /* fsmがアドレス比較しea1から取り出す */
d1581 1
a1581 1
    case OP_TR: /* ★★★★ mws=1 */
d1587 1
a1587 1
    case OP_LDDMQ: /* ★★★★ mws=0 */
d1915 1
a1915 1
    printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
d1919 1
a1919 5
           (Uint) emax5[cid].fsm[col].lmra,
           (Uint)(emax5[cid].fsm[col].axra>>32),
           (Uint) emax5[cid].fsm[col].axra,
           (Uint)(emax5[cid].fsm[col].axwa>>32),
           (Uint) emax5[cid].fsm[col].axwa);
a2174 8
    printf("axraaxwa");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x                                  ",
             (Uint)(unit[cid][row][col].axra>>32),
             (Uint) unit[cid][row][col].axra,
             (Uint)(unit[cid][row][col].axwa>>32),
             (Uint) unit[cid][row][col].axwa);
    printf("\n");
@


1.140
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.139 2016/12/18 07:41:16 nakashim Exp nakashim $";
d1702 2
a1703 4
	if (unit[cid][i][j].conf.cdw1.ea0op != OP_LDDMQ
         && unit[cid][i][j].conf.cdw1.ea0op != OP_TR
         && unit[cid][i][j].conf.cdw1.ea0op != OP_IM_BUFWR)
	  unit[cid][i][j].drty = 1; /* mark dirty (OP_TRとOP_LDDMQは除外が必要) */
@


1.139
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.138 2016/12/17 02:38:42 nakashim Exp nakashim $";
d1703 2
a1704 1
         && unit[cid][i][j].conf.cdw1.ea0op != OP_TR)
@


1.138
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.137 2016/12/16 03:18:07 nakashim Exp nakashim $";
d1385 5
a1389 1
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_DRAIN) {
d1436 2
d1440 1
d1702 3
a1704 1
	unit[cid][i][j].drty = 1; /* mark dirty */
@


1.137
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.136 2016/12/15 01:51:56 nakashim Exp nakashim $";
d520 4
a523 2
          int lmmo_stat = ((emax5[cid].fsm[j].lmmo[i].v                                  )<<3)|(emax5[cid].fsm[j].lmmo[i].rw<<2)|(emax5[cid].fsm[j].lmmo[i].f<<1)|(emax5[cid].fsm[j].lmmo[i].p); /* v|rw|f|p */
          int lmmc_stat = ((emax5[cid].fsm[j].lmmc[i].v & ~emax5[cid].fsm[j].lmmc[i].copy)<<3)|(emax5[cid].fsm[j].lmmc[i].rw<<2)|(emax5[cid].fsm[j].lmmc[i].f<<1)|(emax5[cid].fsm[j].lmmc[i].p); /* v|rw|f|p */
d656 1
a656 1
	      /*                  blksize   = 64<<lmm.blk                   #dwords       */
d659 1
a659 1
	      /*                  lmmblklen-= (lmmblklen<blksize)?0:(lmmblklen-blksize)   */
d674 1
a674 1
	      /*                   lmwd[4] = rdata[4]                                     */
d695 4
a698 2
		    emax5[cid].fsm[j].arlen      = 3; /* 4 dwords */
		    emax5[cid].fsm[j].blksize    = 64<<emax5[cid].fsm[j].lmmc[i].blk; /* max:10bit */
d701 3
a703 3
		    emax5[cid].fsm[j].araddr     = emax5[cid].fsm[j].blktop[emax5[cid].fsm[j].blkcount%4]; /* address should be 8B-aligned */
		    emax5[cid].fsm[j].arlen      = (emax5[cid].fsm[j].lmmblklen<emax5[cid].fsm[j].blksize)?emax5[cid].fsm[j].lmmblklen:emax5[cid].fsm[j].blksize;
		    emax5[cid].fsm[j].lmmblklen -= (emax5[cid].fsm[j].lmmblklen<emax5[cid].fsm[j].blksize)?0:(emax5[cid].fsm[j].lmmblklen-emax5[cid].fsm[j].blksize);
d883 2
d887 12
a923 3
#if 0
		    /* LD.blk!=0の場合,状態遷移を使う複数バーストと.axi_rdata->次axiアドレスが必要 */
#endif
d932 6
a937 4
		      emax5[cid].fsm[j].row_lmm_en |= (1LL<<i); /* 水平方向broadcastの送出はここ */
		      for (k=0; k<EMAX_WIDTH; k++) {
			if (emax5[cid].fsm[j].lmmc[i].bcas & (1<<k))
			  emax5[cid].fsm[k].row_lmm_en |= (1LL<<i);
d939 13
@


1.136
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.135 2016/12/11 00:43:07 nakashim Exp nakashim $";
d97 9
d390 2
d408 2
d639 6
a644 2
	      /*                blksize    = 64<<lmm.blk                   #dwords        */
	      /*                blkcount   = 0..MAXPAGE_PVE-1(127) 7bit                   */
a647 1
	      /*                rrdyc      = 0                             #4dwords       */
d649 10
a658 9
	      /*  FSM_BLKSTAT=0: memif_status = MEMIF_DREQ                                */
	      /*                 araddr    = emax5[cid].fsm[j].lmmc[i].top(+ofs)+blkcount/4*32 */
	      /*                 arlen     = 0 (64bit*4) 使用dataは64bit*4                */
	      /*                 lmm_nreq  = arlen/UNIT_WIDTH                             */
	      /*  FSM_BLKSTAT=1: memif_status = MEMIF_DREQ                                */
	      /*                 araddr    = blktop[blkcount%4]                           */
	      /*                 arlen     = (lmmblklen<blksize)?lmmblklen:blksize        */
	      /*                 lmmblklen-= (lmmblklen<blksize)?0:(lmmblklen-blksize)    */
	      /*                 lmm_nreq  = arlen/UNIT_WIDTH                             */
d667 3
a669 2
	      /*                   if (lmmblklen==0) row_count++                          */
	      /*                   blkcount++                                             */
d674 27
a700 12
              else if (emax5[cid].status==STATUS_LOAD) { /* load */
		switch (emax5[cid].fsm[j].lmmc[i].blk) {
		case 0: /* inf */
		  emax5[cid].fsm[j].axi_arvalid = 1;
		  emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
		  emax5[cid].fsm[j].arlen  = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		  if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		    int i;
		    load_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		    printf(" EMAX_DUMP_DDR(load=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		    for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),load_p++)
		      fprintf(fp_load, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)(*(load_p)>>32), (Uint)(*load_p));
a701 10
		  break;
		case 1: /* 16 */
		  printf("emax5[%d].fsm[%d].lmmc[%d].blk=%d not supported\n", cid, j, i, emax5[cid].fsm[j].lmmc[i].blk);
		  break;
		case 2: /* 32 */
		  printf("emax5[%d].fsm[%d].lmmc[%d].blk=%d not supported\n", cid, j, i, emax5[cid].fsm[j].lmmc[i].blk);
		  break;
		case 3: /* 64 */
		  printf("emax5[%d].fsm[%d].lmmc[%d].blk=%d not supported\n", cid, j, i, emax5[cid].fsm[j].lmmc[i].blk);
		  break;
d703 7
a709 24
              }
              else if (emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0) { /* pload */
		switch (emax5[cid].fsm[j].lmmc[i].blk) {
		case 0: /* inf */
		  emax5[cid].fsm[j].axi_arvalid = 1;
		  emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* address should be 8B-aligned */
		  emax5[cid].fsm[j].arlen  = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		  if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		    int i;
		    load_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		    printf(" EMAX_DUMP_DDR(load=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		    for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),load_p++)
		      fprintf(fp_load, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)(*(load_p)>>32), (Uint)(*load_p));
		  }
		  break;
		case 1: /* 16 */
		  printf("emax5[%d].fsm[%d].lmmc[%d].blk=%d not supported\n", cid, j, i, emax5[cid].fsm[j].lmmc[i].blk);
		  break;
		case 2: /* 32 */
		  printf("emax5[%d].fsm[%d].lmmc[%d].blk=%d not supported\n", cid, j, i, emax5[cid].fsm[j].lmmc[i].blk);
		  break;
		case 3: /* 64 */
		  printf("emax5[%d].fsm[%d].lmmc[%d].blk=%d not supported\n", cid, j, i, emax5[cid].fsm[j].lmmc[i].blk);
		  break;
d804 2
d835 22
a856 2
#if 0
		    /* LD.blk!=0の場合,状態遷移を使う複数バーストと.lmwa先頭=0設定が必要 */
a857 5
		    emax5[cid].fsm[j].lmwa = (emax5[cid].fsm[j].araddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) + emax5[cid].fsm[j].rrdyc*sizeof(Ull)*UNIT_WIDTH;
		    if (trace) {
		      printf("%03.3d:siml_emax5: load row=%d col=%d lmwa=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa, emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
		    }
d867 17
a883 3
		    emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
#if 0
		    /* LD.blk!=0の場合,状態遷移を使う複数バーストと.lmwa先頭=0設定が必要 */
a884 3
		    emax5[cid].fsm[j].row_count++;
		    /*emax5[cid].fsm[j].row_select &= ~(1LL<<i);*/
		    /*emax5[cid].fsm[j].row_lmm_en &= ~(1LL<<i);*//* wait for data arrived from MEM */
d979 2
d988 2
d1001 2
d1031 2
@


1.135
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.134 2016/12/10 10:20:49 nakashim Exp nakashim $";
d619 4
a622 1
	      /* LD.blk!=0の場合,状態遷移を使う複数バーストと.lmwa先頭=0設定が必要        */
d626 6
a631 5

	      /* align=32B, block=1, blocksize=8*4*16=512B     ... 下位5bit無視 4倍幅load */
	      /* align=32B, block=2, blocksize=8*4*32=1KB      ... 下位5bit無視 4倍幅load */
	      /* align=32B, block=3, blocksize=8*4*64=2KB      ... 下位5bit無視 4倍幅load */
	      /*                 blkcount = 0                                             */
d633 9
a641 9
	      /*  FSM_BLKSTAT=0: araddr = emax5[cid].fsm[j].lmmc[i].top(+ofs)+blkcount*32 */
	      /*                 arlen  = 0 (64bit*4)                                     */
	      /*                 lmwa   = not-used                                        */
	      /*  FSM_BLKSTAT=1: araddr = blktop                                          */
	      /*                 arlen  = 0                     64bit*4                   */
	      /*                 lmwa   = rrdy*32                                         */
	      /*  FSM_BLKSTAT=0: araddr = emax5[cid].fsm[j].lmmc[i].top                   */
	      /*                 arlen  = 0;                    64bit*4                   */
	      /*                 lmwa   = not-used                                        */
d643 2
a644 1
	      /*  FSM_BLKSTAT=0: araddr = emax5[cid].fsm[j].lmmc[i].top(+ofs)+blkcount*32 */
d646 10
a655 1

d796 1
d872 3
@


1.134
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.133 2016/12/10 08:49:40 nakashim Exp nakashim $";
d611 2
a612 11
#if 0
	      /* LD.blk!=0の場合,状態遷移を使う複数バーストと.lmwa先頭=0設定が必要 */
	      /* 総転送topは,emax5[cid].fsm[j].lmmc[i].top */
	      /*  pref_topは,emax5[cid].fsm[j].lmmc[i].top+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs */
	      /* 総転送lenは,emax5[cid].fsm[j].lmmc[i].len */

	      /*** GATHER ************/
	      /* block 0:inf, 1:16, 2:32, 3:64 dword*UNIT_WIDTH*block=page(burst_size)    */
	      /* 通常は,     block=0                                                      */
	      /* tricountは, block=2                                                      */
	      /* EMAX5では必ず64bit*4幅                                                   */
d616 2
d619 5
d627 15
a641 15
	      switch (emax5[cid].fsm[j].lmmc[i].blk) {
	      case 0: /* inf */
		ofs =        (       emax5[cid].fsm[j].araddr                                         ) + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc   )*UNIT_WIDTH;
		break;
	      case 1: /* 16 */
		ofs = *(Ull*)(base + emax5[cid].fsm[j].araddr+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc%16)*UNIT_WIDTH; /* ★★★(DELAY) */
		break;
	      case 2: /* 32 */
		ofs = *(Ull*)(base + emax5[cid].fsm[j].araddr+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc%32)*UNIT_WIDTH; /* ★★★(DELAY) */
		break;
	      case 3: /* 64 */
		ofs = *(Ull*)(base + emax5[cid].fsm[j].araddr+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc%64)*UNIT_WIDTH; /* ★★★(DELAY) */
		break;
	      }
#endif
d643 22
a664 9
		emax5[cid].fsm[j].axi_arvalid = 1;
                emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
                emax5[cid].fsm[j].arlen  = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		  int i;
		  load_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		  printf(" EMAX_DUMP_DDR(load=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		  for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),load_p++)
		    fprintf(fp_load, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)(*(load_p)>>32), (Uint)(*load_p));
d668 22
a689 9
		emax5[cid].fsm[j].axi_arvalid = 1;
                emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* address should be 8B-aligned */
                emax5[cid].fsm[j].arlen  = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
		if ((flag & DUMP_DDR) && !dump_ddr_done) { /* dump once */
		  int i;
		  load_p = (Ull*)(base+emax5[cid].fsm[j].araddr);
		  printf(" EMAX_DUMP_DDR(load=%08.8x_%08.8x)\n", (Uint)(emax5[cid].fsm[j].araddr>>32), (Uint)emax5[cid].fsm[j].araddr);
		  for (i=0; i<=emax5[cid].fsm[j].arlen*sizeof(Ull); i+=sizeof(Ull),load_p++)
		    fprintf(fp_load, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)emax5[cid].fsm[j].araddr+i, (Uint)(*(load_p)>>32), (Uint)(*load_p));
@


1.133
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.132 2016/12/08 13:47:44 nakashim Exp nakashim $";
d513 3
d529 1
a529 1
	    else if (lmmc_stat== 9 && !lmmc_ofsz && !lmm_ready)  mark = 1; /* ★7 lmr & !ready */
@


1.132
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.131 2016/11/17 04:02:35 nakashim Exp nakashim $";
d476 1
a476 1
      /*      1  0  0  0 ... lmr       lmmoとlmmiが不一致ならdrainとregvの間にload                      prefetch/--   reuse/mload          */
d481 1
a481 1
      /*      1  0  0  1 ... lmp       lmmoとlmmiが不一致ならexecと同時にloadする                       prefetch/--   reuse/prefetch       */
d485 2
a512 3
          int lmm_readz =  (emax5[cid].fsm[j].lmmo[i].v && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
	                                                && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
	                                                &&(emax5[cid].fsm[j].lmmo[i].top+(Sll)(int)emax5[cid].fsm[j].lmmo[i].ofs) == emax5[cid].fsm[j].lmmc[i].top);
d525 2
a526 2
            if      (lmmc_stat== 8               && !lmm_ready)  mark = 1; /* ★1 lmr & !ready*/
	    else if (lmmc_stat== 9 && !lmmc_ofsz && !lmm_readz)  mark = 1; /* ★7 lmr & !readz*/
d608 33
d785 3
d803 3
a1061 28
#if 0
  /*** GATHER ************/
  /* block 0:inf, 1:16, 2:32, 3:64 dword*UNIT_WIDTH*block=page(burst_size)    */
  /* 通常は,     block=0                                                      */
  /* tricountは, block=2                                                      */
  /* EMAX5では必ず64bit*4幅                                                   */
  /* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
  /* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
  /* align=32B, block=0, blocking=none             ... align済 4倍幅load      */
  /* --- blocking-load --- : fsmがblock単位にburst起動                        */
  /* align=xxx, block=1, blocksize=8*4*16=512B     ... 下位5bit無視 4倍幅load */
  /* align=xxx, block=2, blocksize=8*4*32=1KB      ... 下位5bit無視 4倍幅load */
  /* align=xxx, block=3, blocksize=8*4*64=2KB      ... 下位5bit無視 4倍幅load */
  switch (emax5[cid].fsm[j].lmmc[i].blk) {
  case 0: /* inf */
    ofs =        (       emax5[cid].fsm[j].araddr                                         ) + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc   )*UNIT_WIDTH;
    break;
  case 1: /* 16 */
    ofs = *(Ull*)(base + emax5[cid].fsm[j].araddr+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc%16)*UNIT_WIDTH; /* ★★★(DELAY) */
    break;
  case 2: /* 32 */
    ofs = *(Ull*)(base + emax5[cid].fsm[j].araddr+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc%32)*UNIT_WIDTH; /* ★★★(DELAY) */
    break;
  case 3: /* 64 */
    ofs = *(Ull*)(base + emax5[cid].fsm[j].araddr+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc%64)*UNIT_WIDTH; /* ★★★(DELAY) */
    break;
  }
#endif
@


1.131
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.130 2016/11/15 15:51:44 nakashim Exp nakashim $";
d1472 13
a1484 13
    /* implicit trs[3-0]: 0:t[], 1:lmwd[] */
    if (unit[cid][i][j].conf.cdw1.ea0op == OP_LDDMQ) {
      unit[cid][i][j].tr[0] = unit[cid][i][j].lmwd[0];
      unit[cid][i][j].tr[1] = unit[cid][i][j].lmwd[1];
      unit[cid][i][j].tr[2] = unit[cid][i][j].lmwd[2];
      unit[cid][i][j].tr[3] = unit[cid][i][j].lmwd[3];
    }
    else {
      unit[cid][i][j].tr[0] = unit[cid][i][j].t[0];
      unit[cid][i][j].tr[1] = unit[cid][i][j].t[1];
      unit[cid][i][j].tr[2] = unit[cid][i][j].t[2];
      unit[cid][i][j].tr[3] = unit[cid][i][j].t[3];
    }
@


1.130
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.129 2016/11/15 12:57:23 nakashim Exp nakashim $";
d1323 1
a1323 1
  Ull exdrmsk[UNIT_WIDTH], exdrsft[UNIT_WIDTH];
a1380 28
    exdrsft[0] = unit[cid][i][j].conf.cdw2.mws0==0 ? unit[cid][i][j].exdr /* tr[3-0]はalign不要 */
               : unit[cid][i][j].conf.cdw2.mws0==1 ? unit[cid][i][0].exdr
               : unit[cid][i][j].conf.cdw2.mws0==2 ? unit[cid][i][j].t[0]
               : unit[cid][i][j].conf.cdw2.mws0==3 ? unit[cid][i][j].lmli[0]
               : unit[cid][i][j].conf.cdw2.mws0==4 ? unit[cid][i][j].lmwd[0]
               : unit[cid][i][j].conf.cdw2.mws0==5 ? unit[cid][i][j].lmri[0]
               :                                     0LL;
    exdrsft[1] = unit[cid][i][j].conf.cdw2.mws1==0 ? unit[cid][i][j].exdr
               : unit[cid][i][j].conf.cdw2.mws1==1 ? unit[cid][i][1].exdr
               : unit[cid][i][j].conf.cdw2.mws1==2 ? unit[cid][i][j].t[1]
               : unit[cid][i][j].conf.cdw2.mws1==3 ? unit[cid][i][j].lmli[1]
               : unit[cid][i][j].conf.cdw2.mws1==4 ? unit[cid][i][j].lmwd[1]
               : unit[cid][i][j].conf.cdw2.mws1==5 ? unit[cid][i][j].lmri[1]
               :                                     0LL;
    exdrsft[2] = unit[cid][i][j].conf.cdw2.mws2==0 ? unit[cid][i][j].exdr
               : unit[cid][i][j].conf.cdw2.mws2==1 ? unit[cid][i][2].exdr
               : unit[cid][i][j].conf.cdw2.mws2==2 ? unit[cid][i][j].t[2]
               : unit[cid][i][j].conf.cdw2.mws2==3 ? unit[cid][i][j].lmli[2]
               : unit[cid][i][j].conf.cdw2.mws2==4 ? unit[cid][i][j].lmwd[2]
               : unit[cid][i][j].conf.cdw2.mws2==5 ? unit[cid][i][j].lmri[2]
               :                                     0LL;
    exdrsft[3] = unit[cid][i][j].conf.cdw2.mws3==0 ? unit[cid][i][j].exdr
               : unit[cid][i][j].conf.cdw2.mws3==1 ? unit[cid][i][3].exdr
               : unit[cid][i][j].conf.cdw2.mws3==2 ? unit[cid][i][j].t[3]
               : unit[cid][i][j].conf.cdw2.mws3==3 ? unit[cid][i][j].lmli[3]
               : unit[cid][i][j].conf.cdw2.mws3==4 ? unit[cid][i][j].lmwd[3]
               : unit[cid][i][j].conf.cdw2.mws3==5 ? unit[cid][i][j].lmri[3]
               :                                     0LL;
d1382 17
d1403 1
a1403 1
	unit[cid][i][j].lmm.mw0[k] = exdrsft[k]; /* align不要 */
d1409 1
a1409 1
	unit[cid][i][j].lmm.mw0[k] = exdrsft[k]<<(a & sizeof(int))*8; /* align必要 */
d1415 1
a1415 1
	unit[cid][i][j].lmm.mw0[k] = exdrsft[k]<<(a & (sizeof(int)|sizeof(short)))*8; /* align必要 */
d1421 1
a1421 1
	unit[cid][i][j].lmm.mw0[k] = exdrsft[k]<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
d1428 1
a1428 1
	unit[cid][i][j].lmm.mw0[k] = exdrsft[k];
d1434 1
a1434 1
	unit[cid][i][j].lmm.mw0[k] = exdrsft[k]; /* not used */
d1439 1
a1439 1
      unit[cid][i][j].lmm.mw0[0] = exdrsft[0]; /* LDDMQ addr */
d1442 1
a1442 1
	unit[cid][i][j].lmm.mw0[k] = exdrsft[k]; /* LDDMQ addr */
d1446 26
@


1.129
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.128 2016/11/10 23:49:02 nakashim Exp nakashim $";
d1323 1
a1323 1
  Ull exdrmsk[UNIT_WIDTH], exdrsft;
d1380 29
d1412 4
a1415 3
      for (k=0; k<UNIT_WIDTH; k++)
	exdrmsk[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&2)?0xffffffff00000000LL:0LL)|((unit[cid][i][j].cexdr&1)?0x00000000ffffffffLL:0LL)) : 0LL; /* mask */
      exdrsft = unit[cid][i][j].exdr; /* align不要 */
d1418 4
a1421 3
      for (k=0; k<UNIT_WIDTH; k++)
	exdrmsk[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&1)?0x00000000ffffffffLL:0LL)<<(a & sizeof(int))*8) : 0LL; /* mask */
      exdrsft = unit[cid][i][j].exdr<<(a & sizeof(int))*8; /* align必要 */
d1424 4
a1427 3
      for (k=0; k<UNIT_WIDTH; k++)
	exdrmsk[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&1)?0x000000000000ffffLL:0LL)<<(a & (sizeof(int)|sizeof(short)))*8) : 0LL; /* mask */
      exdrsft = unit[cid][i][j].exdr<<(a & (sizeof(int)|sizeof(short)))*8; /* align必要 */
d1430 4
a1433 3
      for (k=0; k<UNIT_WIDTH; k++)
	exdrmsk[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&1)?0x00000000000000ffLL:0LL)<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8) : 0LL; /* mask */
      exdrsft = unit[cid][i][j].exdr<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
a1435 4
      for (k=0; k<UNIT_WIDTH; k++)
	exdrmsk[k] = 0xffffffffffffffffLL; /* mask */
      exdrsft = unit[cid][i][j].exdr;
      break;
d1437 4
d1443 4
a1446 3
      for (k=0; k<UNIT_WIDTH; k++)
	exdrmsk[k] = (unit[cid][i][j].cexdr&1)?0xffffffffffffffffLL:0LL; /* mask */
      exdrsft = unit[cid][i][j].exdr; /* not used */
d1449 6
a1454 4
      exdrmsk[0] = 0xffffffffffffffffLL; /* mask */
      for (k=1; k<UNIT_WIDTH; k++)
	exdrmsk[k] = 0LL; /* mask */
      exdrsft = unit[cid][i][j].exdr; /* LDDMQ addr */
a1456 37
    /* mws[3-0]: 0:exdr, 1:exdr0, 2:ts0, 3:lmli0, 4:lmwd0, 5:lmri0 */
    unit[cid][i][j].lmm.mm0[0] = unit[cid][i][j].conf.cdw2.mws0==0 ? exdrmsk[0]
                               : 0xffffffffffffffffLL; /* mask */
    unit[cid][i][j].lmm.mw0[0] = unit[cid][i][j].conf.cdw2.mws0==0 ? exdrsft /* tr[3-0]はalign不要 */
                               : unit[cid][i][j].conf.cdw2.mws0==1 ? unit[cid][i][0].exdr
                               : unit[cid][i][j].conf.cdw2.mws0==2 ? unit[cid][i][j].t[0]
                               : unit[cid][i][j].conf.cdw2.mws0==3 ? unit[cid][i][j].lmli[0]
                               : unit[cid][i][j].conf.cdw2.mws0==4 ? unit[cid][i][j].lmwd[0]
                               : unit[cid][i][j].conf.cdw2.mws0==5 ? unit[cid][i][j].lmri[0]
                               :                                     0LL;
    unit[cid][i][j].lmm.mm0[1] = unit[cid][i][j].conf.cdw2.mws1==0 ? exdrmsk[1]
                               : 0xffffffffffffffffLL; /* mask */
    unit[cid][i][j].lmm.mw0[1] = unit[cid][i][j].conf.cdw2.mws1==0 ? exdrsft
                               : unit[cid][i][j].conf.cdw2.mws1==1 ? unit[cid][i][1].exdr
                               : unit[cid][i][j].conf.cdw2.mws1==2 ? unit[cid][i][j].t[1]
                               : unit[cid][i][j].conf.cdw2.mws1==3 ? unit[cid][i][j].lmli[1]
                               : unit[cid][i][j].conf.cdw2.mws1==4 ? unit[cid][i][j].lmwd[1]
                               : unit[cid][i][j].conf.cdw2.mws1==5 ? unit[cid][i][j].lmri[1]
                               :                                     0LL;
    unit[cid][i][j].lmm.mm0[2] = unit[cid][i][j].conf.cdw2.mws2==0 ? exdrmsk[2]
                               : 0xffffffffffffffffLL; /* mask */
    unit[cid][i][j].lmm.mw0[2] = unit[cid][i][j].conf.cdw2.mws2==0 ? exdrsft
                               : unit[cid][i][j].conf.cdw2.mws2==1 ? unit[cid][i][2].exdr
                               : unit[cid][i][j].conf.cdw2.mws2==2 ? unit[cid][i][j].t[2]
                               : unit[cid][i][j].conf.cdw2.mws2==3 ? unit[cid][i][j].lmli[2]
                               : unit[cid][i][j].conf.cdw2.mws2==4 ? unit[cid][i][j].lmwd[2]
                               : unit[cid][i][j].conf.cdw2.mws2==5 ? unit[cid][i][j].lmri[2]
                               :                                     0LL;
    unit[cid][i][j].lmm.mm0[3] = unit[cid][i][j].conf.cdw2.mws3==0 ? exdrmsk[3]
                               : 0xffffffffffffffffLL; /* mask */
    unit[cid][i][j].lmm.mw0[3] = unit[cid][i][j].conf.cdw2.mws3==0 ? exdrsft
                               : unit[cid][i][j].conf.cdw2.mws3==1 ? unit[cid][i][3].exdr
                               : unit[cid][i][j].conf.cdw2.mws3==2 ? unit[cid][i][j].t[3]
                               : unit[cid][i][j].conf.cdw2.mws3==3 ? unit[cid][i][j].lmli[3]
                               : unit[cid][i][j].conf.cdw2.mws3==4 ? unit[cid][i][j].lmwd[3]
                               : unit[cid][i][j].conf.cdw2.mws3==5 ? unit[cid][i][j].lmri[3]
                               :                                     0LL;
@


1.128
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.127 2016/11/10 16:02:10 nakashim Exp nakashim $";
d1244 3
a1246 3
      unit[cid][i][j].ea0dr = unit[cid][i][j].conf.cdw2.xtrs==1 ? unit[cid][i][j].lmlia
                            : unit[cid][i][j].conf.cdw2.xtrs==2 ? unit[cid][i][j].lmwa
                            : unit[cid][i][j].conf.cdw2.xtrs==3 ? unit[cid][i][j].lmria
d1289 3
a1291 3
	unit[cid][i][j].ea0dr = unit[cid][i][j].conf.cdw2.trsa==1 ? unit[cid][i][j].lmlia
	                      : unit[cid][i][j].conf.cdw2.trsa==2 ? unit[cid][i][j].lmwa
                              : unit[cid][i][j].conf.cdw2.trsa==3 ? unit[cid][i][j].lmria
d1323 1
d1350 1
a1350 17
      /* xtrs: 0:off, 1:lmli, 2:lmwd, 3:lmri */
      unit[cid][i][j].tr[0] = unit[cid][i][j].conf.cdw2.xtrs==1 ? unit[cid][i][j].lmli[0]
                            : unit[cid][i][j].conf.cdw2.xtrs==2 ? unit[cid][i][j].lmwd[0]
                            : unit[cid][i][j].conf.cdw2.xtrs==3 ? unit[cid][i][j].lmri[0]
                            :                                     0LL;
      unit[cid][i][j].tr[1] = unit[cid][i][j].conf.cdw2.xtrs==1 ? unit[cid][i][j].lmli[1]
                            : unit[cid][i][j].conf.cdw2.xtrs==2 ? unit[cid][i][j].lmwd[1]
                            : unit[cid][i][j].conf.cdw2.xtrs==3 ? unit[cid][i][j].lmri[1]
                            :                                     0LL;
      unit[cid][i][j].tr[2] = unit[cid][i][j].conf.cdw2.xtrs==1 ? unit[cid][i][j].lmli[2]
                            : unit[cid][i][j].conf.cdw2.xtrs==2 ? unit[cid][i][j].lmwd[2]
                            : unit[cid][i][j].conf.cdw2.xtrs==3 ? unit[cid][i][j].lmri[2]
                            :                                     0LL;
      unit[cid][i][j].tr[3] = unit[cid][i][j].conf.cdw2.xtrs==1 ? unit[cid][i][j].lmli[3]
                            : unit[cid][i][j].conf.cdw2.xtrs==2 ? unit[cid][i][j].lmwd[3]
                            : unit[cid][i][j].conf.cdw2.xtrs==3 ? unit[cid][i][j].lmri[3]
                            :                                     0LL;
d1353 4
a1356 1
        unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k]; /* align不要 */
d1380 79
a1458 30
    /* trs[3-0]: 0:exdr, 1:exdr0, 2:ts0, 3:lmli0, 4:lmwd0, 5:lmri0 */
    unit[cid][i][j].tr[0] = unit[cid][i][j].conf.cdw2.trs0==0 ? unit[cid][i][j].exdr /* tr[3-0]はalign不要 */
                          : unit[cid][i][j].conf.cdw2.trs0==1 ? unit[cid][i][0].exdr
                          : unit[cid][i][j].conf.cdw2.trs0==2 ? unit[cid][i][j].t[0]
                          : unit[cid][i][j].conf.cdw2.trs0==3 ? unit[cid][i][j].lmli[0]
                          : unit[cid][i][j].conf.cdw2.trs0==4 ? unit[cid][i][j].lmwd[0]
                          : unit[cid][i][j].conf.cdw2.trs0==5 ? unit[cid][i][j].lmri[0]
                          :                                     0LL;
    unit[cid][i][j].tr[1] = unit[cid][i][j].conf.cdw2.trs1==0 ? unit[cid][i][j].exdr
                          : unit[cid][i][j].conf.cdw2.trs1==1 ? unit[cid][i][1].exdr
                          : unit[cid][i][j].conf.cdw2.trs1==2 ? unit[cid][i][j].t[1]
                          : unit[cid][i][j].conf.cdw2.trs1==3 ? unit[cid][i][j].lmli[1]
                          : unit[cid][i][j].conf.cdw2.trs1==4 ? unit[cid][i][j].lmwd[1]
                          : unit[cid][i][j].conf.cdw2.trs1==5 ? unit[cid][i][j].lmri[1]
                          :                                     0LL;
    unit[cid][i][j].tr[2] = unit[cid][i][j].conf.cdw2.trs2==0 ? unit[cid][i][j].exdr
                          : unit[cid][i][j].conf.cdw2.trs2==1 ? unit[cid][i][2].exdr
                          : unit[cid][i][j].conf.cdw2.trs2==2 ? unit[cid][i][j].t[2]
                          : unit[cid][i][j].conf.cdw2.trs2==3 ? unit[cid][i][j].lmli[2]
                          : unit[cid][i][j].conf.cdw2.trs2==4 ? unit[cid][i][j].lmwd[2]
                          : unit[cid][i][j].conf.cdw2.trs2==5 ? unit[cid][i][j].lmri[2]
                          :                                     0LL;
    unit[cid][i][j].tr[3] = unit[cid][i][j].conf.cdw2.trs3==0 ? unit[cid][i][j].exdr
                          : unit[cid][i][j].conf.cdw2.trs3==1 ? unit[cid][i][3].exdr
                          : unit[cid][i][j].conf.cdw2.trs3==2 ? unit[cid][i][j].t[3]
                          : unit[cid][i][j].conf.cdw2.trs3==3 ? unit[cid][i][j].lmli[3]
                          : unit[cid][i][j].conf.cdw2.trs3==4 ? unit[cid][i][j].lmwd[3]
                          : unit[cid][i][j].conf.cdw2.trs3==5 ? unit[cid][i][j].lmri[3]
                          :                                     0LL;
    /* fsm pload */
d1460 10
a1469 60
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
	unit[cid][i][j].lmm.mm0[0] = 0xffffffffffffffffLL; /* mask */
	unit[cid][i][j].lmm.mw0[0] = unit[cid][i][j].exdr; /* align不要 */
        for (k=1; k<UNIT_WIDTH; k++) {
          unit[cid][i][j].lmm.mm0[k] = 0LL; /* mask */
          unit[cid][i][j].lmm.mw0[k] = 0LL; /* align不要 */
        }
      }
    }
    else if (unit[cid][i][j].conf.cdw1.ea0op == OP_IM_PREF) {
      if (unit[cid][i][j].lmen) {
        for (k=0; k<UNIT_WIDTH; k++) {
          unit[cid][i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
          unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k]; /* align不要 */
        }
      }
    }
    else if (unit[cid][i][j].conf.cdw1.ea0op & 0x10) { /* normal store */
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
        a = unit[cid][i][j].ea0dr % LMEM_SIZE; /* main-mamory-address -> lmm-address */
        switch (unit[cid][i][j].conf.cdw1.ea0op) {
        case OP_STR:
          for (k=0; k<UNIT_WIDTH; k++) {
            unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&2)?0xffffffff00000000LL:0LL)|((unit[cid][i][j].cexdr&1)?0x00000000ffffffffLL:0LL)) : 0LL; /* mask */
            unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k]; /* align不要 */
          }
          break;
        case OP_STWR:
          for (k=0; k<UNIT_WIDTH; k++) {
            unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&1)?0x00000000ffffffffLL:0LL)<<(a & sizeof(int))*8) : 0LL; /* mask */
            unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & sizeof(int))*8; /* align必要 */
          }
          break;
        case OP_STHR:
          for (k=0; k<UNIT_WIDTH; k++) {
            unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&1)?0x000000000000ffffLL:0LL)<<(a & (sizeof(int)|sizeof(short)))*8) : 0LL; /* mask */
            unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & (sizeof(int)|sizeof(short)))*8; /* align必要 */
          }
          break;
        case OP_STBR:
          for (k=0; k<UNIT_WIDTH; k++) {
            unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (((unit[cid][i][j].cexdr&1)?0x00000000000000ffLL:0LL)<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8) : 0LL; /* mask */
            unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8; /* align必要 */
          }
          break;
        case OP_STRQ:
        case OP_IM_PREF:
          for (k=0; k<UNIT_WIDTH; k++) {
            unit[cid][i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
            unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k];
          }
          break;
        case OP_TR:
          for (k=0; k<UNIT_WIDTH; k++) {
            unit[cid][i][j].lmm.mm0[k] = (unit[cid][i][j].cexdr&1)?0xffffffffffffffffLL:0LL; /* mask */
            unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k];
          }
          break;
        }
      }
d1891 1
a1891 1
      printf("|lmls%d lmrs%d ts3-0=%01.1x%01.1x%01.1x%01.1x trsa%d trs3-0=%d%d%d%d brs3-0=%d%d%d%d xtrs%d mapd=%d  ",
d1898 5
a1902 5
             (Uint) unit[cid][row][col].conf.cdw2.trsa,
             (Uint) unit[cid][row][col].conf.cdw2.trs3,
             (Uint) unit[cid][row][col].conf.cdw2.trs2,
             (Uint) unit[cid][row][col].conf.cdw2.trs1,
             (Uint) unit[cid][row][col].conf.cdw2.trs0,
d1907 1
a1907 1
             (Uint) unit[cid][row][col].conf.cdw2.xtrs,
@


1.127
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.126 2016/11/10 08:07:01 nakashim Exp nakashim $";
d426 1
a426 1
      /*                        ○lmmo.top==lmmi.top,.f=0,.p=0の場合, load/reuse before next exec       */
d429 1
a429 1
      /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
d434 1
a434 1
      /*                        ●lmmi.f=1の場合, load always before next exec                          */
d437 1
a437 1
      /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
d443 2
a444 2
      /*                        ●lmmi.f=1の場合, load always before next exec                          */
      /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
d447 1
a447 1
      /* Example of Prefetch+Drain **********************************************************************/
d452 2
a453 2
      /*                        ○lmmo.top==lmmi.top,.f=0,.p=0の場合, load/reuse before next exec       */
      /*                        ★lmmo.top==lmmi.top,.f=0,.p=1の場合, load/reuse with next exec         */
d456 11
a466 1
      /*                        ★dirty=1,lmmi.top!=NULL,.p=1の場合, delayed drain at next exec         */
d520 3
a522 3
            if      (mode==1 && (lmmo_stat==12 && lmmc_stat!=13) && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* lmw&!lmd drain */
            else if (mode==1 && (lmmo_stat==14                 ) && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* lmx      drain */
            else if (mode==2 &&                                     emax5[cid].fsm[j].lmmd[i]) mark = 1; /* drain_dirty_lmm */
d526 3
a528 3
            if      (lmmc_stat== 8               && !lmm_ready)  mark = 1; /* lmr & !ready*/
	    else if (lmmc_stat== 9 && !lmmc_ofsz && !lmm_readz)  mark = 1; /* lmr & !ready*/
            else if (lmmc_stat==10 || lmmc_stat==14)             mark = 1; /* lmf/lmx always load */
d532 2
a533 2
            if      (lmmc_stat== 9                             ) mark = 1; /* lmp */
            else if (lmmc_stat==13 && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* lmd & dirty */
@


1.126
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.125 2016/11/10 04:37:52 nakashim Exp $";
d497 1
d501 3
d510 4
a513 3
            if      (mode==1 && ((lmmo_stat==12 && lmmc_stat!=13) || lmmo_stat==14) && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* 12:lmw&!13:lmd | 14:lmx drain */
            else if (mode==2 &&                                                        emax5[cid].fsm[j].lmmd[i]) mark = 1; /* drain_dirty_lmm */
            else                                                                                                  mark = 0; /* skip drain */
d516 2
a517 1
            if      (lmmc_stat== 8 && !lmm_ready)                mark = 1; /* lmr & !ready*/
d522 1
a522 1
            if      (lmmc_stat== 9 && !lmm_ready)                mark = 1; /* lmp & !ready */
@


1.125
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.124 2016/11/09 09:41:29 nakashim Exp nakashim $";
d548 1
a548 1
                emax5[cid].fsm[j].awaddr = emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
d607 1
a607 1
                emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
@


1.124
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.123 2016/11/03 14:51:09 nakashim Exp nakashim $";
d408 1
a408 1
      /*                                                                                                                  c+dist  1 ptop  blk  len   0  0  1 */
d410 1
d416 1
a416 1
      /*                                                                                                                  c-dist  1 ptop  blk  len   1  0  1 */
d418 1
@


1.123
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.122 2016/11/01 04:58:57 nakashim Exp nakashim $";
d406 2
a407 2
      /* LD with force-read=1 and ptop==NULL generates current(lmf) and does not reuse LMM. same as lmf in EMAX4            curr  1  top  blk  len   0  1  0 */
      /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). same as lmp in EMAX4                     curr  1  top  blk  len   0  0  0 */
d409 2
a410 1
      /*                                                                                        ptop!=NULL & force=1は，prefetchの意味がないので組合せがない */
d412 6
a417 5
      /* ST with force-read=0 and ptop==NULL writes back after execution. same as lmw in EMAX4                              curr  1  top  blk  len   1  0  0 */
      /* ST with force-read=1 and ptop==NULL prefetches data to LMM in advance and write back. same as lmx in EMAX4         curr  1  top  blk  len   1  1  0 */
      /* ST with force-read=0, top==NULL and ptop!=NULL late drain with next execution. same as lmd in EMAX4                curr  0  (check be empty)        */
      /*                                                   FSMは,dirtyおよびp-bitに従い,exec同時drainか,exec後drainを選択 c-dist  1 ptop  blk  len   1  0  1 */
      /*                                                                                        deleyed-drain & force=1は，delayの意味がないので組合せがない */
a1426 1
        case OP_STBF:
a1450 1
        case OP_STBFQ:
d1564 1
a1564 2
      case OP_LDR:
      case OP_LDBF:  unit[cid][i][j].regv.br[0] =                unit[cid][i][j].mr0d;                                                                                 break;
d1582 1
a1582 2
      case OP_LDR:
      case OP_LDBF:  unit[cid][i][j].regv.br[1] =                unit[cid][i][j].mr1d;                                                                                 break;
@


1.122
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.121 2016/10/23 09:13:39 nakashim Exp nakashim $";
d157 1
d885 3
d1515 1
d1548 2
a1549 1
        emax5[cid].fsm[j].lmmd[i] = 1; /* mark dirty */
@


1.121
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.120 2016/08/24 13:57:19 nakashim Exp nakashim $";
d1398 11
a1408 1
    if (unit[cid][i][j].conf.cdw1.ea0op == OP_IM_PREF) {
@


1.120
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.119 2016/08/16 03:09:22 nakashim Exp nakashim $";
a19 1
enum { STATUS_IDLE, STATUS_CONF, STATUS_SCON, STATUS_LMMI, STATUS_DRAIN, STATUS_LOAD, STATUS_REGV, STATUS_START, STATUS_EXEC, STATUS_TERM };
@


1.119
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.118 2016/08/04 15:36:00 nakashim Exp nakashim $";
d252 1
d332 9
a340 15
      if (flag & DUMP_DDR) {
	FILE *fp;
	Ull *conf_p = (Ull*)(base+conf);
	Ull *lmmi_p = (Ull*)(base+lmmi);
	Ull *regv_p = (Ull*)(base+regv);
	int i;
	if ((fp = fopen("conf.dat", "r")) == NULL) { /* should be removed before new one */
	  if (fp = fopen("conf.dat", "w")) {
	    printf("\n");
	    printf(" EMAX_DUMP_DDR(conf=%08.8x_%08.8x)\n", (Uint)(conf>>32), (Uint)conf);
	    fprintf(fp, "ddr_conf_top = 40\'h%08.8x;\n", (Uint)conf);
	    for (i=0; i<sizeof(struct conf)*EMAX_DEPTH*EMAX_WIDTH; i+=sizeof(Ull),conf_p++)
	      fprintf(fp, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)conf+i, (Uint)((*conf_p)>>32), (Uint)(*conf_p));
	    fclose (fp);
	  }
d342 3
a344 8
	if ((fp = fopen("lmmi.dat", "r")) == NULL) { /* should be removed before new one */
	  if (fp = fopen("lmmi.dat", "w")) {
	    printf(" EMAX_DUMP_DDR(lmmi=%08.8x_%08.8x)\n", (Uint)(lmmi>>32), (Uint)lmmi);
	    fprintf(fp, "ddr_lmmi_top = 40\'h%08.8x;\n", (Uint)lmmi);
	    for (i=0; i<sizeof(struct lmmi)*EMAX_DEPTH*EMAX_WIDTH; i+=sizeof(Ull),lmmi_p++)
	      fprintf(fp, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)lmmi+i, (Uint)(*(lmmi_p)>>32), (Uint)(*lmmi_p));
	    fclose (fp);
	  }
d346 3
a348 8
	if ((fp = fopen("regv.dat", "r")) == NULL) { /* should be removed before new one */
	  if (fp = fopen("regv.dat", "w")) {
	    printf(" EMAX_DUMP_DDR(regv=%08.8x_%08.8x)\n", (Uint)(regv>>32), (Uint)regv);
	    fprintf(fp, "ddr_regv_top = 40\'h%08.8x;\n", (Uint)regv);
	    for (i=0; i<sizeof(struct regv)*EMAX_DEPTH*EMAX_WIDTH; i+=sizeof(Ull),regv_p++)
	      fprintf(fp, "HOST_DDR_W(40\'h%08.8x, 64'h%08.8x_%08.8x);\n", (Uint)regv+i, (Uint)((*regv_p)>>32), (Uint)(*regv_p));
	    fclose (fp);
	  }
d352 1
a352 1
      if (trace)
d551 10
a560 1
              }
d565 9
d579 9
d593 7
d605 7
d866 7
@


1.118
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.117 2016/07/28 23:59:50 nakashim Exp nakashim $";
d212 1
a212 1
siml_trans(tid, pa_cycle, tic, trace, trace_pipe, base, start, end, gr2, gr3, gr4) Uint tid; Ull pa_cycle; int tic; Uint trace, trace_pipe; Uchar *base; Ull start, end, gr2, gr3, gr4;
d245 2
a246 2
siml_emax5(tid, pa_cycle, tic, trace, trace_pipe, base, stack_min, stack_max, conf, lmmi, regv, mode)
     Uint tid; Ull pa_cycle; int tic; Uint trace, trace_pipe; char *base; Ull stack_min, stack_max, conf, lmmi, regv; int mode;
a340 2
	    fprintf(fp, "ddr_stck_min = 40\'h%08.8x;\n", (Uint)(lmmi<regv?lmmi:regv));
	    fprintf(fp, "ddr_stck_max = 40\'h%08.8x;\n", (Uint)(lmmi>regv?(lmmi+sizeof(lmmi)):(regv+sizeof(regv))));
@


1.117
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.116 2016/07/28 06:40:11 nakashim Exp nakashim $";
d212 1
a212 1
siml_trans(tid, pa_cycle, tic, trace, trace_pipe, base, start, end, gr2) Uint tid; Ull pa_cycle; int tic; Uint trace, trace_pipe; Uchar *base; Ull start, end, gr2;
d245 2
a246 1
siml_emax5(tid, pa_cycle, tic, trace, trace_pipe, base, conf, lmmi, regv, mode) Uint tid; Ull pa_cycle; int tic; Uint trace, trace_pipe; char *base; Ull conf, lmmi, regv; int mode;
d341 2
@


1.116
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.115 2016/07/01 08:03:37 nakashim Exp nakashim $";
d340 1
d349 1
d358 1
@


1.115
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.114 2016/06/21 10:19:21 nakashim Exp nakashim $";
d249 1
a249 1
  int i, j, k, flag, sync, total;
d330 32
d509 3
a511 3
	  case STATUS_CONF:                                      flag = 1; break; /* load */
	  case STATUS_REGV:                                      flag = 1; break; /* load */
	  case STATUS_LMMI:                                      flag = 1; break; /* load */
d513 3
a515 3
            if      (mode==1 && ((lmmo_stat==12 && lmmc_stat!=13) || lmmo_stat==14) && emax5[cid].fsm[j].lmmd[i]) flag = 1; /* 12:lmw&!13:lmd | 14:lmx drain */
            else if (mode==2 &&                                                        emax5[cid].fsm[j].lmmd[i]) flag = 1; /* drain_dirty_lmm */
            else                                                                                                  flag = 0; /* skip drain */
d518 3
a520 3
            if      (lmmc_stat== 8 && !lmm_ready)                flag = 1; /* lmr & !ready*/
            else if (lmmc_stat==10 || lmmc_stat==14)             flag = 1; /* lmf/lmx always load */
            else                                                 flag = 0; /* skip load */
d523 3
a525 3
            if      (lmmc_stat== 9 && !lmm_ready)                flag = 1; /* lmp & !ready */
            else if (lmmc_stat==13 && emax5[cid].fsm[j].lmmd[i]) flag = 1; /* lmd & dirty */
            else                                                 flag = 0; /* skip pdrain/pload */
d533 2
a534 2
	    printf("status=%d lmm[row=%d][col=%d]: lmmo_stat=%d lmmc_stat=%d lmm_ready=%d flag=%d\n",
		   emax5[cid].status, i, j, lmmo_stat, lmmc_stat, lmm_ready, flag);
d539 1
a539 1
          if (flag) {
@


1.114
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.113 2016/06/19 09:33:39 nakashim Exp nakashim $";
d132 1
a132 1
    Ull   idelay                ; /* siml MEMORY delay (same as L2DELAY/RATIO)                          */
d868 1
a868 1
      emax5[cid].fsm[j].idelay= L2DELAY/ARM_EMAX5_RATIO;      /* start read */
@


1.113
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.112 2016/06/02 06:44:21 nakashim Exp nakashim $";
d470 5
a474 5
          int lmmo_stat = (emax5[cid].fsm[j].lmmo[i].v<<3)|(emax5[cid].fsm[j].lmmo[i].rw<<2)|(emax5[cid].fsm[j].lmmo[i].f<<1)|(emax5[cid].fsm[j].lmmo[i].p); /* v | rw | f | p */
          int lmmc_stat = (emax5[cid].fsm[j].lmmc[i].v<<3)|(emax5[cid].fsm[j].lmmc[i].rw<<2)|(emax5[cid].fsm[j].lmmc[i].f<<1)|(emax5[cid].fsm[j].lmmc[i].p); /* v | rw | f | p */
          int lmm_ready =  emax5[cid].fsm[j].lmmc[i].copy||(emax5[cid].fsm[j].lmmo[i].v && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
	                                                                                && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
	                                                                                && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top);
d494 1
d496 10
a505 1

d749 2
a750 2
	      if (emax5[cid].fsm[j].lmmd[i])                                      break; /* rough condition for next STATUS_DRAIN */
	      if (emax5[cid].fsm[j].lmmc[i].v && !emax5[cid].fsm[j].lmmc[i].copy) break; /* rough condition for next STATUS_LOAD/EXEC  */
@


1.112
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.111 2016/06/01 02:19:47 nakashim Exp nakashim $";
d472 3
a474 3
          int lmm_ready =  emax5[cid].fsm[j].lmmo[i].v && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
	                                               && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
	                                               && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top;
d739 2
a740 2
	      if (emax5[cid].fsm[j].lmmd[i])   break; /* rough condition for next STATUS_DRAIN */
	      if (emax5[cid].fsm[j].lmmc[i].v) break; /* rough condition for next STATUS_LOAD/EXEC  */
d1580 1
a1580 1
      printf("|\033[1;%dmlmmo%d v%d rw%d f%d p%d b%d l%08.8x b%01.1x top%08.8x%08.8x\033[0m",
d1590 1
d1596 1
a1596 1
      printf("|\033[1;%dmlmmc%d v%d rw%d f%d p%d b%d l%08.8x b%01.1x top%08.8x%08.8x\033[0m",
d1606 1
@


1.111
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.110 2016/05/21 09:51:13 nakashim Exp nakashim $";
d1058 1
a1058 1
      cex(OP_CEXE, c3, c2, c1, c0, pattern, &ex);
d1105 1
a1105 1
      retval = exe(op_ex1, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5, &d);
@


1.110
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.109 2016/05/19 08:21:08 nakashim Exp nakashim $";
d978 1
a978 17
    switch (unit[cid][i][j].conf.cdw1.ea0msk) {
    case MSK_B0: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o     & 0x000000ffLL; break;
    case MSK_B1: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>> 8 & 0x000000ffLL; break;
    case MSK_B2: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>16 & 0x000000ffLL; break;
    case MSK_B3: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>24 & 0x000000ffLL; break;
    case MSK_B4: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>32 & 0x000000ffLL; break;
    case MSK_B5: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>40 & 0x000000ffLL; break;
    case MSK_B6: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>48 & 0x000000ffLL; break;
    case MSK_B7: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>56 & 0x000000ffLL; break;
    case MSK_H0: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o     & 0x0000ffffLL; break;
    case MSK_H1: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>16 & 0x0000ffffLL; break;
    case MSK_H2: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>32 & 0x0000ffffLL; break;
    case MSK_H3: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>48 & 0x0000ffffLL; break;
    case MSK_W0: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o     & 0xffffffffLL; break;
    case MSK_W1: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>32 & 0xffffffffLL; break;
    case MSK_D0: break;
    }
a980 17
    switch (unit[cid][i][j].conf.cdw1.ea1msk) {
    case MSK_B0: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o     & 0x000000ffLL; break;
    case MSK_B1: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>> 8 & 0x000000ffLL; break;
    case MSK_B2: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>16 & 0x000000ffLL; break;
    case MSK_B3: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>24 & 0x000000ffLL; break;
    case MSK_B4: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>32 & 0x000000ffLL; break;
    case MSK_B5: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>40 & 0x000000ffLL; break;
    case MSK_B6: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>48 & 0x000000ffLL; break;
    case MSK_B7: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>56 & 0x000000ffLL; break;
    case MSK_H0: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o     & 0x0000ffffLL; break;
    case MSK_H1: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>16 & 0x0000ffffLL; break;
    case MSK_H2: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>32 & 0x0000ffffLL; break;
    case MSK_H3: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>48 & 0x0000ffffLL; break;
    case MSK_W0: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o     & 0xffffffffLL; break;
    case MSK_W1: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>32 & 0xffffffffLL; break;
    case MSK_D0: break;
    }
d1395 2
a1396 2
  a0   = unit[cid][i][j].ea0dr % LMEM_SIZE; /* should be aligned by fsm */
  a1   = unit[cid][i][j].ea1dr % LMEM_SIZE; /* should be aligned by fsm */
@


1.109
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.108 2016/05/19 06:18:57 nakashim Exp nakashim $";
d798 5
a802 3
      emax5[cid].last_conf = conf;
      emax5[cid].last_dist = emax5[cid].fsm[0].last_dist;
      emax5[cid].last_row0 = (emax5[cid].last_row0+emax5[cid].last_dist)%EMAX_DEPTH;
@


1.108
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.107 2016/05/18 23:59:16 nakashim Exp nakashim $";
d687 1
a687 1
		    emax5[cid].fsm[j].last_dist = (emax5[cid].fsm[j].axi_rdata[2]>>42) & 0x3f; /* mapdist */
@


1.107
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.106 2016/05/16 05:18:06 nakashim Exp nakashim $";
d687 1
a687 1
		    emax5[cid].fsm[j].last_dist = emax5[cid].fsm[j].axi_rdata[3] & 0x3f; /* mapdist */
@


1.106
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.105 2016/05/16 03:32:15 nakashim Exp nakashim $";
d132 1
a132 1
    Ull   idelay                ; /* siml MEMORY delay (same as L2DELAY)                                */
d212 1
a212 1
siml_trans(tid, cycle, trace, trace_pipe, base, start, end, gr2) Uint tid; int cycle; Uint trace, trace_pipe; Uchar *base; Ull start, end, gr2;
d245 1
a245 1
siml_emax5(tid, cycle, trace, trace_pipe, base, conf, lmmi, regv, mode) Uint tid; int cycle; Uint trace, trace_pipe; char *base; Ull conf, lmmi, regv; int mode;
d255 3
d272 1
a272 1
  while (cycle-- > 0) {
d330 3
d794 3
d822 1
a822 1
      cycle = -1;
d831 1
a831 1
  if (cycle < -1)
d856 1
a856 1
      emax5[cid].fsm[j].idelay= L2DELAY;                      /* start read */
d1554 1
a1554 1
  printf("%03.3d:PA %08.8x_%08.8x siml_emax5: tinit=%08.8x_%08.8x conf=%08.8x_%08.8x scon=%08.8x_%08.8x lmmi=%08.8x_%08.8x drain=%08.8x_%08.8x\n",
d1561 3
a1563 3
         (Uint)(emax5[cid].cycles_drain>>32), (Uint)emax5[cid].cycles_drain);
  printf("                                      load=%08.8x_%08.8x regv=%08.8x_%08.8x start=%08.8x_%08.8x exec=%08.8x_%08.8x term=%08.8x_%08.8x trans=%08.8x_%08.8x\n",
         (Uint)(emax5[cid].cycles_load>>32),  (Uint)emax5[cid].cycles_load,
d1570 2
a1571 4
  total *= EMAX5HOST_RATIO; /* 200MHz -> 2.4GHz */
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(icidlrett)", 2400/EMAX5HOST_RATIO, (Uint)(total>>32), (Uint)total);
  total += pa_cycle;
  printf(" TOTAL_CYCLE=%08.8x_%08.8x(icidlrett)\033[0m\n", (Uint)(total>>32), (Uint)total);
@


1.105
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.104 2016/05/15 15:44:19 nakashim Exp nakashim $";
d1119 1
a1119 1
      r4     = unit[cid][i][j].conf.cdw0.e2is==0 ? (Sll)((Ull)unit[cid][i][j].conf.cdw0.e2imm<<(64-E2IMMBITS))>>(64-E2IMMBITS)
d1778 1
a1778 1
      printf("|op123=%02.2x_%x_%x ex1=%01.1x_%d%d ex2=%01.1x_%d ex3=%01.1x_%d e2i=%03.3x_%d e3i=%02.2x_%d           ",
d1789 2
a1790 1
             (Uint) unit[cid][row][col].conf.cdw0.e2imm,
d1833 1
a1833 1
             (Uint) unit[cid][row][col].conf.cdw3.mapdist);
@


1.104
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.103 2016/05/15 11:31:18 nakashim Exp nakashim $";
d2082 1
a2082 1
	     unit[cid][row][col].rrdy?32:34,
@


1.103
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.102 2016/05/15 10:13:33 nakashim Exp nakashim $";
d1012 2
a1013 2
    unit[cid][i][j].lmen = emax5[cid].fsm[j].row_lmm_en>>i&1;
    unit[cid][i][j].lmwa = emax5[cid].fsm[j].lmwa;
d1022 6
a1027 5
    s = unit[cid][i][j].conf.cdw2.lmlsa;  unit[cid][i][j].lmloa   = (s==0)?unit[cid][i][j].lmwa   :unit[cid][i][j].lmria;
    s = unit[cid][i][j].conf.cdw2.lmls0;  unit[cid][i][j].lmlo[0] = (s==0)?unit[cid][i][j].lmwd[0]:unit[cid][i][j].lmri[0];
    s = unit[cid][i][j].conf.cdw2.lmls1;  unit[cid][i][j].lmlo[1] = (s==0)?unit[cid][i][j].lmwd[1]:unit[cid][i][j].lmri[1];
    s = unit[cid][i][j].conf.cdw2.lmls2;  unit[cid][i][j].lmlo[2] = (s==0)?unit[cid][i][j].lmwd[2]:unit[cid][i][j].lmri[2];
    s = unit[cid][i][j].conf.cdw2.lmls3;  unit[cid][i][j].lmlo[3] = (s==0)?unit[cid][i][j].lmwd[3]:unit[cid][i][j].lmri[3];
d1038 6
a1043 5
    s = unit[cid][i][j].conf.cdw2.lmrsa;  unit[cid][i][j].lmroa   = (s==0)?unit[cid][i][j].lmwa   :unit[cid][i][j].lmlia;
    s = unit[cid][i][j].conf.cdw2.lmrs0;  unit[cid][i][j].lmro[0] = (s==0)?unit[cid][i][j].lmwd[0]:unit[cid][i][j].lmli[0];
    s = unit[cid][i][j].conf.cdw2.lmrs1;  unit[cid][i][j].lmro[1] = (s==0)?unit[cid][i][j].lmwd[1]:unit[cid][i][j].lmli[1];
    s = unit[cid][i][j].conf.cdw2.lmrs2;  unit[cid][i][j].lmro[2] = (s==0)?unit[cid][i][j].lmwd[2]:unit[cid][i][j].lmli[2];
    s = unit[cid][i][j].conf.cdw2.lmrs3;  unit[cid][i][j].lmro[3] = (s==0)?unit[cid][i][j].lmwd[3]:unit[cid][i][j].lmli[3];
d1154 2
a1155 1
      unit[cid][i][j].lmm.ma1 = ((unit[cid][i][j].ea1dr = unit[cid][i][j].lmra) % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
d1164 5
a1168 1
      unit[cid][i][j].lmm.ma0 = ((unit[cid][i][j].ea0dr = unit[cid][i][j].lmwa) % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
d1182 2
a1183 1
        unit[cid][i][j].lmm.ma1 = ((unit[cid][i][j].ea1dr = unit[cid][i][j].lmra) % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
a1203 1

d1209 5
a1213 1
        unit[cid][i][j].lmm.ma0 = ((unit[cid][i][j].ea0dr = unit[cid][i][j].lmwa) % LMEM_SIZE) & ~(sizeof(Ull)*UNIT_WIDTH-1);
d1269 17
a1285 17
      /* xtrs[3-0]: 0:off, 1:lmli, 2:lmwd, 3:lmri */
      unit[cid][i][j].tr[0] = unit[cid][i][j].conf.cdw2.xtrs0==1 ? unit[cid][i][j].lmli[0]
                            : unit[cid][i][j].conf.cdw2.xtrs0==2 ? unit[cid][i][j].lmwd[0]
                            : unit[cid][i][j].conf.cdw2.xtrs0==3 ? unit[cid][i][j].lmri[0]
                            :                                      0LL;
      unit[cid][i][j].tr[1] = unit[cid][i][j].conf.cdw2.xtrs1==1 ? unit[cid][i][j].lmli[1]
                            : unit[cid][i][j].conf.cdw2.xtrs1==2 ? unit[cid][i][j].lmwd[1]
                            : unit[cid][i][j].conf.cdw2.xtrs1==3 ? unit[cid][i][j].lmri[1]
                            :                                      0LL;
      unit[cid][i][j].tr[2] = unit[cid][i][j].conf.cdw2.xtrs2==1 ? unit[cid][i][j].lmli[2]
                            : unit[cid][i][j].conf.cdw2.xtrs2==2 ? unit[cid][i][j].lmwd[2]
                            : unit[cid][i][j].conf.cdw2.xtrs2==3 ? unit[cid][i][j].lmri[2]
                            :                                      0LL;
      unit[cid][i][j].tr[3] = unit[cid][i][j].conf.cdw2.xtrs3==1 ? unit[cid][i][j].lmli[3]
                            : unit[cid][i][j].conf.cdw2.xtrs3==2 ? unit[cid][i][j].lmwd[3]
                            : unit[cid][i][j].conf.cdw2.xtrs3==3 ? unit[cid][i][j].lmri[3]
                            :                                      0LL;
d1815 3
a1817 11
      printf("|lma=%d%d lm3-0=%d%d_%d%d_%d%d_%d%d ts3-0=%01.1x%01.1x%01.1x%01.1x trs3-0=%d%d%d%d brs3-0=%d%d%d%d mapd=%d ",
             (Uint) unit[cid][row][col].conf.cdw2.lmlsa,
             (Uint) unit[cid][row][col].conf.cdw2.lmrsa,
             (Uint) unit[cid][row][col].conf.cdw2.lmls3,
             (Uint) unit[cid][row][col].conf.cdw2.lmrs3,
             (Uint) unit[cid][row][col].conf.cdw2.lmls2,
             (Uint) unit[cid][row][col].conf.cdw2.lmrs2,
             (Uint) unit[cid][row][col].conf.cdw2.lmls1,
             (Uint) unit[cid][row][col].conf.cdw2.lmrs1,
             (Uint) unit[cid][row][col].conf.cdw2.lmls0,
             (Uint) unit[cid][row][col].conf.cdw2.lmrs0,
d1822 1
d1831 1
@


1.102
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.101 2016/05/15 07:02:27 nakashim Exp nakashim $";
d1593 1
a1593 1
      printf("|\033[1;%dmlmmo%d v%d rw%d f%d p%d b%d l%08.8x top%08.8x%08.8x\033[0m",
d1602 1
d1608 1
a1608 1
      printf("|\033[1;%dmlmmc%d v%d rw%d f%d p%d b%d l%08.8x top%08.8x%08.8x\033[0m",
d1617 1
d1639 1
a1639 1
    printf("|%d %d rc%02.2d rs%08.8x%08.8x lmen%08.8x%08.8x rrdy=%04.4d         ",
d1647 1
d1817 1
a1817 1
             (Uint) unit[cid][row][col].conf.cdw2.ts2,
a2036 25
    printf("mr1[3-0]");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|\033[1;%dm%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x\033[0m",
	     unit[cid][row][col].rrdy?32:34,
             (Uint)(unit[cid][row][col].lmm.mr1[3]>>32),
             (Uint) unit[cid][row][col].lmm.mr1[3],
             (Uint)(unit[cid][row][col].lmm.mr1[2]>>32),
             (Uint) unit[cid][row][col].lmm.mr1[2],
             (Uint)(unit[cid][row][col].lmm.mr1[1]>>32),
             (Uint) unit[cid][row][col].lmm.mr1[1],
             (Uint)(unit[cid][row][col].lmm.mr1[0]>>32),
             (Uint) unit[cid][row][col].lmm.mr1[0]);
    printf("\n");
    printf("mr0[3-0]");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
             (Uint)(unit[cid][row][col].lmm.mr0[3]>>32),
             (Uint) unit[cid][row][col].lmm.mr0[3],
             (Uint)(unit[cid][row][col].lmm.mr0[2]>>32),
             (Uint) unit[cid][row][col].lmm.mr0[2],
             (Uint)(unit[cid][row][col].lmm.mr0[1]>>32),
             (Uint) unit[cid][row][col].lmm.mr0[1],
             (Uint)(unit[cid][row][col].lmm.mr0[0]>>32),
             (Uint) unit[cid][row][col].lmm.mr0[0]);
    printf("\n");
d2062 25
@


1.101
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.100 2016/05/14 05:02:19 nakashim Exp nakashim $";
d578 2
a579 2
		    emax5[cid].fsm[j].row_select = 1LL<<i;
		    emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
d593 1
a593 1
		  emax5[cid].fsm[j].row_lmm_en   = 0LL;
d642 2
a643 2
		    /*emax5[cid].fsm[j].row_select = 1LL<<i;*/
		    /*emax5[cid].fsm[j].row_lmm_en = 1LL<<i;*//* wait for data arrived from MEM */
d671 2
a672 2
		    /*emax5[cid].fsm[j].row_select   = 0LL;*/
		    /*emax5[cid].fsm[j].row_lmm_en   = 0LL;*//* wait for data arrived from MEM */
d700 8
a707 3
		    if (emax5[cid].status==STATUS_LOAD                                      /* load */
                     ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) /* pload */
		      emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
d719 7
a725 2
		else
		  emax5[cid].fsm[j].row_lmm_en = 0LL;
@


1.100
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.99 2016/05/13 23:47:44 nakashim Exp nakashim $";
d1248 17
d1267 1
a1267 1
        unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k] = unit[cid][i][j].lmwd[k]; /* align不要 */
d1325 1
a1325 1
          unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k] = unit[cid][i][j].lmwd[k]; /* align不要 */
d1416 1
a1416 1
  case STATUS_LOAD:
d2026 1
a2026 1
      printf("\033[1;%dm|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x\033[0m",
d2063 1
a2063 1
      printf("\033[1;%dm|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x\033[0m",
@


1.99
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.98 2016/05/10 23:15:28 nakashim Exp nakashim $";
d642 2
a643 2
		    emax5[cid].fsm[j].row_select = 1LL<<i;
		    emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
d671 2
a672 2
		    emax5[cid].fsm[j].row_select   = 0LL;
		    emax5[cid].fsm[j].row_lmm_en   = 0LL;
d700 3
d714 2
@


1.98
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.97 2016/05/08 05:30:40 nakashim Exp nakashim $";
d950 2
a951 2
    s = unit[cid][i][j].conf.cdw1.ea0bs;  unit[cid][i][j].ea0b = (s&2)?unit[cid][i][j].regv.ea0br:unit[cid][i][j].eab;
    s = unit[cid][i][j].conf.cdw1.ea0os;  unit[cid][i][j].ea0o = (s&1)?unit[cid][i][j].regv.ea0or:unit[cid][i][j].eao;
d969 2
a970 2
    s = unit[cid][i][j].conf.cdw1.ea1bs;  unit[cid][i][j].ea1b = (s&2)?unit[cid][i][j].regv.ea1br:unit[cid][i][j].eab;
    s = unit[cid][i][j].conf.cdw1.ea1os;  unit[cid][i][j].ea1o = (s&1)?unit[cid][i][j].regv.ea1or:unit[cid][i][j].eao;
d1102 1
a1102 1
      r4     = unit[cid][i][j].conf.cdw0.e2is==0 ? unit[cid][i][j].conf.cdw0.e2imm
d2004 2
a2005 1
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
d2041 2
a2042 1
      printf("|%08.8x%08.8x %08.8x%08.8x %08.8x%08.8x %08.8x%08.8x",
@


1.97
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.96 2016/05/07 13:52:53 nakashim Exp nakashim $";
d1510 1
a1510 1
  printf("                                       load=%08.8x_%08.8x regv=%08.8x_%08.8x start=%08.8x_%08.8x exec=%08.8x_%08.8x term=%08.8x_%08.8x trans=%08.8x_%08.8x\n",
@


1.96
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.95 2016/05/07 11:31:57 nakashim Exp nakashim $";
d466 3
a468 4
          int lmm_ready =  emax5[cid].fsm[j].lmmo[i].v
                        && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
                        && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
                        && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top;
a652 4
		  else if (emax5[cid].status==STATUS_LMMI) {
		    for (k=0; k<UNIT_WIDTH; k++) /* copy lmmo <- lmmc */
		      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1)) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1));
		  }
d702 4
a705 1
		    for (k=0; k<UNIT_WIDTH; k++)
d707 1
d715 6
a720 1
            emax5[cid].fsm[j].row_count++;
@


1.95
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.94 2016/05/07 11:26:09 nakashim Exp nakashim $";
d45 1
d56 1
d249 1
a249 1
  int i, j, k, flag, sync;
d264 1
d760 1
d780 4
a783 3
      printf(" c%d s%d i%d d%d l%d r%d e%d z%d t%d\n",
             emax5[cid].cycles_conf_part, emax5[cid].cycles_scon_part, emax5[cid].cycles_lmmi_part, emax5[cid].cycles_drain_part, emax5[cid].cycles_load_part,
             emax5[cid].cycles_regv_part, emax5[cid].cycles_exec_part, emax5[cid].cycles_term_part,  emax5[cid].cycles_trans_part);
d790 1
d1506 1
a1506 1
  printf("                                       load=%08.8x_%08.8x regv=%08.8x_%08.8x exec=%08.8x_%08.8x term=%08.8x_%08.8x trans=%08.8x_%08.8x\n",
d1509 1
d1513 1
a1513 1
  total = emax5[cid].cycles_tinit+emax5[cid].cycles_conf+emax5[cid].cycles_scon+emax5[cid].cycles_lmmi+emax5[cid].cycles_drain+emax5[cid].cycles_load+emax5[cid].cycles_regv+emax5[cid].cycles_exec+emax5[cid].cycles_term+emax5[cid].cycles_trans;
d1526 1
@


1.94
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.93 2016/05/03 05:39:54 nakashim Exp nakashim $";
d360 1
a360 1
	if (emax5[cid].fsm[j].row_count < emax5[cid].last_dist) { /* last_dist > 0 */
d757 1
a758 1
	emax5[cid].status = STATUS_EXEC;
@


1.93
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.92 2016/05/01 23:03:23 nakashim Exp nakashim $";
d17 4
a20 1
enum { STATUS_IDLE, STATUS_CONF, STATUS_LMMI, STATUS_DRAIN, STATUS_LOAD, STATUS_REGV, STATUS_START, STATUS_EXEC, STATUS_TERM };
d40 1
d50 1
d257 1
d329 1
a329 1
      else if (emax5[cid].last_conf != conf || emax5[cid].last_dist > 0) {
d331 1
a331 1
          printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (new)\n", tid, (Uint)(conf>>32), (Uint)conf);
d334 11
d356 17
d647 1
a647 1
		  if (emax5[cid].status==STATUS_CONF) {
a648 1
		  }
d726 1
a726 1
	  break;
a744 1
          emax5[cid].fsm[j].row_lmm_en   = 0LL;
d746 8
d755 1
a755 1
      break;
d758 4
a761 14
        switch (emax5[cid].fsm[j].memif_status) {
        case MEMIF_AREQ:
          emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
          emax5[cid].fsm[j].row_select = 1LL<<emax5[cid].last_row0; /* start row */
          break;
        case MEMIF_DREQ:
          emax5[cid].status = STATUS_EXEC;
          for (j=0; j<EMAX_WIDTH; j++) {
            emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
            emax5[cid].fsm[j].row_count    = 0;
            emax5[cid].fsm[j].row_select   = 0LL;
          }
          break;
        }
d776 2
a777 2
      printf(" c%d i%d d%d l%d r%d e%d z%d t%d\n",
             emax5[cid].cycles_conf_part, emax5[cid].cycles_lmmi_part, emax5[cid].cycles_drain_part, emax5[cid].cycles_load_part,
d780 1
d1037 1
d1074 1
d1120 1
d1218 10
d1372 1
d1492 1
a1492 1
  printf("%03.3d:PA %08.8x_%08.8x siml_emax5: tinit=%08.8x_%08.8x conf=%08.8x_%08.8x lmmi=%08.8x_%08.8x drain=%08.8x_%08.8x load=%08.8x_%08.8x\n",
d1497 1
d1499 3
a1501 3
         (Uint)(emax5[cid].cycles_drain>>32), (Uint)emax5[cid].cycles_drain,
         (Uint)(emax5[cid].cycles_load>>32),  (Uint)emax5[cid].cycles_load);
  printf("                                      regv=%08.8x_%08.8x exec=%08.8x_%08.8x term=%08.8x_%08.8x trans=%08.8x_%08.8x\n",
d1506 1
a1506 1
  total = emax5[cid].cycles_tinit+emax5[cid].cycles_conf+emax5[cid].cycles_lmmi+emax5[cid].cycles_drain+emax5[cid].cycles_load+emax5[cid].cycles_regv+emax5[cid].cycles_exec+emax5[cid].cycles_term+emax5[cid].cycles_trans;
d1514 1
@


1.92
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.91 2016/05/01 16:01:08 nakashim Exp nakashim $";
d439 3
a441 3
            if      (mode==1 && emax5[cid].fsm[j].lmmd[i] && (lmmo_stat == 12 || lmmo_stat == 14)) flag = 1; /* 12:lmw, 14:lmx drain */
            else if (mode==2 && emax5[cid].fsm[j].lmmd[i])                                         flag = 1; /* drain_dirty_lmm */
            else                                                                                   flag = 0; /* skip drain */
d1502 1
a1502 1
      printf("|\033[1;%dmlmmd%d v%d rw%d f%d p%d b%d l%08.8x top%08.8x%08.8x\033[0m",
d1516 1
a1516 1
      printf("|\033[1;%dmlmmd%d v%d rw%d f%d p%d b%d l%08.8x top%08.8x%08.8x\033[0m",
@


1.91
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.90 2016/05/01 15:01:23 nakashim Exp nakashim $";
a688 3
          emax5[cid].last_conf = conf;
          emax5[cid].last_dist = emax5[cid].fsm[0].last_dist;
          emax5[cid].last_row0 = (emax5[cid].last_row0+emax5[cid].last_dist)%EMAX_DEPTH;
d736 3
@


1.90
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.89 2016/05/01 13:52:28 nakashim Exp nakashim $";
d564 12
d818 3
a820 3
	    if (trace)
	      printf("%03.3d:siml_axiif: read col=%d iaddr=%08.8x_%08.8x rdata[%d]=%08.8x_%08.8x\n",
		     tid, j, (Uint)(a>>32), (Uint)a, k, (Uint)(emax5[cid].fsm[j].axi_rdata[k]>>32), (Uint)emax5[cid].fsm[j].axi_rdata[k]);
d839 7
a845 5
	    Ull a = emax5[cid].fsm[j].iaddr + sizeof(Ull)*(emax5[cid].fsm[j].ilen*UNIT_WIDTH+k);
	    *(Ull*)(base + a) = emax5[cid].fsm[j].axi_wdata[k];
	    if (trace)
	      printf("%03.3d:siml_axiif: write col=%d iaddr=%08.8x_%08.8x wdata[%d]=%08.8x_%08.8x\n",
		     tid, j, (Uint)(a>>32), (Uint)a, k, (Uint)(emax5[cid].fsm[j].axi_wdata[k]>>32), (Uint)emax5[cid].fsm[j].axi_wdata[k]);
@


1.89
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.88 2016/05/01 13:17:23 nakashim Exp nakashim $";
d533 1
a533 1
              if (emax5[cid].status==STATUS_DRAIN                                      /* drain */
d573 2
d780 3
d789 3
d803 7
a809 2
	for (k=0; k<UNIT_WIDTH; k++) /* 32B aligned */
	  emax5[cid].fsm[j].axi_rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].iaddr + sizeof(Ull)*(emax5[cid].fsm[j].ilen*UNIT_WIDTH+k));
@


1.88
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.87 2016/05/01 12:20:44 nakashim Exp nakashim $";
d267 1
a267 1
    siml_axiif(cid, base);
d758 1
a758 1
siml_axiif(cid, base) Uint cid; char *base;
d760 1
d813 7
a819 2
	  for (k=0; k<UNIT_WIDTH; k++) /* 32B aligned */
	    *(Ull*)(base + emax5[cid].fsm[j].iaddr + sizeof(Ull)*(emax5[cid].fsm[j].ilen*UNIT_WIDTH+k)) = emax5[cid].fsm[j].axi_wdata[k];
@


1.87
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.86 2016/05/01 09:52:28 nakashim Exp nakashim $";
d557 18
a578 1
		  emax5[cid].fsm[j].row_lmm_en   = 0LL;
a620 1
		    emax5[cid].fsm[j].row_lmm_en   = 0LL;
d630 29
a658 29
	      }
	      /**************************************************/
	      /* MMEMからのrvalid到着データをUNIT/FSMへ書き込み */
	      /**************************************************/
              if (emax5[cid].fsm[j].axi_rvalid) {
		switch (emax5[cid].status) {
		case STATUS_CONF:
		  emax5[cid].fsm[j].last_dist = emax5[cid].fsm[j].axi_rdata[3] & 0x3f; /* mapdist */
		  emax5[cid].fsm[j].row_count++;
		  break;
		case STATUS_REGV:
		  emax5[cid].fsm[j].row_count+=(emax5[cid].fsm[j].rrdyc&1); /* even/odd */
		  break;
		case STATUS_LMMI:
		  emax5[cid].fsm[j].row_count+=2;
		  break;
		case STATUS_DRAIN:
		case STATUS_LOAD:
		case STATUS_EXEC:
		  break;
		}
		if (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV
	         || emax5[cid].status==STATUS_LOAD                                        /* load */
                 ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
		  for (k=0; k<UNIT_WIDTH; k++) {
		    emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].axi_rdata[k];
		    if (trace)
		      printf("%03.3d:siml_emax5: load row=%d col=%d lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
d660 1
a661 5
		else if (emax5[cid].status==STATUS_LMMI) {
		  for (k=0; k<UNIT_WIDTH; k++)
		    *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1)) = emax5[cid].fsm[j].axi_rdata[k];
		}
		emax5[cid].fsm[j].rrdyc++;		
a662 17
	      /*********************************************/
	      /* LMMからのrrdy到着データを主記憶へ書き込み */
	      /*********************************************/
	      if (unit[cid][i][j].rrdy) { /* ack from lmm */
		if (emax5[cid].status==STATUS_DRAIN                                         /* drain */
                 ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw == 1)) { /* pdrain */
		  emax5[cid].fsm[j].axi_wvalid = 1;
		  for (k=0; k<UNIT_WIDTH; k++) { /* 32B aligned */
		    emax5[cid].fsm[j].axi_wdata[k] = emax5[cid].fsm[j].lmrd[k];
		    if (trace)
		      printf("%03.3d:siml_emax5: drain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
		  }
                }
		emax5[cid].fsm[j].rrdyc++;		
              }
              break;
@


1.86
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.85 2016/05/01 07:56:28 nakashim Exp nakashim $";
d91 2
a92 1
    Uint  rrdyc                 ; /* LMM data-ready(read), AXI data-ready(rvalid) counter */
d462 1
d533 22
a554 14
	      emax5[cid].fsm[j].axi_arvalid = 0;
	      emax5[cid].fsm[j].axi_awvalid = 0;
              if (emax5[cid].fsm[j].rrdyc <= emax5[cid].fsm[j].lmm_nreq) { /* /* 0.5/1/2rrdy/1unit */
		/**********************/
		/* row_selectをセット */
		/**********************/
		switch (emax5[cid].status) {
		case STATUS_CONF: case STATUS_REGV: case STATUS_LMMI:
		  emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH); /* units ignore row_select in STATUS_LMMI */
		  break;
		case STATUS_DRAIN: case STATUS_LOAD: case STATUS_EXEC:
		  emax5[cid].fsm[j].row_select = 1LL<<i;
		  emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
		  break;
d556 6
a561 13
		/************************/
		/* generate lmm address */
		/************************/
                if (emax5[cid].status==STATUS_DRAIN                                       /* drain */
                 ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1)) { /* pdrain */
                  emax5[cid].fsm[j].lmra = (emax5[cid].fsm[j].awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) + emax5[cid].fsm[j].rrdyc*sizeof(Ull)*UNIT_WIDTH;
                  if (trace) {
                    printf("%03.3d:siml_emax5: drain row=%d col=%d lmra=%08.8x_%08.8x (%d/%d)\n",
                           tid, i, j, (Uint)(emax5[cid].fsm[j].lmra>>32), (Uint)emax5[cid].fsm[j].lmra, emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
                  }
                }
		else if (emax5[cid].status==STATUS_CONF) {
                  emax5[cid].fsm[j].lmwa = 0LL; /* fixed */
d563 36
a598 5
		else if (emax5[cid].status==STATUS_REGV)
                  emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].rrdyc&1; /* even/odd */
		else if (emax5[cid].status==STATUS_LMMI) {
                  for (k=0; k<UNIT_WIDTH; k++) /* copy lmmo <- lmmc */
                    *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1)) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1));
d600 13
a612 7
                else if (emax5[cid].status==STATUS_LOAD                                        /* load */
		      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
                  emax5[cid].fsm[j].lmwa = (emax5[cid].fsm[j].araddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) + emax5[cid].fsm[j].rrdyc*sizeof(Ull)*UNIT_WIDTH;
                  if (trace) {
                    printf("%03.3d:siml_emax5: load row=%d col=%d lmwa=%08.8x_%08.8x (%d/%d)\n",
                           tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa, emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
                  }
d614 1
a614 23
              }
              else { /* バースト転送終了 */
		if      (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV || emax5[cid].status==STATUS_LMMI) {
		  emax5[cid].fsm[j].memif_status = MEMIF_TERM;
		  emax5[cid].fsm[j].row_select   = 0LL;
                  emax5[cid].fsm[j].row_lmm_en   = 0LL;
		}
                else if (emax5[cid].status==STATUS_DRAIN                                         /* drain */
                      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw == 1)) { /* pdrain */
                  emax5[cid].fsm[j].lmmd[i] = 0;
                  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
                  emax5[cid].fsm[j].row_count++;
		  emax5[cid].fsm[j].row_select   = 0LL;
                  emax5[cid].fsm[j].row_lmm_en   = 0LL;
                }
                else if (emax5[cid].status==STATUS_LOAD                                          /* load */
                      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw == 0)) { /* pload */
                  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
                  emax5[cid].fsm[j].row_count++;
                  emax5[cid].fsm[j].row_select   = 0LL;
                  emax5[cid].fsm[j].row_lmm_en   = 0LL;
                }
              }
d641 2
a642 3
		      printf("%03.3d:siml_emax5: load row=%d col=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa,
			     k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].rrdyc, emax5[cid].fsm[j].lmm_nreq);
d658 1
a658 1
		  for (k=0; k<UNIT_WIDTH; k++) /* 32B aligned */
d660 4
@


1.85
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.84 2016/04/30 00:20:19 nakashim Exp nakashim $";
d463 1
d468 1
d473 1
d478 1
d483 1
d488 1
d493 1
d531 2
d644 1
d780 1
d1498 1
a1499 1
           (Uint) emax5[cid].fsm[col].memif_status,
d1507 13
a1519 1
  printf("lmwalmra");
d1521 1
a1521 1
    printf("|%08.8x%08.8x %08.8x%08.8x                                  ",
d1525 5
a1529 1
           (Uint) emax5[cid].fsm[col].lmra);
d1555 14
a1568 1
  printf("axrw ral");
d1571 8
a1578 8
           (Uint)(emax5[cid].fsm[col].axra>>32),
           (Uint) emax5[cid].fsm[col].axra,
           (Uint)(emax5[cid].fsm[col].axwa>>32),
           (Uint) emax5[cid].fsm[col].axwa,
           (Uint)(emax5[cid].fsm[col].araddr>>32),
           (Uint) emax5[cid].fsm[col].araddr,
           (Uint)(emax5[cid].fsm[col].arlen>>32),
           (Uint) emax5[cid].fsm[col].arlen);
a1591 8
  printf("wadrwlen");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("|%08.8x%08.8x %08.8x%08.8x                                  ",
           (Uint)(emax5[cid].fsm[col].awaddr>>32),
           (Uint) emax5[cid].fsm[col].awaddr,
           (Uint)(emax5[cid].fsm[col].awlen>>32),
           (Uint) emax5[cid].fsm[col].awlen);
  printf("\n");
@


1.84
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.83 2016/04/29 11:52:18 nakashim Exp nakashim $";
d85 40
a124 26
    Ull   last_dist       : 6; /* latest map_dist */
    Ull   memif_status    : 4;
    Ull   row_count       : 8; /* valid row counter is 6bit */
    Ull   row_select      :64; /* bitmap 0:off 1:selected */
    Ull   row_lmm_en      :64; /* lmm enable for read/write */
    Uint  ardyc;               /* LMM addr-request(read/write) counter */
    Uint  rrdyc;               /* LMM data-ready(read) counter */
                               /*                         CF  RV  LI  PF  DR  TR  DM                 */
    Ull   lmwa               ; /* -> ea0dr                     v       v                             */
    Ull   lmwd[UNIT_WIDTH]   ; /* <- lmm wdata                 v       v           v                 */
    Ull   lmra               ; /* -> ea1dr                                 v                         */
    Ull   lmrd[UNIT_WIDTH]   ; /* -> lmm rdata                             v   v                     */
    Ull   axra               ; /* <- ea0dr                     -       -           v                 */
    Ull   axwa               ; /* <- ea1dr (not used)                      -                         */

    Ull   rbusy           : 1; /* fsm internal */
    Ull   ravalid         : 1; /* emax -> axi                                                        */
    Ull   raddr              ; /* read-address  of mm      v   v   v   v           v                 */
    Ull   rlen               ; /* read-length   of mm      v   v   v   v           1                 */
    Ull   rvalid          : 1; /* axi -> emax read-ready                                             */
    Ull   rdata[UNIT_WIDTH]  ; /* read-data     of mm      v   v   v   v           v                 */
    Ull   wbusy           : 1; /* fsm internal                                                       */
    Ull   wavalid         : 1; /* emax -> axi                                                        */
    Ull   waddr              ; /* write-address of mm                      v                         */
    Ull   wlen               ; /* write-length  of mm                      v                         */
    Ull   wdata[UNIT_WIDTH];   /* write-data    of mm                      v                         */
d126 1
a126 1
    Ull   tcureg[UNIT_WIDTH];  /* tcu-data      of tcu                         v                     */
a174 1
    Ull   mb0         : 5; /* internal reg  addr(byte index in 32B)*/
a175 1
    Ull   mb1         : 5; /* internal reg  addr(byte index in 32B)*/
d266 1
a266 1
    siml_axiif(cid);
d432 1
a454 1
            Uint lmm_nreq;
d457 3
a459 1
	      /* AXIアドレスおよび長さをセット */
d461 1
a461 1
              emax5[cid].fsm[j].ardyc = 0; /* LMM addr-request(read/write) counter */
d463 2
a464 3
                emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read) counter */
                emax5[cid].fsm[j].waddr = (mode==1)?emax5[cid].fsm[j].lmmo[i].top:emax5[cid].fsm[j].lmmc[i].top;
                emax5[cid].fsm[j].wlen  = (mode==1)?emax5[cid].fsm[j].lmmo[i].len:emax5[cid].fsm[j].lmmc[i].len;
d467 2
a468 3
                emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read) counter */
                emax5[cid].fsm[j].waddr = emax5[cid].fsm[j].lmmc[i].top;
                emax5[cid].fsm[j].wlen  = emax5[cid].fsm[j].lmmc[i].len;
d470 3
a472 4
              if      (emax5[cid].status==STATUS_CONF) {
                emax5[cid].fsm[j].rrdyc = 0; /* AXI data-ready(read) counter */
                emax5[cid].fsm[j].raddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
                emax5[cid].fsm[j].rlen  =                  UNIT_WIDTH*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
d475 2
a476 3
                emax5[cid].fsm[j].rrdyc = 0; /* AXI data-ready(read) counter */
                emax5[cid].fsm[j].raddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*j; /* regv_topをfsmに渡すインタフェース */
                emax5[cid].fsm[j].rlen  =                  UNIT_WIDTH*2*EMAX_DEPTH*1; /* regv_topをfsmに渡すインタフェース */
d479 2
a480 3
                emax5[cid].fsm[j].rrdyc = 0; /* AXI data-ready(read) counter */
                emax5[cid].fsm[j].raddr = lmmi+sizeof(Ull)*2*EMAX_DEPTH*j; /* lmmi_topをfsmに渡すインタフェース */
                emax5[cid].fsm[j].rlen  =                  2*EMAX_DEPTH*1; /* lmmi_topをfsmに渡すインタフェース */
d483 2
a484 3
                emax5[cid].fsm[j].rrdyc = 0; /* AXI data-ready(read) counter */
                emax5[cid].fsm[j].raddr = emax5[cid].fsm[j].lmmc[i].top;
                emax5[cid].fsm[j].rlen  = emax5[cid].fsm[j].lmmc[i].len;
d487 2
a488 3
                emax5[cid].fsm[j].rrdyc = 0; /* AXI data-ready(read) counter */
                emax5[cid].fsm[j].raddr = emax5[cid].fsm[j].lmmc[i].top;
                emax5[cid].fsm[j].rlen  = emax5[cid].fsm[j].lmmc[i].len;
d490 32
d524 4
a527 21
              /* block 0:inf, 1:16, 2:32, 3:64 dword*UNIT_WIDTH*block=page(burst_size)    */
              /* 通常は,     block=0                                                      */
              /* tricountは, block=2                                                      */
              /* EMAX5では必ず64bit*4幅                                                   */
              /* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
              /* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
              /* align=32B, block=0, blocking=none             ... align済 4倍幅load      */
              /* --- blocking-load --- : fsmがblock単位にburst起動                        */
              /* align=xxx, block=1, blocksize=8*4*16=512B     ... 下位5bit無視 4倍幅load */
              /* align=xxx, block=2, blocksize=8*4*32=1KB      ... 下位5bit無視 4倍幅load */
              /* align=xxx, block=3, blocksize=8*4*64=2KB      ... 下位5bit無視 4倍幅load */
	      switch (emax5[cid].status) {
	      case STATUS_CONF: case STATUS_REGV: case STATUS_LMMI:
		lmm_nreq = emax5[cid].fsm[j].rlen/UNIT_WIDTH;
		break;
	      case STATUS_DRAIN: case STATUS_LOAD: case STATUS_EXEC:
		lmm_nreq = ((emax5[cid].status==STATUS_DRAIN && mode==1)?emax5[cid].fsm[j].lmmo[i].len:emax5[cid].fsm[j].lmmc[i].len)/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
		break;
	      }
              if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* /* 0.5/1/2rrdy/1unit */
                Ull ofs;
d542 1
a542 1
                  emax5[cid].fsm[j].lmra = emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
d545 1
a545 1
                           tid, i, j, (Uint)(emax5[cid].fsm[j].lmra>>32), (Uint)emax5[cid].fsm[j].lmra, emax5[cid].fsm[j].ardyc, lmm_nreq);
d548 1
a548 1
		else if (emax5[cid].status==STATUS_CONF)
d550 1
d552 1
a552 1
                  emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].ardyc&1; /* even/odd */
d554 1
a554 1
                  for (k=0; k<UNIT_WIDTH; k++)
a556 8
                else if (emax5[cid].status==STATUS_LOAD                                      /* load */
                      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) /* pload */
                  emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
		/***********************/
		/* calc offset address */
		/***********************/
		if      (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV || emax5[cid].status==STATUS_LMMI)
		  ofs = emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc)*UNIT_WIDTH;
d558 5
a562 15
                      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
                  /*** GATHER ************/
                  switch (emax5[cid].fsm[j].lmmc[i].blk) {
                  case 0: /* inf */
                    ofs =        (       emax5[cid].fsm[j].raddr                                         ) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc   )*UNIT_WIDTH;
                    break;
                  case 1: /* 16 */
                    ofs = *(Ull*)(base + emax5[cid].fsm[j].raddr+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%16)*UNIT_WIDTH; /* ★★★(DELAY) */
                    break;
                  case 2: /* 32 */
                    ofs = *(Ull*)(base + emax5[cid].fsm[j].raddr+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%32)*UNIT_WIDTH; /* ★★★(DELAY) */
                    break;
                  case 3: /* 64 */
                    ofs = *(Ull*)(base + emax5[cid].fsm[j].raddr+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%64)*UNIT_WIDTH; /* ★★★(DELAY) */
                    break;
a564 47
		/******************************/
		/* read data from MAIN-MEMORY */
		/******************************/
		if (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV || emax5[cid].status==STATUS_LMMI
                 || emax5[cid].status==STATUS_LOAD                                        /* load */
                 ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
		  for (k=0; k<UNIT_WIDTH; k++)
		    emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + ofs + sizeof(Ull)*k); /* ★★★(DELAY) */
		}
		/**************************/
		/* store data in unit/fsm */
		/**************************/
		if (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV
		 || emax5[cid].status==STATUS_LOAD                                        /* load */
                 ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
                  for (k=0; k<UNIT_WIDTH; k++) {
                    emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k];
		    if (trace)
		      printf("%03.3d:siml_emax5: load row=%d col=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa,
			     k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].ardyc, lmm_nreq);
		  }
		}
		else if (emax5[cid].status==STATUS_LMMI) {
		  for (k=0; k<UNIT_WIDTH; k++)
		    *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1)) = emax5[cid].fsm[j].rdata[k];
		}
		/****************************/
		/* update row_count & ardyc */
		/****************************/
		switch (emax5[cid].status) {
		case STATUS_CONF:
                  emax5[cid].fsm[j].last_dist = emax5[cid].fsm[j].rdata[3] & 0x3f; /* mapdist */
                  emax5[cid].fsm[j].row_count++;
		  break;
		case STATUS_REGV:
		  emax5[cid].fsm[j].row_count+=(emax5[cid].fsm[j].ardyc&1); /* even/odd */
		  break;
		case STATUS_LMMI:
                  emax5[cid].fsm[j].row_count+=2;
		  break;
		case STATUS_DRAIN:
		case STATUS_LOAD:
		case STATUS_EXEC:
		  break;
		}
                emax5[cid].fsm[j].ardyc++;
d570 1
d574 5
a578 1
                  emax5[cid].fsm[j].row_lmm_en   = 0LL; /* row_countとrow_selectは残りrrdyのために維持 */
d585 1
a585 1
                  emax5[cid].fsm[j].row_lmm_en   = 0LL; /* row_selectは直ちにOFF */
d591 34
a624 1

d628 6
a633 29
              if (emax5[cid].status==STATUS_DRAIN                                         /* drain */
               ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw == 1)) { /* pdrain */
                if (emax5[cid].fsm[j].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		  Ull ofs;
                  if (unit[cid][i][j].rrdy) { /* ack from lmm */
		    /***********************/
		    /* calc offset address */
		    /***********************/
		    ofs = emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc)*UNIT_WIDTH;
		    /******************************/
		    /* write data to MAIN-MEMORY  */
		    /******************************/
                    for (k=0; k<UNIT_WIDTH; k++) {
                      *(Ull*)(base + ofs + sizeof(Ull)*k) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k]; /* ★★★ */
                      if (trace)
                        printf("%03.3d:siml_emax5: drain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
                               tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
                    }
		    /****************/
		    /* update ardyc */
		    /****************/
                    emax5[cid].fsm[j].rrdyc++;
                  }
                }
                else { /* バースト転送終了 */
                  emax5[cid].fsm[j].lmmd[i] = 0;               /* rrdy満了時に遅れて遷移 */
                  emax5[cid].fsm[j].memif_status = MEMIF_AREQ; /* rrdy満了時に遅れて遷移 */
                  emax5[cid].fsm[j].row_count++;               /* rrdy満了時に遅れて遷移 */
                  emax5[cid].fsm[j].row_select   = 0LL;        /* rrdy満了時に遅れて遷移 */
d732 1
a732 1
siml_axiif(cid) Uint cid;
d734 9
a742 1
  int j;
d745 30
a774 1
    if (!emax5[cid].fsm[j].rbusy && emax5[cid].fsm[j].ravalid) { /* new read_req starts */
d776 17
a792 1
    else if (!emax5[cid].fsm[j].wbusy && emax5[cid].fsm[j].wavalid) { /* new write_req starts */
d795 28
d1033 1
a1033 2
      unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = unit[cid][i][j].lmra;
      unit[cid][i][j].lmm.mb1 = 0;
d1042 1
a1042 2
      unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = unit[cid][i][j].lmwa;
      unit[cid][i][j].lmm.mb0 = 0;
d1056 1
a1056 2
        unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = unit[cid][i][j].lmra;
        unit[cid][i][j].lmm.mb1 = 0;
d1068 1
a1068 2
        unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr & ~(sizeof(Ull)*UNIT_WIDTH-1);
        unit[cid][i][j].lmm.mb1 = unit[cid][i][j].ea1dr &  (sizeof(Ull)*UNIT_WIDTH-1);
a1075 1
      unit[cid][i][j].lmm.mb1 = 0LL;
d1083 1
a1083 2
        unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = unit[cid][i][j].lmwa;
        unit[cid][i][j].lmm.mb0 = 0;
d1095 1
a1095 2
        unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr & ~(sizeof(Ull)*UNIT_WIDTH-1);
        unit[cid][i][j].lmm.mb0 = unit[cid][i][j].ea0dr &  (sizeof(Ull)*UNIT_WIDTH-1);
d1260 4
a1263 4
  a0 = unit[cid][i][j].ea0dr % LMEM_SIZE; /* should be aligned by fsm */
  a1 = unit[cid][i][j].ea1dr % LMEM_SIZE; /* should be aligned by fsm */
  a0al = a0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */
  a1al = a1 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */
d1486 1
a1486 1
    printf("|%d %d rc%02.2d rs%08.8x%08.8x lmen%08.8x%08.8x ardy%04.4d rrdy=%04.4d",
a1493 1
           emax5[cid].fsm[col].ardyc,
d1535 4
a1538 4
           (Uint)(emax5[cid].fsm[col].raddr>>32),
           (Uint) emax5[cid].fsm[col].raddr,
           (Uint)(emax5[cid].fsm[col].rlen>>32),
           (Uint) emax5[cid].fsm[col].rlen);
d1543 8
a1550 8
           (Uint)(emax5[cid].fsm[col].rdata[3]>>32),
           (Uint) emax5[cid].fsm[col].rdata[3],
           (Uint)(emax5[cid].fsm[col].rdata[2]>>32),
           (Uint) emax5[cid].fsm[col].rdata[2],
           (Uint)(emax5[cid].fsm[col].rdata[1]>>32),
           (Uint) emax5[cid].fsm[col].rdata[1],
           (Uint)(emax5[cid].fsm[col].rdata[0]>>32),
           (Uint) emax5[cid].fsm[col].rdata[0]);
d1555 4
a1558 4
           (Uint)(emax5[cid].fsm[col].waddr>>32),
           (Uint) emax5[cid].fsm[col].waddr,
           (Uint)(emax5[cid].fsm[col].wlen>>32),
           (Uint) emax5[cid].fsm[col].wlen);
d1563 8
a1570 8
           (Uint)(emax5[cid].fsm[col].wdata[3]>>32),
           (Uint) emax5[cid].fsm[col].wdata[3],
           (Uint)(emax5[cid].fsm[col].wdata[2]>>32),
           (Uint) emax5[cid].fsm[col].wdata[2],
           (Uint)(emax5[cid].fsm[col].wdata[1]>>32),
           (Uint) emax5[cid].fsm[col].wdata[1],
           (Uint)(emax5[cid].fsm[col].wdata[0]>>32),
           (Uint) emax5[cid].fsm[col].wdata[0]);
d1852 1
a1852 1
      printf("|en%d rw%d ma%08.8x%08.8x mb%02.2x   en%d rw%d ma%08.8x%08.8x mb%02.2x  ",
a1856 1
             (Uint) unit[cid][row][col].lmm.mb1,
d1860 1
a1860 2
             (Uint) unit[cid][row][col].lmm.ma0,
             (Uint) unit[cid][row][col].lmm.mb0);
@


1.83
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.82 2016/04/29 11:48:27 nakashim Exp nakashim $";
d100 10
a109 5
    Ull   raddr;               /* read-address  of mm      v   v   v   v           v                 */
    Ull   rlen;                /* read-length   of mm      v   v   v   v           1                 */
    Ull   rdata[UNIT_WIDTH];   /* read-data     of mm      v   v   v   v           v                 */
    Ull   waddr;               /* write-address of mm                      v                         */
    Ull   wlen;                /* write-length  of mm                      v                         */
d254 1
d459 1
d464 1
d469 1
d474 1
d479 1
d625 4
d759 12
@


1.82
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.81 2016/04/29 10:10:35 nakashim Exp nakashim $";
d454 1
a454 1
                emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
d458 1
a458 1
                emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*1; /* regv_topをfsmに渡すインタフェース */
d462 1
a462 1
                emax5[cid].fsm[j].rlen  =      sizeof(Ull)*2*EMAX_DEPTH*1; /* lmmi_topをfsmに渡すインタフェース */
d487 1
a487 1
		lmm_nreq = emax5[cid].fsm[j].rlen/(sizeof(Ull)*UNIT_WIDTH);
@


1.81
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.80 2016/04/29 10:08:49 nakashim Exp nakashim $";
d1126 1
a1126 1
            unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? 0xffffffffffffffffLL : 0LL; /* mask */
d1132 2
a1133 2
            unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (0x00000000ffffffffLL<<(a & sizeof(int))*8) : 0LL; /* mask */
            unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & sizeof(int))*8       ; /* align必要 */
d1138 2
a1139 2
            unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (0x000000000000ffffLL<<(a & (sizeof(int)|sizeof(short)))*8) : 0LL; /* mask */
            unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & (sizeof(int)|sizeof(short)))*8       ; /* align必要 */
d1144 2
a1145 2
            unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (0x00000000000000ffLL<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8) : 0LL; /* mask */
            unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8       ; /* align必要 */
a1149 1
        case OP_TR:
d1156 6
@


1.80
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.79 2016/04/29 09:48:30 nakashim Exp nakashim $";
d552 3
a554 3
		if      (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV || emax5[cid].status==STATUS_LMMI
                      || emax5[cid].status==STATUS_LOAD                                        /* load */
                      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
@


1.79
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.78 2016/04/29 08:48:36 nakashim Exp nakashim $";
d576 3
a578 3
		/********************/
		/* update row_count */
		/********************/
d614 1
a614 1

d616 1
d620 1
d622 7
d630 1
a630 1
                      *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k]; /* ★★★ */
d635 3
d641 1
a641 1
                else {
@


1.78
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.77 2016/04/28 23:49:32 nakashim Exp nakashim $";
d434 1
d439 1
d504 3
a506 2

		/* generate address */
d526 5
a530 6

		/* read data from MAIN-MEMORY */
		if      (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV || emax5[cid].status==STATUS_LMMI) {
		  for (k=0; k<UNIT_WIDTH; k++)
		    emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k)); /* ★★★(DELAY) */
		}
a547 2
                  for (k=0; k<UNIT_WIDTH; k++)
                    emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + ofs + sizeof(Ull)*k); /* ★★★(DELAY) */
d549 5
a553 4

		/* store data */
		if      (emax5[cid].status==STATUS_CONF || emax5[cid].status==STATUS_REGV
		      || emax5[cid].status==STATUS_LOAD                                        /* load */
d555 9
d576 1
a576 1

d578 1
d597 1
a597 1
              else {
d603 2
a604 2
                 ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw == 1)) { /* pdrain */
                  emax5[cid].fsm[j].row_lmm_en = 0LL; /* row_selectは残りrrdyのために維持 */
d611 1
a611 1
                  emax5[cid].fsm[j].row_lmm_en   = 0LL;
d614 2
d630 4
a633 5
                  emax5[cid].fsm[j].lmmd[i] = 0;
                  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
                  emax5[cid].fsm[j].row_count++;
                  emax5[cid].fsm[j].row_select   = 0LL;
                  emax5[cid].fsm[j].row_lmm_en   = 0LL;
d645 1
d654 3
a659 3
	case STATUS_REGV:
          emax5[cid].status = STATUS_START;
	  break;
@


1.77
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.76 2016/04/28 23:43:47 nakashim Exp nakashim $";
d9 1
a9 1
/* emax5.c 2012/9/22 */ 
d29 1
a29 1
  
d34 1
a34 1
  
d53 26
a78 26
				/* dirtyが残っている場合,lmmiの前にdrain               */
				/*  conf  | drain | load | lmmi | regv | exec        | */
				/*        |       |             |      | pload       | */
				/* 残っていない場合,execと同時にdrain開始              */
				/*  conf  |       |      | lmmi | regv | exec        | */
				/*                       |      |      | drain pload | */

				/* 1 :conf  fsm_way毎に,last_row0から順にEMAX本体に格納                */
				/*          4wayが全て完了するまで待機                                 */
				/* 2 :lmmi  fsm_way毎に,fsm内部のlmmiへ読み込み                        */
				/*          4wayが全て完了するまで待機                                 */
				/*(3):drain fsm_way毎に,lmmoにdirtyがあるか検査                        */
				/*          dirtyは,fsm_way毎にdrain                                   */
				/*          4wayが全て完了するまで待機                                 */
				/*(4):load  fsm_way毎に,lmmiにpreload以外の未loadLMMがあるか検査       */
				/*          未loadLMMが存在する場合,fsm_way毎にload                    */
				/*          4wayが全て完了するまで待機                                 */
				/* 5 :regv  全fsm_wayに,start準備をセット                              */
				/*          4wayが全て完了するまで待機                                 */
				/* 6 :start 全fsm_wayに,startをセット                                  */
				/* 7 :exec  全fsm_wayのlast_row0にflag=1をセット.EMAX5起動             */
				/*          4wayが全て完了するまで待機                                 */
				/*          この間,各fsm_wayは全lmmiに未drainがあるか検査              */
				/*          未drainが存在する場合,fsm_way毎に,last_row0から順にdrain   */
				/*          drain後,pload開始(drain+ploadは，EMAX5の演算動作と同時)    */
				/*          EMAX5動作と全fsmのdrain/pload動作完了をもって,8:termへ遷移 */
d84 1
a84 1
    
d92 1
a92 1
			       /*                         CF  RV  LI  PF  DR  TR  DM                 */
d193 1
a193 1
  
d213 1
a213 1
   
d229 1
a229 1
  
d243 1
a243 1
    Ull prev1_stop, prev2_stop;    
d253 4
a256 4
	/**************************/
	/****** do lmm ************/
	/**************************/
	siml_unit_lmm(cid, i, j); /* lmm */
d259 6
a264 6
	/**************************/
	/****** do exe ************/
	/**************************/
	siml_unit_cex(cid, i, j); /* cexdr */
	siml_unit_exe(cid, i, j); /* exdr */
	siml_unit_eag(cid, i, j); /* eadr,ma */
d267 1
a267 1
	siml_unit_trg(cid, i, j); /* tr,mw */
d271 3
a273 3
	emax5[cid].unit1_stop &= ~(1LL<<i);
	emax5[cid].unit2_stop &= ~(1LL<<i);
	break;
d275 2
a276 2
	emax5[cid].unit1_exec |= emax5[cid].fsm[0].row_select;
	break;
d278 7
a284 7
	emax5[cid].unit2_stop |= ( prev1_stop           &(1LL<<  i                          ))                                      ? (1LL<<i): 0;
	emax5[cid].unit1_stop |= ( prev2_stop           &(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))                                      ? (1LL<<i): 0;
	emax5[cid].unit2_exec &= (                                                                  emax5[cid].unit2_stop&(1LL<<i) )?~(1LL<<i):~0;
	emax5[cid].unit2_exec |= ((emax5[cid].unit1_exec&(1LL<<  i                          )) && !(emax5[cid].unit2_stop&(1LL<<i)))? (1LL<<i): 0;
	emax5[cid].unit1_exec &= (                                                                  emax5[cid].unit1_stop&(1LL<<i) )?~(1LL<<i):~0;
	emax5[cid].unit1_exec |= ((emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))) && !(emax5[cid].unit1_stop&(1LL<<i)))? (1LL<<i): 0;
	break;
d287 1
a287 1
	break;
d292 1
a292 1
    
d300 3
a302 3
	if (trace)
	  printf("%03.3d:siml_emax5: drain_dirty_lmm start\n", tid);
	emax5[cid].status = STATUS_DRAIN;
d305 3
a307 3
	if (trace)
	  printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (new)\n", tid, (Uint)(conf>>32), (Uint)conf);
	emax5[cid].status = STATUS_CONF;
d310 3
a312 3
	if (trace)
	  printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (reuse)\n", tid, (Uint)(conf>>32), (Uint)conf);
	emax5[cid].status = STATUS_LMMI;
d315 3
a317 3
	emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	emax5[cid].fsm[j].row_count    = 0;
	emax5[cid].fsm[j].row_select   = 0LL;
d334 1
a334 1
      /* Example of Load+Store **************************************************************************/ 
d344 1
a344 1
      /* Example of Accumulate **************************************************************************/ 
d353 1
a353 1
      /* Example of Partial Update **********************************************************************/ 
d360 1
a360 1
      /* Example of Prefetch+Drain **********************************************************************/ 
d390 1
d392 11
a402 4
    case STATUS_REGV:
      if (emax5[cid].status==STATUS_CONF) emax5[cid].cycles_conf_part++;
      if (emax5[cid].status==STATUS_LMMI) emax5[cid].cycles_lmmi_part++;
      if (emax5[cid].status==STATUS_REGV) emax5[cid].cycles_regv_part++;
d404 86
a489 12
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {	
	  flag = 1;
	  if (flag) {
	    Uint lmm_nreq;
	    switch (emax5[cid].fsm[j].memif_status) {
	    case MEMIF_AREQ:
	      emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[j].ardyc = 0;
	      if (emax5[cid].status==STATUS_CONF) {
		emax5[cid].fsm[j].raddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
		emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
d491 23
a513 15
	      else if (emax5[cid].status==STATUS_LMMI) {
		emax5[cid].fsm[j].raddr = lmmi+sizeof(Ull)*2*EMAX_DEPTH*j; /* lmmi_topをfsmに渡すインタフェース */
		emax5[cid].fsm[j].rlen  =      sizeof(Ull)*2*EMAX_DEPTH*1; /* lmmi_topをfsmに渡すインタフェース */
	      }
	      else if (emax5[cid].status==STATUS_REGV) {
		emax5[cid].fsm[j].raddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*j; /* regv_topをfsmに渡すインタフェース */
		emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*1; /* regv_topをfsmに渡すインタフェース */
	      }
	      break;
	    case MEMIF_DREQ:
	      lmm_nreq = emax5[cid].fsm[j].rlen/(sizeof(Ull)*UNIT_WIDTH);
	      if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* 0.5/1/2rrdy/1unit */
		emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH); /* units ignore row_select in STATUS_LMMI */
		if (emax5[cid].status==STATUS_CONF)
		  emax5[cid].fsm[j].lmwa = 0LL; /* fixed */
d515 4
a518 5
		  emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].ardyc&1; /* even/odd */
		
		if (emax5[cid].status==STATUS_LMMI) {
		  for (k=0; k<UNIT_WIDTH; k++)
		    *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1)) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1));
d520 6
a525 6
		
		/* MEM-ACCESS */
		for (k=0; k<UNIT_WIDTH; k++)
		  emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k)); /* ★★★(DELAY) */
		
		if (emax5[cid].status==STATUS_LMMI) {
d527 1
a527 1
		    *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1)) = emax5[cid].fsm[j].rdata[k];
d529 19
a547 3
		else {
		  for (k=0; k<UNIT_WIDTH; k++)
		    emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k];
d550 7
a556 153
		if (emax5[cid].status==STATUS_CONF) {
		  emax5[cid].fsm[j].last_dist = emax5[cid].fsm[j].rdata[3] & 0x3f; /* mapdist */
		  emax5[cid].fsm[j].row_count++;
		}
		else if (emax5[cid].status==STATUS_LMMI)
		  emax5[cid].fsm[j].row_count+=2;
		else if (emax5[cid].status==STATUS_REGV)
		emax5[cid].fsm[j].row_count+=(emax5[cid].fsm[j].ardyc&1); /* even/odd */
		emax5[cid].fsm[j].ardyc++;
	      }
	      else {
		emax5[cid].fsm[j].memif_status = MEMIF_TERM;
		emax5[cid].fsm[j].row_select   = 0LL;
	      }
	      break;
	    }
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_CONF finished */
	if (emax5[cid].status==STATUS_CONF) {
	  emax5[cid].last_conf = conf;
	  emax5[cid].last_dist = emax5[cid].fsm[0].last_dist;
	  emax5[cid].last_row0 = (emax5[cid].last_row0+emax5[cid].last_dist)%EMAX_DEPTH;
	  emax5[cid].status = STATUS_LMMI;
	}
	else if (emax5[cid].status==STATUS_LMMI)
	  emax5[cid].status = STATUS_DRAIN;
	else if (emax5[cid].status==STATUS_REGV)
	  emax5[cid].status = STATUS_START;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	}
      }
      break;
    case STATUS_DRAIN:
    case STATUS_LOAD:
    case STATUS_EXEC: /* simulate from stage15 to stage0, from col=3 to col=0 */
      if (emax5[cid].status==STATUS_DRAIN) emax5[cid].cycles_drain_part++;
      if (emax5[cid].status==STATUS_LOAD)  emax5[cid].cycles_load_part++;
      if (emax5[cid].status==STATUS_EXEC)  emax5[cid].cycles_exec_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	if (emax5[cid].unit1_exec | emax5[cid].unit2_exec) /* exec not finished */
	  sync = 0; /* not finished */
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {
	  int lmmo_stat = (emax5[cid].fsm[j].lmmo[i].v<<3)|(emax5[cid].fsm[j].lmmo[i].rw<<2)|(emax5[cid].fsm[j].lmmo[i].f<<1)|(emax5[cid].fsm[j].lmmo[i].p); /* v | rw | f | p */
	  int lmmc_stat = (emax5[cid].fsm[j].lmmc[i].v<<3)|(emax5[cid].fsm[j].lmmc[i].rw<<2)|(emax5[cid].fsm[j].lmmc[i].f<<1)|(emax5[cid].fsm[j].lmmc[i].p); /* v | rw | f | p */
	  int lmm_ready = emax5[cid].fsm[j].lmmo[i].v
	               && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
	               && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
	               && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top;
	  if (emax5[cid].status==STATUS_DRAIN) {
	    if      (mode==1 && emax5[cid].fsm[j].lmmd[i] && (lmmo_stat == 12 || lmmo_stat == 14)) /* 12:lmw, 14:lmx */
	      flag = 1; /* drain */
	    else if (mode==2 && emax5[cid].fsm[j].lmmd[i]) /* drain_dirty_lmm */
	      flag = 1; /* drain */
	    else
	      flag = 0; /* skip drain */
	  }
	  if (emax5[cid].status==STATUS_LOAD) {
	    if (lmmc_stat==8 && !lmm_ready) /* lmr & !ready*/
	      flag = 1; /* load */
	    else if (lmmc_stat==10 || lmmc_stat==14) /* lmf/lmx always load */
	      flag = 1; /* load */
	    else
	      flag = 0; /* skip load */
	  }
	  if (emax5[cid].status==STATUS_EXEC) {
	    if (lmmc_stat==9 && !lmm_ready) /* lmp & !ready */
	      flag = 1; /* pload */
	    else if (lmmc_stat==13 && emax5[cid].fsm[j].lmmd[i]) /* lmd & dirty */
	      flag = 1; /* pdrain */
	    else
	      flag = 0; /* skip pdrain/pload */
	  }

	  if (flag) {
	    Uint lmm_nreq;
	    switch (emax5[cid].fsm[j].memif_status) {
	    case MEMIF_AREQ:
	      emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[j].ardyc = 0; /* LMM addr-request(read/write) counter */
	      if (emax5[cid].status==STATUS_DRAIN) { /* drain */
		emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read) counter */
		emax5[cid].fsm[j].waddr = (mode==1)?emax5[cid].fsm[j].lmmo[i].top:emax5[cid].fsm[j].lmmc[i].top;
		emax5[cid].fsm[j].wlen  = (mode==1)?emax5[cid].fsm[j].lmmo[i].len:emax5[cid].fsm[j].lmmc[i].len;
	      }
	      else if (emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1) { /* pdrain */
		emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read) counter */
		emax5[cid].fsm[j].waddr = emax5[cid].fsm[j].lmmc[i].top;
		emax5[cid].fsm[j].wlen  = emax5[cid].fsm[j].lmmc[i].len;
	      }
	      else if (emax5[cid].status==STATUS_LOAD) { /* load */
		emax5[cid].fsm[j].raddr = emax5[cid].fsm[j].lmmc[i].top;
		emax5[cid].fsm[j].rlen  = emax5[cid].fsm[j].lmmc[i].len;
	      }
	      else if (emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0) { /* pload */
		emax5[cid].fsm[j].raddr = emax5[cid].fsm[j].lmmc[i].top;
		emax5[cid].fsm[j].rlen  = emax5[cid].fsm[j].lmmc[i].len;
	      }
	      break;
	    case MEMIF_DREQ:
	      /* block 0:inf, 1:16, 2:32, 3:64 dword*UNIT_WIDTH*block=page(burst_size)    */
	      /* 通常は,     block=0                                                      */
	      /* tricountは, block=2                                                      */
	      /* EMAX5では必ず64bit*4幅                                                   */
	      /* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	      /* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	      /* align=32B, block=0, blocking=none             ... align済 4倍幅load      */
	      /* --- blocking-load --- : fsmがblock単位にburst起動                        */
	      /* align=xxx, block=1, blocksize=8*4*16=512B     ... 下位5bit無視 4倍幅load */
	      /* align=xxx, block=2, blocksize=8*4*32=1KB      ... 下位5bit無視 4倍幅load */
	      /* align=xxx, block=3, blocksize=8*4*64=2KB      ... 下位5bit無視 4倍幅load */
	      lmm_nreq = ((emax5[cid].status==STATUS_DRAIN && mode==1)?emax5[cid].fsm[j].lmmo[i].len:emax5[cid].fsm[j].lmmc[i].len)/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */		
	      if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		Ull ofs;
		emax5[cid].fsm[j].row_select = 1LL<<i;
		emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
		if (emax5[cid].status==STATUS_DRAIN                                       /* drain */
		 ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1)) { /* pdrain */
		  emax5[cid].fsm[j].lmra = emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
		  if (trace) {
		    printf("%03.3d:siml_emax5: drain row=%d col=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, (Uint)(emax5[cid].fsm[j].lmra>>32), (Uint)emax5[cid].fsm[j].lmra, emax5[cid].fsm[j].ardyc, lmm_nreq);
		  }
		}
		else if (emax5[cid].status==STATUS_LOAD                                        /* load */
		      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload */
		  emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
#if 1
		  /*** GATHER ************/
		  switch (emax5[cid].fsm[j].lmmc[i].blk) {
		  case 0: /* inf */
		    ofs =        (       emax5[cid].fsm[j].lmmc[i].top                                         ) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc   )*UNIT_WIDTH;
		    break;
		  case 1: /* 16 */
		    ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%16)*UNIT_WIDTH; /* ★★★(DELAY) */
		    break;
		  case 2: /* 32 */
		    ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%32)*UNIT_WIDTH; /* ★★★(DELAY) */
		    break;
		  case 3: /* 64 */
		    ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%64)*UNIT_WIDTH; /* ★★★(DELAY) */
		    break;
		  }
#endif
		  for (k=0; k<UNIT_WIDTH; k++) {
		    emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + ofs + sizeof(Ull)*k); /* ★★★(DELAY) */
		    if (trace) {
a559 1
		    }
d562 3
a564 6
		emax5[cid].fsm[j].ardyc++;
	      }
	      else {
		if (emax5[cid].status==STATUS_DRAIN                                         /* drain */
	         ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw == 1)) { /* pdrain */
		  emax5[cid].fsm[j].row_lmm_en = 0LL; /* row_selectは残りrrdyのために維持 */
d566 17
a582 6
		else if (emax5[cid].status==STATUS_LOAD                                          /* load */
		      ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw == 0)) { /* pload */
		  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		  emax5[cid].fsm[j].row_count++;
		  emax5[cid].fsm[j].row_select   = 0LL;
		  emax5[cid].fsm[j].row_lmm_en   = 0LL;
d584 5
a588 18
	      }
	      if (emax5[cid].status==STATUS_DRAIN                                         /* drain */
	       ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw == 1)) { /* pdrain */
		if (emax5[cid].fsm[j].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		  if (unit[cid][i][j].rrdy) { /* ack from lmm */
		    for (k=0; k<UNIT_WIDTH; k++) {
		      *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k]; /* ★★★ */
		      if (trace)
			printf("%03.3d:siml_emax5: drain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			       tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
		    }
		    emax5[cid].fsm[j].rrdyc++;
		  }
		}
		else {
		  emax5[cid].fsm[j].lmmd[i] = 0;
		  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		  emax5[cid].fsm[j].row_count++;
a589 1
		  emax5[cid].fsm[j].row_lmm_en   = 0LL;
d591 41
a631 9
	      }
	      break;
	    }
	  }
	  else {
	    emax5[cid].fsm[j].row_count++;
	  }
	  sync = 0; /* not finished */
	}
d634 23
a656 13
	if      (emax5[cid].status==STATUS_DRAIN && mode==1) /* normal_array */
	  emax5[cid].status = STATUS_LOAD;
	else if (emax5[cid].status==STATUS_DRAIN && mode==2) /* drain_dirty_lmm */
	  emax5[cid].status = STATUS_TERM;
	else if (emax5[cid].status==STATUS_LOAD)
	  emax5[cid].status = STATUS_REGV;
	else if (emax5[cid].status==STATUS_EXEC)
	  emax5[cid].status = STATUS_TERM;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	  emax5[cid].fsm[j].row_lmm_en   = 0LL;
d658 6
d668 14
a681 14
	switch (emax5[cid].fsm[j].memif_status) {
	case MEMIF_AREQ:
	  emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	  emax5[cid].fsm[j].row_select = 1LL<<emax5[cid].last_row0; /* start row */
	  break;
	case MEMIF_DREQ:
	  emax5[cid].status = STATUS_EXEC;
	  for (j=0; j<EMAX_WIDTH; j++) {
	    emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	    emax5[cid].fsm[j].row_count    = 0;
	    emax5[cid].fsm[j].row_select   = 0LL;
	  }
	  break;
	}
d689 3
a691 3
	emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	emax5[cid].fsm[j].row_count    = 0;
	emax5[cid].fsm[j].row_select   = 0LL;
d694 2
a695 2
	     emax5[cid].cycles_conf_part, emax5[cid].cycles_lmmi_part, emax5[cid].cycles_drain_part, emax5[cid].cycles_load_part,
	     emax5[cid].cycles_regv_part, emax5[cid].cycles_exec_part, emax5[cid].cycles_term_part,  emax5[cid].cycles_trans_part);
d723 1
a723 1
  
d730 1
a730 1
    
d735 1
a735 1
    
d739 1
a739 1
    
d742 1
a742 1
    
d787 1
a787 1
  
d835 1
a835 1
  
d871 1
a871 1
  
d916 1
a916 1
  
d950 4
a953 4
	unit[cid][i][j].lmm.en1 = 1;
	unit[cid][i][j].lmm.rw1 = 0; /* read */
	unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = unit[cid][i][j].lmra;
	unit[cid][i][j].lmm.mb1 = 0;
d956 1
a956 1
	unit[cid][i][j].lmm.en1 = 0;
d960 8
a967 8
	base1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
	offs1 = (!(unit[cid][i][j].conf.cdw1.ea1bs&1) ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
	eag(&unit[cid][i][j].ea1dr, base1, offs1, unit[cid][i][j].conf.cdw1.ea1msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
	unit[cid][i][j].lmm.en1 = 1;
	unit[cid][i][j].lmm.rw1 = 0; /* read */
	unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr & ~(sizeof(Ull)*UNIT_WIDTH-1);
	unit[cid][i][j].lmm.mb1 = unit[cid][i][j].ea1dr &  (sizeof(Ull)*UNIT_WIDTH-1);
	unit[cid][i][j].axwa    = unit[cid][i][j].ea1dr;
d970 1
a970 1
	unit[cid][i][j].lmm.en1 = 0;
d976 1
a976 1
    
d980 4
a983 4
	unit[cid][i][j].lmm.en0 = 1;
	unit[cid][i][j].lmm.rw0 = 1; /* write */
	unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = unit[cid][i][j].lmwa;
	unit[cid][i][j].lmm.mb0 = 0;
d986 1
a986 1
	unit[cid][i][j].lmm.en0 = 0;
d990 8
a997 8
	base0 = (!(unit[cid][i][j].conf.cdw1.ea0bs&1) || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
	offs0 = (!(unit[cid][i][j].conf.cdw1.ea0bs&1) ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
	eag(&unit[cid][i][j].ea0dr, base0, offs0, unit[cid][i][j].conf.cdw1.ea0msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
	unit[cid][i][j].lmm.en0 = 1;
	unit[cid][i][j].lmm.rw0 = (unit[cid][i][j].conf.cdw1.ea0op & 0x10)!=0; /* read/write */
	unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr & ~(sizeof(Ull)*UNIT_WIDTH-1);
	unit[cid][i][j].lmm.mb0 = unit[cid][i][j].ea0dr &  (sizeof(Ull)*UNIT_WIDTH-1);
	unit[cid][i][j].axra    = unit[cid][i][j].ea0dr;
d1000 1
a1000 1
	unit[cid][i][j].lmm.en0 = 0;
d1014 1
a1014 1
  
d1022 1
a1022 1
	*((Ull*)&unit[cid][i][j].conf+k) = unit[cid][i][j].lmwd[k];
d1031 2
a1032 2
	unit[cid][i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k] = unit[cid][i][j].lmwd[k]; /* align不要 */
d1040 8
a1047 8
	switch (unit[cid][i][j].lmwa) {
	case 0: /* lower */
	  *((Ull*)&unit[cid][i][j].regv+0+k) = unit[cid][i][j].lmwd[k];
	  break;
	case 1: /* upper */
	  *((Ull*)&unit[cid][i][j].regv+4+k) = unit[cid][i][j].lmwd[k];
	  break;
	}
d1058 6
a1063 6
			  : unit[cid][i][j].conf.cdw2.trs0==1 ? unit[cid][i][0].exdr
			  : unit[cid][i][j].conf.cdw2.trs0==2 ? unit[cid][i][j].t[0]
			  : unit[cid][i][j].conf.cdw2.trs0==3 ? unit[cid][i][j].lmli[0]
			  : unit[cid][i][j].conf.cdw2.trs0==4 ? unit[cid][i][j].lmwd[0]
			  : unit[cid][i][j].conf.cdw2.trs0==5 ? unit[cid][i][j].lmri[0]
			  :                                     0LL;
d1065 6
a1070 6
		          : unit[cid][i][j].conf.cdw2.trs1==1 ? unit[cid][i][1].exdr
		          : unit[cid][i][j].conf.cdw2.trs1==2 ? unit[cid][i][j].t[1]
		          : unit[cid][i][j].conf.cdw2.trs1==3 ? unit[cid][i][j].lmli[1]
		          : unit[cid][i][j].conf.cdw2.trs1==4 ? unit[cid][i][j].lmwd[1]
		          : unit[cid][i][j].conf.cdw2.trs1==5 ? unit[cid][i][j].lmri[1]
		          :                                     0LL;
d1072 6
a1077 6
		          : unit[cid][i][j].conf.cdw2.trs2==1 ? unit[cid][i][2].exdr
		          : unit[cid][i][j].conf.cdw2.trs2==2 ? unit[cid][i][j].t[2]
		          : unit[cid][i][j].conf.cdw2.trs2==3 ? unit[cid][i][j].lmli[2]
		          : unit[cid][i][j].conf.cdw2.trs2==4 ? unit[cid][i][j].lmwd[2]
		          : unit[cid][i][j].conf.cdw2.trs2==5 ? unit[cid][i][j].lmri[2]
		          :                                     0LL;
d1079 6
a1084 6
		          : unit[cid][i][j].conf.cdw2.trs3==1 ? unit[cid][i][3].exdr
		          : unit[cid][i][j].conf.cdw2.trs3==2 ? unit[cid][i][j].t[3]
		          : unit[cid][i][j].conf.cdw2.trs3==3 ? unit[cid][i][j].lmli[3]
		          : unit[cid][i][j].conf.cdw2.trs3==4 ? unit[cid][i][j].lmwd[3]
		          : unit[cid][i][j].conf.cdw2.trs3==5 ? unit[cid][i][j].lmri[3]
		          :                                     0LL;
d1088 4
a1091 4
	for (k=0; k<UNIT_WIDTH; k++) {
	  unit[cid][i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	  unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k] = unit[cid][i][j].lmwd[k]; /* align不要 */
	}
d1096 37
a1132 37
	a = unit[cid][i][j].ea0dr % LMEM_SIZE; /* main-mamory-address -> lmm-address */
	switch (unit[cid][i][j].conf.cdw1.ea0op) {
	case OP_STR:
	case OP_STBF:
	  for (k=0; k<UNIT_WIDTH; k++) {
	    unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? 0xffffffffffffffffLL : 0LL; /* mask */
	    unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k]; /* align不要 */
	  }
	  break;
	case OP_STWR:
	  for (k=0; k<UNIT_WIDTH; k++) {
	    unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (0x00000000ffffffffLL<<(a & sizeof(int))*8) : 0LL; /* mask */
	    unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & sizeof(int))*8       ; /* align必要 */
	  }
	  break;
	case OP_STHR:
	  for (k=0; k<UNIT_WIDTH; k++) {
	    unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (0x000000000000ffffLL<<(a & (sizeof(int)|sizeof(short)))*8) : 0LL; /* mask */
	    unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & (sizeof(int)|sizeof(short)))*8       ; /* align必要 */
	  }
	  break;
	case OP_STBR:
	  for (k=0; k<UNIT_WIDTH; k++) {
	    unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (0x00000000000000ffLL<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8) : 0LL; /* mask */
	    unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8       ; /* align必要 */
	  }
	  break;
	case OP_STRQ:
	case OP_STBFQ:
	case OP_TR:
	case OP_IM_PREF:
	  for (k=0; k<UNIT_WIDTH; k++) {
	    unit[cid][i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	    unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k];
	  }
	  break;
	}
d1145 1
a1145 1
  
d1155 1
a1155 1
  
d1170 1
a1170 1
	emax5[cid].fsm[j].lmrd[k] = unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
d1178 1
a1178 1
	*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
d1189 3
a1191 3
	unit[cid][i][j].rrdy = 1; /* rdata valid */
	for (k=0; k<UNIT_WIDTH; k++)
	  emax5[cid].fsm[j].lmrd[k] = unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
d1194 1
a1194 1
	unit[cid][i][j].rrdy = 0; /* rdata invalid */
d1198 2
a1199 2
	for (k=0; k<UNIT_WIDTH; k++)
	  unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
d1202 1
a1202 1
    
d1205 2
a1206 2
	for (k=0; k<UNIT_WIDTH; k++)
	  *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
d1211 2
a1212 2
	for (k=0; k<UNIT_WIDTH; k++)
	  unit[cid][i][j].lmm.mr0[k] = *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k);
d1215 3
a1217 3
	emax5[cid].fsm[j].lmmd[i] = 1; /* mark dirty */
	for (k=0; k<UNIT_WIDTH; k++)
	  *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
d1220 1
a1220 1
    
d1284 7
a1290 7
	 tid,
	 (Uint)(t[tid].total_steps>>32),      (Uint)(t[tid].total_steps),
	 (Uint)(emax5[cid].cycles_tinit>>32), (Uint)emax5[cid].cycles_tinit,
	 (Uint)(emax5[cid].cycles_conf>>32),  (Uint)emax5[cid].cycles_conf,
	 (Uint)(emax5[cid].cycles_lmmi>>32),  (Uint)emax5[cid].cycles_lmmi,
	 (Uint)(emax5[cid].cycles_drain>>32), (Uint)emax5[cid].cycles_drain,
	 (Uint)(emax5[cid].cycles_load>>32),  (Uint)emax5[cid].cycles_load);
d1292 4
a1295 4
	 (Uint)(emax5[cid].cycles_regv>>32),  (Uint)emax5[cid].cycles_regv,
	 (Uint)(emax5[cid].cycles_exec>>32),  (Uint)emax5[cid].cycles_exec,
	 (Uint)(emax5[cid].cycles_term>>32),  (Uint)emax5[cid].cycles_term,
	 (Uint)(emax5[cid].cycles_trans>>32), (Uint)emax5[cid].cycles_trans);
d1328 2
a1329 2
	 cid, emax5[cid].v, emax5[cid].tid, emax5[cid].status, (Uint)(emax5[cid].last_conf>>32), (Uint)emax5[cid].last_conf, emax5[cid].last_dist, emax5[cid].last_row0,
	 (Uint)(emax5[cid].unit1_exec>>32), (Uint)emax5[cid].unit1_exec, (Uint)(emax5[cid].unit1_stop>>32), (Uint)emax5[cid].unit1_stop, (Uint)(emax5[cid].unit2_exec>>32), (Uint)emax5[cid].unit2_exec, (Uint)(emax5[cid].unit2_stop>>32), (Uint)emax5[cid].unit2_stop);
d1339 10
a1348 10
	     (Uint) emax5[cid].fsm[col].lmmo[row].v?36:34,
	     (Uint) emax5[cid].fsm[col].lmmd[row],
	     (Uint) emax5[cid].fsm[col].lmmo[row].v,
	     (Uint) emax5[cid].fsm[col].lmmo[row].rw,
	     (Uint) emax5[cid].fsm[col].lmmo[row].f,
	     (Uint) emax5[cid].fsm[col].lmmo[row].p,
	     (Uint) emax5[cid].fsm[col].lmmo[row].blk,
	     (Uint) emax5[cid].fsm[col].lmmo[row].len,
	     (Uint)(emax5[cid].fsm[col].lmmo[row].top>>32),
	     (Uint) emax5[cid].fsm[col].lmmo[row].top);
d1353 10
a1362 10
	     (Uint) emax5[cid].fsm[col].lmmc[row].v?36:34,
	     (Uint) emax5[cid].fsm[col].lmmd[row],
	     (Uint) emax5[cid].fsm[col].lmmc[row].v,
	     (Uint) emax5[cid].fsm[col].lmmc[row].rw,
	     (Uint) emax5[cid].fsm[col].lmmc[row].f,
	     (Uint) emax5[cid].fsm[col].lmmc[row].p,
	     (Uint) emax5[cid].fsm[col].lmmc[row].blk,
	     (Uint) emax5[cid].fsm[col].lmmc[row].len,
	     (Uint)(emax5[cid].fsm[col].lmmc[row].top>>32),
	     (Uint) emax5[cid].fsm[col].lmmc[row].top);
d1372 2
a1373 2
	 (Uint)(emax5[cid].unit1_exec>>32), (Uint)emax5[cid].unit1_exec,
	 (Uint)(emax5[cid].unit1_stop>>32), (Uint)emax5[cid].unit1_stop);
d1377 2
a1378 2
	 (Uint)(emax5[cid].unit2_exec>>32), (Uint)emax5[cid].unit2_exec,
	 (Uint)(emax5[cid].unit2_stop>>32), (Uint)emax5[cid].unit2_stop);
d1383 9
a1391 9
	   (Uint) emax5[cid].fsm[col].last_dist,
	   (Uint) emax5[cid].fsm[col].memif_status,
	   (Uint) emax5[cid].fsm[col].row_count,
	   (Uint)(emax5[cid].fsm[col].row_select>>32),
	   (Uint) emax5[cid].fsm[col].row_select,
	   (Uint)(emax5[cid].fsm[col].row_lmm_en>>32),
	   (Uint) emax5[cid].fsm[col].row_lmm_en,
	   emax5[cid].fsm[col].ardyc,
	   emax5[cid].fsm[col].rrdyc);
d1396 4
a1399 4
	   (Uint)(emax5[cid].fsm[col].lmwa>>32),
	   (Uint) emax5[cid].fsm[col].lmwa,
	   (Uint)(emax5[cid].fsm[col].lmra>>32),
	   (Uint) emax5[cid].fsm[col].lmra);
d1404 8
a1411 8
	   (Uint)(emax5[cid].fsm[col].lmwd[3]>>32),
	   (Uint) emax5[cid].fsm[col].lmwd[3],
	   (Uint)(emax5[cid].fsm[col].lmwd[2]>>32),
	   (Uint) emax5[cid].fsm[col].lmwd[2],
	   (Uint)(emax5[cid].fsm[col].lmwd[1]>>32),
	   (Uint) emax5[cid].fsm[col].lmwd[1],
	   (Uint)(emax5[cid].fsm[col].lmwd[0]>>32),
	   (Uint) emax5[cid].fsm[col].lmwd[0]);
d1416 8
a1423 8
	   (Uint)(emax5[cid].fsm[col].lmrd[3]>>32),
	   (Uint) emax5[cid].fsm[col].lmrd[3],
	   (Uint)(emax5[cid].fsm[col].lmrd[2]>>32),
	   (Uint) emax5[cid].fsm[col].lmrd[2],
	   (Uint)(emax5[cid].fsm[col].lmrd[1]>>32),
	   (Uint) emax5[cid].fsm[col].lmrd[1],
	   (Uint)(emax5[cid].fsm[col].lmrd[0]>>32),
	   (Uint) emax5[cid].fsm[col].lmrd[0]);
d1428 8
a1435 8
	   (Uint)(emax5[cid].fsm[col].axra>>32),
	   (Uint) emax5[cid].fsm[col].axra,
	   (Uint)(emax5[cid].fsm[col].axwa>>32),
	   (Uint) emax5[cid].fsm[col].axwa,
	   (Uint)(emax5[cid].fsm[col].raddr>>32),
	   (Uint) emax5[cid].fsm[col].raddr,
	   (Uint)(emax5[cid].fsm[col].rlen>>32),
	   (Uint) emax5[cid].fsm[col].rlen);
d1440 8
a1447 8
	   (Uint)(emax5[cid].fsm[col].rdata[3]>>32),
	   (Uint) emax5[cid].fsm[col].rdata[3],
	   (Uint)(emax5[cid].fsm[col].rdata[2]>>32),
	   (Uint) emax5[cid].fsm[col].rdata[2],
	   (Uint)(emax5[cid].fsm[col].rdata[1]>>32),
	   (Uint) emax5[cid].fsm[col].rdata[1],
	   (Uint)(emax5[cid].fsm[col].rdata[0]>>32),
	   (Uint) emax5[cid].fsm[col].rdata[0]);
d1452 4
a1455 4
	   (Uint)(emax5[cid].fsm[col].waddr>>32),
	   (Uint) emax5[cid].fsm[col].waddr,
	   (Uint)(emax5[cid].fsm[col].wlen>>32),
	   (Uint) emax5[cid].fsm[col].wlen);
d1460 8
a1467 8
	   (Uint)(emax5[cid].fsm[col].wdata[3]>>32),
	   (Uint) emax5[cid].fsm[col].wdata[3],
	   (Uint)(emax5[cid].fsm[col].wdata[2]>>32),
	   (Uint) emax5[cid].fsm[col].wdata[2],
	   (Uint)(emax5[cid].fsm[col].wdata[1]>>32),
	   (Uint) emax5[cid].fsm[col].wdata[1],
	   (Uint)(emax5[cid].fsm[col].wdata[0]>>32),
	   (Uint) emax5[cid].fsm[col].wdata[0]);
d1472 8
a1479 8
	   (Uint)(emax5[cid].fsm[col].tcureg[3]>>32),
	   (Uint) emax5[cid].fsm[col].tcureg[3],
	   (Uint)(emax5[cid].fsm[col].tcureg[2]>>32),
	   (Uint) emax5[cid].fsm[col].tcureg[2],
	   (Uint)(emax5[cid].fsm[col].tcureg[1]>>32),
	   (Uint) emax5[cid].fsm[col].tcureg[1],
	   (Uint)(emax5[cid].fsm[col].tcureg[0]>>32),
	   (Uint) emax5[cid].fsm[col].tcureg[0]);
d1490 14
a1503 14
	     (Uint) unit[cid][row][col].conf.cdw0.op1,
	     (Uint) unit[cid][row][col].conf.cdw0.op2,
	     (Uint) unit[cid][row][col].conf.cdw0.op3,
	     (Uint) unit[cid][row][col].conf.cdw0.ex1brs,
	     (Uint) unit[cid][row][col].conf.cdw0.ex1s,
	     (Uint) unit[cid][row][col].conf.cdw0.ex1exp,
	     (Uint) unit[cid][row][col].conf.cdw0.ex2brs,
	     (Uint) unit[cid][row][col].conf.cdw0.ex2exp,
	     (Uint) unit[cid][row][col].conf.cdw0.ex3brs,
	     (Uint) unit[cid][row][col].conf.cdw0.ex3exp,
	     (Uint) unit[cid][row][col].conf.cdw0.e2imm,
	     (Uint) unit[cid][row][col].conf.cdw0.e2is,
	     (Uint) unit[cid][row][col].conf.cdw0.e3imm,
	     (Uint) unit[cid][row][col].conf.cdw0.e3is);
d1508 15
a1522 15
	     (Uint) unit[cid][row][col].conf.cdw1.cs3,
	     (Uint) unit[cid][row][col].conf.cdw1.cs2,
	     (Uint) unit[cid][row][col].conf.cdw1.cs1,
	     (Uint) unit[cid][row][col].conf.cdw1.cs0,
	     (Uint) unit[cid][row][col].conf.cdw1.cex_tab,
	     (Uint) unit[cid][row][col].conf.cdw1.ea1op,
	     (Uint) unit[cid][row][col].conf.cdw1.ea1bs,
	     (Uint) unit[cid][row][col].conf.cdw1.ea1os,
	     (Uint) unit[cid][row][col].conf.cdw1.ea1msk,
	     (Uint) unit[cid][row][col].conf.cdw1.ea0op,
	     (Uint) unit[cid][row][col].conf.cdw1.ea0bs,
	     (Uint) unit[cid][row][col].conf.cdw1.ea0os,
	     (Uint) unit[cid][row][col].conf.cdw1.ea0msk,
	     (Uint) unit[cid][row][col].conf.cdw1.eabbrs,
	     (Uint) unit[cid][row][col].conf.cdw1.eaobrs);
d1527 23
a1549 23
	     (Uint) unit[cid][row][col].conf.cdw2.lmlsa,
	     (Uint) unit[cid][row][col].conf.cdw2.lmrsa,
	     (Uint) unit[cid][row][col].conf.cdw2.lmls3,
	     (Uint) unit[cid][row][col].conf.cdw2.lmrs3,
	     (Uint) unit[cid][row][col].conf.cdw2.lmls2,
	     (Uint) unit[cid][row][col].conf.cdw2.lmrs2,
	     (Uint) unit[cid][row][col].conf.cdw2.lmls1,
	     (Uint) unit[cid][row][col].conf.cdw2.lmrs1,
	     (Uint) unit[cid][row][col].conf.cdw2.lmls0,
	     (Uint) unit[cid][row][col].conf.cdw2.lmrs0,
	     (Uint) unit[cid][row][col].conf.cdw2.ts3,
	     (Uint) unit[cid][row][col].conf.cdw2.ts2,
	     (Uint) unit[cid][row][col].conf.cdw2.ts2,
	     (Uint) unit[cid][row][col].conf.cdw2.ts0,
	     (Uint) unit[cid][row][col].conf.cdw2.trs3,
	     (Uint) unit[cid][row][col].conf.cdw2.trs2,
	     (Uint) unit[cid][row][col].conf.cdw2.trs1,
	     (Uint) unit[cid][row][col].conf.cdw2.trs0,
	     (Uint) unit[cid][row][col].conf.cdw2.brs3,
	     (Uint) unit[cid][row][col].conf.cdw2.brs2,
	     (Uint) unit[cid][row][col].conf.cdw2.brs1,
	     (Uint) unit[cid][row][col].conf.cdw2.brs0,
	     (Uint) unit[cid][row][col].conf.cdw3.mapdist);
d1554 8
a1561 8
	     (Uint)(unit[cid][row][col].regv.ea1br>>32),
	     (Uint) unit[cid][row][col].regv.ea1br,
	     (Uint)(unit[cid][row][col].regv.ea1or>>32),
	     (Uint) unit[cid][row][col].regv.ea1or,
	     (Uint)(unit[cid][row][col].regv.ea0br>>32),
	     (Uint) unit[cid][row][col].regv.ea0br,
	     (Uint)(unit[cid][row][col].regv.ea0or>>32),
	     (Uint) unit[cid][row][col].regv.ea0or);
d1566 8
a1573 8
	     (Uint)(unit[cid][row][col].regv.br[3]>>32),
	     (Uint) unit[cid][row][col].regv.br[3],
	     (Uint)(unit[cid][row][col].regv.br[2]>>32),
	     (Uint) unit[cid][row][col].regv.br[2],
	     (Uint)(unit[cid][row][col].regv.br[1]>>32),
	     (Uint) unit[cid][row][col].regv.br[1],
	     (Uint)(unit[cid][row][col].regv.br[0]>>32),
	     (Uint) unit[cid][row][col].regv.br[0]);
d1578 12
a1589 12
	     (Uint) unit[cid][row][col].one_shot,
	     (Uint) unit[cid][row][col].c[3],
	     (Uint) unit[cid][row][col].c[2],
	     (Uint) unit[cid][row][col].c[1],
	     (Uint) unit[cid][row][col].c[0],
	     (Uint) unit[cid][row][col].cexdr,
	     (Uint)(unit[cid][row][col].ex1>>32),
	     (Uint) unit[cid][row][col].ex1,
	     (Uint)(unit[cid][row][col].ex2>>32),
	     (Uint) unit[cid][row][col].ex2,
	     (Uint)(unit[cid][row][col].ex3>>32),
	     (Uint) unit[cid][row][col].ex3);
d1594 4
a1597 4
	     (Uint)(unit[cid][row][col].eab>>32),
	     (Uint) unit[cid][row][col].eab,
	     (Uint)(unit[cid][row][col].eao>>32),
	     (Uint) unit[cid][row][col].eao);
d1602 8
a1609 8
	     (Uint)(unit[cid][row][col].ea1b>>32),
	     (Uint) unit[cid][row][col].ea1b,
	     (Uint)(unit[cid][row][col].ea1o>>32),
	     (Uint) unit[cid][row][col].ea1o,
	     (Uint)(unit[cid][row][col].ea0b>>32),
	     (Uint) unit[cid][row][col].ea0b,
	     (Uint)(unit[cid][row][col].ea0o>>32),
	     (Uint) unit[cid][row][col].ea0o);
d1614 8
a1621 8
	     (Uint)(unit[cid][row][col].exdr>>32),
	     (Uint) unit[cid][row][col].exdr,
	     (Uint)(unit[cid][row][col].ea1dr>>32),
	     (Uint) unit[cid][row][col].ea1dr,
	     (Uint)(unit[cid][row][col].ea0dr>>32),
	     (Uint) unit[cid][row][col].ea0dr,
	     unit[cid][row][col].lmen,
	     unit[cid][row][col].rrdy);
d1626 4
a1629 4
	     (Uint)(unit[cid][row][col].lmwa>>32),
	     (Uint) unit[cid][row][col].lmwa,
	     (Uint)(unit[cid][row][col].lmra>>32),
	     (Uint) unit[cid][row][col].lmra);
d1634 8
a1641 8
	     (Uint)(unit[cid][row][col].lmwd[3]>>32),
	     (Uint) unit[cid][row][col].lmwd[3],
	     (Uint)(unit[cid][row][col].lmwd[2]>>32),
	     (Uint) unit[cid][row][col].lmwd[2],
	     (Uint)(unit[cid][row][col].lmwd[1]>>32),
	     (Uint) unit[cid][row][col].lmwd[1],
	     (Uint)(unit[cid][row][col].lmwd[0]>>32),
	     (Uint) unit[cid][row][col].lmwd[0]);
d1646 8
a1653 8
	     (Uint)(unit[cid][row][col].lmrd[3]>>32),
	     (Uint) unit[cid][row][col].lmrd[3],
	     (Uint)(unit[cid][row][col].lmrd[2]>>32),
	     (Uint) unit[cid][row][col].lmrd[2],
	     (Uint)(unit[cid][row][col].lmrd[1]>>32),
	     (Uint) unit[cid][row][col].lmrd[1],
	     (Uint)(unit[cid][row][col].lmrd[0]>>32),
	     (Uint) unit[cid][row][col].lmrd[0]);
d1658 4
a1661 4
	     (Uint)(unit[cid][row][col].axra>>32),
	     (Uint) unit[cid][row][col].axra,
	     (Uint)(unit[cid][row][col].axwa>>32),
	     (Uint) unit[cid][row][col].axwa);
d1666 8
a1673 8
	     (Uint)(unit[cid][row][col].lmria>>32),
	     (Uint) unit[cid][row][col].lmria,
	     (Uint)(unit[cid][row][col].lmroa>>32),
	     (Uint) unit[cid][row][col].lmroa,
	     (Uint)(unit[cid][row][col].lmlia>>32),
	     (Uint) unit[cid][row][col].lmlia,
	     (Uint)(unit[cid][row][col].lmloa>>32),
	     (Uint) unit[cid][row][col].lmloa);
d1678 8
a1685 8
	     (Uint)(unit[cid][row][col].lmri[3]>>32),
	     (Uint) unit[cid][row][col].lmri[3],
	     (Uint)(unit[cid][row][col].lmri[2]>>32),
	     (Uint) unit[cid][row][col].lmri[2],
	     (Uint)(unit[cid][row][col].lmri[1]>>32),
	     (Uint) unit[cid][row][col].lmri[1],
	     (Uint)(unit[cid][row][col].lmri[0]>>32),
	     (Uint) unit[cid][row][col].lmri[0]);
d1690 8
a1697 8
	     (Uint)(unit[cid][row][col].lmro[3]>>32),
	     (Uint) unit[cid][row][col].lmro[3],
	     (Uint)(unit[cid][row][col].lmro[2]>>32),
	     (Uint) unit[cid][row][col].lmro[2],
	     (Uint)(unit[cid][row][col].lmro[1]>>32),
	     (Uint) unit[cid][row][col].lmro[1],
	     (Uint)(unit[cid][row][col].lmro[0]>>32),
	     (Uint) unit[cid][row][col].lmro[0]);
d1702 8
a1709 8
	     (Uint)(unit[cid][row][col].lmli[3]>>32),
	     (Uint) unit[cid][row][col].lmli[3],
	     (Uint)(unit[cid][row][col].lmli[2]>>32),
	     (Uint) unit[cid][row][col].lmli[2],
	     (Uint)(unit[cid][row][col].lmli[1]>>32),
	     (Uint) unit[cid][row][col].lmli[1],
	     (Uint)(unit[cid][row][col].lmli[0]>>32),
	     (Uint) unit[cid][row][col].lmli[0]);
d1714 8
a1721 8
	     (Uint)(unit[cid][row][col].lmlo[3]>>32),
	     (Uint) unit[cid][row][col].lmlo[3],
	     (Uint)(unit[cid][row][col].lmlo[2]>>32),
	     (Uint) unit[cid][row][col].lmlo[2],
	     (Uint)(unit[cid][row][col].lmlo[1]>>32),
	     (Uint) unit[cid][row][col].lmlo[1],
	     (Uint)(unit[cid][row][col].lmlo[0]>>32),
	     (Uint) unit[cid][row][col].lmlo[0]);
d1726 8
a1733 8
	     (Uint)(unit[cid][row][col].t[3]>>32),
	     (Uint) unit[cid][row][col].t[3],
	     (Uint)(unit[cid][row][col].t[2]>>32),
	     (Uint) unit[cid][row][col].t[2],
	     (Uint)(unit[cid][row][col].t[1]>>32),
	     (Uint) unit[cid][row][col].t[1],
	     (Uint)(unit[cid][row][col].t[0]>>32),
	     (Uint) unit[cid][row][col].t[0]);
d1738 8
a1745 8
	     (Uint)(unit[cid][row][col].tr[3]>>32),
	     (Uint) unit[cid][row][col].tr[3],
	     (Uint)(unit[cid][row][col].tr[2]>>32),
	     (Uint) unit[cid][row][col].tr[2],
	     (Uint)(unit[cid][row][col].tr[1]>>32),
	     (Uint) unit[cid][row][col].tr[1],
	     (Uint)(unit[cid][row][col].tr[0]>>32),
	     (Uint) unit[cid][row][col].tr[0]);
d1750 10
a1759 10
	     (Uint) unit[cid][row][col].lmm.en1,
	     (Uint) unit[cid][row][col].lmm.rw1,
	     (Uint)(unit[cid][row][col].lmm.ma1>>32),
	     (Uint) unit[cid][row][col].lmm.ma1,
	     (Uint) unit[cid][row][col].lmm.mb1,
	     (Uint) unit[cid][row][col].lmm.en0,
	     (Uint) unit[cid][row][col].lmm.rw0,
	     (Uint)(unit[cid][row][col].lmm.ma0>>32),
	     (Uint) unit[cid][row][col].lmm.ma0,
	     (Uint) unit[cid][row][col].lmm.mb0);
d1764 8
a1771 8
	     (Uint)(unit[cid][row][col].lmm.mr1[3]>>32),
	     (Uint) unit[cid][row][col].lmm.mr1[3],
	     (Uint)(unit[cid][row][col].lmm.mr1[2]>>32),
	     (Uint) unit[cid][row][col].lmm.mr1[2],
	     (Uint)(unit[cid][row][col].lmm.mr1[1]>>32),
	     (Uint) unit[cid][row][col].lmm.mr1[1],
	     (Uint)(unit[cid][row][col].lmm.mr1[0]>>32),
	     (Uint) unit[cid][row][col].lmm.mr1[0]);
d1776 8
a1783 8
	     (Uint)(unit[cid][row][col].lmm.mr0[3]>>32),
	     (Uint) unit[cid][row][col].lmm.mr0[3],
	     (Uint)(unit[cid][row][col].lmm.mr0[2]>>32),
	     (Uint) unit[cid][row][col].lmm.mr0[2],
	     (Uint)(unit[cid][row][col].lmm.mr0[1]>>32),
	     (Uint) unit[cid][row][col].lmm.mr0[1],
	     (Uint)(unit[cid][row][col].lmm.mr0[0]>>32),
	     (Uint) unit[cid][row][col].lmm.mr0[0]);
d1788 8
a1795 8
	     (Uint)(unit[cid][row][col].lmm.mm0[3]>>32),
	     (Uint) unit[cid][row][col].lmm.mm0[3],
	     (Uint)(unit[cid][row][col].lmm.mm0[2]>>32),
	     (Uint) unit[cid][row][col].lmm.mm0[2],
	     (Uint)(unit[cid][row][col].lmm.mm0[1]>>32),
	     (Uint) unit[cid][row][col].lmm.mm0[1],
	     (Uint)(unit[cid][row][col].lmm.mm0[0]>>32),
	     (Uint) unit[cid][row][col].lmm.mm0[0]);
d1800 8
a1807 8
	     (Uint)(unit[cid][row][col].lmm.mw0[3]>>32),
	     (Uint) unit[cid][row][col].lmm.mw0[3],
	     (Uint)(unit[cid][row][col].lmm.mw0[2]>>32),
	     (Uint) unit[cid][row][col].lmm.mw0[2],
	     (Uint)(unit[cid][row][col].lmm.mw0[1]>>32),
	     (Uint) unit[cid][row][col].lmm.mw0[1],
	     (Uint)(unit[cid][row][col].lmm.mw0[0]>>32),
	     (Uint) unit[cid][row][col].lmm.mw0[0]);
d1812 6
a1817 6
	     (Uint) unit[cid][row][col].mr1mux,
	     (Uint) unit[cid][row][col].mr0mux,
	     (Uint)(unit[cid][row][col].mr1d>>32),
	     (Uint) unit[cid][row][col].mr1d,
	     (Uint)(unit[cid][row][col].mr0d>>32),
	     (Uint) unit[cid][row][col].mr0d);
@


1.76
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.75 2016/04/28 23:28:05 nakashim Exp nakashim $";
d400 1
d419 2
a420 1
	      if (emax5[cid].fsm[j].ardyc < emax5[cid].fsm[j].rlen/(sizeof(Ull)*UNIT_WIDTH)) { /* 0.5/1/2rrdy/1unit */
@


1.75
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.74 2016/04/28 15:59:21 nakashim Exp nakashim $";
d398 6
a403 43
	  switch (emax5[cid].fsm[j].memif_status) {
	  case MEMIF_AREQ:
	    emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	    emax5[cid].fsm[j].ardyc = 0;
	    if (emax5[cid].status==STATUS_CONF) {
	      emax5[cid].fsm[j].raddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
	      emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
	    }
	    else if (emax5[cid].status==STATUS_LMMI) {
	      emax5[cid].fsm[j].raddr = lmmi+sizeof(Ull)*2*EMAX_DEPTH*j; /* lmmi_topをfsmに渡すインタフェース */
	      emax5[cid].fsm[j].rlen  =      sizeof(Ull)*2*EMAX_DEPTH*1; /* lmmi_topをfsmに渡すインタフェース */
	    }
	    else if (emax5[cid].status==STATUS_REGV) {
	      emax5[cid].fsm[j].raddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
	      emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
	    }
	    break;
	  case MEMIF_DREQ:
	    if (emax5[cid].fsm[j].ardyc < emax5[cid].fsm[j].rlen/(sizeof(Ull)*UNIT_WIDTH)) { /* 0.5/1/2rrdy/1unit */
	      emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH); /* units ignore row_select in STATUS_LMMI */
	      if (emax5[cid].status==STATUS_CONF)
		emax5[cid].fsm[j].lmwa = 0LL; /* fixed */
	      else if (emax5[cid].status==STATUS_REGV)
		emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].ardyc&1; /* even/odd */

	      if (emax5[cid].status==STATUS_LMMI) {
	        for (k=0; k<UNIT_WIDTH; k++)
		  *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1)) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1));
              }

	      /* MEM-ACCESS */
	      for (k=0; k<UNIT_WIDTH; k++)
		emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k)); /* ★★★(DELAY) */

	      if (emax5[cid].status==STATUS_LMMI) {
	        for (k=0; k<UNIT_WIDTH; k++)
		  *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+(k>>1))%EMAX_DEPTH])+(k&1)) = emax5[cid].fsm[j].rdata[k];
              }
              else {
	        for (k=0; k<UNIT_WIDTH; k++)
		  emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k];
              }

d405 10
a414 2
		emax5[cid].fsm[j].last_dist = emax5[cid].fsm[j].rdata[3] & 0x3f; /* mapdist */
		emax5[cid].fsm[j].row_count++;
d416 34
a449 3
	      else if (emax5[cid].status==STATUS_LMMI)
	        emax5[cid].fsm[j].row_count+=2;
	      else if (emax5[cid].status==STATUS_REGV)
d451 7
a457 5
	      emax5[cid].fsm[j].ardyc++;
	    }
	    else {
	      emax5[cid].fsm[j].memif_status = MEMIF_TERM;
	      emax5[cid].fsm[j].row_select   = 0LL;
a458 1
	    break;
@


1.74
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.73 2016/04/28 15:47:29 nakashim Exp nakashim $";
d389 1
a390 44
      emax5[cid].cycles_lmmi_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {	
	  switch (emax5[cid].fsm[j].memif_status) {
	  case MEMIF_AREQ:
	    emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	    emax5[cid].fsm[j].ardyc = 0;
	    emax5[cid].fsm[j].raddr = lmmi+sizeof(Ull)*2*EMAX_DEPTH*j; /* lmmi_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[j].rlen  =      sizeof(Ull)*2*EMAX_DEPTH*1; /* lmmi_topをfsmに渡すインタフェース */
	    break;
	  case MEMIF_DREQ:
	    if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH/2) { /* 1rrdy/2unit */
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+1);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+1);
	      
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[0] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+0)); /* ★★★(DELAY) */
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[1] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+1)); /* ★★★(DELAY) */
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[2] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+2)); /* ★★★(DELAY) */
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[3] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+3)); /* ★★★(DELAY) */
	      emax5[cid].fsm[j].row_count+=2;
	      emax5[cid].fsm[j].ardyc++;
	    }
	    else {
	      emax5[cid].fsm[j].memif_status = MEMIF_TERM;
	      emax5[cid].fsm[j].row_select   = 0LL;
	    }
	    break;
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_LMMI finished */
	emax5[cid].status = STATUS_DRAIN;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	}
      }
      break;
    case STATUS_CONF:
d393 1
d406 4
d416 2
a417 2
	    if (emax5[cid].fsm[j].ardyc < emax5[cid].fsm[j].rlen/(sizeof(Ull)*UNIT_WIDTH)) { /* 1/2rrdy/1unit */
	      emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH);
d422 7
d430 11
a440 1
		emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k)); /* ★★★(DELAY) */
d445 2
d467 2
@


1.73
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.72 2016/04/28 12:58:43 nakashim Exp nakashim $";
d434 3
a436 1
      emax5[cid].cycles_conf_part++;
d444 8
a451 2
	    emax5[cid].fsm[j].raddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
d454 1
a454 1
	    if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH) { /* 1rrdy/1unit */
d456 4
a459 1
	      emax5[cid].fsm[j].lmwa = 0LL; /* fixed */
d462 6
a467 2
	      emax5[cid].fsm[j].last_dist = emax5[cid].fsm[j].rdata[3] & 0x3f; /* mapdist */
	      emax5[cid].fsm[j].row_count++;
d480 5
a484 8
	emax5[cid].last_conf = conf;
	emax5[cid].last_dist = emax5[cid].fsm[0].last_dist;
	emax5[cid].last_row0 = (emax5[cid].last_row0+emax5[cid].last_dist)%EMAX_DEPTH;
	emax5[cid].status = STATUS_LMMI;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
d486 2
a487 34
      }
      break;
    case STATUS_REGV:
      emax5[cid].cycles_regv_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {	
	  switch (emax5[cid].fsm[j].memif_status) {
	  case MEMIF_AREQ:
	    emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	    emax5[cid].fsm[j].ardyc = 0;
	    emax5[cid].fsm[j].raddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
	    break;
	  case MEMIF_DREQ:
	    if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH*2) { /* 2rrdy/1unit */
	      emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH);
	      emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].ardyc&1; /* even/odd */
	      for (k=0; k<UNIT_WIDTH; k++)
		emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k)); /* ★★★(DELAY) */
	      emax5[cid].fsm[j].row_count+=(emax5[cid].fsm[j].ardyc&1); /* even/odd */
	      emax5[cid].fsm[j].ardyc++;
	    }
	    else {
	      emax5[cid].fsm[j].memif_status = MEMIF_TERM;
	      emax5[cid].fsm[j].row_select   = 0LL;
	    }
	    break;
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_REGV finished */
	emax5[cid].status = STATUS_START;
@


1.72
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.71 2016/04/28 00:05:10 nakashim Exp nakashim $";
d320 71
a390 2
    case STATUS_CONF:
      emax5[cid].cycles_conf_part++;
d398 2
a399 2
	    emax5[cid].fsm[j].raddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
d402 11
a412 7
	    if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH) { /* 1rrdy/1unit */
	      emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH);
	      emax5[cid].fsm[j].lmwa = 0LL; /* fixed */
	      for (k=0; k<UNIT_WIDTH; k++)
		emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k)); /* ★★★(DELAY) */
	      emax5[cid].fsm[j].last_dist = emax5[cid].fsm[j].rdata[3] & 0x3f; /* mapdist */
	      emax5[cid].fsm[j].row_count++;
d424 2
a425 5
      if (sync) { /* all FSM_CONF finished */
	emax5[cid].last_conf = conf;
	emax5[cid].last_dist = emax5[cid].fsm[0].last_dist;
	emax5[cid].last_row0 = (emax5[cid].last_row0+emax5[cid].last_dist)%EMAX_DEPTH;
	emax5[cid].status = STATUS_LMMI;
d433 2
a434 2
    case STATUS_LMMI:
      emax5[cid].cycles_lmmi_part++;
d442 2
a443 2
	    emax5[cid].fsm[j].raddr = lmmi+sizeof(Ull)*2*EMAX_DEPTH*j; /* lmmi_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[j].rlen  =      sizeof(Ull)*2*EMAX_DEPTH*1; /* lmmi_topをfsmに渡すインタフェース */
d446 7
a452 11
	    if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH/2) { /* 1rrdy/2unit */
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+1);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+1);
	      
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[0] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+0)); /* ★★★(DELAY) */
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[1] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+1)); /* ★★★(DELAY) */
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[2] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+2)); /* ★★★(DELAY) */
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[3] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+3)); /* ★★★(DELAY) */
	      emax5[cid].fsm[j].row_count+=2;
d464 5
a468 2
      if (sync) { /* all FSM_LMMI finished */
	emax5[cid].status = STATUS_DRAIN;
a514 87
    case STATUS_START:
      for (j=0; j<EMAX_WIDTH; j++) {
	switch (emax5[cid].fsm[j].memif_status) {
	case MEMIF_AREQ:
	  emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	  emax5[cid].fsm[j].row_select = 1LL<<emax5[cid].last_row0; /* start row */
	  break;
	case MEMIF_DREQ:
	  emax5[cid].status = STATUS_EXEC;
	  for (j=0; j<EMAX_WIDTH; j++) {
	    emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	    emax5[cid].fsm[j].row_count    = 0;
	    emax5[cid].fsm[j].row_select   = 0LL;
	  }
	  break;
	}
      }
      break;
      /*******************************************************************************************************************************************************/
      /* ●lmmi指示ルール (copy from conv-c2d/emac5.c)                                                                  lmmi-loc  v  top  blk  len  rw  f  p */
      /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  len   0  0  0 */
      /* LD with force-read=1 and ptop==NULL generates current(lmf) and does not reuse LMM. same as lmf in EMAX4            curr  1  top  blk  len   0  1  0 */
      /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). same as lmp in EMAX4                     curr  1  top  blk  len   0  0  0 */
      /*                                                                                                                  c+dist  1 ptop  blk  len   0  0  1 */
      /*                                                                                        ptop!=NULL & force=1は，prefetchの意味がないので組合せがない */
      /*******************************************************************************************************************************************************/
      /* ST with force-read=0 and ptop==NULL writes back after execution. same as lmw in EMAX4                              curr  1  top  blk  len   1  0  0 */
      /* ST with force-read=1 and ptop==NULL prefetches data to LMM in advance and write back. same as lmx in EMAX4         curr  1  top  blk  len   1  1  0 */
      /* ST with force-read=0, top==NULL and ptop!=NULL late drain with next execution. same as lmd in EMAX4                curr  0  (check be empty)        */
      /*                                                   FSMは,dirtyおよびp-bitに従い,exec同時drainか,exec後drainを選択 c-dist  1 ptop  blk  len   1  0  1 */
      /*                                                                                        deleyed-drain & force=1は，delayの意味がないので組合せがない */
      /*******************************************************************************************************************************************************/
      /* Example of Load+Store **************************************************************************/ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
      /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
      /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
      /*                        ○lmmo.top==lmmi.top,.f=0,.p=0の場合, load/reuse before next exec       */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                                           */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmw (store)                    */
      /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
      /* }                                                                                              */
      /* Example of Accumulate **************************************************************************/ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(LDRQ,  1, src1, D[y], x, msk, D[y], 0, XSIZE, 1, NULL);   lmf (load)                     */
      /*                        ●lmmi.f=1の場合, load always before next exec                          */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                (accumulate)               */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmw (store)                    */
      /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
      /*                   (lmfとlmwが重なるケースでも一旦memに追い出すことで単純化. lmfは再利用しない) */
      /* }                                                                                              */
      /* Example of Partial Update **********************************************************************/ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(STRQ, ex, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmx (read-&-conditional-write) */
      /*                        ●lmmi.f=1の場合, load always before next exec                          */
      /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
      /*                                        (lmxも一旦memに追い出すことで単純化. lmxも再利用しない) */
      /* }                                                                                              */
      /* Example of Prefetch+Drain **********************************************************************/ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, A[y+1]); lmr+lmp prefetch               */
      /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, B[y+1]); lmr+lmp prefetch               */
      /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, C[y+1]); lmr+lmp prefetch               */
      /*                        ○lmmo.top==lmmi.top,.f=0,.p=0の場合, load/reuse before next exec       */
      /*                        ★lmmo.top==lmmi.top,.f=0,.p=1の場合, load/reuse with next exec         */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                                           */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, NULL, 0, XSIZE, 0, D[y-1]); lmd explicit late drain        */
      /*                        ★dirty=1,lmmi.top!=NULL,.p=1の場合, delayed drain at next exec         */
      /* }                                                                                              */
      /*************************************************************************************************************************************/
      /* 【FSM_DRAIN】                                                                                                                     */
      /* lmmo.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
      /*      1  1  0  0 ... lmw       lmmd=1のみ,必ず,regv前にdrain.終了時にlmmd=0                     store:d=1     --                   */
      /*      1  1  1  0 ... lmx       lmmd=1のみ,必ず,regv前にdrain.終了時にlmmd=0                     store:d=1     --                   */
      /*      1  1  0  1 ... lmd       drainは完了(dirty=0)しているので無視してよい                     drain済       --                   */
      /* 【FSM_LOAD】                                                                                                                      */
      /* lmmi.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
      /*      1  0  0  0 ... lmr       lmmoとlmmiが不一致ならdrainとregvの間にload                      prefetch/--   reuse/mload          */
      /*      1  0  1  0 ... lmf       必ずdrainとregvの間にload                                        --            mload(always)        */
      /*      1  1  1  0 ... lmx       必ずdrainとregvの間にload                                        --            store:d=1            */
      /* 【FSM_EXEC】lmm_store開始と同時にlmmd=1                                                                                           */
      /* lmmi.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
      /*      1  0  0  1 ... lmp       lmmoとlmmiが不一致ならexecと同時にloadする                       prefetch/--   reuse/prefetch       */
      /*      1  1  0  0 ... lmw                                                                        --            store:d=1            */
      /*      1  1  0  1 ... lmd       lmmd=1のみ,execと同時にdrain.終了時にlmmd=0                      store:d=1     d=1時のみdrain       */
      /*                               最後のlmdを追い出すためには明示的drain指示(startとは別コマンド)が必要                               */
      /*************************************************************************************************************************************/
d698 18
@


1.71
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.70 2016/04/27 15:19:05 nakashim Exp nakashim $";
d407 57
d534 5
a538 1
      emax5[cid].cycles_drain_part++;
d540 2
d545 12
a556 62
	  if      (mode==1 && emax5[cid].fsm[j].lmmd[i] && (lmmo_stat == 12 || lmmo_stat == 14)) /* 12:lmw, 14:lmx */
	    flag = 1; /* drain */
	  else if (mode==2 && emax5[cid].fsm[j].lmmd[i]) /* drain_dirty_lmm */
	    flag = 1; /* drain */
	  else
	    flag = 0; /* skip drain */
	  /*printf("XXXXXX col=%d row=%d XXXXXXX v=%d rw=%d f=%d p=%d XXXXXXXXXXXXX flag=%d\n", j, i, emax5[cid].fsm[j].lmmo[i].v, emax5[cid].fsm[j].lmmo[j].rw, emax5[cid].fsm[j].lmmo[j].f, emax5[cid].fsm[j].lmmo[j].p, flag);*/
	  if (flag) {
	    Uint lmm_nreq;
	    switch (emax5[cid].fsm[j].memif_status) {
	    case MEMIF_AREQ:
	      emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[j].ardyc = 0; /* LMM addr-request(read/write) counter */
	      emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read) counter */
	      emax5[cid].fsm[j].waddr = (mode==1)?emax5[cid].fsm[j].lmmo[i].top:emax5[cid].fsm[j].lmmc[i].top;
	      emax5[cid].fsm[j].wlen  = (mode==1)?emax5[cid].fsm[j].lmmo[i].len:emax5[cid].fsm[j].lmmc[i].len;
	      break;
	    case MEMIF_DREQ:
	      /* block 0:inf, 1:16, 2:32, 3:64 dword*UNIT_WIDTH*block=page(burst_size)    */
	      /* 通常は,     block=0                                                      */
	      /* tricountは, block=2                                                      */
	      /* EMAX5では必ず64bit*4幅                                                   */
	      /* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	      /* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	      /* align=32B, block=0, blocking=none             ... align済 4倍幅load      */
	      /* --- blocking-load --- : fsmがblock単位にburst起動                        */
	      /* align=xxx, block=1, blocksize=8*4*16=512B     ... 下位5bit無視 4倍幅load */
	      /* align=xxx, block=2, blocksize=8*4*32=1KB      ... 下位5bit無視 4倍幅load */
	      /* align=xxx, block=3, blocksize=8*4*64=2KB      ... 下位5bit無視 4倍幅load */
	      lmm_nreq = ((mode==1)?emax5[cid].fsm[j].lmmo[i].len:emax5[cid].fsm[j].lmmc[i].len)/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	      if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		emax5[cid].fsm[j].row_select = 1LL<<i;
		emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
		emax5[cid].fsm[j].lmra = emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
		if (trace) {
		  printf("%03.3d:siml_emax5: drain row=%d col=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			 tid, i, j, (Uint)(emax5[cid].fsm[j].lmra>>32), (Uint)emax5[cid].fsm[j].lmra, emax5[cid].fsm[j].ardyc, lmm_nreq);
		}
		emax5[cid].fsm[j].ardyc++;
	      }
	      else
		emax5[cid].fsm[j].row_lmm_en = 0LL; /* row_selectは残りrrdyのために維持 */
	      if (emax5[cid].fsm[j].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		if (unit[cid][i][j].rrdy) { /* ack from lmm */
		  for (k=0; k<UNIT_WIDTH; k++) {
		    *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k]; /* ★★★ */
		    if (trace)
		      printf("%03.3d:siml_emax5: drain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
		  }
		  emax5[cid].fsm[j].rrdyc++;
		}
	      }
	      else {
		emax5[cid].fsm[j].lmmd[i] = 0;
		emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		emax5[cid].fsm[j].row_count++;
		emax5[cid].fsm[j].row_select   = 0LL;
		emax5[cid].fsm[j].row_lmm_en   = 0LL;
	      }
	      break;
	    }
d558 7
a564 2
	  else {
	    emax5[cid].fsm[j].row_count++;
d566 5
a570 33
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_DRAIN finished */
	if (mode==1) /* normal_array */
	  emax5[cid].status = STATUS_LOAD;
	else /* drain_dirty_lmm */
	  emax5[cid].status = STATUS_TERM;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	  emax5[cid].fsm[j].row_lmm_en   = 0LL;
	}
      }
      break;
    case STATUS_LOAD:
      emax5[cid].cycles_load_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {
	  switch ((emax5[cid].fsm[j].lmmc[i].v<<3)|(emax5[cid].fsm[j].lmmc[i].rw<<2)|(emax5[cid].fsm[j].lmmc[i].f<<1)|(emax5[cid].fsm[j].lmmc[i].p)) {
	    /* v | rw | f | p */
	  case  8: /* lmr */
	    if (emax5[cid].fsm[j].lmmo[i].v
	     && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
	     && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
	     && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top) {
	      if (trace)
		printf("%03.3d:siml_emax5: load row=%d col=%d top=%08.8x_%08.8x found in LMM\n",
		       tid, i, j, (Uint)(emax5[cid].fsm[j].lmmc[i].top>>32), (Uint)emax5[cid].fsm[j].lmmc[i].top);
	      flag = 0; /* skip load */
	    }
d572 1
a572 9
	      flag = 1; /* load */
	    break;
	  case 10: /* lmf always load */
	  case 14: /* lmx always load */
	    flag = 1; /* load */
	    break;
	  default:
	    flag = 0; /* skip load */
	    break;
d581 18
a598 2
	      emax5[cid].fsm[j].raddr = emax5[cid].fsm[j].lmmc[i].top;
	      emax5[cid].fsm[j].rlen  = emax5[cid].fsm[j].lmmc[i].len;
d612 1
a612 1
	      lmm_nreq = emax5[cid].fsm[j].lmmc[i].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
d617 3
a619 20
		emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
#if 1
		/*** GATHER ************/
		switch (emax5[cid].fsm[j].lmmc[i].blk) {
		case 0: /* inf */
		  ofs =        (       emax5[cid].fsm[j].lmmc[i].top                                         ) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc   )*UNIT_WIDTH;
		  break;
		case 1: /* 16 */
		  ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%16)*UNIT_WIDTH; /* ★★★(DELAY) */
		  break;
		case 2: /* 32 */
		  ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%32)*UNIT_WIDTH; /* ★★★(DELAY) */
		  break;
		case 3: /* 64 */
		  ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%64)*UNIT_WIDTH; /* ★★★(DELAY) */
		  break;
		}
#endif
		for (k=0; k<UNIT_WIDTH; k++) {
		  emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + ofs + sizeof(Ull)*k); /* ★★★(DELAY) */
d621 2
a622 3
		    printf("%03.3d:siml_emax5: load row=%d col=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa,
			   k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].ardyc, lmm_nreq);
d625 2
a626 151
		emax5[cid].fsm[j].ardyc++;
	      }
	      else {
#if 0
		emax5[cid].fsm[j].lmmo[i].v   = emax5[cid].fsm[j].lmmc[i].v;
		emax5[cid].fsm[j].lmmo[i].rw  = emax5[cid].fsm[j].lmmc[i].rw;
		emax5[cid].fsm[j].lmmo[i].f   = emax5[cid].fsm[j].lmmc[i].f;
		emax5[cid].fsm[j].lmmo[i].p   = emax5[cid].fsm[j].lmmc[i].p;
		emax5[cid].fsm[j].lmmo[i].blk = emax5[cid].fsm[j].lmmc[i].blk;
		emax5[cid].fsm[j].lmmo[i].len = emax5[cid].fsm[j].lmmc[i].len;
		emax5[cid].fsm[j].lmmo[i].top = emax5[cid].fsm[j].lmmc[i].top;
#endif
		emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		emax5[cid].fsm[j].row_count++;
		emax5[cid].fsm[j].row_select   = 0LL;
		emax5[cid].fsm[j].row_lmm_en   = 0LL;
	      }
	      break;
	    }
	  }
	  else {
	    emax5[cid].fsm[j].row_count++;
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_LOAD finished */
	emax5[cid].status = STATUS_REGV;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	  emax5[cid].fsm[j].row_lmm_en   = 0LL;
	}
      }
      break;
    case STATUS_REGV:
      emax5[cid].cycles_regv_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {	
	  switch (emax5[cid].fsm[j].memif_status) {
	  case MEMIF_AREQ:
	    emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	    emax5[cid].fsm[j].ardyc = 0;
	    emax5[cid].fsm[j].raddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
	    break;
	  case MEMIF_DREQ:
	    if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH*2) { /* 2rrdy/1unit */
	      emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+i)%EMAX_DEPTH);
	      emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].ardyc&1; /* even/odd */
	      for (k=0; k<UNIT_WIDTH; k++)
		emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k)); /* ★★★(DELAY) */
	      emax5[cid].fsm[j].row_count+=(emax5[cid].fsm[j].ardyc&1); /* even/odd */
	      emax5[cid].fsm[j].ardyc++;
	    }
	    else {
	      emax5[cid].fsm[j].memif_status = MEMIF_TERM;
	      emax5[cid].fsm[j].row_select   = 0LL;
	    }
	    break;
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_REGV finished */
	emax5[cid].status = STATUS_START;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	}
      }
      break;
    case STATUS_START:
      for (j=0; j<EMAX_WIDTH; j++) {
	switch (emax5[cid].fsm[j].memif_status) {
	case MEMIF_AREQ:
	  emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	  emax5[cid].fsm[j].row_select = 1LL<<emax5[cid].last_row0; /* start row */
	  break;
	case MEMIF_DREQ:
	  emax5[cid].status = STATUS_EXEC;
	  for (j=0; j<EMAX_WIDTH; j++) {
	    emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	    emax5[cid].fsm[j].row_count    = 0;
	    emax5[cid].fsm[j].row_select   = 0LL;
	  }
	  break;
	}
      }
      break;
    case STATUS_EXEC: /* simulate from stage15 to stage0, from col=3 to col=0 */
      emax5[cid].cycles_exec_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	if (emax5[cid].unit1_exec | emax5[cid].unit2_exec) /* exec not finished */
	  sync = 0; /* not finished */
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {
	  switch ((emax5[cid].fsm[j].lmmc[i].v<<3)|(emax5[cid].fsm[j].lmmc[i].rw<<2)|(emax5[cid].fsm[j].lmmc[i].f<<1)|(emax5[cid].fsm[j].lmmc[i].p)) {
	    /* v | rw | f | p */
	  case  9: /* lmp */
	    if (emax5[cid].fsm[j].lmmo[i].v
	     && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
	     && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
	     && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top) {
	      if (trace)
		printf("%03.3d:siml_emax5: pload row=%d col=%d top=%08.8x_%08.8x found in LMM\n",
		       tid, i, j, (Uint)(emax5[cid].fsm[j].lmmc[i].top>>32), (Uint)emax5[cid].fsm[j].lmmc[i].top);
	      flag = 0; /* skip pload */
	    }
	    else
	      flag = 1; /* pload */
	    break;
	  case 13: /* lmd */
	    if (emax5[cid].fsm[j].lmmd[i]) /* dirty exist */
	      flag = 1; /* pdrain */
	    else
	      flag = 0; /* skip pdrain */
	    break;
	  default:
	    flag = 0; /* skip pdrain/pload */
	    break;
	  }

	  /* emax5[cid].fsm[j].lmmc[i].rw=0:pload  */
	  /* emax5[cid].fsm[j].lmmc[i].rw=1:pdrain */
	  if (flag) {
	    Uint lmm_nreq;
	    switch (emax5[cid].fsm[j].memif_status) {
	    case MEMIF_AREQ:
	      emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[j].ardyc = 0; /* LMM addr-request(read/write) counter */
	      if (emax5[cid].fsm[j].lmmc[i].rw == 0) { /* pload */
		emax5[cid].fsm[j].raddr = emax5[cid].fsm[j].lmmc[i].top;
		emax5[cid].fsm[j].rlen  = emax5[cid].fsm[j].lmmc[i].len;
	      }
	      else { /* pdrain */
		emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read) counter */
		emax5[cid].fsm[j].waddr = emax5[cid].fsm[j].lmmc[i].top;
		emax5[cid].fsm[j].wlen  = emax5[cid].fsm[j].lmmc[i].len;
	      }
	      break;
	    case MEMIF_DREQ:
	      lmm_nreq = emax5[cid].fsm[j].lmmc[i].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	      if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		Ull ofs;
		emax5[cid].fsm[j].row_select = 1LL<<i;
		emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
		if (emax5[cid].fsm[j].lmmc[i].rw == 0) { /* pload */
d648 1
a648 1
		      printf("%03.3d:siml_emax5: pload row=%d col=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
a653 7
		else { /* pdrain */
		  emax5[cid].fsm[j].lmra = emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
		  if (trace) {
		    printf("%03.3d:siml_emax5: pdrain row=%d col=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, (Uint)(emax5[cid].fsm[j].lmra>>32), (Uint)emax5[cid].fsm[j].lmra, emax5[cid].fsm[j].ardyc, lmm_nreq);
		  }
		}
d657 6
a662 10
		if (emax5[cid].fsm[j].lmmc[i].rw == 0) { /* pload */
#if 0
		  emax5[cid].fsm[j].lmmo[i].v   = emax5[cid].fsm[j].lmmc[i].v;
		  emax5[cid].fsm[j].lmmo[i].rw  = emax5[cid].fsm[j].lmmc[i].rw;
		  emax5[cid].fsm[j].lmmo[i].f   = emax5[cid].fsm[j].lmmc[i].f;
		  emax5[cid].fsm[j].lmmo[i].p   = emax5[cid].fsm[j].lmmc[i].p;
		  emax5[cid].fsm[j].lmmo[i].blk = emax5[cid].fsm[j].lmmc[i].blk;
		  emax5[cid].fsm[j].lmmo[i].len = emax5[cid].fsm[j].lmmc[i].len;
		  emax5[cid].fsm[j].lmmo[i].top = emax5[cid].fsm[j].lmmc[i].top;
#endif
a667 3
		else { /* pdrain */
		  emax5[cid].fsm[j].row_lmm_en = 0LL; /* row_selectは残りrrdyのために維持 */
		}
d669 3
a671 2
	      if (emax5[cid].fsm[j].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		if (emax5[cid].fsm[j].lmmc[i].rw == 1) { /* pdrain */
d676 1
a676 1
			printf("%03.3d:siml_emax5: pdrain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
d682 1
a682 3
	      }
	      else {
		if (emax5[cid].fsm[j].lmmc[i].rw == 1) { /* pdrain */
d699 9
a707 2
      if (sync) { /* all FSM_EXEC finished */
	emax5[cid].status = STATUS_TERM;
@


1.70
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.69 2016/04/26 14:18:18 nakashim Exp nakashim $";
d337 1
a337 1
		emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k));
d382 4
a385 4
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[0] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+0));
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+0)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[1] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+1));
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[2] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+2));
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+i+1)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[3] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+3));
d527 1
a527 1
		    *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k];
d627 1
a627 1
		  ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%16)*UNIT_WIDTH;
d630 1
a630 1
		  ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%32)*UNIT_WIDTH;
d633 1
a633 1
		  ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%64)*UNIT_WIDTH;
d638 1
a638 1
		  emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + ofs + sizeof(Ull)*k);
d698 1
a698 1
		emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k));
d804 1
a804 1
		    ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%16)*UNIT_WIDTH;
d807 1
a807 1
		    ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%32)*UNIT_WIDTH;
d810 1
a810 1
		    ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%64)*UNIT_WIDTH;
d815 1
a815 1
		    emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + ofs + sizeof(Ull)*k);
d856 1
a856 1
		      *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k];
@


1.69
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.68 2016/04/26 12:13:01 nakashim Exp nakashim $";
d24 1
d220 1
a220 1
siml_emax5(tid, cycle, trace, trace_pipe, base, conf, lmmi, regv) Uint tid; int cycle; Uint trace, trace_pipe; char *base; Ull conf, lmmi, regv;
d222 1
d299 6
a304 1
      if (emax5[cid].last_conf != conf || emax5[cid].last_dist > 0) {
a307 5
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	}
d313 5
a317 5
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	}
d481 6
a486 10
	  switch ((emax5[cid].fsm[j].lmmo[i].v<<3)|(emax5[cid].fsm[j].lmmo[i].rw<<2)|(emax5[cid].fsm[j].lmmo[i].f<<1)|(emax5[cid].fsm[j].lmmo[i].p)) {
	    /* v | rw | f | p */
	  case 12: /* lmw */
	  case 14: /* lmx */
	    if (emax5[cid].fsm[j].lmmd[i]) /* dirty exist */
	      flag = 1; /* drain */
	    else
	      flag = 0; /* skip drain */
	    break;
	  default:
a487 2
	    break;
	  }
d496 2
a497 2
	      emax5[cid].fsm[j].waddr = emax5[cid].fsm[j].lmmo[i].top;
	      emax5[cid].fsm[j].wlen  = emax5[cid].fsm[j].lmmo[i].len;
d511 1
a511 1
	      lmm_nreq = emax5[cid].fsm[j].lmmo[i].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
d552 4
a555 1
	emax5[cid].status = STATUS_LOAD;
@


1.68
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.67 2016/04/26 11:53:21 nakashim Exp nakashim $";
d530 1
a530 1
		  for (k=0; k<UNIT_WIDTH; k++)
d532 3
a534 3
		  if (trace) {
		    printf("%03.3d:siml_emax5: drain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
d856 1
a856 1
		    for (k=0; k<UNIT_WIDTH; k++)
d858 3
a860 3
		    if (trace) {
		      printf("%03.3d:siml_emax5: pdrain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
d953 2
a954 2
    s = unit[cid][i][j].conf.cdw1.ea0bs;  unit[cid][i][j].ea0b = (s==2)?unit[cid][i][j].regv.ea0br:unit[cid][i][j].eab;
    s = unit[cid][i][j].conf.cdw1.ea0os;  unit[cid][i][j].ea0o = (s==1)?unit[cid][i][j].regv.ea0or:unit[cid][i][j].eao;
d972 2
a973 2
    s = unit[cid][i][j].conf.cdw1.ea1bs;  unit[cid][i][j].ea1b = (s==2)?unit[cid][i][j].regv.ea1br:unit[cid][i][j].eab;
    s = unit[cid][i][j].conf.cdw1.ea1os;  unit[cid][i][j].ea1o = (s==1)?unit[cid][i][j].regv.ea1or:unit[cid][i][j].eao;
d1170 2
a1171 2
	base1 = (unit[cid][i][j].conf.cdw1.ea1bs!=1 || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
	offs1 = (unit[cid][i][j].conf.cdw1.ea1bs!=1 ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
d1200 2
a1201 2
	base0 = (unit[cid][i][j].conf.cdw1.ea0bs!=1 || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
	offs0 = (unit[cid][i][j].conf.cdw1.ea0bs!=1 ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
d1264 2
a1265 1
    unit[cid][i][j].one_shot = 1; /* set one_shot here */
d1380 1
a1380 1
	unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
d1401 1
a1401 1
	  unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
d1717 1
a1717 1
      printf("|cop=%01.1x%01.1x%01.1x%01.1x_%04.4x ea0=%02.2x_%d_%d_%01.1x ea1=%02.2x_%d_%d_%01.1x eab=%01.1x eao=%01.1x                ",
d1723 4
a1730 4
	     (Uint) unit[cid][row][col].conf.cdw1.ea1op,
	     (Uint) unit[cid][row][col].conf.cdw1.ea1bs,
	     (Uint) unit[cid][row][col].conf.cdw1.ea1os,
	     (Uint) unit[cid][row][col].conf.cdw1.ea1msk,
d1809 1
a1809 1
    printf("ea1 ea1 ");
@


1.67
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.66 2016/04/26 11:20:57 nakashim Exp nakashim $";
d1305 1
a1305 1
	a = unit[cid][i][j].lmm.ma0 % LMEM_SIZE; /* main-mamory-address -> lmm-address */
d1365 2
a1366 2
  a0 = unit[cid][i][j].lmm.ma0 % LMEM_SIZE; /* should be aligned by fsm */
  a1 = unit[cid][i][j].lmm.ma1 % LMEM_SIZE; /* should be aligned by fsm */
@


1.66
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.65 2016/04/26 09:53:08 nakashim Exp nakashim $";
d1264 30
a1305 29
	/* trs[3-0]: 0:exdr, 1:exdr0, 2:ts0, 3:lmli0, 4:lmwd0, 5:lmri0 */
	unit[cid][i][j].tr[0] = unit[cid][i][j].conf.cdw2.trs0==0 ? unit[cid][i][j].exdr /* tr[3-0]はalign不要 */
			      : unit[cid][i][j].conf.cdw2.trs0==1 ? unit[cid][i][0].exdr
			      : unit[cid][i][j].conf.cdw2.trs0==2 ? unit[cid][i][j].t[0]
			      : unit[cid][i][j].conf.cdw2.trs0==3 ? unit[cid][i][j].lmli[0]
			      : unit[cid][i][j].conf.cdw2.trs0==4 ? unit[cid][i][j].lmwd[0]
			      : unit[cid][i][j].conf.cdw2.trs0==5 ? unit[cid][i][j].lmri[0]
			      :                                     0LL;
	unit[cid][i][j].tr[1] = unit[cid][i][j].conf.cdw2.trs1==0 ? unit[cid][i][j].exdr
		              : unit[cid][i][j].conf.cdw2.trs1==1 ? unit[cid][i][1].exdr
		              : unit[cid][i][j].conf.cdw2.trs1==2 ? unit[cid][i][j].t[1]
		              : unit[cid][i][j].conf.cdw2.trs1==3 ? unit[cid][i][j].lmli[1]
		              : unit[cid][i][j].conf.cdw2.trs1==4 ? unit[cid][i][j].lmwd[1]
		              : unit[cid][i][j].conf.cdw2.trs1==5 ? unit[cid][i][j].lmri[1]
		              :                                     0LL;
	unit[cid][i][j].tr[2] = unit[cid][i][j].conf.cdw2.trs2==0 ? unit[cid][i][j].exdr
		              : unit[cid][i][j].conf.cdw2.trs2==1 ? unit[cid][i][2].exdr
		              : unit[cid][i][j].conf.cdw2.trs2==2 ? unit[cid][i][j].t[2]
		              : unit[cid][i][j].conf.cdw2.trs2==3 ? unit[cid][i][j].lmli[2]
		              : unit[cid][i][j].conf.cdw2.trs2==4 ? unit[cid][i][j].lmwd[2]
		              : unit[cid][i][j].conf.cdw2.trs2==5 ? unit[cid][i][j].lmri[2]
		              :                                     0LL;
	unit[cid][i][j].tr[3] = unit[cid][i][j].conf.cdw2.trs3==0 ? unit[cid][i][j].exdr
		              : unit[cid][i][j].conf.cdw2.trs3==1 ? unit[cid][i][3].exdr
		              : unit[cid][i][j].conf.cdw2.trs3==2 ? unit[cid][i][j].t[3]
		              : unit[cid][i][j].conf.cdw2.trs3==3 ? unit[cid][i][j].lmli[3]
		              : unit[cid][i][j].conf.cdw2.trs3==4 ? unit[cid][i][j].lmwd[3]
		              : unit[cid][i][j].conf.cdw2.trs3==5 ? unit[cid][i][j].lmri[3]
		              :                                     0LL;
a1343 1
    unit[cid][i][j].one_shot = 1; /* set one_shot here */
@


1.65
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.64 2016/04/26 08:01:34 nakashim Exp nakashim $";
d1947 8
a1954 8
	     (Uint)(unit[cid][row][col].t[3]>>32),
	     (Uint) unit[cid][row][col].t[3],
	     (Uint)(unit[cid][row][col].t[2]>>32),
	     (Uint) unit[cid][row][col].t[2],
	     (Uint)(unit[cid][row][col].t[1]>>32),
	     (Uint) unit[cid][row][col].t[1],
	     (Uint)(unit[cid][row][col].t[0]>>32),
	     (Uint) unit[cid][row][col].t[0]);
@


1.64
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.63 2016/04/25 22:54:03 nakashim Exp nakashim $";
d479 1
a479 1
	  switch ((emax5[cid].fsm[j].lmmo[j].v<<3)|(emax5[cid].fsm[j].lmmo[i].rw<<2)|(emax5[cid].fsm[j].lmmo[i].f<<1)|(emax5[cid].fsm[j].lmmo[i].p)) {
d492 1
a492 1
	  
d1134 1
a1134 1
    if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
d1137 1
a1137 1
      unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = emax5[cid].fsm[j].lmra;
d1144 1
a1144 1
    if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
d1147 1
a1147 1
      unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = emax5[cid].fsm[j].lmwa;
d1159 1
a1159 1
      if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
d1162 1
a1162 1
	unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = emax5[cid].fsm[j].lmra;
d1189 1
a1189 1
      if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
d1192 1
a1192 1
	unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = emax5[cid].fsm[j].lmwa;
d1232 1
a1232 1
	*((Ull*)&unit[cid][i][j].conf+k) = emax5[cid].fsm[j].lmwd[k];
a1235 1
    return (0);
d1239 1
a1239 1
    if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
d1242 1
a1242 1
	unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k] = emax5[cid].fsm[j].lmwd[k]; /* align不要 */
d1250 1
a1250 1
	switch (emax5[cid].fsm[j].lmwa) {
d1252 1
a1252 1
	  *((Ull*)&unit[cid][i][j].regv+0+k) = emax5[cid].fsm[j].lmwd[k];
d1255 1
a1255 1
	  *((Ull*)&unit[cid][i][j].regv+4+k) = emax5[cid].fsm[j].lmwd[k];
d1266 1
a1266 1
      if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
d1269 1
a1269 1
	  unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k] = emax5[cid].fsm[j].lmwd[k]; /* align不要 */
d1377 1
d1381 2
a1390 1
    return (0);
d1398 1
d1402 2
d1424 1
d1542 1
a1542 1
    printf("         ---- FSM[%d] lmmo[],lmmc[],lmmd[]         ", col);
@


1.63
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.62 2016/04/25 13:52:33 nakashim Exp nakashim $";
d639 1
a639 1
		  emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + ofs + sizeof(Ull)*k);
d649 1
d657 1
d816 1
a816 1
		    emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + ofs + sizeof(Ull)*k);
d835 1
d843 1
@


1.62
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.61 2016/04/24 13:17:02 nakashim Exp nakashim $";
d332 1
a332 1
	      emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[j].row_count)%EMAX_DEPTH);
d375 4
a378 4
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+1);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+1);
d380 4
a383 4
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[0] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+0);
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[1] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+1);
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[2] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+2);
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[3] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+3);
d694 1
a694 1
	      emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[j].row_count)%EMAX_DEPTH);
d1538 2
a1539 1
      printf("|lmmd%d v%d rw%d f%d p%d b%d l%08.8x top%08.8x%08.8x",
d1552 2
a1553 1
      printf("|lmmd%d v%d rw%d f%d p%d b%d l%08.8x top%08.8x%08.8x",
@


1.61
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.60 2016/04/24 12:20:00 nakashim Exp nakashim $";
d267 6
a272 1
      if (emax5[cid].status == STATUS_START)
d274 2
a275 1
      if (emax5[cid].status == STATUS_EXEC) {
d282 1
d1244 1
d1538 8
a1545 8
      printf("|lmmd%d v%d rw%d f%d p%d b%d l%d      top%08.8x%08.8x",
	     emax5[cid].fsm[col].lmmd[row],
	     emax5[cid].fsm[col].lmmo[row].v,
	     emax5[cid].fsm[col].lmmo[row].rw,
	     emax5[cid].fsm[col].lmmo[row].f,
	     emax5[cid].fsm[col].lmmo[row].p,
	     emax5[cid].fsm[col].lmmo[row].blk,
	     emax5[cid].fsm[col].lmmo[row].len,
d1551 8
a1558 8
      printf("|lmmd%d v%d rw%d f%d p%d b%d l%d      top%08.8x%08.8x",
	     emax5[cid].fsm[col].lmmd[row],
	     emax5[cid].fsm[col].lmmc[row].v,
	     emax5[cid].fsm[col].lmmc[row].rw,
	     emax5[cid].fsm[col].lmmc[row].f,
	     emax5[cid].fsm[col].lmmc[row].p,
	     emax5[cid].fsm[col].lmmc[row].blk,
	     emax5[cid].fsm[col].lmmc[row].len,
d1566 11
a1576 1
    printf("         ---- FSM[%d] bus_controller                                 ", col);
d1580 4
a1583 4
    printf("|%d %d %02.2d rosl%08.8x%08.8x lmen%08.8x%08.8x ardy%04.4d rrdy=%04.4d",
	   emax5[cid].fsm[col].last_dist,
	   emax5[cid].fsm[col].memif_status,
	   emax5[cid].fsm[col].row_count,
d1688 14
a1701 14
	     unit[cid][row][col].conf.cdw0.op1,
	     unit[cid][row][col].conf.cdw0.op2,
	     unit[cid][row][col].conf.cdw0.op3,
	     unit[cid][row][col].conf.cdw0.ex1brs,
	     unit[cid][row][col].conf.cdw0.ex1s,
	     unit[cid][row][col].conf.cdw0.ex1exp,
	     unit[cid][row][col].conf.cdw0.ex2brs,
	     unit[cid][row][col].conf.cdw0.ex2exp,
	     unit[cid][row][col].conf.cdw0.ex3brs,
	     unit[cid][row][col].conf.cdw0.ex3exp,
	     unit[cid][row][col].conf.cdw0.e2imm,
	     unit[cid][row][col].conf.cdw0.e2is,
	     unit[cid][row][col].conf.cdw0.e3imm,
	     unit[cid][row][col].conf.cdw0.e3is);
d1706 15
a1720 15
	     unit[cid][row][col].conf.cdw1.cs3,
	     unit[cid][row][col].conf.cdw1.cs2,
	     unit[cid][row][col].conf.cdw1.cs1,
	     unit[cid][row][col].conf.cdw1.cs0,
	     unit[cid][row][col].conf.cdw1.cex_tab,
	     unit[cid][row][col].conf.cdw1.ea0op,
	     unit[cid][row][col].conf.cdw1.ea0bs,
	     unit[cid][row][col].conf.cdw1.ea0os,
	     unit[cid][row][col].conf.cdw1.ea0msk,
	     unit[cid][row][col].conf.cdw1.ea1op,
	     unit[cid][row][col].conf.cdw1.ea1bs,
	     unit[cid][row][col].conf.cdw1.ea1os,
	     unit[cid][row][col].conf.cdw1.ea1msk,
	     unit[cid][row][col].conf.cdw1.eabbrs,
	     unit[cid][row][col].conf.cdw1.eaobrs);
d1725 23
a1747 23
	     unit[cid][row][col].conf.cdw2.lmlsa,
	     unit[cid][row][col].conf.cdw2.lmrsa,
	     unit[cid][row][col].conf.cdw2.lmls3,
	     unit[cid][row][col].conf.cdw2.lmrs3,
	     unit[cid][row][col].conf.cdw2.lmls2,
	     unit[cid][row][col].conf.cdw2.lmrs2,
	     unit[cid][row][col].conf.cdw2.lmls1,
	     unit[cid][row][col].conf.cdw2.lmrs1,
	     unit[cid][row][col].conf.cdw2.lmls0,
	     unit[cid][row][col].conf.cdw2.lmrs0,
	     unit[cid][row][col].conf.cdw2.ts3,
	     unit[cid][row][col].conf.cdw2.ts2,
	     unit[cid][row][col].conf.cdw2.ts2,
	     unit[cid][row][col].conf.cdw2.ts0,
	     unit[cid][row][col].conf.cdw2.trs3,
	     unit[cid][row][col].conf.cdw2.trs2,
	     unit[cid][row][col].conf.cdw2.trs1,
	     unit[cid][row][col].conf.cdw2.trs0,
	     unit[cid][row][col].conf.cdw2.brs3,
	     unit[cid][row][col].conf.cdw2.brs2,
	     unit[cid][row][col].conf.cdw2.brs1,
	     unit[cid][row][col].conf.cdw2.brs0,
	     unit[cid][row][col].conf.cdw3.mapdist);
d1776 6
a1781 6
	     unit[cid][row][col].one_shot,
	     unit[cid][row][col].c[3],
	     unit[cid][row][col].c[2],
	     unit[cid][row][col].c[1],
	     unit[cid][row][col].c[0],
	     unit[cid][row][col].cexdr,
d1948 2
a1949 2
	     unit[cid][row][col].lmm.en1,
	     unit[cid][row][col].lmm.rw1,
d1952 3
a1954 3
	     unit[cid][row][col].lmm.mb1,
	     unit[cid][row][col].lmm.en0,
	     unit[cid][row][col].lmm.rw0,
d1957 1
a1957 1
	     unit[cid][row][col].lmm.mb0);
d2010 2
a2011 2
	     unit[cid][row][col].mr1mux,
	     unit[cid][row][col].mr0mux,
@


1.60
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.59 2016/04/20 23:29:29 nakashim Exp nakashim $";
d942 2
a943 2
    s = unit[cid][i][j].conf.cdw1.ea0bs;  unit[cid][i][j].ea0b = (s==0)?unit[cid][i][j].eab:unit[cid][i][j].regv.ea0br;
    s = unit[cid][i][j].conf.cdw1.ea0os;  unit[cid][i][j].ea0o = (s==0)?unit[cid][i][j].eao:unit[cid][i][j].regv.ea0or;
d961 2
a962 2
    s = unit[cid][i][j].conf.cdw1.ea1bs;  unit[cid][i][j].ea1b = (s==0)?unit[cid][i][j].eab:unit[cid][i][j].regv.ea1br;
    s = unit[cid][i][j].conf.cdw1.ea1os;  unit[cid][i][j].ea1o = (s==0)?unit[cid][i][j].eao:unit[cid][i][j].regv.ea1or;
a1030 1
  Uint op_cx;
a1048 1
      op_cx   = unit[cid][i][j].conf.cdw1.cop;
d1054 1
a1054 1
      cex(op_cx, c3, c2, c1, c0, pattern, &ex);
d1088 1
a1088 1
      r1     = (!unit[cid][i][j].conf.cdw0.ex1s || !unit[cid][i][j].one_shot)
d1159 2
a1160 2
	base1 = (!unit[cid][i][j].conf.cdw1.ea1bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
	offs1 = (!unit[cid][i][j].conf.cdw1.ea1bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
d1189 2
a1190 2
	base0 = (!unit[cid][i][j].conf.cdw1.ea0bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
	offs0 = (!unit[cid][i][j].conf.cdw1.ea0bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
d1687 1
a1687 2
      printf("|cop=%d_%01.1x%01.1x%01.1x%01.1x_%04.4x ea0=%02.2x_%d_%d_%01.1x ea1=%02.2x_%d_%d_%01.1x eab=%01.1x eao=%01.1x              ",
	     unit[cid][row][col].conf.cdw1.cop,
@


1.59
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.58 2016/04/20 23:00:24 nakashim Exp nakashim $";
d22 3
a24 3
  Uint  v                 : 1; /* 0:empty, 1:unuse */
  Uint  tid               :12; /* owner thread of EMAX */
  Uint  status            : 4;
d26 2
a27 2
  Uint  last_dist         : 6; /* latest map_dist */
  Uint  last_row0         : 6; /* physical top of logical unit[][0] */
d84 3
a86 3
    Uint  last_dist       : 6; /* latest map_dist */
    Uint  memif_status    : 4;
    Uint  row_count       : 8; /* valid row counter is 6bit */
d113 1
a113 1
  Uint  one_shot     : 1;  /* reg  *//* for self_loop_control 0:init 1:self_loop */
d115 1
a115 1
  Uint  cexdr        : 2;  /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
d129 2
a130 2
  Uint  lmen         : 1;  /* lmm enable for read/write */
  Uint  rrdy         : 1;  /* wire *//* LMM data-valid for FSM */
d150 4
a153 4
    Uint  en0         : 1; /* internal reg       */
    Uint  en1         : 1; /* internal reg       */
    Uint  rw0         : 1; /* 0:read, 1:write    */
    Uint  rw1         : 1; /* 0:read,(1:write)   */
d155 1
a155 1
    Uint  mb0         : 5; /* internal reg  addr(byte index in 32B)*/
d157 1
a157 1
    Uint  mb1         : 5; /* internal reg  addr(byte index in 32B)*/
d164 2
a165 2
  Uint  mr0mux        : 2; /* mr0[3-0] -> brs0     */
  Uint  mr1mux        : 2; /* mr1[3-0] -> brs1     */
d178 2
a179 2
  Uint  status : 4;
  Uint  tcbid; /* 0:invalid, start address of trans */
@


1.58
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.57 2016/04/20 12:05:07 nakashim Exp nakashim $";
d884 1
d892 1
a892 1
      printf("c%d i%d d%d l%d r%d e%d z%d t%d\n",
d1474 1
d1477 3
a1479 2
  printf("%03.3d:siml_emax5: tinit=%08.8x_%08.8x conf=%08.8x_%08.8x lmmi=%08.8x_%08.8x drain=%08.8x_%08.8x load=%08.8x_%08.8x\n",
	 cid,
d1485 1
a1485 1
  printf("                 regv=%08.8x_%08.8x exec=%08.8x_%08.8x term=%08.8x_%08.8x trans=%08.8x_%08.8x\n",
@


1.57
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.56 2016/04/19 23:02:41 nakashim Exp nakashim $";
d1070 1
d1101 1
a1101 1
      exe(op_ex1, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5, &d);
d1103 2
@


1.56
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.55 2016/04/19 10:19:32 nakashim Exp nakashim $";
d186 1
a186 1
siml_trans(tid, cycle, trace, trace_pipe, base, start, end, gr2) Uint tid, cycle, trace, trace_pipe; Uchar *base; Ull start, end, gr2;
d219 1
a219 1
siml_emax5(tid, cycle, trace, trace_pipe, base, conf, lmmi, regv) Uint tid, cycle, trace, trace_pipe; char *base; Ull conf, lmmi, regv;
d260 3
a262 3
	siml_unit_cex(cid, i, j); /* cnd */
	siml_unit_exe(cid, i, j); /* exe */
	siml_unit_eag(cid, i, j); /* eag */
d265 1
a265 1
	siml_unit_trg(cid, i, j); /* trg */
a279 3

    if (trace && trace_pipe)
      show_emax5_status(cid);
d891 1
a891 2
      printf("%03.3d:siml_emax5: term c=%d i=%d d=%d l=%d r=%d e=%d z=%d t=%d\n",
	     cid,
d902 2
a903 1
      return (0); /* EMAX5 terminated */
d908 2
d911 4
a914 1
  return (2); /* EMAX5 busy */
@


1.55
log
@*** empty log message ***
@
text
@d2 1
a2 1
 static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.54 2016/04/19 04:38:47 nakashim Exp nakashim $";
d4 48
a51 48
 /* EMAX5 Simulator                     */
 /*         Copyright (C) 2012 by NAIST */
 /*         Primary writer: Y.Nakashima */
 /*                nakashim@@is.naist.jp */

 /* emax5.c 2012/9/22 */ 

 #include <stdio.h>
 #include "bsim.h"
 #include "../conv-c2d/emax5.h"
 #include "../conv-c2d/emax5lib.c"

 /* CGRA hardware */
 enum { STATUS_IDLE, STATUS_CONF, STATUS_LMMI, STATUS_DRAIN, STATUS_LOAD, STATUS_REGV, STATUS_START, STATUS_EXEC, STATUS_TERM };
 enum { FSM_IDLE,    FSM_CONF,    FSM_LMMI,    FSM_DRAIN,    FSM_LOAD,    FSM_REGV,    FSM_START,    FSM_EXEC,    FSM_TERM };
 enum { MEMIF_IDLE,  MEMIF_AREQ,  MEMIF_DREQ,  MEMIF_TERM };

 struct emax5 { /* lmm status of EMAX5 */
   Uint  v                 : 1; /* 0:empty, 1:unuse */
   Uint  tid               :12; /* owner thread of EMAX */
   Uint  status            : 4;
   Ull   last_conf            ; /* for insn_reuse */
   Uint  last_dist         : 6; /* latest map_dist */
   Uint  last_row0         : 6; /* physical top of logical unit[][0] */

   Ull   unit1_exec; /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:exec */
   Ull   unit1_stop; /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:stop */
   Ull   unit2_exec; /* 1bit corresponds to each row (lmm),         0:wait 1:exec */
   Ull   unit2_stop; /* 1bit corresponds to each row (lmm),         0:wait 1:stop */

   Uint  cycles_tinit_part;
   Uint  cycles_conf_part;
   Uint  cycles_lmmi_part;
   Uint  cycles_drain_part;
   Uint  cycles_load_part;
   Uint  cycles_regv_part;
   Uint  cycles_exec_part;
   Uint  cycles_term_part;
   Uint  cycles_trans_part;
   Ull   cycles_tinit;
   Ull   cycles_conf;
   Ull   cycles_lmmi;
   Ull   cycles_drain;
   Ull   cycles_load;
   Ull   cycles_regv;
   Ull   cycles_exec;
   Ull   cycles_term;
   Ull   cycles_trans;
d79 1384
a1462 1384
   struct fsm {                 /* load/drainは,複数rowを同時動作 */
     struct lmmi lmmo[EMAX_DEPTH]; /* previous lmmi */
     struct lmmi lmmc[EMAX_DEPTH]; /* current lmmi */
     Uchar       lmmd[EMAX_DEPTH]; /* 0:clean, 1:dirty,   exec後store箇所に1, drain直後0 */

     Uint  last_dist       : 6; /* latest map_dist */
     Uint  memif_status    : 4;
     Uint  row_count       : 8; /* valid row counter is 6bit */
     Ull   row_select      :64; /* bitmap 0:off 1:selected */
     Ull   row_lmm_en      :64; /* lmm enable for read/write */
     Uint  ardyc;               /* LMM addr-request(read/write) counter */
     Uint  rrdyc;               /* LMM data-ready(read) counter */
				/*                         CF  RV  LI  PF  DR  TR  DM                 */
     Ull   lmwa               ; /* -> ea0dr                     v       v                             */
     Ull   lmwd[UNIT_WIDTH]   ; /* <- lmm wdata                 v       v           v                 */
     Ull   lmra               ; /* -> ea1dr                                 v                         */
     Ull   lmrd[UNIT_WIDTH]   ; /* -> lmm rdata                             v   v                     */
     Ull   axra               ; /* <- ea0dr                     -       -           v                 */
     Ull   axwa               ; /* <- ea1dr (not used)                      -                         */

     Ull   raddr;               /* read-address  of mm      v   v   v   v           v                 */
     Ull   rlen;                /* read-length   of mm      v   v   v   v           1                 */
     Ull   rdata[UNIT_WIDTH];   /* read-data     of mm      v   v   v   v           v                 */
     Ull   waddr;               /* write-address of mm                      v                         */
     Ull   wlen;                /* write-length  of mm                      v                         */
     Ull   wdata[UNIT_WIDTH];   /* write-data    of mm                      v                         */

     Ull   tcureg[UNIT_WIDTH];  /* tcu-data      of tcu                         v                     */
   } fsm[EMAX_WIDTH];
 } emax5[MAXCORE];

 struct unit { /* hardware status of EMAX5 units */
   struct conf conf;
   struct regv regv;        /* ea0br,ea0or,ea1br,ea1or,br[UNIT_WIDTH] */
   Uint  one_shot     : 1;  /* reg  *//* for self_loop_control 0:init 1:self_loop */
   Uchar c[UNIT_WIDTH];     /* wire */
   Uint  cexdr        : 2;  /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
   Ull   ex1             ;  /* wire *//* in for ALU */
   Ull   ex2             ;  /* wire *//* in for ALU */
   Ull   ex3             ;  /* wire *//* in for ALU */
   Ull   eab             ;  /* wire *//* in for ALU */
   Ull   eao             ;  /* wire *//* in for ALU */
   Ull   ea0b            ;  /* wire *//* in for EA0 */
   Ull   ea0o            ;  /* wire *//* in for EA0 */
   Ull   ea1b            ;  /* wire *//* in for EA1 */
   Ull   ea1o            ;  /* wire *//* in for EA1 */
   Ull   exdr            ;  /* reg  */
   Ull   ea0dr           ;  /* reg  */
   Ull   ea1dr           ;  /* reg  */

   Uint  lmen         : 1;  /* lmm enable for read/write */
   Uint  rrdy         : 1;  /* wire *//* LMM data-valid for FSM */

   Ull   lmwa            ;  /* wire *//* -> ea0dr */
   Ull   lmwd[UNIT_WIDTH];  /* wire *//* <- axi */
   Ull   lmra            ;  /* wire *//* -> ea1dr */
   Ull   lmrd[UNIT_WIDTH];  /* wire *//* -> axi */
   Ull   axra            ;  /* wire *//* <- ea0dr */
   Ull   axwa            ;  /* wire *//* <- ea1dr .. not used */

   Ull   lmria           ;  /* wire */
   Ull   lmroa           ;  /* wire */
   Ull   lmlia           ;  /* wire */
   Ull   lmloa           ;  /* wire */
   Ull   lmri[UNIT_WIDTH];  /* wire */
   Ull   lmro[UNIT_WIDTH];  /* wire */
   Ull   lmli[UNIT_WIDTH];  /* wire */
   Ull   lmlo[UNIT_WIDTH];  /* wire */
   Ull   t[UNIT_WIDTH];     /* wire */
   Ull   tr[UNIT_WIDTH];    /* reg  */
   struct lmm {
     Uint  en0         : 1; /* internal reg       */
     Uint  en1         : 1; /* internal reg       */
     Uint  rw0         : 1; /* 0:read, 1:write    */
     Uint  rw1         : 1; /* 0:read,(1:write)   */
     Ull   ma0            ; /* internal reg  addr(32B aligned)      */
     Uint  mb0         : 5; /* internal reg  addr(byte index in 32B)*/
     Ull   ma1            ; /* internal reg  addr(32B aligned)      */
     Uint  mb1         : 5; /* internal reg  addr(byte index in 32B)*/
     Ull   mm0[UNIT_WIDTH]; /* internal reg  mask */
     Ull   mw0[UNIT_WIDTH]; /* internal reg  data */
     Ull   mr0[UNIT_WIDTH]; /* internal wire data */
     Ull   mr1[UNIT_WIDTH]; /* internal wire data */
     Uchar m[LMEM_SIZE]   ; /* local memory       */
   } lmm;
   Uint  mr0mux        : 2; /* mr0[3-0] -> brs0     */
   Uint  mr1mux        : 2; /* mr1[3-0] -> brs1     */
   Ull   mr0d             ; /* muxed data for BR[0] */
   Ull   mr1d             ; /* muxed data for BR[1] */
 } unit[MAXCORE][EMAX_DEPTH][EMAX_WIDTH];

 /* TCU hardware */
 enum { TCU_IDLE, TCU_BUSY };

 #define MAX_TRANS_CBL 8
 #define MAX_TRANS_REG 8

 Uint next_tcu; /* tcb_entry for next tcb registration by trans_start() */
 struct tcu { /* final information for EMAX5 hardware */
   Uint  status : 4;
   Uint  tcbid; /* 0:invalid, start address of trans */
   struct tconf tconf[TRANS_DEPTH]; /* copy of tconf[] */
   Uint  pc;                 /* program counter */
   Ull   reg[MAX_TRANS_REG]; /* r0-r7 for param/work */
 } tcu[MAX_TRANS_CBL];

 /* TCU control */
 siml_trans(tid, cycle, trace, trace_pipe, base, start, end, gr2) Uint tid, cycle, trace, trace_pipe; Uchar *base; Ull start, end, gr2;
 {
   Uint cid = tid2cid(tid);
   int i, j, k, a;

   emax5[cid].cycles_tinit_part = 0;

   for (i=0; i<MAX_TRANS_CBL; i++) {
     if (tcu[i].tcbid == start) {
       next_tcu = i;
       break;
     }
   }

   if (tcu[next_tcu].status != TCU_IDLE)
     return (2);

   /* new tcb is stored in tcu.next_tcb */
   tcu[next_tcu].tcbid = start;
   for (i=0; i<TRANS_DEPTH; i++)
     tcu[next_tcu].tconf[i] = *((struct tconf*)(base+start)+i);

   emax5[cid].cycles_tinit_part = sizeof(tconf)/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
   emax5[cid].cycles_tinit += emax5[cid].cycles_tinit_part;

   next_tcu = (next_tcu+1)%MAX_TRANS_CBL;

   return (0);
 }

 /* EMAX5 control */
 //application -> emax5_start((Ull*)emax5_conf_x1, (Ull*)emax5_lmmi_x1, (Ull*)emax5_regv_x1);
 //            -> svc 0xf1
 siml_emax5(tid, cycle, trace, trace_pipe, base, conf, lmmi, regv) Uint tid, cycle, trace, trace_pipe; char *base; Ull conf, lmmi, regv;
 {
   Uint cid = tid2cid(tid);
   int i, j, k, flag, sync;
   Ull a;

   if (emax5[cid].v && emax5[cid].tid != tid)
     return (2); /* busy */

   if (emax5[cid].status == STATUS_IDLE) {
     emax5[cid].v = 1; /* lock */
     emax5[cid].tid = tid;
     emax5[cid].cycles_conf_part  = 0;
     emax5[cid].cycles_lmmi_part  = 0;
     emax5[cid].cycles_drain_part = 0;
     emax5[cid].cycles_load_part  = 0;
     emax5[cid].cycles_regv_part  = 0;
     emax5[cid].cycles_exec_part  = 0;
     emax5[cid].cycles_term_part  = 0;
     emax5[cid].cycles_trans_part = 0;
   }
   while (cycle-- > 0) {
     Ull prev1_stop, prev2_stop;    
     /*******************************************************/
     /******************* unit siml start *******************/
     /*******************************************************/
     prev1_stop =  emax5[cid].unit1_stop;
     prev2_stop =  emax5[cid].unit2_stop;
     for (i=(emax5[cid].last_row0+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
       siml_unit_bus1(cid, i); /* br */
       siml_unit_bus2(cid, i); /* mr */
       for (j=EMAX_WIDTH-1; j>=0; j--) { /* for each unit */
	 /**************************/
	 /****** do lmm ************/
	 /**************************/
	 siml_unit_lmm(cid, i, j); /* lmm */
       }
       for (j=EMAX_WIDTH-1; j>=0; j--) { /* for each unit */
	 /**************************/
	 /****** do exe ************/
	 /**************************/
	 siml_unit_cex(cid, i, j); /* cnd */
	 siml_unit_exe(cid, i, j); /* exe */
	 siml_unit_eag(cid, i, j); /* eag */
       }
       for (j=EMAX_WIDTH-1; j>=0; j--) /* for each unit */
	 siml_unit_trg(cid, i, j); /* trg */
       /* 自stage:stop=1と同時に自stage:exec=0 次cycleから実行停止 */
       if (emax5[cid].status == STATUS_START)
	 emax5[cid].unit1_exec |= emax5[cid].fsm[0].row_select;
       if (emax5[cid].status == STATUS_EXEC) {
	 emax5[cid].unit2_stop |= ( prev1_stop           &(1LL<<  i                          ))                                      ? (1LL<<i): 0;
	 emax5[cid].unit1_stop |= ( prev2_stop           &(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))                                      ? (1LL<<i): 0;
	 emax5[cid].unit2_exec &= (                                                                  emax5[cid].unit2_stop&(1LL<<i) )?~(1LL<<i):~0;
	 emax5[cid].unit2_exec |= ((emax5[cid].unit1_exec&(1LL<<  i                          )) && !(emax5[cid].unit2_stop&(1LL<<i)))? (1LL<<i): 0;
	 emax5[cid].unit1_exec &= (                                                                  emax5[cid].unit1_stop&(1LL<<i) )?~(1LL<<i):~0;
	 emax5[cid].unit1_exec |= ((emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))) && !(emax5[cid].unit1_stop&(1LL<<i)))? (1LL<<i): 0;
       }
       if (i==emax5[cid].last_row0)
	 break;
     }

     if (trace && trace_pipe)
       show_emax5_status(cid);
     /*******************************************************/
     /******************* unit siml end *********************/
     /*******************************************************/

     /*******************************************************/
     /******************* FSM siml start ********************/
     /******** 全unit 1cycle動作後,FSMは次のcmdを用意 *******/
     /*******************************************************/
     switch (emax5[cid].status) {
     case STATUS_IDLE:
       if (emax5[cid].last_conf != conf || emax5[cid].last_dist > 0) {
	 if (trace)
	   printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (new)\n", tid, (Uint)(conf>>32), (Uint)conf);
	 emax5[cid].status = STATUS_CONF;
	 for (j=0; j<EMAX_WIDTH; j++) {
	   emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	   emax5[cid].fsm[j].row_count    = 0;
	   emax5[cid].fsm[j].row_select   = 0LL;
	 }
       }
       else {
	 if (trace)
	   printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (reuse)\n", tid, (Uint)(conf>>32), (Uint)conf);
	 emax5[cid].status = STATUS_LMMI;
	 for (j=0; j<EMAX_WIDTH; j++) {
	   emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	   emax5[cid].fsm[j].row_count    = 0;
	   emax5[cid].fsm[j].row_select   = 0LL;
	 }
       }
       break;
     case STATUS_CONF:
       emax5[cid].cycles_conf_part++;
       for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	 i = emax5[cid].fsm[j].row_count;
	 if (i < EMAX_DEPTH) {	
	   switch (emax5[cid].fsm[j].memif_status) {
	   case MEMIF_AREQ:
	     emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	     emax5[cid].fsm[j].ardyc = 0;
	     emax5[cid].fsm[j].raddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
	     emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
	     break;
	   case MEMIF_DREQ:
	     if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH) { /* 1rrdy/1unit */
	       emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[j].row_count)%EMAX_DEPTH);
	       emax5[cid].fsm[j].lmwa = 0LL; /* fixed */
	       for (k=0; k<UNIT_WIDTH; k++)
		 emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k));
	       emax5[cid].fsm[j].last_dist = emax5[cid].fsm[j].rdata[3] & 0x3f; /* mapdist */
	       emax5[cid].fsm[j].row_count++;
	       emax5[cid].fsm[j].ardyc++;
	     }
	     else {
	       emax5[cid].fsm[j].memif_status = MEMIF_TERM;
	       emax5[cid].fsm[j].row_select   = 0LL;
	     }
	     break;
	   }
	   sync = 0; /* not finished */
	 }
       }
       if (sync) { /* all FSM_CONF finished */
	 emax5[cid].last_conf = conf;
	 emax5[cid].last_dist = emax5[cid].fsm[0].last_dist;
	 emax5[cid].last_row0 = (emax5[cid].last_row0+emax5[cid].last_dist)%EMAX_DEPTH;
	 emax5[cid].status = STATUS_LMMI;
	 for (j=0; j<EMAX_WIDTH; j++) {
	   emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	   emax5[cid].fsm[j].row_count    = 0;
	   emax5[cid].fsm[j].row_select   = 0LL;
	 }
       }
       break;
     case STATUS_LMMI:
       emax5[cid].cycles_lmmi_part++;
       for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	 i = emax5[cid].fsm[j].row_count;
	 if (i < EMAX_DEPTH) {	
	   switch (emax5[cid].fsm[j].memif_status) {
	   case MEMIF_AREQ:
	     emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	     emax5[cid].fsm[j].ardyc = 0;
	     emax5[cid].fsm[j].raddr = lmmi+sizeof(Ull)*2*EMAX_DEPTH*j; /* lmmi_topをfsmに渡すインタフェース */
	     emax5[cid].fsm[j].rlen  =      sizeof(Ull)*2*EMAX_DEPTH*1; /* lmmi_topをfsmに渡すインタフェース */
	     break;
	   case MEMIF_DREQ:
	     if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH/2) { /* 1rrdy/2unit */
	       *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+0);
	       *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+1);
	       *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+0);
	       *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+1);

	       *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[0] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+0);
	       *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[1] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+1);
	       *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[2] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+2);
	       *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[3] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+3);
	       emax5[cid].fsm[j].row_count+=2;
	       emax5[cid].fsm[j].ardyc++;
	     }
	     else {
	       emax5[cid].fsm[j].memif_status = MEMIF_TERM;
	       emax5[cid].fsm[j].row_select   = 0LL;
	     }
	     break;
	   }
	   sync = 0; /* not finished */
	 }
       }
       if (sync) { /* all FSM_LMMI finished */
	 emax5[cid].status = STATUS_DRAIN;
	 for (j=0; j<EMAX_WIDTH; j++) {
	   emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	   emax5[cid].fsm[j].row_count    = 0;
	   emax5[cid].fsm[j].row_select   = 0LL;
	 }
       }
       break;
       /*******************************************************************************************************************************************************/
       /* ●lmmi指示ルール (copy from conv-c2d/emac5.c)                                                                  lmmi-loc  v  top  blk  len  rw  f  p */
       /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  len   0  0  0 */
       /* LD with force-read=1 and ptop==NULL generates current(lmf) and does not reuse LMM. same as lmf in EMAX4            curr  1  top  blk  len   0  1  0 */
       /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). same as lmp in EMAX4                     curr  1  top  blk  len   0  0  0 */
       /*                                                                                                                  c+dist  1 ptop  blk  len   0  0  1 */
       /*                                                                                        ptop!=NULL & force=1は，prefetchの意味がないので組合せがない */
       /*******************************************************************************************************************************************************/
       /* ST with force-read=0 and ptop==NULL writes back after execution. same as lmw in EMAX4                              curr  1  top  blk  len   1  0  0 */
       /* ST with force-read=1 and ptop==NULL prefetches data to LMM in advance and write back. same as lmx in EMAX4         curr  1  top  blk  len   1  1  0 */
       /* ST with force-read=0, top==NULL and ptop!=NULL late drain with next execution. same as lmd in EMAX4                curr  0  (check be empty)        */
       /*                                                   FSMは,dirtyおよびp-bitに従い,exec同時drainか,exec後drainを選択 c-dist  1 ptop  blk  len   1  0  1 */
       /*                                                                                        deleyed-drain & force=1は，delayの意味がないので組合せがない */
       /*******************************************************************************************************************************************************/
       /* Example of Load+Store **************************************************************************/ 
       /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
       /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
       /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
       /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
       /*                        ○lmmo.top==lmmi.top,.f=0,.p=0の場合, load/reuse before next exec       */
       /*   ex4(FMAQ, src1, src2, src3, dst1);                                                           */
       /*   mo4(STRQ,  1, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmw (store)                    */
       /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
       /* }                                                                                              */
       /* Example of Accumulate **************************************************************************/ 
       /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
       /*   mo4(LDRQ,  1, src1, D[y], x, msk, D[y], 0, XSIZE, 1, NULL);   lmf (load)                     */
       /*                        ●lmmi.f=1の場合, load always before next exec                          */
       /*   ex4(FMAQ, src1, src2, src3, dst1);                                (accumulate)               */
       /*   mo4(STRQ,  1, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmw (store)                    */
       /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
       /*                   (lmfとlmwが重なるケースでも一旦memに追い出すことで単純化. lmfは再利用しない) */
       /* }                                                                                              */
       /* Example of Partial Update **********************************************************************/ 
       /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
       /*   mo4(STRQ, ex, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmx (read-&-conditional-write) */
       /*                        ●lmmi.f=1の場合, load always before next exec                          */
       /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
       /*                                        (lmxも一旦memに追い出すことで単純化. lmxも再利用しない) */
       /* }                                                                                              */
       /* Example of Prefetch+Drain **********************************************************************/ 
       /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
       /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, A[y+1]); lmr+lmp prefetch               */
       /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, B[y+1]); lmr+lmp prefetch               */
       /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, C[y+1]); lmr+lmp prefetch               */
       /*                        ○lmmo.top==lmmi.top,.f=0,.p=0の場合, load/reuse before next exec       */
       /*                        ★lmmo.top==lmmi.top,.f=0,.p=1の場合, load/reuse with next exec         */
       /*   ex4(FMAQ, src1, src2, src3, dst1);                                                           */
       /*   mo4(STRQ,  1, dst1, D[y], x, msk, NULL, 0, XSIZE, 0, D[y-1]); lmd explicit late drain        */
       /*                        ★dirty=1,lmmi.top!=NULL,.p=1の場合, delayed drain at next exec         */
       /* }                                                                                              */
       /*************************************************************************************************************************************/
       /* 【FSM_DRAIN】                                                                                                                     */
       /* lmmo.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
       /*      1  1  0  0 ... lmw       lmmd=1のみ,必ず,regv前にdrain.終了時にlmmd=0                     store:d=1     --                   */
       /*      1  1  1  0 ... lmx       lmmd=1のみ,必ず,regv前にdrain.終了時にlmmd=0                     store:d=1     --                   */
       /*      1  1  0  1 ... lmd       drainは完了(dirty=0)しているので無視してよい                     drain済       --                   */
       /* 【FSM_LOAD】                                                                                                                      */
       /* lmmi.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
       /*      1  0  0  0 ... lmr       lmmoとlmmiが不一致ならdrainとregvの間にload                      prefetch/--   reuse/mload          */
       /*      1  0  1  0 ... lmf       必ずdrainとregvの間にload                                        --            mload(always)        */
       /*      1  1  1  0 ... lmx       必ずdrainとregvの間にload                                        --            store:d=1            */
       /* 【FSM_EXEC】lmm_store開始と同時にlmmd=1                                                                                           */
       /* lmmi.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
       /*      1  0  0  1 ... lmp       lmmoとlmmiが不一致ならexecと同時にloadする                       prefetch/--   reuse/prefetch       */
       /*      1  1  0  0 ... lmw                                                                        --            store:d=1            */
       /*      1  1  0  1 ... lmd       lmmd=1のみ,execと同時にdrain.終了時にlmmd=0                      store:d=1     d=1時のみdrain       */
       /*                               最後のlmdを追い出すためには明示的drain指示(startとは別コマンド)が必要                               */
       /*************************************************************************************************************************************/
     case STATUS_DRAIN:
       emax5[cid].cycles_drain_part++;
       for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	 i = emax5[cid].fsm[j].row_count;
	 if (i < EMAX_DEPTH) {
	   switch ((emax5[cid].fsm[j].lmmo[j].v<<3)|(emax5[cid].fsm[j].lmmo[i].rw<<2)|(emax5[cid].fsm[j].lmmo[i].f<<1)|(emax5[cid].fsm[j].lmmo[i].p)) {
	     /* v | rw | f | p */
	   case 12: /* lmw */
	   case 14: /* lmx */
	     if (emax5[cid].fsm[j].lmmd[i]) /* dirty exist */
	       flag = 1; /* drain */
	     else
	       flag = 0; /* skip drain */
	     break;
	   default:
	     flag = 0; /* skip drain */
	     break;
	   }

	   if (flag) {
	     Uint lmm_nreq;
	     switch (emax5[cid].fsm[j].memif_status) {
	     case MEMIF_AREQ:
	       emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	       emax5[cid].fsm[j].ardyc = 0; /* LMM addr-request(read/write) counter */
	       emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read) counter */
	       emax5[cid].fsm[j].waddr = emax5[cid].fsm[j].lmmo[i].top;
	       emax5[cid].fsm[j].wlen  = emax5[cid].fsm[j].lmmo[i].len;
	       break;
	     case MEMIF_DREQ:
	       /* block 0:inf, 1:16, 2:32, 3:64 dword*UNIT_WIDTH*block=page(burst_size)    */
	       /* 通常は,     block=0                                                      */
	       /* tricountは, block=2                                                      */
	       /* EMAX5では必ず64bit*4幅                                                   */
	       /* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	       /* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	       /* align=32B, block=0, blocking=none             ... align済 4倍幅load      */
	       /* --- blocking-load --- : fsmがblock単位にburst起動                        */
	       /* align=xxx, block=1, blocksize=8*4*16=512B     ... 下位5bit無視 4倍幅load */
	       /* align=xxx, block=2, blocksize=8*4*32=1KB      ... 下位5bit無視 4倍幅load */
	       /* align=xxx, block=3, blocksize=8*4*64=2KB      ... 下位5bit無視 4倍幅load */
	       lmm_nreq = emax5[cid].fsm[j].lmmo[i].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	       if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		 emax5[cid].fsm[j].row_select = 1LL<<i;
		 emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
		 emax5[cid].fsm[j].lmra = emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
		 if (trace) {
		   printf("%03.3d:siml_emax5: drain row=%d col=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			  tid, i, j, (Uint)(emax5[cid].fsm[j].lmra>>32), (Uint)emax5[cid].fsm[j].lmra, emax5[cid].fsm[j].ardyc, lmm_nreq);
		 }
		 emax5[cid].fsm[j].ardyc++;
	       }
	       else
		 emax5[cid].fsm[j].row_lmm_en = 0LL; /* row_selectは残りrrdyのために維持 */
	       if (emax5[cid].fsm[j].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		 if (unit[cid][i][j].rrdy) { /* ack from lmm */
		   for (k=0; k<UNIT_WIDTH; k++)
		     *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k];
		   if (trace) {
		     printf("%03.3d:siml_emax5: drain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			    tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
		   }
		   emax5[cid].fsm[j].rrdyc++;
		 }
	       }
	       else {
		 emax5[cid].fsm[j].lmmd[i] = 0;
		 emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		 emax5[cid].fsm[j].row_count++;
		 emax5[cid].fsm[j].row_select   = 0LL;
		 emax5[cid].fsm[j].row_lmm_en   = 0LL;
	       }
	       break;
	     }
	   }
	   else {
	     emax5[cid].fsm[j].row_count++;
	   }
	   sync = 0; /* not finished */
	 }
       }
       if (sync) { /* all FSM_DRAIN finished */
	 emax5[cid].status = STATUS_LOAD;
	 for (j=0; j<EMAX_WIDTH; j++) {
	   emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	   emax5[cid].fsm[j].row_count    = 0;
	   emax5[cid].fsm[j].row_select   = 0LL;
	   emax5[cid].fsm[j].row_lmm_en   = 0LL;
	 }
       }
       break;
     case STATUS_LOAD:
       emax5[cid].cycles_load_part++;
       for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	 i = emax5[cid].fsm[j].row_count;
	 if (i < EMAX_DEPTH) {
	   switch ((emax5[cid].fsm[j].lmmc[i].v<<3)|(emax5[cid].fsm[j].lmmc[i].rw<<2)|(emax5[cid].fsm[j].lmmc[i].f<<1)|(emax5[cid].fsm[j].lmmc[i].p)) {
	     /* v | rw | f | p */
	   case  8: /* lmr */
	     if (emax5[cid].fsm[j].lmmo[i].v
	      && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
	      && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
	      && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top) {
	       if (trace)
		 printf("%03.3d:siml_emax5: load row=%d col=%d top=%08.8x_%08.8x found in LMM\n",
			tid, i, j, (Uint)(emax5[cid].fsm[j].lmmc[i].top>>32), (Uint)emax5[cid].fsm[j].lmmc[i].top);
	       flag = 0; /* skip load */
	     }
	     else
	       flag = 1; /* load */
	     break;
	   case 10: /* lmf always load */
	   case 14: /* lmx always load */
	     flag = 1; /* load */
	     break;
	   default:
	     flag = 0; /* skip load */
	     break;
	   }

	   if (flag) {
	     Uint lmm_nreq;
	     switch (emax5[cid].fsm[j].memif_status) {
	     case MEMIF_AREQ:
	       emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	       emax5[cid].fsm[j].ardyc = 0; /* LMM addr-request(read/write) counter */
	       emax5[cid].fsm[j].raddr = emax5[cid].fsm[j].lmmc[i].top;
	       emax5[cid].fsm[j].rlen  = emax5[cid].fsm[j].lmmc[i].len;
	       break;
	     case MEMIF_DREQ:
	       /* block 0:inf, 1:16, 2:32, 3:64 dword*UNIT_WIDTH*block=page(burst_size)    */
	       /* 通常は,     block=0                                                      */
	       /* tricountは, block=2                                                      */
	       /* EMAX5では必ず64bit*4幅                                                   */
	       /* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	       /* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	       /* align=32B, block=0, blocking=none             ... align済 4倍幅load      */
	       /* --- blocking-load --- : fsmがblock単位にburst起動                        */
	       /* align=xxx, block=1, blocksize=8*4*16=512B     ... 下位5bit無視 4倍幅load */
	       /* align=xxx, block=2, blocksize=8*4*32=1KB      ... 下位5bit無視 4倍幅load */
	       /* align=xxx, block=3, blocksize=8*4*64=2KB      ... 下位5bit無視 4倍幅load */
	       lmm_nreq = emax5[cid].fsm[j].lmmc[i].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	       if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		 Ull ofs;
		 emax5[cid].fsm[j].row_select = 1LL<<i;
		 emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
		 emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
 #if 1
		 /*** GATHER ************/
		 switch (emax5[cid].fsm[j].lmmc[i].blk) {
		 case 0: /* inf */
		   ofs =        (       emax5[cid].fsm[j].lmmc[i].top                                         ) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc   )*UNIT_WIDTH;
		   break;
		 case 1: /* 16 */
		   ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%16)*UNIT_WIDTH;
		   break;
		 case 2: /* 32 */
		   ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%32)*UNIT_WIDTH;
		   break;
		 case 3: /* 64 */
		   ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%64)*UNIT_WIDTH;
		   break;
		 }
 #endif
		 for (k=0; k<UNIT_WIDTH; k++) {
		   emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + ofs + sizeof(Ull)*k);
		   if (trace) {
		     printf("%03.3d:siml_emax5: load row=%d col=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			    tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa,
			    k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].ardyc, lmm_nreq);
		   }
		 }
		 emax5[cid].fsm[j].ardyc++;
	       }
	       else {
		 emax5[cid].fsm[j].lmmo[i].v   = emax5[cid].fsm[j].lmmc[i].v;
		 emax5[cid].fsm[j].lmmo[i].rw  = emax5[cid].fsm[j].lmmc[i].rw;
		 emax5[cid].fsm[j].lmmo[i].f   = emax5[cid].fsm[j].lmmc[i].f;
		 emax5[cid].fsm[j].lmmo[i].p   = emax5[cid].fsm[j].lmmc[i].p;
		 emax5[cid].fsm[j].lmmo[i].blk = emax5[cid].fsm[j].lmmc[i].blk;
		 emax5[cid].fsm[j].lmmo[i].len = emax5[cid].fsm[j].lmmc[i].len;
		 emax5[cid].fsm[j].lmmo[i].top = emax5[cid].fsm[j].lmmc[i].top;
		 emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		 emax5[cid].fsm[j].row_count++;
		 emax5[cid].fsm[j].row_select   = 0LL;
		 emax5[cid].fsm[j].row_lmm_en   = 0LL;
	       }
	       break;
	     }
	   }
	   else {
	     emax5[cid].fsm[j].row_count++;
	   }
	   sync = 0; /* not finished */
	 }
       }
       if (sync) { /* all FSM_LOAD finished */
	 emax5[cid].status = STATUS_REGV;
	 for (j=0; j<EMAX_WIDTH; j++) {
	   emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	   emax5[cid].fsm[j].row_count    = 0;
	   emax5[cid].fsm[j].row_select   = 0LL;
	   emax5[cid].fsm[j].row_lmm_en   = 0LL;
	 }
       }
       break;
     case STATUS_REGV:
       emax5[cid].cycles_regv_part++;
       for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	 i = emax5[cid].fsm[j].row_count;
	 if (i < EMAX_DEPTH) {	
	   switch (emax5[cid].fsm[j].memif_status) {
	   case MEMIF_AREQ:
	     emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	     emax5[cid].fsm[j].ardyc = 0;
	     emax5[cid].fsm[j].raddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
	     emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
	     break;
	   case MEMIF_DREQ:
	     if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH*2) { /* 2rrdy/1unit */
	       emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[j].row_count)%EMAX_DEPTH);
	       emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].ardyc&1; /* even/odd */
	       for (k=0; k<UNIT_WIDTH; k++)
		 emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k));
	       emax5[cid].fsm[j].row_count+=(emax5[cid].fsm[j].ardyc&1); /* even/odd */
	       emax5[cid].fsm[j].ardyc++;
	     }
	     else {
	       emax5[cid].fsm[j].memif_status = MEMIF_TERM;
	       emax5[cid].fsm[j].row_select   = 0LL;
	     }
	     break;
	   }
	   sync = 0; /* not finished */
	 }
       }
       if (sync) { /* all FSM_REGV finished */
	 emax5[cid].status = STATUS_START;
	 for (j=0; j<EMAX_WIDTH; j++) {
	   emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	   emax5[cid].fsm[j].row_count    = 0;
	   emax5[cid].fsm[j].row_select   = 0LL;
	 }
       }
       break;
     case STATUS_START:
       for (j=0; j<EMAX_WIDTH; j++) {
	 switch (emax5[cid].fsm[j].memif_status) {
	 case MEMIF_AREQ:
	   emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	   emax5[cid].fsm[j].row_select = 1LL<<emax5[cid].last_row0; /* start row */
	   break;
	 case MEMIF_DREQ:
	   emax5[cid].status = STATUS_EXEC;
	   for (j=0; j<EMAX_WIDTH; j++) {
	     emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	     emax5[cid].fsm[j].row_count    = 0;
	     emax5[cid].fsm[j].row_select   = 0LL;
	   }
	   break;
	 }
       }
       break;
     case STATUS_EXEC: /* simulate from stage15 to stage0, from col=3 to col=0 */
       emax5[cid].cycles_exec_part++;
       for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	 if (emax5[cid].unit1_exec | emax5[cid].unit2_exec) /* exec not finished */
	   sync = 0; /* not finished */
	 i = emax5[cid].fsm[j].row_count;
	 if (i < EMAX_DEPTH) {
	   switch ((emax5[cid].fsm[j].lmmc[i].v<<3)|(emax5[cid].fsm[j].lmmc[i].rw<<2)|(emax5[cid].fsm[j].lmmc[i].f<<1)|(emax5[cid].fsm[j].lmmc[i].p)) {
	     /* v | rw | f | p */
	   case  9: /* lmp */
	     if (emax5[cid].fsm[j].lmmo[i].v
	      && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
	      && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
	      && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top) {
	       if (trace)
		 printf("%03.3d:siml_emax5: pload row=%d col=%d top=%08.8x_%08.8x found in LMM\n",
			tid, i, j, (Uint)(emax5[cid].fsm[j].lmmc[i].top>>32), (Uint)emax5[cid].fsm[j].lmmc[i].top);
	       flag = 0; /* skip pload */
	     }
	     else
	       flag = 1; /* pload */
	     break;
	   case 13: /* lmd */
	     if (emax5[cid].fsm[j].lmmd[i]) /* dirty exist */
	       flag = 1; /* pdrain */
	     else
	       flag = 0; /* skip pdrain */
	     break;
	   default:
	     flag = 0; /* skip pdrain/pload */
	     break;
	   }

	   /* emax5[cid].fsm[j].lmmc[i].rw=0:pload  */
	   /* emax5[cid].fsm[j].lmmc[i].rw=1:pdrain */
	   if (flag) {
	     Uint lmm_nreq;
	     switch (emax5[cid].fsm[j].memif_status) {
	     case MEMIF_AREQ:
	       emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	       emax5[cid].fsm[j].ardyc = 0; /* LMM addr-request(read/write) counter */
	       if (emax5[cid].fsm[j].lmmc[i].rw == 0) { /* pload */
		 emax5[cid].fsm[j].raddr = emax5[cid].fsm[j].lmmc[i].top;
		 emax5[cid].fsm[j].rlen  = emax5[cid].fsm[j].lmmc[i].len;
	       }
	       else { /* pdrain */
		 emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read) counter */
		 emax5[cid].fsm[j].waddr = emax5[cid].fsm[j].lmmc[i].top;
		 emax5[cid].fsm[j].wlen  = emax5[cid].fsm[j].lmmc[i].len;
	       }
	       break;
	     case MEMIF_DREQ:
	       lmm_nreq = emax5[cid].fsm[j].lmmc[i].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	       if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		 Ull ofs;
		 emax5[cid].fsm[j].row_select = 1LL<<i;
		 emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
		 if (emax5[cid].fsm[j].lmmc[i].rw == 0) { /* pload */
		   emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
 #if 1
		   /*** GATHER ************/
		   switch (emax5[cid].fsm[j].lmmc[i].blk) {
		   case 0: /* inf */
		     ofs =        (       emax5[cid].fsm[j].lmmc[i].top                                         ) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc   )*UNIT_WIDTH;
		     break;
		   case 1: /* 16 */
		     ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%16)*UNIT_WIDTH;
		     break;
		   case 2: /* 32 */
		     ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%32)*UNIT_WIDTH;
		     break;
		   case 3: /* 64 */
		     ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%64)*UNIT_WIDTH;
		     break;
		   }
 #endif
		   for (k=0; k<UNIT_WIDTH; k++) {
		     emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + ofs + sizeof(Ull)*k);
		     if (trace) {
		       printf("%03.3d:siml_emax5: pload row=%d col=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			      tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa,
			      k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].ardyc, lmm_nreq);
		     }
		   }
		 }
		 else { /* pdrain */
		   emax5[cid].fsm[j].lmra = emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
		   if (trace) {
		     printf("%03.3d:siml_emax5: pdrain row=%d col=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			    tid, i, j, (Uint)(emax5[cid].fsm[j].lmra>>32), (Uint)emax5[cid].fsm[j].lmra, emax5[cid].fsm[j].ardyc, lmm_nreq);
		   }
		 }
		 emax5[cid].fsm[j].ardyc++;
	       }
	       else {
		 if (emax5[cid].fsm[j].lmmc[i].rw == 0) { /* pload */
		   emax5[cid].fsm[j].lmmo[i].v   = emax5[cid].fsm[j].lmmc[i].v;
		   emax5[cid].fsm[j].lmmo[i].rw  = emax5[cid].fsm[j].lmmc[i].rw;
		   emax5[cid].fsm[j].lmmo[i].f   = emax5[cid].fsm[j].lmmc[i].f;
		   emax5[cid].fsm[j].lmmo[i].p   = emax5[cid].fsm[j].lmmc[i].p;
		   emax5[cid].fsm[j].lmmo[i].blk = emax5[cid].fsm[j].lmmc[i].blk;
		   emax5[cid].fsm[j].lmmo[i].len = emax5[cid].fsm[j].lmmc[i].len;
		   emax5[cid].fsm[j].lmmo[i].top = emax5[cid].fsm[j].lmmc[i].top;
		   emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		   emax5[cid].fsm[j].row_count++;
		   emax5[cid].fsm[j].row_select   = 0LL;
		   emax5[cid].fsm[j].row_lmm_en   = 0LL;
		 }
		 else { /* pdrain */
		   emax5[cid].fsm[j].row_lmm_en = 0LL; /* row_selectは残りrrdyのために維持 */
		 }
	       }
	       if (emax5[cid].fsm[j].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		 if (emax5[cid].fsm[j].lmmc[i].rw == 1) { /* pdrain */
		   if (unit[cid][i][j].rrdy) { /* ack from lmm */
		     for (k=0; k<UNIT_WIDTH; k++)
		       *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k];
		     if (trace) {
		       printf("%03.3d:siml_emax5: pdrain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			      tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
		     }
		     emax5[cid].fsm[j].rrdyc++;
		   }
		 }
	       }
	       else {
		 if (emax5[cid].fsm[j].lmmc[i].rw == 1) { /* pdrain */
		   emax5[cid].fsm[j].lmmd[i] = 0;
		   emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		   emax5[cid].fsm[j].row_count++;
		   emax5[cid].fsm[j].row_select   = 0LL;
		   emax5[cid].fsm[j].row_lmm_en   = 0LL;
		 }
	       }
	       break;
	     }
	   }
	   else {
	     emax5[cid].fsm[j].row_count++;
	   }
	   sync = 0; /* not finished */
	 }
       }
       if (sync) { /* all FSM_EXEC finished */
	 emax5[cid].status = STATUS_TERM;
	 for (j=0; j<EMAX_WIDTH; j++) {
	   emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	   emax5[cid].fsm[j].row_count    = 0;
	   emax5[cid].fsm[j].row_select   = 0LL;
	   emax5[cid].fsm[j].row_lmm_en   = 0LL;
	 }
       }
       break;
     case STATUS_TERM:
       emax5[cid].v = 0; /* unlock */
       emax5[cid].status = STATUS_IDLE;
       for (j=0; j<EMAX_WIDTH; j++) {
	 emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	 emax5[cid].fsm[j].row_count    = 0;
	 emax5[cid].fsm[j].row_select   = 0LL;
       }
       printf("%03.3d:siml_emax5: term c=%d i=%d d=%d l=%d r=%d e=%d z=%d t=%d\n",
	      cid,
	      emax5[cid].cycles_conf_part, emax5[cid].cycles_lmmi_part, emax5[cid].cycles_drain_part, emax5[cid].cycles_load_part,
	      emax5[cid].cycles_regv_part, emax5[cid].cycles_exec_part, emax5[cid].cycles_term_part,  emax5[cid].cycles_trans_part);
       emax5[cid].cycles_conf  += emax5[cid].cycles_conf_part;
       emax5[cid].cycles_lmmi  += emax5[cid].cycles_lmmi_part;
       emax5[cid].cycles_drain += emax5[cid].cycles_drain_part;
       emax5[cid].cycles_load  += emax5[cid].cycles_load_part;
       emax5[cid].cycles_regv  += emax5[cid].cycles_regv_part;
       emax5[cid].cycles_exec  += emax5[cid].cycles_exec_part;
       emax5[cid].cycles_term  += emax5[cid].cycles_term_part;
       emax5[cid].cycles_trans += emax5[cid].cycles_trans_part;
       return (0); /* EMAX5 terminated */
     }
     /*******************************************************/
     /******************* FSM siml end **********************/
     /*******************************************************/
   }
   return (2); /* EMAX5 busy */
 }

 siml_unit_bus1(cid, i) Uint cid, i; /* 演算器入力までを計算 */
 {
   int j, k, s;
   int pi = (i+EMAX_DEPTH-1)%EMAX_DEPTH;

   /* regv(br,ea[01][bo]r) -> c,t,ex[123],ea[bo],ea[01][bo] */
   for (j=0; j<EMAX_WIDTH; j++) { /* 0:br0_0, 1:br0_1, ... 15:3_3 */
     s = unit[cid][i][j].conf.cdw1.cs0;    unit[cid][i][j].c[0] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;
     s = unit[cid][i][j].conf.cdw1.cs1;    unit[cid][i][j].c[1] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;
     s = unit[cid][i][j].conf.cdw1.cs2;    unit[cid][i][j].c[2] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;
     s = unit[cid][i][j].conf.cdw1.cs3;    unit[cid][i][j].c[3] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;

     s = unit[cid][i][j].conf.cdw2.ts0;    unit[cid][i][j].t[0] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
     s = unit[cid][i][j].conf.cdw2.ts1;    unit[cid][i][j].t[1] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
     s = unit[cid][i][j].conf.cdw2.ts2;    unit[cid][i][j].t[2] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
     s = unit[cid][i][j].conf.cdw2.ts3;    unit[cid][i][j].t[3] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];

     s = unit[cid][i][j].conf.cdw0.ex1brs; unit[cid][i][j].ex1  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
     s = unit[cid][i][j].conf.cdw0.ex2brs; unit[cid][i][j].ex2  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
     s = unit[cid][i][j].conf.cdw0.ex3brs; unit[cid][i][j].ex3  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];

     s = unit[cid][i][j].conf.cdw1.eabbrs; unit[cid][i][j].eab  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
     s = unit[cid][i][j].conf.cdw1.eaobrs; unit[cid][i][j].eao  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];

     s = unit[cid][i][j].conf.cdw1.ea0bs;  unit[cid][i][j].ea0b = (s==0)?unit[cid][i][j].eab:unit[cid][i][j].regv.ea0br;
     s = unit[cid][i][j].conf.cdw1.ea0os;  unit[cid][i][j].ea0o = (s==0)?unit[cid][i][j].eao:unit[cid][i][j].regv.ea0or;
     switch (unit[cid][i][j].conf.cdw1.ea0msk) {
     case MSK_B0: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o     & 0x000000ffLL; break;
     case MSK_B1: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>> 8 & 0x000000ffLL; break;
     case MSK_B2: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>16 & 0x000000ffLL; break;
     case MSK_B3: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>24 & 0x000000ffLL; break;
     case MSK_B4: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>32 & 0x000000ffLL; break;
     case MSK_B5: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>40 & 0x000000ffLL; break;
     case MSK_B6: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>48 & 0x000000ffLL; break;
     case MSK_B7: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>56 & 0x000000ffLL; break;
     case MSK_H0: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o     & 0x0000ffffLL; break;
     case MSK_H1: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>16 & 0x0000ffffLL; break;
     case MSK_H2: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>32 & 0x0000ffffLL; break;
     case MSK_H3: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>48 & 0x0000ffffLL; break;
     case MSK_W0: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o     & 0xffffffffLL; break;
     case MSK_W1: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>32 & 0xffffffffLL; break;
     case MSK_D0: break;
     }
     s = unit[cid][i][j].conf.cdw1.ea1bs;  unit[cid][i][j].ea1b = (s==0)?unit[cid][i][j].eab:unit[cid][i][j].regv.ea1br;
     s = unit[cid][i][j].conf.cdw1.ea1os;  unit[cid][i][j].ea1o = (s==0)?unit[cid][i][j].eao:unit[cid][i][j].regv.ea1or;
     switch (unit[cid][i][j].conf.cdw1.ea1msk) {
     case MSK_B0: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o     & 0x000000ffLL; break;
     case MSK_B1: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>> 8 & 0x000000ffLL; break;
     case MSK_B2: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>16 & 0x000000ffLL; break;
     case MSK_B3: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>24 & 0x000000ffLL; break;
     case MSK_B4: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>32 & 0x000000ffLL; break;
     case MSK_B5: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>40 & 0x000000ffLL; break;
     case MSK_B6: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>48 & 0x000000ffLL; break;
     case MSK_B7: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>56 & 0x000000ffLL; break;
     case MSK_H0: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o     & 0x0000ffffLL; break;
     case MSK_H1: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>16 & 0x0000ffffLL; break;
     case MSK_H2: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>32 & 0x0000ffffLL; break;
     case MSK_H3: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>48 & 0x0000ffffLL; break;
     case MSK_W0: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o     & 0xffffffffLL; break;
     case MSK_W1: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>32 & 0xffffffffLL; break;
     case MSK_D0: break;
     }
   }
 }

 siml_unit_bus2(cid, i) Uint cid, i; /* TR入力を計算 */
 {
   int j, k, s;

   /* fsm.lmw[ad],lmra <-> unit.lmw[ad],lmra */
   for (j=0; j<EMAX_WIDTH; j++) {
     unit[cid][i][j].lmen = emax5[cid].fsm[j].row_lmm_en>>i&1;
     unit[cid][i][j].lmwa = emax5[cid].fsm[j].lmwa;
     unit[cid][i][j].lmwd[0] = emax5[cid].fsm[j].lmwd[0];
     unit[cid][i][j].lmwd[1] = emax5[cid].fsm[j].lmwd[1];
     unit[cid][i][j].lmwd[2] = emax5[cid].fsm[j].lmwd[2];
     unit[cid][i][j].lmwd[3] = emax5[cid].fsm[j].lmwd[3];
     unit[cid][i][j].lmra = emax5[cid].fsm[j].lmra;
   }
   /* lmw[ad] -> (lmlo <- lmri) */
   for (j=0; j<EMAX_WIDTH; j++) { /* s=0:lmwd, s=1:lmri */
     s = unit[cid][i][j].conf.cdw2.lmlsa;  unit[cid][i][j].lmloa   = (s==0)?unit[cid][i][j].lmwa   :unit[cid][i][j].lmria;
     s = unit[cid][i][j].conf.cdw2.lmls0;  unit[cid][i][j].lmlo[0] = (s==0)?unit[cid][i][j].lmwd[0]:unit[cid][i][j].lmri[0];
     s = unit[cid][i][j].conf.cdw2.lmls1;  unit[cid][i][j].lmlo[1] = (s==0)?unit[cid][i][j].lmwd[1]:unit[cid][i][j].lmri[1];
     s = unit[cid][i][j].conf.cdw2.lmls2;  unit[cid][i][j].lmlo[2] = (s==0)?unit[cid][i][j].lmwd[2]:unit[cid][i][j].lmri[2];
     s = unit[cid][i][j].conf.cdw2.lmls3;  unit[cid][i][j].lmlo[3] = (s==0)?unit[cid][i][j].lmwd[3]:unit[cid][i][j].lmri[3];
     if (j<EMAX_WIDTH-1) { /* 左へ伝搬 */
       unit[cid][i][j+1].lmria   = unit[cid][i][j].lmloa;
       unit[cid][i][j+1].lmri[0] = unit[cid][i][j].lmlo[0];
       unit[cid][i][j+1].lmri[1] = unit[cid][i][j].lmlo[1];
       unit[cid][i][j+1].lmri[2] = unit[cid][i][j].lmlo[2];
       unit[cid][i][j+1].lmri[3] = unit[cid][i][j].lmlo[3];
     }
   }
   /* lmw[ad] -> (lmli -> lmro) */
   for (j=EMAX_WIDTH-1; j>=0; j--) { /* s=0:lmwd, s=1:lmli */
     s = unit[cid][i][j].conf.cdw2.lmrsa;  unit[cid][i][j].lmroa   = (s==0)?unit[cid][i][j].lmwa   :unit[cid][i][j].lmlia;
     s = unit[cid][i][j].conf.cdw2.lmrs0;  unit[cid][i][j].lmro[0] = (s==0)?unit[cid][i][j].lmwd[0]:unit[cid][i][j].lmli[0];
     s = unit[cid][i][j].conf.cdw2.lmrs1;  unit[cid][i][j].lmro[1] = (s==0)?unit[cid][i][j].lmwd[1]:unit[cid][i][j].lmli[1];
     s = unit[cid][i][j].conf.cdw2.lmrs2;  unit[cid][i][j].lmro[2] = (s==0)?unit[cid][i][j].lmwd[2]:unit[cid][i][j].lmli[2];
     s = unit[cid][i][j].conf.cdw2.lmrs3;  unit[cid][i][j].lmro[3] = (s==0)?unit[cid][i][j].lmwd[3]:unit[cid][i][j].lmli[3];
     if (j>0) { /* 右へ伝搬 */
       unit[cid][i][j-1].lmlia   = unit[cid][i][j].lmroa;
       unit[cid][i][j-1].lmli[0] = unit[cid][i][j].lmro[0];
       unit[cid][i][j-1].lmli[1] = unit[cid][i][j].lmro[1];
       unit[cid][i][j-1].lmli[2] = unit[cid][i][j].lmro[2];
       unit[cid][i][j-1].lmli[3] = unit[cid][i][j].lmro[3];
     }
   }
 }

 siml_unit_cex(cid, i, j) Uint cid, i, j; /* reg更新がないので最初に実行 */
 {
   Uint op_cx;
   Ull c3, c2, c1, c0;
   Ushort pattern;
   Ull ex;

   /* c -> cexdr */
   switch (emax5[cid].status) {
   case STATUS_IDLE:
   case STATUS_CONF:
   case STATUS_LMMI:
   case STATUS_DRAIN:
   case STATUS_LOAD:
   case STATUS_REGV:
   case STATUS_START:
     return (0);
   case STATUS_EXEC:
     if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active */
       unit[cid][i][j].cexdr = 0; /* always non-exec */
     else { /* active */
       op_cx   = unit[cid][i][j].conf.cdw1.cop;
       c0      = unit[cid][i][j].c[0];
       c1      = unit[cid][i][j].c[1];
       c2      = unit[cid][i][j].c[2];
       c3      = unit[cid][i][j].c[3];
       pattern = unit[cid][i][j].conf.cdw1.cex_tab;
       cex(op_cx, c3, c2, c1, c0, pattern, &ex);
       unit[cid][i][j].cexdr = ex;
     }
     return (0);
   case STATUS_TERM:
     return (0);
   }
 }

 siml_unit_exe(cid, i, j) Uint cid, i, j; /* 全bus計算後にreg更新 */
 {
   Uint op_ex1, op_ex2, op_ex3;
   Ull  r1, r2, r3, r4, r5;
   Uint exp1, exp2, exp3;
   Ull  d;

   /* ex[123] -> exdr */
   switch (emax5[cid].status) {
   case STATUS_IDLE:
   case STATUS_CONF:
   case STATUS_LMMI:
   case STATUS_DRAIN:
   case STATUS_LOAD:
   case STATUS_REGV:
   case STATUS_START:
     return (0);
   case STATUS_EXEC:
     if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active */
       unit[cid][i][j].exdr = 0LL; /* always non-exec */
     else { /* active */
       op_ex1 = unit[cid][i][j].conf.cdw0.op1;
       op_ex2 = unit[cid][i][j].conf.cdw0.op2;
       op_ex3 = unit[cid][i][j].conf.cdw0.op3;
       r1     = (!unit[cid][i][j].conf.cdw0.ex1s || !unit[cid][i][j].one_shot)
	      ? unit[cid][i][j].ex1 : unit[cid][i][j].exdr; /* self_loop */
       r2     = unit[cid][i][j].ex2;
       r3     = unit[cid][i][j].ex3;
       r4     = unit[cid][i][j].conf.cdw0.e2is==0 ? unit[cid][i][j].conf.cdw0.e2imm
	      : unit[cid][i][j].conf.cdw0.e2is==1 ? unit[cid][i][j].ex2
	      :                                     unit[cid][i][j].ex3;
       r5     = unit[cid][i][j].conf.cdw0.e3is==0 ? unit[cid][i][j].conf.cdw0.e3imm
	      :                                     unit[cid][i][j].ex3;
       exp1   = unit[cid][i][j].conf.cdw0.ex1exp;
       exp2   = unit[cid][i][j].conf.cdw0.ex2exp;
       exp3   = unit[cid][i][j].conf.cdw0.ex3exp;
       exe(op_ex1, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5, &d);
       unit[cid][i][j].exdr = d;
     }
     return (0);
   case STATUS_TERM:
     return (0);
   }
 }

 siml_unit_eag(cid, i, j) Uint cid, i, j; /* 全bus計算後にreg更新 */
 {
   Ull base0, offs0;
   Ull base1, offs1;

   /* ea[01][bo] -> ea[01]dr,ma */
   switch (emax5[cid].status) {
   case STATUS_IDLE:
   case STATUS_CONF:
   case STATUS_LMMI:
     return (0);
   case STATUS_DRAIN: /* fsm drain */
     if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
       unit[cid][i][j].lmm.en1 = 1;
       unit[cid][i][j].lmm.rw1 = 0; /* read */
       unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = emax5[cid].fsm[j].lmra;
       unit[cid][i][j].lmm.mb1 = 0;
     }
     else
       unit[cid][i][j].lmm.en1 = 0;
     return (0);
   case STATUS_LOAD: /* fsm pload */
     if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
       unit[cid][i][j].lmm.en0 = 1;
       unit[cid][i][j].lmm.rw0 = 1; /* write */
       unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = emax5[cid].fsm[j].lmwa;
       unit[cid][i][j].lmm.mb0 = 0;
     }
     else
       unit[cid][i][j].lmm.en0 = 0;
     return (0);
   case STATUS_REGV:
   case STATUS_START:
     return (0);
   case STATUS_EXEC:
     /* fsm drain */
     if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_DRAIN) {
       if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
	 unit[cid][i][j].lmm.en1 = 1;
	 unit[cid][i][j].lmm.rw1 = 0; /* read */
	 unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = emax5[cid].fsm[j].lmra;
	 unit[cid][i][j].lmm.mb1 = 0;
       }
       else
	 unit[cid][i][j].lmm.en1 = 0;
     }
     else if (unit[cid][i][j].conf.cdw1.ea1op) { /* normal load */
       if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
	 base1 = (!unit[cid][i][j].conf.cdw1.ea1bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
	 offs1 = (!unit[cid][i][j].conf.cdw1.ea1bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
	 eag(&unit[cid][i][j].ea1dr, base1, offs1, unit[cid][i][j].conf.cdw1.ea1msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
	 unit[cid][i][j].lmm.en1 = 1;
	 unit[cid][i][j].lmm.rw1 = 0; /* read */
	 unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr & ~(sizeof(Ull)*UNIT_WIDTH-1);
	 unit[cid][i][j].lmm.mb1 = unit[cid][i][j].ea1dr &  (sizeof(Ull)*UNIT_WIDTH-1);
	 unit[cid][i][j].axwa    = unit[cid][i][j].ea1dr;
       }
       else /* inactive */
	 unit[cid][i][j].lmm.en1 = 0;
     }
     else { /* inactive */
       unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = 0LL; /* always non-exec */
       unit[cid][i][j].lmm.mb1 = 0LL;
     }

     /* fsm pload */
     if (unit[cid][i][j].conf.cdw1.ea0op == OP_IM_PREF) {
       if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
	 unit[cid][i][j].lmm.en0 = 1;
	 unit[cid][i][j].lmm.rw0 = 1; /* write */
	 unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = emax5[cid].fsm[j].lmwa;
	 unit[cid][i][j].lmm.mb0 = 0;
       }
       else
	 unit[cid][i][j].lmm.en0 = 0;
     }
     else if (unit[cid][i][j].conf.cdw1.ea0op) { /* normal load/store */
       if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
	 base0 = (!unit[cid][i][j].conf.cdw1.ea0bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
	 offs0 = (!unit[cid][i][j].conf.cdw1.ea0bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
	 eag(&unit[cid][i][j].ea0dr, base0, offs0, unit[cid][i][j].conf.cdw1.ea0msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
	 unit[cid][i][j].lmm.en0 = 1;
	 unit[cid][i][j].lmm.rw0 = (unit[cid][i][j].conf.cdw1.ea0op & 0x10)!=0; /* read/write */
	 unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr & ~(sizeof(Ull)*UNIT_WIDTH-1);
	 unit[cid][i][j].lmm.mb0 = unit[cid][i][j].ea0dr &  (sizeof(Ull)*UNIT_WIDTH-1);
	 unit[cid][i][j].axra    = unit[cid][i][j].ea0dr;
       }
       else /* inactive */
	 unit[cid][i][j].lmm.en0 = 0;
     }
     else /* inactive */
       unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = 0LL; /* always non-exec */
     return (0);
   case STATUS_TERM:
     return (0);
   }
 }

 siml_unit_trg(cid, i, j) Uint cid, i, j; /* 全bus計算後にtr更新 */
 {
   Ull a;
   int k;

   /* update: exdr,t,lmwd,lmlio/lmrio -> tr,mw */
   switch (emax5[cid].status) {
   case STATUS_IDLE:
     return (0);
   case STATUS_CONF:
     if (emax5[cid].fsm[j].row_select & (1LL<<i)) {
       for (k=0; k<UNIT_WIDTH; k++)
	 *((Ull*)&unit[cid][i][j].conf+k) = emax5[cid].fsm[j].lmwd[k];
     }
     return (0);
   case STATUS_LMMI:
     return (0);
   case STATUS_DRAIN:
     return (0);
   case STATUS_LOAD:
     if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
       for (k=0; k<UNIT_WIDTH; k++) {
	 unit[cid][i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	 unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k] = emax5[cid].fsm[j].lmwd[k]; /* align不要 */
       }
     }
     return (0);
   case STATUS_REGV:
     if (emax5[cid].fsm[j].row_select & (1LL<<i)) {
       for (k=0; k<UNIT_WIDTH; k++) {
	 switch (emax5[cid].fsm[j].lmwa) {
	 case 0: /* lower */
	   *((Ull*)&unit[cid][i][j].regv+0+k) = emax5[cid].fsm[j].lmwd[k];
	   break;
	 case 1: /* upper */
	   *((Ull*)&unit[cid][i][j].regv+4+k) = emax5[cid].fsm[j].lmwd[k];
	   break;
	 }
       }
     }
     return (0);
   case STATUS_START:
     return (0);
   case STATUS_EXEC:
     /* fsm pload */
     if (unit[cid][i][j].conf.cdw1.ea0op == OP_IM_PREF) {
       if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
	 for (k=0; k<UNIT_WIDTH; k++) {
	   unit[cid][i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	   unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k] = emax5[cid].fsm[j].lmwd[k]; /* align不要 */
	 }
       }
     }
     else if (unit[cid][i][j].conf.cdw1.ea0op & 0x10) { /* normal store */
       if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
	 a = unit[cid][i][j].lmm.ma0 % LMEM_SIZE; /* main-mamory-address -> lmm-address */
	 /* trs[3-0]: 0:exdr, 1:exdr0, 2:ts0, 3:lmli0, 4:lmwd0, 5:lmri0 */
	 unit[cid][i][j].tr[0] = unit[cid][i][j].conf.cdw2.trs0==0 ? unit[cid][i][j].exdr /* tr[3-0]はalign不要 */
			       : unit[cid][i][j].conf.cdw2.trs0==1 ? unit[cid][i][0].exdr
			       : unit[cid][i][j].conf.cdw2.trs0==2 ? unit[cid][i][j].t[0]
			       : unit[cid][i][j].conf.cdw2.trs0==3 ? unit[cid][i][j].lmli[0]
			       : unit[cid][i][j].conf.cdw2.trs0==4 ? unit[cid][i][j].lmwd[0]
			       : unit[cid][i][j].conf.cdw2.trs0==5 ? unit[cid][i][j].lmri[0]
			       :                                     0LL;
	 unit[cid][i][j].tr[1] = unit[cid][i][j].conf.cdw2.trs1==0 ? unit[cid][i][j].exdr
			       : unit[cid][i][j].conf.cdw2.trs1==1 ? unit[cid][i][1].exdr
			       : unit[cid][i][j].conf.cdw2.trs1==2 ? unit[cid][i][j].t[1]
			       : unit[cid][i][j].conf.cdw2.trs1==3 ? unit[cid][i][j].lmli[1]
			       : unit[cid][i][j].conf.cdw2.trs1==4 ? unit[cid][i][j].lmwd[1]
			       : unit[cid][i][j].conf.cdw2.trs1==5 ? unit[cid][i][j].lmri[1]
			       :                                     0LL;
	 unit[cid][i][j].tr[2] = unit[cid][i][j].conf.cdw2.trs2==0 ? unit[cid][i][j].exdr
			       : unit[cid][i][j].conf.cdw2.trs2==1 ? unit[cid][i][2].exdr
			       : unit[cid][i][j].conf.cdw2.trs2==2 ? unit[cid][i][j].t[2]
			       : unit[cid][i][j].conf.cdw2.trs2==3 ? unit[cid][i][j].lmli[2]
			       : unit[cid][i][j].conf.cdw2.trs2==4 ? unit[cid][i][j].lmwd[2]
			       : unit[cid][i][j].conf.cdw2.trs2==5 ? unit[cid][i][j].lmri[2]
			       :                                     0LL;
	 unit[cid][i][j].tr[3] = unit[cid][i][j].conf.cdw2.trs3==0 ? unit[cid][i][j].exdr
			       : unit[cid][i][j].conf.cdw2.trs3==1 ? unit[cid][i][3].exdr
			       : unit[cid][i][j].conf.cdw2.trs3==2 ? unit[cid][i][j].t[3]
			       : unit[cid][i][j].conf.cdw2.trs3==3 ? unit[cid][i][j].lmli[3]
			       : unit[cid][i][j].conf.cdw2.trs3==4 ? unit[cid][i][j].lmwd[3]
			       : unit[cid][i][j].conf.cdw2.trs3==5 ? unit[cid][i][j].lmri[3]
			       :                                     0LL;
	 switch (unit[cid][i][j].conf.cdw1.ea0op) {
	 case OP_STR:
	 case OP_STBF:
	   for (k=0; k<UNIT_WIDTH; k++) {
	     unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? 0xffffffffffffffffLL : 0LL; /* mask */
	     unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k]; /* align不要 */
	   }
	   break;
	 case OP_STWR:
	   for (k=0; k<UNIT_WIDTH; k++) {
	     unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (0x00000000ffffffffLL<<(a & sizeof(int))*8) : 0LL; /* mask */
	     unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & sizeof(int))*8       ; /* align必要 */
	   }
	   break;
	 case OP_STHR:
	   for (k=0; k<UNIT_WIDTH; k++) {
	     unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (0x000000000000ffffLL<<(a & (sizeof(int)|sizeof(short)))*8) : 0LL; /* mask */
	     unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & (sizeof(int)|sizeof(short)))*8       ; /* align必要 */
	   }
	   break;
	 case OP_STBR:
	   for (k=0; k<UNIT_WIDTH; k++) {
	     unit[cid][i][j].lmm.mm0[k] = (a/sizeof(Ull) & (UNIT_WIDTH-1))==k ? (0x00000000000000ffLL<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8) : 0LL; /* mask */
	     unit[cid][i][j].lmm.mw0[k] =                                       unit[cid][i][j].tr[k]<<(a & (sizeof(int)|sizeof(short)|sizeof(char)))*8       ; /* align必要 */
	   }
	   break;
	 case OP_STRQ:
	 case OP_STBFQ:
	 case OP_TR:
	 case OP_IM_PREF:
	   for (k=0; k<UNIT_WIDTH; k++) {
	     unit[cid][i][j].lmm.mm0[k] = 0xffffffffffffffffLL; /* mask */
	     unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k];
	   }
	   break;
	 }
       }
     }
     unit[cid][i][j].one_shot = 1; /* set one_shot here */
     return (0);
   case STATUS_TERM:
     return (0);
   }
 }

 siml_unit_lmm(cid,  i, j) Uint cid, i, j; /* 旧TR/旧EADRを使ったLMM動作 & TR更新 */
 {
   Ull a0, a1, a0al, a1al, d;
   int k;

   /* write:  cexdr,mw,ma                                -> LMM                      */
   /* read:   cexdr,exdr,mw/tr,ma/ea[01]dr,LMM -> mr[01] -> br,lmrd                  */
   /*        |         |         |         |         |         |         |         | */
   /* clk ___/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/~~~~\____/ */
   /* en  ____/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\___________________ */
   /* rw  _______read___/~~~~~~write~~~~~~~~\______read_____________________________ */
   /* ma  -----<   A0  ><   A1   ><   A2   ><   A3   ><   A4   >-------------------- */
   /* mw  --------------<   W1   ><   W2   >---------------------------------------- */
   /* mr  --------------<   R0   >--------------------<   R3   ><   R4   >---------- */

   a0 = unit[cid][i][j].lmm.ma0 % LMEM_SIZE; /* should be aligned by fsm */
   a1 = unit[cid][i][j].lmm.ma1 % LMEM_SIZE; /* should be aligned by fsm */
   a0al = a0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */
   a1al = a1 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */

   switch (emax5[cid].status) {
   case STATUS_IDLE:
   case STATUS_CONF:
   case STATUS_LMMI:
     return (0);
   case STATUS_DRAIN:
     if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
       for (k=0; k<UNIT_WIDTH; k++)
	 unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
     }
     return (0);
   case STATUS_LOAD:
     if (unit[cid][i][j].lmm.en0 && unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
       for (k=0; k<UNIT_WIDTH; k++)
	 *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
     }
     return (0);
   case STATUS_REGV:
     return (0);
   case STATUS_START:
     return (0);
   case STATUS_EXEC:
     /* store mw    -> lmm[] */
     /* load  lmm[] -> mr    */
     if (unit[cid][i][j].conf.cdw1.ea1op == OP_IM_DRAIN) {
       if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
	 for (k=0; k<UNIT_WIDTH; k++)
	   unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
       }
     }
     else if (unit[cid][i][j].conf.cdw1.ea1op) { /* normal load */
       if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
	 for (k=0; k<UNIT_WIDTH; k++)
	   unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a1al]+k);
       }
     }
     
     if (unit[cid][i][j].conf.cdw1.ea0op == OP_IM_PREF) {
       if (unit[cid][i][j].lmm.en0 &&  unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
	 for (k=0; k<UNIT_WIDTH; k++)
	   *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
       }
     }
     else if (unit[cid][i][j].conf.cdw1.ea0op) { /* normal load/store */
       if (unit[cid][i][j].lmm.en0 && !unit[cid][i][j].lmm.rw0) { /* lmm read enabled */
	 for (k=0; k<UNIT_WIDTH; k++)
	   unit[cid][i][j].lmm.mr0[k] = *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k);
       }
       if (unit[cid][i][j].lmm.en0 &&  unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
	 for (k=0; k<UNIT_WIDTH; k++)
	   *((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) = (*((Ull*)&unit[cid][i][j].lmm.m[a0al]+k) & ~unit[cid][i][j].lmm.mm0[k]) | (unit[cid][i][j].lmm.mw0[k] & unit[cid][i][j].lmm.mm0[k]);
       }
     }

     /* load mr -> br0 */
     switch (unit[cid][i][j].conf.cdw2.brs0) {
     case 0:                                                          break; /* off */
     case 1: unit[cid][i][j].regv.br[0] = unit[cid][i][j].lmm.mr1[0]; break; /* 1:mr10 align不要 */
     case 2: unit[cid][i][j].regv.br[0] = unit[cid][i][j].tr[0];      break; /* 2:tr0  align不要 */
     case 3:                                                                 /* 3:mr0  align必要 */
       unit[cid][i][j].mr0mux = (a0/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr0[3-0] -> mr0d */
       unit[cid][i][j].mr0d   = unit[cid][i][j].lmm.mr0[unit[cid][i][j].mr0mux];
       switch (unit[cid][i][j].conf.cdw1.ea0op) {
       case OP_LDR:
       case OP_LDBF:  unit[cid][i][j].regv.br[0] =                unit[cid][i][j].mr0d;                                                                                 break;
       case OP_LDWR:  unit[cid][i][j].regv.br[0] = (Sll)   (int)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
       case OP_LDUWR: unit[cid][i][j].regv.br[0] = (Ull)  (Uint)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
       case OP_LDHR:  unit[cid][i][j].regv.br[0] = (Sll) (short)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
       case OP_LDUHR: unit[cid][i][j].regv.br[0] = (Ull)(Ushort)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
       case OP_LDBR:  unit[cid][i][j].regv.br[0] = (Sll)  (char)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
       case OP_LDUBR: unit[cid][i][j].regv.br[0] = (Ull) (Uchar)((unit[cid][i][j].mr0d >> ((a0 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
       }
     }
     /* load mr -> br1 */
     switch (unit[cid][i][j].conf.cdw2.brs1) {
     case 0:                                                          break; /* off */
     case 1: unit[cid][i][j].regv.br[1] = unit[cid][i][j].lmm.mr1[1]; break; /* 1:mr11 align不要 */
     case 2: unit[cid][i][j].regv.br[1] = unit[cid][i][j].tr[1];      break; /* 2:tr1  align不要 */
     case 3:                                                                 /* 3:mr1  align必要 */
       unit[cid][i][j].mr1mux = (a1/sizeof(Ull) & (UNIT_WIDTH-1)); /* mr1[3-0] -> mr0d */
       unit[cid][i][j].mr1d   = unit[cid][i][j].lmm.mr1[unit[cid][i][j].mr1mux];
       switch (unit[cid][i][j].conf.cdw1.ea1op) {
       case OP_LDR:
       case OP_LDBF:  unit[cid][i][j].regv.br[1] =                unit[cid][i][j].mr1d;                                                                                 break;
       case OP_LDWR:  unit[cid][i][j].regv.br[1] = (Sll)   (int)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
       case OP_LDUWR: unit[cid][i][j].regv.br[1] = (Ull)  (Uint)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)                           ))*8)) & 0x00000000ffffffffLL); break;
       case OP_LDHR:  unit[cid][i][j].regv.br[1] = (Sll) (short)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
       case OP_LDUHR: unit[cid][i][j].regv.br[1] = (Ull)(Ushort)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)             ))*8)) & 0x000000000000ffffLL); break;
       case OP_LDBR:  unit[cid][i][j].regv.br[1] = (Sll)  (char)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
       case OP_LDUBR: unit[cid][i][j].regv.br[1] = (Ull) (Uchar)((unit[cid][i][j].mr1d >> ((a1 & (sizeof(int)|sizeof(short)|sizeof(char)))*8)) & 0x00000000000000ffLL); break;
       }
     }
     /* load mr -> br2 */
     switch (unit[cid][i][j].conf.cdw2.brs2) {
     case 0:                                                          break; /* off */
     case 1: unit[cid][i][j].regv.br[2] = unit[cid][i][j].lmm.mr1[2]; break; /* 1:mr12 align不要 */
     case 2: unit[cid][i][j].regv.br[2] = unit[cid][i][j].tr[2];      break; /* 2:tr2  align不要 */
     case 3: unit[cid][i][j].regv.br[2] = unit[cid][i][j].exdr;       break; /* 3:exdr align不要 */
     }
     /* load mr -> br3 */
     switch (unit[cid][i][j].conf.cdw2.brs3) {
     case 0:                                                          break; /* off */
     case 1: unit[cid][i][j].regv.br[3] = unit[cid][i][j].lmm.mr1[3]; break; /* 1:mr13 align不要 */
     case 2: unit[cid][i][j].regv.br[3] = unit[cid][i][j].tr[3];      break; /* 2:tr3  align不要 */
     }
     return (0);
   case STATUS_TERM:
     return (0);
@


1.54
log
@*** empty log message ***
@
text
@d2 1
a2 1
 static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.53 2016/04/18 13:11:19 nakashim Exp nakashim $";
d219 1
a219 1
 siml_emax5(tid, cycle, trace, trace_pipe, base, conf, lmmi, regv) Uint tid, cycle, trace, trace_pipe; Ull *base; Ull conf, lmmi, regv;
@


1.53
log
@*** empty log message ***
@
text
@d2 1
a2 1
 static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.52 2016/04/17 23:56:19 nakashim Exp nakashim $";
d157 1
a157 1
     Ull   mb1         : 5; /* internal reg  addr(byte index in 32B)*/
d164 4
a167 4
   Ull   mr0mux        : 2; /* mr0[3-0] -> brs0     */
   Ull   mr1mux        : 2; /* mr1[3-0] -> brs1     */
   Uint  mr0d             ; /* muxed data for BR[0] */
   Uint  mr1d             ; /* muxed data for BR[1] */
d281 1
a281 2
     if (trace && trace_pipe) {
       printf("\n");
a282 1
     }
d1513 3
a1515 4
  printf("==== EMAX5[%d] v=%d tid=%d status=%d last_conf=%08.8x_%08.8x last_dist=%d last_row0=%d\n",
	 cid, emax5[cid].v, emax5[cid].tid, emax5[cid].status, (Uint)(emax5[cid].last_conf>>32), (Uint)emax5[cid].last_conf, emax5[cid].last_dist, emax5[cid].last_row0);
  printf("==== EMAX5[%d] unit1_exec=%08.8x_%08.8x unit1_stop=%08.8x_%08.8x unit2_exec=%08.8x_%08.8x unit2_stop=%08.8x_%08.8x\n",
	 cid, (Uint)(emax5[cid].unit1_exec>>32), (Uint)emax5[cid].unit1_exec, (Uint)(emax5[cid].unit1_stop>>32), (Uint)emax5[cid].unit1_stop, (Uint)(emax5[cid].unit2_exec>>32), (Uint)emax5[cid].unit2_exec, (Uint)(emax5[cid].unit2_stop>>32), (Uint)emax5[cid].unit2_stop);
d1519 1
a1519 1
    printf("  -- FSM[%d] lmmo[],lmmc[],lmmd[]                               ", col);
d1522 1
a1522 1
    printf("lmmo[%02.2d]:", row);
d1524 1
a1524 1
      printf(" D%d v%d rw%d f%d p%d b%d l%d top%08.8x_%08.8x",
d1535 1
a1535 1
    printf("lmmc[%02.2d]:", row);
d1537 1
a1537 1
      printf(" D%d v%d rw%d f%d p%d b%d l%d top%08.8x_%08.8x",
d1552 1
a1552 1
    printf("  -- FSM[%d] bus_controller                               ", col);
d1554 1
d1556 1
a1556 1
    printf(" last=%d mems=%d rowc=%d rows=%08.8x_%08.8x rowl=%08.8x_%08.8x ardy=%d rrdy=%d",
d1567 1
d1569 1
a1569 1
    printf(" lmwa=%08.8x_%08.8x                          ",
d1571 3
a1573 1
	   (Uint) emax5[cid].fsm[col].lmwa);
d1575 1
d1577 1
a1577 1
    printf(" lmwd3=%08.8x_%08.8x 2=%08.8x_%08.8x 1=%08.8x_%08.8x 0=%08.8x_%08.8x",
d1587 1
d1589 1
a1589 6
    printf(" lmra=%08.8x_%08.8x                          ",
	   (Uint)(emax5[cid].fsm[col].lmra>>32),
	   (Uint) emax5[cid].fsm[col].lmra);
  printf("\n");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf(" lmrd3=%08.8x_%08.8x 2=%08.8x_%08.8x 1=%08.8x_%08.8x 0=%08.8x_%08.8x",
d1599 1
d1601 1
a1601 1
    printf(" axra=%08.8x_%08.8x axwa=%08.8x_%08.8x            ",
d1605 1
a1605 4
	   (Uint) emax5[cid].fsm[col].axwa);
  printf("\n");
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf(" raddr=%08.8x_%08.8x rlen=%08.8x_%08.8x            ",
d1611 1
d1613 1
a1613 1
    printf(" rdata3=%08.8x_%08.8x 2=%08.8x_%08.8x 1=%08.8x_%08.8x 0=%08.8x_%08.8x",
d1623 1
d1625 1
a1625 1
    printf(" waddr=%08.8x_%08.8x wlen=%08.8x_%08.8x            ",
d1631 1
d1633 1
a1633 1
    printf(" wdata3=%08.8x_%08.8x 2=%08.8x_%08.8x 1=%08.8x_%08.8x 0=%08.8x_%08.8x",
d1643 1
d1645 1
a1645 1
    printf(" tcurg3=%08.8x_%08.8x 2=%08.8x_%08.8x 1=%08.8x_%08.8x 0=%08.8x_%08.8x",
d1659 1
a1659 1
      printf("  -- UNIT[%d] conf[%d].cdw0", row, col);
d1661 1
d1663 1
a1663 1
      printf(" op1=%d op2=%d op3=%d ex1b=%d ex1s=%d ex1e=%d ex2b=%d ex2e=%d ex3b=%d ex3e=%d",
d1673 1
a1673 4
	     unit[cid][row][col].conf.cdw0.ex3exp);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" e2imm=%d e2is=%d e3imm=%d e3is=%d",
d1679 1
d1681 1
a1681 4
      printf("  -- UNIT[%d] conf[%d].cdw1", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" cop=%d cs3,2,1,0=%01.1x%01.1x%01.1x%01.1x ctab=%04.4x",
d1687 1
a1687 4
	     unit[cid][row][col].conf.cdw1.cex_tab);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" ea0op=%d ea0bs==%d ea0os=%d ea0msk=%d ea1op=%d ea1bs==%d ea1os=%d ea1msk=%d eabbrs=%d eaobrs=%d",
d1699 1
d1701 1
a1701 4
      printf("  -- UNIT[%d] conf[%d].cdw2", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" lmlrsa=%d%d s3=%d%d s2=%d%d s1=%d%d s0=%d%d ts3210=%01.1x%01.1x%01.1x%01.1x trs3210=%d%d%d%d brs3210=%d%d%d%d",
d1723 1
a1723 7
	     unit[cid][row][col].conf.cdw2.brs0);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("  -- UNIT[%d] conf[%d].cdw3", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" mapdist=%d",
d1726 1
d1728 1
a1728 4
      printf("  -- UNIT[%d] regv[%d].er  ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" ea1br=%08.8x_%08.8x ea1or=%08.8x_%08.8x ea0br=%08.8x_%08.8x ea0or=%08.8x_%08.8x",
d1738 1
d1740 1
a1740 4
      printf("  -- UNIT[%d] regv[%d].br  ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" br3=%08.8x_%08.8x br2=%08.8x_%08.8x br1=%08.8x_%08.8x br0=%08.8x_%08.8x",
d1750 1
d1752 1
a1752 4
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" one_shot=%d c3210=%01.1x%01.1x%01.1x%01.1x cexdr=%d",
d1758 1
a1758 7
	     unit[cid][row][col].cexdr);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" ex1=%08.8x_%08.8x ex2=%08.8x_%08.8x ex3=%08.8x_%08.8x",
d1766 1
d1768 1
a1768 4
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" eab=%08.8x_%08.8x eao=%08.8x_%08.8x",
d1774 1
d1776 5
a1780 4
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" ea0b=%08.8x_%08.8x ea0o=%08.8x_%08.8x",
d1786 1
d1788 1
a1788 14
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" ea1b=%08.8x_%08.8x ea1o=%08.8x_%08.8x",
	     (Uint)(unit[cid][row][col].ea1b>>32),
	     (Uint) unit[cid][row][col].ea1b,
	     (Uint)(unit[cid][row][col].ea1o>>32),
	     (Uint) unit[cid][row][col].ea1o);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" exdr=%08.8x_%08.8x ea1dr=%08.8x_%08.8x ea0dr=%08.8x_%08.8x",
d1794 1
a1794 7
	     (Uint) unit[cid][row][col].ea0dr);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" lmenr=%d rrdy=%d",
d1798 1
d1800 1
a1800 4
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" lmwa=%08.8x_%08.8x",
d1802 3
a1804 4
	     (Uint) unit[cid][row][col].lmwa);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
d1806 1
d1808 1
a1808 1
      printf(" lmwd3=%08.8x_%08.8x lmwd2=%08.8x_%08.8x lmwd1=%08.8x_%08.8x lmwd0=%08.8x_%08.8x",
d1818 1
d1820 1
a1820 12
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" lmra=%08.8x_%08.8x",
	     (Uint)(unit[cid][row][col].lmra>>32),
	     (Uint) unit[cid][row][col].lmra);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" lmrd3=%08.8x_%08.8x lmrd2=%08.8x_%08.8x lmrd1=%08.8x_%08.8x lmrd0=%08.8x_%08.8x",
d1830 1
d1832 1
a1832 4
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" axra=%08.8x_%08.8x axwa=%08.8x_%08.8x",
d1838 1
d1840 1
a1840 4
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" lmria=%08.8x_%08.8x lmroa=%08.8x_%08.8x lmlia=%08.8x_%08.8x lmloa=%08.8x_%08.8x",
d1850 1
d1852 1
a1852 4
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" lmri3=%08.8x_%08.8x lmri2=%08.8x_%08.8x lmri1=%08.8x_%08.8x lmri0=%08.8x_%08.8x",
d1862 1
d1864 1
a1864 4
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" lmro3=%08.8x_%08.8x lmro2=%08.8x_%08.8x lmro1=%08.8x_%08.8x lmro0=%08.8x_%08.8x",
d1874 1
d1876 1
a1876 4
      printf("  -- UNIT[%d] misc[%d]     ", row, col);
    printf("\n");
    for (col=EMAX_WIDTH-1; col>=0; col--)
      printf(" lmli3=%08.8x_%08.8x lmli2=%08.8x_%08.8x lmli1=%08.8x_%08.8x lmli0=%08.8x_%08.8x",
d1886 108
a1993 1
    
a1994 25
#if 0
   Ull   lmlo[UNIT_WIDTH];  /* wire */
   Ull   t[UNIT_WIDTH];     /* wire */
   Ull   tr[UNIT_WIDTH];    /* reg  */
   struct lmm {
     Uint  en0         : 1; /* internal reg       */
     Uint  en1         : 1; /* internal reg       */
     Uint  rw0         : 1; /* 0:read, 1:write    */
     Uint  rw1         : 1; /* 0:read,(1:write)   */
     Ull   ma0            ; /* internal reg  addr(32B aligned)      */
     Uint  mb0         : 5; /* internal reg  addr(byte index in 32B)*/
     Ull   ma1            ; /* internal reg  addr(32B aligned)      */
     Ull   mb1         : 5; /* internal reg  addr(byte index in 32B)*/
     Ull   mm0[UNIT_WIDTH]; /* internal reg  mask */
     Ull   mw0[UNIT_WIDTH]; /* internal reg  data */
     Ull   mr0[UNIT_WIDTH]; /* internal wire data */
     Ull   mr1[UNIT_WIDTH]; /* internal wire data */
     Uchar m[LMEM_SIZE]   ; /* local memory       */
   } lmm;
   Ull   mr0mux        : 2; /* mr0[3-0] -> brs0     */
   Ull   mr1mux        : 2; /* mr1[3-0] -> brs1     */
   Uint  mr0d             ; /* muxed data for BR[0] */
   Uint  mr1d             ; /* muxed data for BR[1] */
 } unit[MAXCORE][EMAX_DEPTH][EMAX_WIDTH];
#endif
@


1.52
log
@*** empty log message ***
@
text
@d2 1
a2 1
 static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.51 2016/04/17 13:55:17 nakashim Exp nakashim $";
d217 1
a217 1
 //application -> emax5_start((Ull*)emax5_conf_x1, (Ull*)emax5_regv_x1, (Ull*)emax5_lmmi_x1);
d219 1
a219 1
 siml_emax5(tid, cycle, trace, trace_pipe, base, conf, regv, lmmi) Uint tid, cycle, trace, trace_pipe; Ull *base; Ull conf, regv, lmmi;
d1660 1
d1683 1
d1708 1
d1736 1
d1743 1
d1757 1
d1769 185
a1955 33
   Uint  one_shot     : 1;  /* reg  *//* for self_loop_control 0:init 1:self_loop */
   Uchar c[UNIT_WIDTH];     /* wire */
   Uint  cexdr        : 2;  /* reg  *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
   Ull   ex1             ;  /* wire *//* in for ALU */
   Ull   ex2             ;  /* wire *//* in for ALU */
   Ull   ex3             ;  /* wire *//* in for ALU */
   Ull   eab             ;  /* wire *//* in for ALU */
   Ull   eao             ;  /* wire *//* in for ALU */
   Ull   ea0b            ;  /* wire *//* in for EA0 */
   Ull   ea0o            ;  /* wire *//* in for EA0 */
   Ull   ea1b            ;  /* wire *//* in for EA1 */
   Ull   ea1o            ;  /* wire *//* in for EA1 */
   Ull   exdr            ;  /* reg  */
   Ull   ea0dr           ;  /* reg  */
   Ull   ea1dr           ;  /* reg  */

   Uint  lmen         : 1;  /* lmm enable for read/write */
   Uint  rrdy         : 1;  /* wire *//* LMM data-valid for FSM */

   Ull   lmwa            ;  /* wire *//* -> ea0dr */
   Ull   lmwd[UNIT_WIDTH];  /* wire *//* <- axi */
   Ull   lmra            ;  /* wire *//* -> ea1dr */
   Ull   lmrd[UNIT_WIDTH];  /* wire *//* -> axi */
   Ull   axra            ;  /* wire *//* <- ea0dr */
   Ull   axwa            ;  /* wire *//* <- ea1dr .. not used */

   Ull   lmria           ;  /* wire */
   Ull   lmroa           ;  /* wire */
   Ull   lmlia           ;  /* wire */
   Ull   lmloa           ;  /* wire */
   Ull   lmri[UNIT_WIDTH];  /* wire */
   Ull   lmro[UNIT_WIDTH];  /* wire */
   Ull   lmli[UNIT_WIDTH];  /* wire */
@


1.51
log
@*** empty log message ***
@
text
@d2 1
a2 1
 static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.50 2016/04/17 00:53:44 nakashim Exp nakashim $";
d1555 1
a1555 1
    printf("  -- FSM[%d] buscontroller                               ", col);
a1656 3
  for (col=EMAX_WIDTH-1; col>=0; col--)
    printf("  -- UNIT[%d] conf                              ", col);
  printf("\n");
a1657 1
    printf("lmmo[%02.2d]:", row);
d1659 3
a1661 1
      printf(" op1=%d op2=%d op3=%d ex1brs=%d ex1s=%d ex1exp=%d ex2brs=%d ex2exp=%d ex3brs=%d ex3exp=%d",
d1673 90
a1763 1

a1764 71
#define E2IMMBITS 12
    Uint e2imm  : E2IMMBITS;
    Uint e2is   :  2; /* 0:e2imm, 1:ex2, 2:ex3 */
#define E3IMMBITS  6
    Uint e3imm  : E3IMMBITS;
    Uint e3is   :  1; /* 0:e3imm, 1:ex3 */
    Uint dmy00  : 12;
  } cdw0;

  struct cdw1 { /* select CEX-in and EAG-in */
    Uint cop    :  1; /* 0:NOP, 1:CEXE */
    Uint cs0    :  4; /* 0:br0_0, 1:br0_1, ... 15:3_3 */
    Uint cs1    :  4; /* 0:br0_0, 1:br0_1, ... 15:3_3 */
    Uint cs2    :  4; /* 0:br0_0, 1:br0_1, ... 15:3_3 */
    Uint cs3    :  4; /* 0:br0_0, 1:br0_1, ... 15:3_3 */
    Uint cex_tab: 16; /* c3.c2.c1.c0の組合せ */
                      /* 1111,1110,1101,1100,....,0001,0000 の各々に0/1を割り当てた16bitを指定 */
    Uint ea0op  :  5; /* mem_opcd */
    Uint ea0bs  :  1; /* 0:eabbrs, 1:ea0br(self-loop) */
    Uint ea0os  :  1; /* 0:eaobrs, 1:ea0or */
    Uint ea0msk :  4; /* 15:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
    Uint ea1op  :  5; /* mem_opcd */
    Uint ea1bs  :  1; /* 0:eabbrs, 1:ea1br(self-loop) */
    Uint ea1os  :  1; /* 0:eaobrs, 1:ea1or, */
    Uint ea1msk :  4; /* 15:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
    Uint eabbrs :  4; /* 0:br0_0, 1:br0_1, ... 15:3_3 */
    Uint eaobrs :  4; /* 0:br0_0, 1:br0_1, ... 15:3_3 */
    Uint dmy10  :  1;
  } cdw1;

  struct cdw2 { /* select TR/BR-in */
    Uint lmlsa  :  1; /* 0:lmwa,  1:lmria */
    Uint lmrsa  :  1; /* 0:lmwa,  1:lmlia */
    Uint lmls0  :  1; /* 0:lmwd0, 1:lmri0 */
    Uint lmrs0  :  1; /* 0:lmwd0, 1:lmli0 */
    Uint lmls1  :  1; /* 0:lmwd1, 1:lmri1 */
    Uint lmrs1  :  1; /* 0:lmwd1, 1:lmli1 */
    Uint lmls2  :  1; /* 0:lmwd2, 1:lmri2 */
    Uint lmrs2  :  1; /* 0:lmwd2, 1:lmli2 */
    Uint lmls3  :  1; /* 0:lmwd3, 1:lmri3 */
    Uint lmrs3  :  1; /* 0:lmwd3, 1:lmli3 */
    Uint ts0    :  4; /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
    Uint ts1    :  4; /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
    Uint ts2    :  4; /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
    Uint ts3    :  4; /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
    Uint trs0   :  3; /* 0:exdr, 1:exdr0, 2:ts0, 3:lmli0, 4:lmwd0, 5:lmri0 */
    Uint trs1   :  3; /* 0:exdr, 1:exdr1, 2:ts1, 3:lmli1, 4:lmwd1, 5:lmri1 */
    Uint trs2   :  3; /* 0:exdr, 1:exdr2, 2:ts2, 3:lmli2, 4:lmwd2, 5:lmri2 */
    Uint trs3   :  3; /* 0:exdr, 1:exdr3, 2:ts3, 3:lmli3, 4:lmwd3, 5:lmri3 */
    Uint brs0   :  2; /* 0:off, 1:mr10, 2:tr0, 3:mr0  */
    Uint brs1   :  2; /* 0:off, 1:mr11, 2:tr1, 3:mr1  */
    Uint brs2   :  2; /* 0:off, 1:mr12, 2:tr2, 3:exdr */
    Uint brs3   :  2; /* 0:off, 1:mr13, 2:tr3         */
    Uint dmy20  : 18;
  } cdw2;

  struct cdw3 { /* reserved */
    Ull  mapdist:  6;
    Ull  dmy20  : 58;
  } cdw3;
} conf[EMAX_WIDTH][EMAX_DEPTH]; /* 4dwords/unit costs 1cycle/unit: 4-parallel conf costs 1cycle/stage */

/* regv */
struct regv { /* final register values for EMAX5-CGRA */
  Ull ea0br;
  Ull ea0or;
  Ull ea1br;
  Ull ea1or;
  Ull br[UNIT_WIDTH];
}; /* 8dwords/unit costs 2cycle/unit: 4-parallel conf costs 2cycle/stage */

a1820 1

a1821 1

@


1.50
log
@*** empty log message ***
@
text
@d2 1
a2 1
 static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.49 2016/04/15 00:04:25 nakashim Exp nakashim $";
d283 1
a283 2
       for (i=0; i<EMAX_DEPTH; i++) /* for each instructions to be assigned */
	 show_status(cid, i);
d1501 1
a1501 1
show_status(cid, row) Uint cid, row;
d1503 1
a1503 1
  int col, i;
d1513 295
@


1.49
log
@*** empty log message ***
@
text
@d2 1
a2 1
 static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.48 2016/04/14 14:36:55 nakashim Exp nakashim $";
d1263 1
a1263 1
	 a = unit[cid][i][j].lmm.ma0;
d1340 1
a1340 1
   Ull a, d;
d1352 6
a1364 1
       a = unit[cid][i][j].lmm.ma1 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */
d1366 1
a1366 1
	 unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a % LMEM_SIZE]+k);
a1370 1
       a = unit[cid][i][j].lmm.ma0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */
d1372 1
a1372 1
	 *((Ull*)&unit[cid][i][j].lmm.m[a % LMEM_SIZE]+k) = unit[cid][i][j].lmm.mw0[k];
d1380 2
a1381 1
     /* fsm drain */
a1383 1
	 a = unit[cid][i][j].lmm.ma1 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */
d1385 1
a1385 1
	   unit[cid][i][j].lmrd[k] = unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a % LMEM_SIZE]+k);
a1389 1
	 a = unit[cid][i][j].lmm.ma1 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */
d1391 8
a1398 1
	   unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a % LMEM_SIZE]+k);
d1401 12
d1418 30
a1447 21
       k = (unit[cid][i][j].lmm.ma1>>3) & 3;
       d = unit[cid][i][j].lmm.mr1[k];

     /*------------------------ここまで--------------------*/
	 switch (unit[cid][i][j].conf.cdw1.ea1op) {
       ---------------
LD      & OP_LDDMQ  & (ex(b0), 
ST      & OP_STR    & (ex,     
        & OP_STWR   & (ex(b0), 
        & OP_STHR   & (ex(b0), 
        & OP_STBR   & (ex(b0), 
        & OP_STBF   & (ex,     
TR      & TR        & (ex(b0), 
---------------
	   switch (unit[cid][i][j].conf.cdw1.ea1op) {
	   case OP_LDR: /* 64bit lmm LMM is preloaded, random-access */
	     break;
	   }
	   unit[cid][i][j].regv.br[0]
	     break; /* 3:mr0 */
	 }
a1448 6
     }       

       if (unit[cid][i][j].lmm.en0 && !unit[cid][i][j].lmm.rw0) { /* lmm read enabled */
       a = unit[cid][i][j].lmm.ma0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */
       for (k=0; k<UNIT_WIDTH; k++)
	 unit[cid][i][j].lmm.mr0[k] = *((Ull*)&unit[cid][i][j].lmm.m[a % LMEM_SIZE]+k);
d1450 6
a1455 4
     if (unit[cid][i][j].lmm.en1 && !unit[cid][i][j].lmm.rw1) { /* lmm read enabled */
       a = unit[cid][i][j].lmm.ma1 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */
       for (k=0; k<UNIT_WIDTH; k++)
	 unit[cid][i][j].lmm.mr1[k] = *((Ull*)&unit[cid][i][j].lmm.m[a % LMEM_SIZE]+k);
d1457 5
a1461 4
     if (unit[cid][i][j].lmm.en0 &&  unit[cid][i][j].lmm.rw0) { /* lmm write enabled */
       a = unit[cid][i][j].lmm.ma0 & ~(sizeof(Ull)*UNIT_WIDTH-1); /* should be aligned by fsm */
       for (k=0; k<UNIT_WIDTH; k++)
	 *((Ull*)&unit[cid][i][j].lmm.m[a % LMEM_SIZE]+k) = unit[cid][i][j].lmm.mw0[k];
a1462 1
     /*------------------------ここまで--------------------*/
@


1.48
log
@*** empty log message ***
@
text
@d2 1
a2 1
 static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.47 2016/04/12 01:58:54 nakashim Exp nakashim $";
d115 1
a115 1
   Uint  cexd         : 2;  /* wire *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
d1036 1
a1036 1
   /* c -> cexd */
d1048 1
a1048 1
       unit[cid][i][j].cexd = 0; /* always non-exec */
d1057 1
a1057 1
       unit[cid][i][j].cexd = ex;
d1115 1
a1115 1
   /* cexd,ea[01][bo] -> ea[01]dr,ma */
a1156 11
---------------
        & LDDMQ  & (ex(b0), (Ull*)d, base(++), offs, msk, -, -, -, -, -)                    & 64bit*4 mem      & Direct access to MM\\\hline
ST      & STR    & (ex,     s,       base(++), offs, msk, top, blk, len, force-read, ptop)  & 64bit lmm        & LMM rand-access\\
        & STWR   & (ex(b0), s,       base(++), offs, msk, top, blk, len, force-read, ptop)  & 32bit lmm        & LMM rand-access\\
        & STHR   & (ex(b0), s,       base(++), offs, msk, top, blk, len, force-read, ptop)  & 16bit lmm        & LMM rand-access\\
        & STBR   & (ex(b0), s,       base(++), offs, msk, top, blk, len, force-read, ptop)  & 8bit lmm         & LMM rand-access\\
        & STBF   & (ex,     (Ull*)s, base(++), offs, msk, top, blk, len,          -,    -)  & 64bit buffered   & LMM as a buffer\\\cline{2-5}
        & STRQ   & (-,      (Ull*)s, base(++), offs, msk, top, blk, len, force-read, ptop)  & 64bit*4 lmm      & LMM rand-access\\
        & STBFQ  & (-,      (Ull*)s, base(++), offs, msk, top, blk, len,          -,    -)  & 64bit*4 buffered & LMM as a buffer\\\hline
TR      & TR     & (ex(b0), (Ull*)s, base, offs)  base+offs=void(*transaction)()            & 64bit*4 exec     & Send transaction\\\hline
---------------
d1320 3
d1324 1
a1327 6
	 case OP_STBFQ:
	   break;
	 case OP_TR:
	   break;
	 case OP_IM_PREF:
	   break;
a1328 1
	 /*----------------------------------ここまで----------------------------*/
d1340 2
a1341 1
   Uint a, s, d, k, cycles = 0;
d1343 2
a1344 2
   /* write:  mw,ma                                -> LMM                            */
   /* read:   exdr,mw/tr,ma/ea[01]dr,LMM -> mr[01] -> br,lmrd                        */
d1359 1
a1359 1
       a = unit[cid][i][j].lmm.ma1 & ~31;--------------------------
d1366 1
a1366 1
       a = unit[cid][i][j].lmm.ma0 & ~31;
d1379 1
a1379 1
	 a = unit[cid][i][j].lmm.ma1 & ~31;
d1386 1
a1386 1
	 a = unit[cid][i][j].lmm.ma1 & ~31;
d1389 9
a1397 7
	 switch (unit[cid][i][j].conf.cdw2.brs0) {
	 case 0:                                                          break; /* off */
	 case 1: unit[cid][i][j].regv.br[0] = unit[cid][i][j].lmm.mr1[0]; break; /* 1:mr10 */
	 case 2: unit[cid][i][j].regv.br[0] = unit[cid][i][j].tr[0];      break; /* 2:tr0 */
	 case 3: 
	   k = (unit[cid][i][j].lmm.ma1>>3) & 3;
	   d = unit[cid][i][j].lmm.mr1[k];
d1400 10
a1409 1

d1421 1
a1421 1
       a = unit[cid][i][j].lmm.ma0 & ~31;
d1426 1
a1426 1
       a = unit[cid][i][j].lmm.ma1 & ~31;
d1431 1
a1431 1
       a = unit[cid][i][j].lmm.ma0 & ~31;
@


1.47
log
@*** empty log message ***
@
text
@d2 1
a2 1
 static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.46 2016/04/11 15:36:07 nakashim Exp nakashim $";
d150 13
a162 10
     Uint  en0         : 1; /* internal reg     */
     Uint  en1         : 1; /* internal reg     */
     Uint  rw0         : 1; /* 0:read, 1:write  */
     Uint  rw1         : 1; /* 0:read,(1:write) */
     Ull   ma0            ; /* internal reg     */
     Ull   ma1            ; /* internal reg     */
     Ull   mw0[UNIT_WIDTH]; /* internal reg     */
     Ull   mr0[UNIT_WIDTH]; /* internal wire    */
     Ull   mr1[UNIT_WIDTH]; /* internal wire    */
     Uchar m[LMEM_SIZE]   ; /* local memory     */
d164 4
d1115 1
a1115 1
   /* ea[01][bo] -> ea[01]dr,ma */
d1126 1
d1136 1
d1145 41
d1187 1
a1187 1
     if (unit[cid][i][j].conf.cdw1.ea0op == OP_IMLD_PREF) {
d1192 1
d1204 3
a1206 1
	 unit[cid][i][j].axra = unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr;
a1212 25

     /* fsm drain */
     if (unit[cid][i][j].conf.cdw1.ea1op == OP_IMST_DRAIN) {
       if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
	 unit[cid][i][j].lmm.en1 = 1;
	 unit[cid][i][j].lmm.rw1 = 0; /* read */
	 unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = emax5[cid].fsm[j].lmra;
       }
       else
	 unit[cid][i][j].lmm.en1 = 0;
     }
     else if (unit[cid][i][j].conf.cdw1.ea1op) { /* normal load */
       if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
	 base1 = (!unit[cid][i][j].conf.cdw1.ea1bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
	 offs1 = (!unit[cid][i][j].conf.cdw1.ea1bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
	 eag(&unit[cid][i][j].ea1dr, base1, offs1, unit[cid][i][j].conf.cdw1.ea1msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
	 unit[cid][i][j].lmm.en1 = 1;
	 unit[cid][i][j].lmm.rw1 = 0; /* read */
	 unit[cid][i][j].axwa = unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr;
       }
       else /* inactive */
	 unit[cid][i][j].lmm.en1 = 0;
     }
     else /* inactive */
       unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = 0LL; /* always non-exec */
d1221 1
d1240 4
a1243 2
       for (k=0; k<UNIT_WIDTH; k++)
	 unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k] = emax5[cid].fsm[j].lmwd[k];    
d1264 1
a1264 1
     if (unit[cid][i][j].conf.cdw1.ea0op == OP_IMLD_PREF) {
d1266 4
a1269 2
	 for (k=0; k<UNIT_WIDTH; k++)
	   unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k] = emax5[cid].fsm[j].lmwd[k];
d1274 3
a1276 2
	 /* 0:exdr, 1:exdr0, 2:ts0, 3:lmli0, 4:lmwd0, 5:lmri0 */
	 unit[cid][i][j].tr[0] = unit[cid][i][j].conf.cdw2.trs0==0 ? unit[cid][i][j].exdr
d1304 39
a1342 2
	 for (k=0; k<UNIT_WIDTH; k++)
	   unit[cid][i][j].lmm.mw0[k] = unit[cid][i][j].tr[k];
d1371 5
a1375 2
     /* lmm.m[LMEM_SIZE] */
     /*---------------------- ここまで -----------------------*/
d1378 5
a1382 2
     /* lmm.m[LMEM_SIZE] */
     /*---------------------- ここまで -----------------------*/
d1389 49
a1437 1
     /*---------------------- ここまで -----------------------*/
@


1.46
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.45 2016/04/11 14:32:57 nakashim Exp nakashim $";
d4 1312
a1315 1294
/* EMAX5 Simulator                     */
/*         Copyright (C) 2012 by NAIST */
/*         Primary writer: Y.Nakashima */
/*                nakashim@@is.naist.jp */

/* emax5.c 2012/9/22 */ 

#include <stdio.h>
#include "bsim.h"
#include "../conv-c2d/emax5.h"
#include "../conv-c2d/emax5lib.c"

/* CGRA hardware */
enum { STATUS_IDLE, STATUS_CONF, STATUS_LMMI, STATUS_DRAIN, STATUS_LOAD, STATUS_REGV, STATUS_START, STATUS_EXEC, STATUS_TERM };
enum { FSM_IDLE,    FSM_CONF,    FSM_LMMI,    FSM_DRAIN,    FSM_LOAD,    FSM_REGV,    FSM_START,    FSM_EXEC,    FSM_TERM };
enum { MEMIF_IDLE,  MEMIF_AREQ,  MEMIF_DREQ,  MEMIF_TERM };

struct emax5 { /* lmm status of EMAX5 */
  Uint  v                 : 1; /* 0:empty, 1:unuse */
  Uint  tid               :12; /* owner thread of EMAX */
  Uint  status            : 4;
  Ull   last_conf            ; /* for insn_reuse */
  Uint  last_dist         : 6; /* latest map_dist */
  Uint  last_row0         : 6; /* physical top of logical unit[][0] */

  Ull   unit1_exec; /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:exec */
  Ull   unit1_stop; /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:stop */
  Ull   unit2_exec; /* 1bit corresponds to each row (lmm),         0:wait 1:exec */
  Ull   unit2_stop; /* 1bit corresponds to each row (lmm),         0:wait 1:stop */

  Uint  cycles_tinit_part;
  Uint  cycles_conf_part;
  Uint  cycles_lmmi_part;
  Uint  cycles_drain_part;
  Uint  cycles_load_part;
  Uint  cycles_regv_part;
  Uint  cycles_exec_part;
  Uint  cycles_term_part;
  Uint  cycles_trans_part;
  Ull   cycles_tinit;
  Ull   cycles_conf;
  Ull   cycles_lmmi;
  Ull   cycles_drain;
  Ull   cycles_load;
  Ull   cycles_regv;
  Ull   cycles_exec;
  Ull   cycles_term;
  Ull   cycles_trans;
                               /* dirtyが残っている場合,lmmiの前にdrain               */
                               /*  conf  | drain | load | lmmi | regv | exec        | */
                               /*        |       |             |      | pload       | */
                               /* 残っていない場合,execと同時にdrain開始              */
                               /*  conf  |       |      | lmmi | regv | exec        | */
                               /*                       |      |      | drain pload | */

                               /* 1 :conf  fsm_way毎に,last_row0から順にEMAX本体に格納                */
                               /*          4wayが全て完了するまで待機                                 */
                               /* 2 :lmmi  fsm_way毎に,fsm内部のlmmiへ読み込み                        */
                               /*          4wayが全て完了するまで待機                                 */
                               /*(3):drain fsm_way毎に,lmmoにdirtyがあるか検査                        */
                               /*          dirtyは,fsm_way毎にdrain                                   */
                               /*          4wayが全て完了するまで待機                                 */
                               /*(4):load  fsm_way毎に,lmmiにpreload以外の未loadLMMがあるか検査       */
                               /*          未loadLMMが存在する場合,fsm_way毎にload                    */
                               /*          4wayが全て完了するまで待機                                 */
                               /* 5 :regv  全fsm_wayに,start準備をセット                              */
                               /*          4wayが全て完了するまで待機                                 */
                               /* 6 :start 全fsm_wayに,startをセット                                  */
                               /* 7 :exec  全fsm_wayのlast_row0にflag=1をセット.EMAX5起動             */
                               /*          4wayが全て完了するまで待機                                 */
                               /*          この間,各fsm_wayは全lmmiに未drainがあるか検査              */
                               /*          未drainが存在する場合,fsm_way毎に,last_row0から順にdrain   */
                               /*          drain後,pload開始(drain+ploadは，EMAX5の演算動作と同時)    */
                               /*          EMAX5動作と全fsmのdrain/pload動作完了をもって,8:termへ遷移 */

  struct fsm {                 /* load/drainは,複数rowを同時動作 */
    struct lmmi lmmo[EMAX_DEPTH]; /* previous lmmi */
    struct lmmi lmmc[EMAX_DEPTH]; /* current lmmi */
    Uchar       lmmd[EMAX_DEPTH]; /* 0:clean, 1:dirty,   exec後store箇所に1, drain直後0 */

    Uint  last_dist       : 6; /* latest map_dist */
    Uint  memif_status    : 4;
    Uint  row_count       : 8; /* valid row counter is 6bit */
    Ull   row_select      :64; /* bitmap 0:off 1:selected */
    Ull   row_lmm_en      :64; /* lmm enable for read/write */
    Uint  ardyc;               /* LMM addr-request(read/write) counter */
    Uint  rrdyc;               /* LMM data-ready(read) counter */
                               /*                         CF  RV  LI  PF  DR  TR  DM                 */
    Ull   lmwa               ; /* -> ea0dr                     v       v                             */
    Ull   lmwd[UNIT_WIDTH]   ; /* <- lmm wdata                 v       v           v                 */
    Ull   lmra               ; /* -> ea1dr                                 v                         */
    Ull   lmrd[UNIT_WIDTH]   ; /* -> lmm rdata                             v   v                     */
    Ull   axra               ; /* <- ea0dr                     -       -           v                 */
    Ull   axwa               ; /* <- ea1dr (not used)                      -                         */

    Ull   raddr;               /* read-address  of mm      v   v   v   v           v                 */
    Ull   rlen;                /* read-length   of mm      v   v   v   v           1                 */
    Ull   rdata[UNIT_WIDTH];   /* read-data     of mm      v   v   v   v           v                 */
    Ull   waddr;               /* write-address of mm                      v                         */
    Ull   wlen;                /* write-length  of mm                      v                         */
    Ull   wdata[UNIT_WIDTH];   /* write-data    of mm                      v                         */

    Ull   tcureg[UNIT_WIDTH];  /* tcu-data      of tcu                         v                     */
  } fsm[EMAX_WIDTH];
} emax5[MAXCORE];

struct unit { /* hardware status of EMAX5 units */
  struct conf conf;
  struct regv regv;        /* ea0br,ea0or,ea1br,ea1or,br[UNIT_WIDTH] */
  Uint  one_shot     : 1;  /* reg  *//* for self_loop_control 0:init 1:self_loop */
  Uchar c[UNIT_WIDTH];     /* wire */
  Uint  cexd         : 2;  /* wire *//* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
  Ull   ex1             ;  /* wire *//* in for ALU */
  Ull   ex2             ;  /* wire *//* in for ALU */
  Ull   ex3             ;  /* wire *//* in for ALU */
  Ull   eab             ;  /* wire *//* in for ALU */
  Ull   eao             ;  /* wire *//* in for ALU */
  Ull   ea0b            ;  /* wire *//* in for EA0 */
  Ull   ea0o            ;  /* wire *//* in for EA0 */
  Ull   ea1b            ;  /* wire *//* in for EA1 */
  Ull   ea1o            ;  /* wire *//* in for EA1 */
  Ull   exdr            ;  /* reg  */
  Ull   ea0dr           ;  /* reg  */
  Ull   ea1dr           ;  /* reg  */

  Uint  lmen         : 1;  /* lmm enable for read/write */
  Uint  rrdy         : 1;  /* wire *//* LMM data-valid for FSM */

  Ull   lmwa            ;  /* wire *//* -> ea0dr */
  Ull   lmwd[UNIT_WIDTH];  /* wire *//* <- axi */
  Ull   lmra            ;  /* wire *//* -> ea1dr */
  Ull   lmrd[UNIT_WIDTH];  /* wire *//* -> axi */
  Ull   axra            ;  /* wire *//* <- ea0dr */
  Ull   axwa            ;  /* wire *//* <- ea1dr .. not used */

  Ull   lmria           ;  /* wire */
  Ull   lmroa           ;  /* wire */
  Ull   lmlia           ;  /* wire */
  Ull   lmloa           ;  /* wire */
  Ull   lmri[UNIT_WIDTH];  /* wire */
  Ull   lmro[UNIT_WIDTH];  /* wire */
  Ull   lmli[UNIT_WIDTH];  /* wire */
  Ull   lmlo[UNIT_WIDTH];  /* wire */
  Ull   t[UNIT_WIDTH];     /* wire */
  Ull   tr[UNIT_WIDTH];    /* reg  */
  struct lmm {
    Uint  en0         : 1; /* internal reg   */
    Uint  en1         : 1; /* internal reg   */
    Uint  rw0         : 1; /* 0:read,1:write */
    Uint  rw1         : 1; /* 0:read,1:write */
    Ull   ma0            ; /* internal reg   */
    Ull   ma1            ; /* internal reg   */
    Ull   mw[UNIT_WIDTH] ; /* internal reg   */
    Ull   mr0[UNIT_WIDTH]; /* internal wire  */
    Ull   mr1[UNIT_WIDTH]; /* internal wire  */
    Uchar m[LMEM_SIZE]   ; /* local memory   */
  } lmm;
} unit[MAXCORE][EMAX_DEPTH][EMAX_WIDTH];

/* TCU hardware */
enum { TCU_IDLE, TCU_BUSY };

#define MAX_TRANS_CBL 8
#define MAX_TRANS_REG 8

Uint next_tcu; /* tcb_entry for next tcb registration by trans_start() */
struct tcu { /* final information for EMAX5 hardware */
  Uint  status : 4;
  Uint  tcbid; /* 0:invalid, start address of trans */
  struct tconf tconf[TRANS_DEPTH]; /* copy of tconf[] */
  Uint  pc;                 /* program counter */
  Ull   reg[MAX_TRANS_REG]; /* r0-r7 for param/work */
} tcu[MAX_TRANS_CBL];

/* TCU control */
siml_trans(tid, cycle, trace, trace_pipe, base, start, end, gr2) Uint tid, cycle, trace, trace_pipe; Uchar *base; Ull start, end, gr2;
{
  Uint cid = tid2cid(tid);
  int i, j, k, a;

  emax5[cid].cycles_tinit_part = 0;

  for (i=0; i<MAX_TRANS_CBL; i++) {
    if (tcu[i].tcbid == start) {
      next_tcu = i;
      break;
    }
  }

  if (tcu[next_tcu].status != TCU_IDLE)
    return (2);

  /* new tcb is stored in tcu.next_tcb */
  tcu[next_tcu].tcbid = start;
  for (i=0; i<TRANS_DEPTH; i++)
    tcu[next_tcu].tconf[i] = *((struct tconf*)(base+start)+i);

  emax5[cid].cycles_tinit_part = sizeof(tconf)/(sizeof(Ull)*UNIT_WIDTH*EMAX_WIDTH);
  emax5[cid].cycles_tinit += emax5[cid].cycles_tinit_part;

  next_tcu = (next_tcu+1)%MAX_TRANS_CBL;

  return (0);
}

/* EMAX5 control */
//application -> emax5_start((Ull*)emax5_conf_x1, (Ull*)emax5_regv_x1, (Ull*)emax5_lmmi_x1);
//            -> svc 0xf1
siml_emax5(tid, cycle, trace, trace_pipe, base, conf, regv, lmmi) Uint tid, cycle, trace, trace_pipe; Ull *base; Ull conf, regv, lmmi;
{
  Uint cid = tid2cid(tid);
  int i, j, k, flag, sync;
  Ull a;

  if (emax5[cid].v && emax5[cid].tid != tid)
    return (2); /* busy */

  if (emax5[cid].status == STATUS_IDLE) {
    emax5[cid].v = 1; /* lock */
    emax5[cid].tid = tid;
    emax5[cid].cycles_conf_part  = 0;
    emax5[cid].cycles_lmmi_part  = 0;
    emax5[cid].cycles_drain_part = 0;
    emax5[cid].cycles_load_part  = 0;
    emax5[cid].cycles_regv_part  = 0;
    emax5[cid].cycles_exec_part  = 0;
    emax5[cid].cycles_term_part  = 0;
    emax5[cid].cycles_trans_part = 0;
  }
  while (cycle-- > 0) {
    Ull prev1_stop, prev2_stop;    
    /*******************************************************/
    /******************* unit siml start *******************/
    /*******************************************************/
    prev1_stop =  emax5[cid].unit1_stop;
    prev2_stop =  emax5[cid].unit2_stop;
    for (i=(emax5[cid].last_row0+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
      siml_unit_bus1(cid, i); /* br */
      siml_unit_bus2(cid, i); /* mr */
      for (j=EMAX_WIDTH-1; j>=0; j--) { /* for each unit */
	/**************************/
	/****** do lmm ************/
	/**************************/
	siml_unit_lmm(cid, i, j); /* lmm */
      }
      for (j=EMAX_WIDTH-1; j>=0; j--) { /* for each unit */
	/**************************/
	/****** do exe ************/
	/**************************/
	siml_unit_cex(cid, i, j); /* cnd */
	siml_unit_exe(cid, i, j); /* exe */
	siml_unit_eag(cid, i, j); /* eag */
      }
      for (j=EMAX_WIDTH-1; j>=0; j--) /* for each unit */
	siml_unit_trg(cid, i, j); /* trg */
      /* 自stage:stop=1と同時に自stage:exec=0 次cycleから実行停止 */
      if (emax5[cid].status == STATUS_START)
	emax5[cid].unit1_exec |= emax5[cid].fsm[0].row_select;
      if (emax5[cid].status == STATUS_EXEC) {
	emax5[cid].unit2_stop |= ( prev1_stop           &(1LL<<  i                          ))                                      ? (1LL<<i): 0;
	emax5[cid].unit1_stop |= ( prev2_stop           &(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))                                      ? (1LL<<i): 0;
	emax5[cid].unit2_exec &= (                                                                  emax5[cid].unit2_stop&(1LL<<i) )?~(1LL<<i):~0;
	emax5[cid].unit2_exec |= ((emax5[cid].unit1_exec&(1LL<<  i                          )) && !(emax5[cid].unit2_stop&(1LL<<i)))? (1LL<<i): 0;
	emax5[cid].unit1_exec &= (                                                                  emax5[cid].unit1_stop&(1LL<<i) )?~(1LL<<i):~0;
	emax5[cid].unit1_exec |= ((emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))) && !(emax5[cid].unit1_stop&(1LL<<i)))? (1LL<<i): 0;
      }
      if (i==emax5[cid].last_row0)
        break;
    }

    if (trace && trace_pipe) {
      printf("\n");
      for (i=0; i<EMAX_DEPTH; i++) /* for each instructions to be assigned */
        show_status(cid, i);
    }
    /*******************************************************/
    /******************* unit siml end *********************/
    /*******************************************************/

    /*******************************************************/
    /******************* FSM siml start ********************/
    /******** 全unit 1cycle動作後,FSMは次のcmdを用意 *******/
    /*******************************************************/
    switch (emax5[cid].status) {
    case STATUS_IDLE:
      if (emax5[cid].last_conf != conf || emax5[cid].last_dist > 0) {
	if (trace)
	  printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (new)\n", tid, (Uint)(conf>>32), (Uint)conf);
	emax5[cid].status = STATUS_CONF;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	}
      }
      else {
	if (trace)
	  printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start (reuse)\n", tid, (Uint)(conf>>32), (Uint)conf);
	emax5[cid].status = STATUS_LMMI;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	}
      }
      break;
    case STATUS_CONF:
      emax5[cid].cycles_conf_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {	
	  switch (emax5[cid].fsm[j].memif_status) {
	  case MEMIF_AREQ:
	    emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	    emax5[cid].fsm[j].ardyc = 0;
	    emax5[cid].fsm[j].raddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
	    break;
	  case MEMIF_DREQ:
	    if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH) { /* 1rrdy/1unit */
	      emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[j].row_count)%EMAX_DEPTH);
	      emax5[cid].fsm[j].lmwa = 0LL; /* fixed */
	      for (k=0; k<UNIT_WIDTH; k++)
		emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k));
	      emax5[cid].fsm[j].last_dist = emax5[cid].fsm[j].rdata[3] & 0x3f; /* mapdist */
	      emax5[cid].fsm[j].row_count++;
	      emax5[cid].fsm[j].ardyc++;
	    }
	    else {
	      emax5[cid].fsm[j].memif_status = MEMIF_TERM;
	      emax5[cid].fsm[j].row_select   = 0LL;
	    }
	    break;
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_CONF finished */
	emax5[cid].last_conf = conf;
	emax5[cid].last_dist = emax5[cid].fsm[0].last_dist;
	emax5[cid].last_row0 = (emax5[cid].last_row0+emax5[cid].last_dist)%EMAX_DEPTH;
	emax5[cid].status = STATUS_LMMI;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	}
      }
      break;
    case STATUS_LMMI:
      emax5[cid].cycles_lmmi_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {	
	  switch (emax5[cid].fsm[j].memif_status) {
	  case MEMIF_AREQ:
	    emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	    emax5[cid].fsm[j].ardyc = 0;
	    emax5[cid].fsm[j].raddr = lmmi+sizeof(Ull)*2*EMAX_DEPTH*j; /* lmmi_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[j].rlen  =      sizeof(Ull)*2*EMAX_DEPTH*1; /* lmmi_topをfsmに渡すインタフェース */
	    break;
	  case MEMIF_DREQ:
	    if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH/2) { /* 1rrdy/2unit */
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+1);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].fsm[j].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+1);
	      
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[0] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+0);
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+0)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[1] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+1);
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+0) = emax5[cid].fsm[j].rdata[2] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+2);
	      *(((Ull*)&emax5[cid].fsm[j].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[j].row_count+1)%EMAX_DEPTH])+1) = emax5[cid].fsm[j].rdata[3] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*emax5[cid].fsm[j].ardyc*UNIT_WIDTH+3);
	      emax5[cid].fsm[j].row_count+=2;
	      emax5[cid].fsm[j].ardyc++;
	    }
	    else {
	      emax5[cid].fsm[j].memif_status = MEMIF_TERM;
	      emax5[cid].fsm[j].row_select   = 0LL;
	    }
	    break;
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_LMMI finished */
	emax5[cid].status = STATUS_DRAIN;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	}
      }
      break;
      /*******************************************************************************************************************************************************/
      /* ●lmmi指示ルール (copy from conv-c2d/emac5.c)                                                                  lmmi-loc  v  top  blk  len  rw  f  p */
      /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  len   0  0  0 */
      /* LD with force-read=1 and ptop==NULL generates current(lmf) and does not reuse LMM. same as lmf in EMAX4            curr  1  top  blk  len   0  1  0 */
      /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). same as lmp in EMAX4                     curr  1  top  blk  len   0  0  0 */
      /*                                                                                                                  c+dist  1 ptop  blk  len   0  0  1 */
      /*                                                                                        ptop!=NULL & force=1は，prefetchの意味がないので組合せがない */
      /*******************************************************************************************************************************************************/
      /* ST with force-read=0 and ptop==NULL writes back after execution. same as lmw in EMAX4                              curr  1  top  blk  len   1  0  0 */
      /* ST with force-read=1 and ptop==NULL prefetches data to LMM in advance and write back. same as lmx in EMAX4         curr  1  top  blk  len   1  1  0 */
      /* ST with force-read=0, top==NULL and ptop!=NULL late drain with next execution. same as lmd in EMAX4                curr  0  (check be empty)        */
      /*                                                   FSMは,dirtyおよびp-bitに従い,exec同時drainか,exec後drainを選択 c-dist  1 ptop  blk  len   1  0  1 */
      /*                                                                                        deleyed-drain & force=1は，delayの意味がないので組合せがない */
      /*******************************************************************************************************************************************************/
      /* Example of Load+Store **************************************************************************/ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
      /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
      /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, NULL);   lmr reuse-OK                   */
      /*                        ○lmmo.top==lmmi.top,.f=0,.p=0の場合, load/reuse before next exec       */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                                           */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmw (store)                    */
      /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
      /* }                                                                                              */
      /* Example of Accumulate **************************************************************************/ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(LDRQ,  1, src1, D[y], x, msk, D[y], 0, XSIZE, 1, NULL);   lmf (load)                     */
      /*                        ●lmmi.f=1の場合, load always before next exec                          */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                (accumulate)               */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmw (store)                    */
      /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
      /*                   (lmfとlmwが重なるケースでも一旦memに追い出すことで単純化. lmfは再利用しない) */
      /* }                                                                                              */
      /* Example of Partial Update **********************************************************************/ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(STRQ, ex, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmx (read-&-conditional-write) */
      /*                        ●lmmi.f=1の場合, load always before next exec                          */
      /*                        ○dirty=1,lmmo.top!=NULL,.p=0の場合, writeback before next exec         */
      /*                                        (lmxも一旦memに追い出すことで単純化. lmxも再利用しない) */
      /* }                                                                                              */
      /* Example of Prefetch+Drain **********************************************************************/ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                                */
      /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, A[y+1]); lmr+lmp prefetch               */
      /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, B[y+1]); lmr+lmp prefetch               */
      /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, C[y+1]); lmr+lmp prefetch               */
      /*                        ○lmmo.top==lmmi.top,.f=0,.p=0の場合, load/reuse before next exec       */
      /*                        ★lmmo.top==lmmi.top,.f=0,.p=1の場合, load/reuse with next exec         */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                                           */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, NULL, 0, XSIZE, 0, D[y-1]); lmd explicit late drain        */
      /*                        ★dirty=1,lmmi.top!=NULL,.p=1の場合, delayed drain at next exec         */
      /* }                                                                                              */
      /*************************************************************************************************************************************/
      /* 【FSM_DRAIN】                                                                                                                     */
      /* lmmo.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
      /*      1  1  0  0 ... lmw       lmmd=1のみ,必ず,regv前にdrain.終了時にlmmd=0                     store:d=1     --                   */
      /*      1  1  1  0 ... lmx       lmmd=1のみ,必ず,regv前にdrain.終了時にlmmd=0                     store:d=1     --                   */
      /*      1  1  0  1 ... lmd       drainは完了(dirty=0)しているので無視してよい                     drain済       --                   */
      /* 【FSM_LOAD】                                                                                                                      */
      /* lmmi.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
      /*      1  0  0  0 ... lmr       lmmoとlmmiが不一致ならdrainとregvの間にload                      prefetch/--   reuse/mload          */
      /*      1  0  1  0 ... lmf       必ずdrainとregvの間にload                                        --            mload(always)        */
      /*      1  1  1  0 ... lmx       必ずdrainとregvの間にload                                        --            store:d=1            */
      /* 【FSM_EXEC】lmm_store開始と同時にlmmd=1                                                                                           */
      /* lmmi.v rw  f  p                                                                                lmmo_cur      lmmi_cur             */
      /*      1  0  0  1 ... lmp       lmmoとlmmiが不一致ならexecと同時にloadする                       prefetch/--   reuse/prefetch       */
      /*      1  1  0  0 ... lmw                                                                        --            store:d=1            */
      /*      1  1  0  1 ... lmd       lmmd=1のみ,execと同時にdrain.終了時にlmmd=0                      store:d=1     d=1時のみdrain       */
      /*                               最後のlmdを追い出すためには明示的drain指示(startとは別コマンド)が必要                               */
      /*************************************************************************************************************************************/
    case STATUS_DRAIN:
      emax5[cid].cycles_drain_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {
	  switch ((emax5[cid].fsm[j].lmmo[j].v<<3)|(emax5[cid].fsm[j].lmmo[i].rw<<2)|(emax5[cid].fsm[j].lmmo[i].f<<1)|(emax5[cid].fsm[j].lmmo[i].p)) {
	    /* v | rw | f | p */
	  case 12: /* lmw */
	  case 14: /* lmx */
	    if (emax5[cid].fsm[j].lmmd[i]) /* dirty exist */
	      flag = 1; /* drain */
	    else
	      flag = 0; /* skip drain */
	    break;
	  default:
	    flag = 0; /* skip drain */
	    break;
	  }

	  if (flag) {
	    Uint lmm_nreq;
	    switch (emax5[cid].fsm[j].memif_status) {
	    case MEMIF_AREQ:
	      emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[j].ardyc = 0; /* LMM addr-request(read/write) counter */
	      emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read) counter */
	      emax5[cid].fsm[j].waddr = emax5[cid].fsm[j].lmmo[i].top;
	      emax5[cid].fsm[j].wlen  = emax5[cid].fsm[j].lmmo[i].len;
	      break;
	    case MEMIF_DREQ:
	      /* block 0:inf, 1:16, 2:32, 3:64 dword*UNIT_WIDTH*block=page(burst_size)    */
	      /* 通常は,     block=0                                                      */
	      /* tricountは, block=2                                                      */
	      /* EMAX5では必ず64bit*4幅                                                   */
	      /* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	      /* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	      /* align=32B, block=0, blocking=none             ... align済 4倍幅load      */
	      /* --- blocking-load --- : fsmがblock単位にburst起動                        */
	      /* align=xxx, block=1, blocksize=8*4*16=512B     ... 下位5bit無視 4倍幅load */
	      /* align=xxx, block=2, blocksize=8*4*32=1KB      ... 下位5bit無視 4倍幅load */
	      /* align=xxx, block=3, blocksize=8*4*64=2KB      ... 下位5bit無視 4倍幅load */
	      lmm_nreq = emax5[cid].fsm[j].lmmo[i].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	      if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		emax5[cid].fsm[j].row_select = 1LL<<i;
		emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
		emax5[cid].fsm[j].lmra = emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
		if (trace) {
		  printf("%03.3d:siml_emax5: drain row=%d col=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			 tid, i, j, (Uint)(emax5[cid].fsm[j].lmra>>32), (Uint)emax5[cid].fsm[j].lmra, emax5[cid].fsm[j].ardyc, lmm_nreq);
		}
		emax5[cid].fsm[j].ardyc++;
	      }
	      else
		emax5[cid].fsm[j].row_lmm_en = 0LL; /* row_selectは残りrrdyのために維持 */
	      if (emax5[cid].fsm[j].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		if (unit[cid][i][j].rrdy) { /* ack from lmm */
		  for (k=0; k<UNIT_WIDTH; k++)
		    *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k];
		  if (trace) {
		    printf("%03.3d:siml_emax5: drain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
		  }
		  emax5[cid].fsm[j].rrdyc++;
		}
	      }
	      else {
		emax5[cid].fsm[j].lmmd[i] = 0;
		emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		emax5[cid].fsm[j].row_count++;
		emax5[cid].fsm[j].row_select   = 0LL;
		emax5[cid].fsm[j].row_lmm_en   = 0LL;
	      }
	      break;
	    }
	  }
	  else {
	    emax5[cid].fsm[j].row_count++;
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_DRAIN finished */
	emax5[cid].status = STATUS_LOAD;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	  emax5[cid].fsm[j].row_lmm_en   = 0LL;
	}
      }
      break;
    case STATUS_LOAD:
      emax5[cid].cycles_load_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {
	  switch ((emax5[cid].fsm[j].lmmc[i].v<<3)|(emax5[cid].fsm[j].lmmc[i].rw<<2)|(emax5[cid].fsm[j].lmmc[i].f<<1)|(emax5[cid].fsm[j].lmmc[i].p)) {
	    /* v | rw | f | p */
	  case  8: /* lmr */
	    if (emax5[cid].fsm[j].lmmo[i].v
             && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
             && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
      	     && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top) {
	      if (trace)
		printf("%03.3d:siml_emax5: load row=%d col=%d top=%08.8x_%08.8x found in LMM\n",
		       tid, i, j, (Uint)(emax5[cid].fsm[j].lmmc[i].top>>32), (Uint)emax5[cid].fsm[j].lmmc[i].top);
	      flag = 0; /* skip load */
	    }
	    else
	      flag = 1; /* load */
	    break;
	  case 10: /* lmf always load */
	  case 14: /* lmx always load */
	    flag = 1; /* load */
	    break;
	  default:
	    flag = 0; /* skip load */
	    break;
	  }

	  if (flag) {
	    Uint lmm_nreq;
	    switch (emax5[cid].fsm[j].memif_status) {
	    case MEMIF_AREQ:
	      emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[j].ardyc = 0; /* LMM addr-request(read/write) counter */
	      emax5[cid].fsm[j].raddr = emax5[cid].fsm[j].lmmc[i].top;
	      emax5[cid].fsm[j].rlen  = emax5[cid].fsm[j].lmmc[i].len;
	      break;
	    case MEMIF_DREQ:
	      /* block 0:inf, 1:16, 2:32, 3:64 dword*UNIT_WIDTH*block=page(burst_size)    */
	      /* 通常は,     block=0                                                      */
	      /* tricountは, block=2                                                      */
	      /* EMAX5では必ず64bit*4幅                                                   */
	      /* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	      /* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
	      /* align=32B, block=0, blocking=none             ... align済 4倍幅load      */
	      /* --- blocking-load --- : fsmがblock単位にburst起動                        */
	      /* align=xxx, block=1, blocksize=8*4*16=512B     ... 下位5bit無視 4倍幅load */
	      /* align=xxx, block=2, blocksize=8*4*32=1KB      ... 下位5bit無視 4倍幅load */
	      /* align=xxx, block=3, blocksize=8*4*64=2KB      ... 下位5bit無視 4倍幅load */
	      lmm_nreq = emax5[cid].fsm[j].lmmc[i].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	      if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		Ull ofs;
		emax5[cid].fsm[j].row_select = 1LL<<i;
		emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
		emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
#if 1
		/*** GATHER ************/
		switch (emax5[cid].fsm[j].lmmc[i].blk) {
		case 0: /* inf */
		  ofs =        (       emax5[cid].fsm[j].lmmc[i].top                                         ) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc   )*UNIT_WIDTH;
		  break;
		case 1: /* 16 */
		  ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%16)*UNIT_WIDTH;
		  break;
		case 2: /* 32 */
		  ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%32)*UNIT_WIDTH;
		  break;
		case 3: /* 64 */
		  ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%64)*UNIT_WIDTH;
		  break;
		}
#endif
		for (k=0; k<UNIT_WIDTH; k++) {
		  emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + ofs + sizeof(Ull)*k);
		  if (trace) {
		    printf("%03.3d:siml_emax5: load row=%d col=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa,
			   k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].ardyc, lmm_nreq);
		  }
		}
		emax5[cid].fsm[j].ardyc++;
	      }
	      else {
		emax5[cid].fsm[j].lmmo[i].v   = emax5[cid].fsm[j].lmmc[i].v;
		emax5[cid].fsm[j].lmmo[i].rw  = emax5[cid].fsm[j].lmmc[i].rw;
		emax5[cid].fsm[j].lmmo[i].f   = emax5[cid].fsm[j].lmmc[i].f;
		emax5[cid].fsm[j].lmmo[i].p   = emax5[cid].fsm[j].lmmc[i].p;
		emax5[cid].fsm[j].lmmo[i].blk = emax5[cid].fsm[j].lmmc[i].blk;
		emax5[cid].fsm[j].lmmo[i].len = emax5[cid].fsm[j].lmmc[i].len;
		emax5[cid].fsm[j].lmmo[i].top = emax5[cid].fsm[j].lmmc[i].top;
		emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		emax5[cid].fsm[j].row_count++;
		emax5[cid].fsm[j].row_select   = 0LL;
		emax5[cid].fsm[j].row_lmm_en   = 0LL;
	      }
	      break;
	    }
	  }
	  else {
	    emax5[cid].fsm[j].row_count++;
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_LOAD finished */
	emax5[cid].status = STATUS_REGV;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	  emax5[cid].fsm[j].row_lmm_en   = 0LL;
	}
      }
      break;
    case STATUS_REGV:
      emax5[cid].cycles_regv_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {	
	  switch (emax5[cid].fsm[j].memif_status) {
	  case MEMIF_AREQ:
	    emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	    emax5[cid].fsm[j].ardyc = 0;
	    emax5[cid].fsm[j].raddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*j; /* conf_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[j].rlen  =      sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
	    break;
	  case MEMIF_DREQ:
	    if (emax5[cid].fsm[j].ardyc < EMAX_DEPTH*2) { /* 2rrdy/1unit */
	      emax5[cid].fsm[j].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[j].row_count)%EMAX_DEPTH);
	      emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].ardyc&1; /* even/odd */
	      for (k=0; k<UNIT_WIDTH; k++)
		emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH+k));
	      emax5[cid].fsm[j].row_count+=(emax5[cid].fsm[j].ardyc&1); /* even/odd */
	      emax5[cid].fsm[j].ardyc++;
	    }
	    else {
	      emax5[cid].fsm[j].memif_status = MEMIF_TERM;
	      emax5[cid].fsm[j].row_select   = 0LL;
	    }
	    break;
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_REGV finished */
	emax5[cid].status = STATUS_START;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	}
      }
      break;
    case STATUS_START:
      for (j=0; j<EMAX_WIDTH; j++) {
	switch (emax5[cid].fsm[j].memif_status) {
	case MEMIF_AREQ:
	  emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	  emax5[cid].fsm[j].row_select = 1LL<<emax5[cid].last_row0; /* start row */
	  break;
	case MEMIF_DREQ:
	  emax5[cid].status = STATUS_EXEC;
	  for (j=0; j<EMAX_WIDTH; j++) {
	    emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	    emax5[cid].fsm[j].row_count    = 0;
	    emax5[cid].fsm[j].row_select   = 0LL;
	  }
	  break;
	}
      }
      break;
    case STATUS_EXEC: /* simulate from stage15 to stage0, from col=3 to col=0 */
      emax5[cid].cycles_exec_part++;
      for (sync=1,j=0; j<EMAX_WIDTH; j++) {
	if (emax5[cid].unit1_exec | emax5[cid].unit2_exec) /* exec not finished */
	  sync = 0; /* not finished */
	i = emax5[cid].fsm[j].row_count;
	if (i < EMAX_DEPTH) {
	  switch ((emax5[cid].fsm[j].lmmc[i].v<<3)|(emax5[cid].fsm[j].lmmc[i].rw<<2)|(emax5[cid].fsm[j].lmmc[i].f<<1)|(emax5[cid].fsm[j].lmmc[i].p)) {
	    /* v | rw | f | p */
	  case  9: /* lmp */
	    if (emax5[cid].fsm[j].lmmo[i].v
             && emax5[cid].fsm[j].lmmo[i].blk == emax5[cid].fsm[j].lmmc[i].blk
             && emax5[cid].fsm[j].lmmo[i].len == emax5[cid].fsm[j].lmmc[i].len
      	     && emax5[cid].fsm[j].lmmo[i].top == emax5[cid].fsm[j].lmmc[i].top) {
	      if (trace)
		printf("%03.3d:siml_emax5: pload row=%d col=%d top=%08.8x_%08.8x found in LMM\n",
		       tid, i, j, (Uint)(emax5[cid].fsm[j].lmmc[i].top>>32), (Uint)emax5[cid].fsm[j].lmmc[i].top);
	      flag = 0; /* skip pload */
	    }
	    else
	      flag = 1; /* pload */
	    break;
	  case 13: /* lmd */
	    if (emax5[cid].fsm[j].lmmd[i]) /* dirty exist */
	      flag = 1; /* pdrain */
	    else
	      flag = 0; /* skip pdrain */
	    break;
	  default:
	    flag = 0; /* skip pdrain/pload */
	    break;
	  }

	  /* emax5[cid].fsm[j].lmmc[i].rw=0:pload  */
	  /* emax5[cid].fsm[j].lmmc[i].rw=1:pdrain */
	  if (flag) {
	    Uint lmm_nreq;
	    switch (emax5[cid].fsm[j].memif_status) {
	    case MEMIF_AREQ:
	      emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[j].ardyc = 0; /* LMM addr-request(read/write) counter */
	      if (emax5[cid].fsm[j].lmmc[i].rw == 0) { /* pload */
		emax5[cid].fsm[j].raddr = emax5[cid].fsm[j].lmmc[i].top;
		emax5[cid].fsm[j].rlen  = emax5[cid].fsm[j].lmmc[i].len;
	      }
	      else { /* pdrain */
		emax5[cid].fsm[j].rrdyc = 0; /* LMM data-ready(read) counter */
		emax5[cid].fsm[j].waddr = emax5[cid].fsm[j].lmmc[i].top;
		emax5[cid].fsm[j].wlen  = emax5[cid].fsm[j].lmmc[i].len;
	      }
	      break;
	    case MEMIF_DREQ:
	      lmm_nreq = emax5[cid].fsm[j].lmmc[i].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	      if (emax5[cid].fsm[j].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		Ull ofs;
		emax5[cid].fsm[j].row_select = 1LL<<i;
		emax5[cid].fsm[j].row_lmm_en = 1LL<<i;
		if (emax5[cid].fsm[j].lmmc[i].rw == 0) { /* pload */
		  emax5[cid].fsm[j].lmwa = emax5[cid].fsm[j].raddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
#if 1
		  /*** GATHER ************/
		  switch (emax5[cid].fsm[j].lmmc[i].blk) {
		  case 0: /* inf */
		    ofs =        (       emax5[cid].fsm[j].lmmc[i].top                                         ) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc   )*UNIT_WIDTH;
		    break;
		  case 1: /* 16 */
		    ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%16)*UNIT_WIDTH;
		    break;
		  case 2: /* 32 */
		    ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%32)*UNIT_WIDTH;
		    break;
		  case 3: /* 64 */
		    ofs = *(Ull*)(base + emax5[cid].fsm[j].lmmc[i].top+sizeof(Ull)*(emax5[cid].fsm[j].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[j].ardyc%64)*UNIT_WIDTH;
		    break;
		  }
#endif
		  for (k=0; k<UNIT_WIDTH; k++) {
		    emax5[cid].fsm[j].lmwd[k] = emax5[cid].fsm[j].rdata[k] = *(Ull*)(base + emax5[cid].fsm[j].raddr + ofs + sizeof(Ull)*k);
		    if (trace) {
		      printf("%03.3d:siml_emax5: pload row=%d col=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, (Uint)(emax5[cid].fsm[j].lmwa>>32), (Uint)emax5[cid].fsm[j].lmwa,
			     k, (Uint)(emax5[cid].fsm[j].lmwd[k]>>32), (Uint)emax5[cid].fsm[j].lmwd[k], emax5[cid].fsm[j].ardyc, lmm_nreq);
		    }
		  }
		}
		else { /* pdrain */
		  emax5[cid].fsm[j].lmra = emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].ardyc*UNIT_WIDTH);
		  if (trace) {
		    printf("%03.3d:siml_emax5: pdrain row=%d col=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, (Uint)(emax5[cid].fsm[j].lmra>>32), (Uint)emax5[cid].fsm[j].lmra, emax5[cid].fsm[j].ardyc, lmm_nreq);
		  }
		}
		emax5[cid].fsm[j].ardyc++;
	      }
	      else {
		if (emax5[cid].fsm[j].lmmc[i].rw == 0) { /* pload */
		  emax5[cid].fsm[j].lmmo[i].v   = emax5[cid].fsm[j].lmmc[i].v;
		  emax5[cid].fsm[j].lmmo[i].rw  = emax5[cid].fsm[j].lmmc[i].rw;
		  emax5[cid].fsm[j].lmmo[i].f   = emax5[cid].fsm[j].lmmc[i].f;
		  emax5[cid].fsm[j].lmmo[i].p   = emax5[cid].fsm[j].lmmc[i].p;
		  emax5[cid].fsm[j].lmmo[i].blk = emax5[cid].fsm[j].lmmc[i].blk;
		  emax5[cid].fsm[j].lmmo[i].len = emax5[cid].fsm[j].lmmc[i].len;
		  emax5[cid].fsm[j].lmmo[i].top = emax5[cid].fsm[j].lmmc[i].top;
		  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		  emax5[cid].fsm[j].row_count++;
		  emax5[cid].fsm[j].row_select   = 0LL;
		  emax5[cid].fsm[j].row_lmm_en   = 0LL;
		}
		else { /* pdrain */
		  emax5[cid].fsm[j].row_lmm_en = 0LL; /* row_selectは残りrrdyのために維持 */
		}
	      }
	      if (emax5[cid].fsm[j].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		if (emax5[cid].fsm[j].lmmc[i].rw == 1) { /* pdrain */
		  if (unit[cid][i][j].rrdy) { /* ack from lmm */
		    for (k=0; k<UNIT_WIDTH; k++)
		      *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k];
		    if (trace) {
		      printf("%03.3d:siml_emax5: pdrain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
		    }
		    emax5[cid].fsm[j].rrdyc++;
		  }
		}
	      }
	      else {
		if (emax5[cid].fsm[j].lmmc[i].rw == 1) { /* pdrain */
		  emax5[cid].fsm[j].lmmd[i] = 0;
		  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
		  emax5[cid].fsm[j].row_count++;
		  emax5[cid].fsm[j].row_select   = 0LL;
		  emax5[cid].fsm[j].row_lmm_en   = 0LL;
		}
	      }
	      break;
	    }
	  }
	  else {
	    emax5[cid].fsm[j].row_count++;
	  }
	  sync = 0; /* not finished */
	}
      }
      if (sync) { /* all FSM_EXEC finished */
	emax5[cid].status = STATUS_TERM;
	for (j=0; j<EMAX_WIDTH; j++) {
	  emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[j].row_count    = 0;
	  emax5[cid].fsm[j].row_select   = 0LL;
	  emax5[cid].fsm[j].row_lmm_en   = 0LL;
	}
      }
      break;
    case STATUS_TERM:
      emax5[cid].v = 0; /* unlock */
      emax5[cid].status = STATUS_IDLE;
      for (j=0; j<EMAX_WIDTH; j++) {
	emax5[cid].fsm[j].memif_status = MEMIF_AREQ;
	emax5[cid].fsm[j].row_count    = 0;
	emax5[cid].fsm[j].row_select   = 0LL;
      }
      printf("%03.3d:siml_emax5: term c=%d i=%d d=%d l=%d r=%d e=%d z=%d t=%d\n",
	     cid,
	     emax5[cid].cycles_conf_part, emax5[cid].cycles_lmmi_part, emax5[cid].cycles_drain_part, emax5[cid].cycles_load_part,
	     emax5[cid].cycles_regv_part, emax5[cid].cycles_exec_part, emax5[cid].cycles_term_part,  emax5[cid].cycles_trans_part);
      emax5[cid].cycles_conf  += emax5[cid].cycles_conf_part;
      emax5[cid].cycles_lmmi  += emax5[cid].cycles_lmmi_part;
      emax5[cid].cycles_drain += emax5[cid].cycles_drain_part;
      emax5[cid].cycles_load  += emax5[cid].cycles_load_part;
      emax5[cid].cycles_regv  += emax5[cid].cycles_regv_part;
      emax5[cid].cycles_exec  += emax5[cid].cycles_exec_part;
      emax5[cid].cycles_term  += emax5[cid].cycles_term_part;
      emax5[cid].cycles_trans += emax5[cid].cycles_trans_part;
      return (0); /* EMAX5 terminated */
    }
    /*******************************************************/
    /******************* FSM siml end **********************/
    /*******************************************************/
  }
  return (2); /* EMAX5 busy */
}

siml_unit_bus1(cid, i) Uint cid, i; /* 演算器入力までを計算 */
{
  int j, k, s;
  int pi = (i+EMAX_DEPTH-1)%EMAX_DEPTH;

  /* regv(br,ea[01][bo]r) -> c,t,ex[123],ea[bo],ea[01][bo] */
  for (j=0; j<EMAX_WIDTH; j++) { /* 0:br0_0, 1:br0_1, ... 15:3_3 */
    s = unit[cid][i][j].conf.cdw1.cs0;    unit[cid][i][j].c[0] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;
    s = unit[cid][i][j].conf.cdw1.cs1;    unit[cid][i][j].c[1] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;
    s = unit[cid][i][j].conf.cdw1.cs2;    unit[cid][i][j].c[2] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;
    s = unit[cid][i][j].conf.cdw1.cs3;    unit[cid][i][j].c[3] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH]&3;

    s = unit[cid][i][j].conf.cdw2.ts0;    unit[cid][i][j].t[0] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw2.ts1;    unit[cid][i][j].t[1] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw2.ts2;    unit[cid][i][j].t[2] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw2.ts3;    unit[cid][i][j].t[3] = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];

    s = unit[cid][i][j].conf.cdw0.ex1brs; unit[cid][i][j].ex1  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw0.ex2brs; unit[cid][i][j].ex2  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw0.ex3brs; unit[cid][i][j].ex3  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];

    s = unit[cid][i][j].conf.cdw1.eabbrs; unit[cid][i][j].eab  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];
    s = unit[cid][i][j].conf.cdw1.eaobrs; unit[cid][i][j].eao  = unit[cid][pi][s/UNIT_WIDTH].regv.br[s%UNIT_WIDTH];

    s = unit[cid][i][j].conf.cdw1.ea0bs;  unit[cid][i][j].ea0b = (s==0)?unit[cid][i][j].eab:unit[cid][i][j].regv.ea0br;
    s = unit[cid][i][j].conf.cdw1.ea0os;  unit[cid][i][j].ea0o = (s==0)?unit[cid][i][j].eao:unit[cid][i][j].regv.ea0or;
    switch (unit[cid][i][j].conf.cdw1.ea0msk) {
    case MSK_B0: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o     & 0x000000ffLL; break;
    case MSK_B1: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>> 8 & 0x000000ffLL; break;
    case MSK_B2: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>16 & 0x000000ffLL; break;
    case MSK_B3: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>24 & 0x000000ffLL; break;
    case MSK_B4: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>32 & 0x000000ffLL; break;
    case MSK_B5: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>40 & 0x000000ffLL; break;
    case MSK_B6: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>48 & 0x000000ffLL; break;
    case MSK_B7: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>56 & 0x000000ffLL; break;
    case MSK_H0: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o     & 0x0000ffffLL; break;
    case MSK_H1: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>16 & 0x0000ffffLL; break;
    case MSK_H2: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>32 & 0x0000ffffLL; break;
    case MSK_H3: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>48 & 0x0000ffffLL; break;
    case MSK_W0: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o     & 0xffffffffLL; break;
    case MSK_W1: unit[cid][i][j].ea0o = unit[cid][i][j].ea0o>>32 & 0xffffffffLL; break;
    case MSK_D0: break;
    }
    s = unit[cid][i][j].conf.cdw1.ea1bs;  unit[cid][i][j].ea1b = (s==0)?unit[cid][i][j].eab:unit[cid][i][j].regv.ea1br;
    s = unit[cid][i][j].conf.cdw1.ea1os;  unit[cid][i][j].ea1o = (s==0)?unit[cid][i][j].eao:unit[cid][i][j].regv.ea1or;
    switch (unit[cid][i][j].conf.cdw1.ea1msk) {
    case MSK_B0: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o     & 0x000000ffLL; break;
    case MSK_B1: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>> 8 & 0x000000ffLL; break;
    case MSK_B2: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>16 & 0x000000ffLL; break;
    case MSK_B3: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>24 & 0x000000ffLL; break;
    case MSK_B4: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>32 & 0x000000ffLL; break;
    case MSK_B5: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>40 & 0x000000ffLL; break;
    case MSK_B6: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>48 & 0x000000ffLL; break;
    case MSK_B7: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>56 & 0x000000ffLL; break;
    case MSK_H0: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o     & 0x0000ffffLL; break;
    case MSK_H1: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>16 & 0x0000ffffLL; break;
    case MSK_H2: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>32 & 0x0000ffffLL; break;
    case MSK_H3: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>48 & 0x0000ffffLL; break;
    case MSK_W0: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o     & 0xffffffffLL; break;
    case MSK_W1: unit[cid][i][j].ea1o = unit[cid][i][j].ea1o>>32 & 0xffffffffLL; break;
    case MSK_D0: break;
    }
  }
}

siml_unit_bus2(cid, i) Uint cid, i; /* TR入力を計算 */
{
  int j, k, s;

  /* fsm.lmw[ad],lmra <-> unit.lmw[ad],lmra */
  for (j=0; j<EMAX_WIDTH; j++) {
    unit[cid][i][j].lmen = emax5[cid].fsm[j].row_lmm_en>>i&1;
    unit[cid][i][j].lmwa = emax5[cid].fsm[j].lmwa;
    unit[cid][i][j].lmwd[0] = emax5[cid].fsm[j].lmwd[0];
    unit[cid][i][j].lmwd[1] = emax5[cid].fsm[j].lmwd[1];
    unit[cid][i][j].lmwd[2] = emax5[cid].fsm[j].lmwd[2];
    unit[cid][i][j].lmwd[3] = emax5[cid].fsm[j].lmwd[3];
    unit[cid][i][j].lmra = emax5[cid].fsm[j].lmra;
  }
  /* lmw[ad] -> (lmlo <- lmri) */
  for (j=0; j<EMAX_WIDTH; j++) { /* s=0:lmwd, s=1:lmri */
    s = unit[cid][i][j].conf.cdw2.lmlsa;  unit[cid][i][j].lmloa   = (s==0)?unit[cid][i][j].lmwa   :unit[cid][i][j].lmria;
    s = unit[cid][i][j].conf.cdw2.lmls0;  unit[cid][i][j].lmlo[0] = (s==0)?unit[cid][i][j].lmwd[0]:unit[cid][i][j].lmri[0];
    s = unit[cid][i][j].conf.cdw2.lmls1;  unit[cid][i][j].lmlo[1] = (s==0)?unit[cid][i][j].lmwd[1]:unit[cid][i][j].lmri[1];
    s = unit[cid][i][j].conf.cdw2.lmls2;  unit[cid][i][j].lmlo[2] = (s==0)?unit[cid][i][j].lmwd[2]:unit[cid][i][j].lmri[2];
    s = unit[cid][i][j].conf.cdw2.lmls3;  unit[cid][i][j].lmlo[3] = (s==0)?unit[cid][i][j].lmwd[3]:unit[cid][i][j].lmri[3];
    if (j<EMAX_WIDTH-1) { /* 左へ伝搬 */
      unit[cid][i][j+1].lmria   = unit[cid][i][j].lmloa;
      unit[cid][i][j+1].lmri[0] = unit[cid][i][j].lmlo[0];
      unit[cid][i][j+1].lmri[1] = unit[cid][i][j].lmlo[1];
      unit[cid][i][j+1].lmri[2] = unit[cid][i][j].lmlo[2];
      unit[cid][i][j+1].lmri[3] = unit[cid][i][j].lmlo[3];
    }
  }
  /* lmw[ad] -> (lmli -> lmro) */
  for (j=EMAX_WIDTH-1; j>=0; j--) { /* s=0:lmwd, s=1:lmli */
    s = unit[cid][i][j].conf.cdw2.lmrsa;  unit[cid][i][j].lmroa   = (s==0)?unit[cid][i][j].lmwa   :unit[cid][i][j].lmlia;
    s = unit[cid][i][j].conf.cdw2.lmrs0;  unit[cid][i][j].lmro[0] = (s==0)?unit[cid][i][j].lmwd[0]:unit[cid][i][j].lmli[0];
    s = unit[cid][i][j].conf.cdw2.lmrs1;  unit[cid][i][j].lmro[1] = (s==0)?unit[cid][i][j].lmwd[1]:unit[cid][i][j].lmli[1];
    s = unit[cid][i][j].conf.cdw2.lmrs2;  unit[cid][i][j].lmro[2] = (s==0)?unit[cid][i][j].lmwd[2]:unit[cid][i][j].lmli[2];
    s = unit[cid][i][j].conf.cdw2.lmrs3;  unit[cid][i][j].lmro[3] = (s==0)?unit[cid][i][j].lmwd[3]:unit[cid][i][j].lmli[3];
    if (j>0) { /* 右へ伝搬 */
      unit[cid][i][j-1].lmlia   = unit[cid][i][j].lmroa;
      unit[cid][i][j-1].lmli[0] = unit[cid][i][j].lmro[0];
      unit[cid][i][j-1].lmli[1] = unit[cid][i][j].lmro[1];
      unit[cid][i][j-1].lmli[2] = unit[cid][i][j].lmro[2];
      unit[cid][i][j-1].lmli[3] = unit[cid][i][j].lmro[3];
    }
  }
}

siml_unit_cex(cid, i, j) Uint cid, i, j; /* reg更新がないので最初に実行 */
{
  Uint op_cx;
  Ull c3, c2, c1, c0;
  Ushort pattern;
  Ull ex;

  /* c -> cexd */
  switch (emax5[cid].status) {
  case STATUS_IDLE:
  case STATUS_CONF:
  case STATUS_LMMI:
  case STATUS_DRAIN:
  case STATUS_LOAD:
  case STATUS_REGV:
  case STATUS_START:
    return (0);
  case STATUS_EXEC:
    if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active */
      unit[cid][i][j].cexd = 0; /* always non-exec */
    else { /* active */
      op_cx   = unit[cid][i][j].conf.cdw1.cop;
      c0      = unit[cid][i][j].c[0];
      c1      = unit[cid][i][j].c[1];
      c2      = unit[cid][i][j].c[2];
      c3      = unit[cid][i][j].c[3];
      pattern = unit[cid][i][j].conf.cdw1.cex_tab;
      cex(op_cx, c3, c2, c1, c0, pattern, &ex);
      unit[cid][i][j].cexd = ex;
    }
    return (0);
  case STATUS_TERM:
    return (0);
  }
}

siml_unit_exe(cid, i, j) Uint cid, i, j; /* 全bus計算後にreg更新 */
{
  Uint op_ex1, op_ex2, op_ex3;
  Ull  r1, r2, r3, r4, r5;
  Uint exp1, exp2, exp3;
  Ull  d;

  /* ex[123] -> exdr */
  switch (emax5[cid].status) {
  case STATUS_IDLE:
  case STATUS_CONF:
  case STATUS_LMMI:
  case STATUS_DRAIN:
  case STATUS_LOAD:
  case STATUS_REGV:
  case STATUS_START:
    return (0);
  case STATUS_EXEC:
    if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active */
      unit[cid][i][j].exdr = 0LL; /* always non-exec */
    else { /* active */
      op_ex1 = unit[cid][i][j].conf.cdw0.op1;
      op_ex2 = unit[cid][i][j].conf.cdw0.op2;
      op_ex3 = unit[cid][i][j].conf.cdw0.op3;
      r1     = (!unit[cid][i][j].conf.cdw0.ex1s || !unit[cid][i][j].one_shot)
             ? unit[cid][i][j].ex1 : unit[cid][i][j].exdr; /* self_loop */
      r2     = unit[cid][i][j].ex2;
      r3     = unit[cid][i][j].ex3;
      r4     = unit[cid][i][j].conf.cdw0.e2is==0 ? unit[cid][i][j].conf.cdw0.e2imm
	     : unit[cid][i][j].conf.cdw0.e2is==1 ? unit[cid][i][j].ex2
             :                                     unit[cid][i][j].ex3;
      r5     = unit[cid][i][j].conf.cdw0.e3is==0 ? unit[cid][i][j].conf.cdw0.e3imm
             :                                     unit[cid][i][j].ex3;
      exp1   = unit[cid][i][j].conf.cdw0.ex1exp;
      exp2   = unit[cid][i][j].conf.cdw0.ex2exp;
      exp3   = unit[cid][i][j].conf.cdw0.ex3exp;
      exe(op_ex1, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5, &d);
      unit[cid][i][j].exdr = d;
    }
    return (0);
  case STATUS_TERM:
    return (0);
  }
}

siml_unit_eag(cid, i, j) Uint cid, i, j; /* 全bus計算後にreg更新 */
{
  Ull base0, offs0;
  Ull base1, offs1;

  /* ea[01][bo] -> ea[01]dr,ma */
  switch (emax5[cid].status) {
  case STATUS_IDLE:
  case STATUS_CONF:
  case STATUS_LMMI:
    return (0);
  case STATUS_DRAIN: /* fsm drain */
    if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
      unit[cid][i][j].lmm.en1 = 1;
      unit[cid][i][j].lmm.rw1 = 0; /* read */
      unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = emax5[cid].fsm[j].lmra;
    }
    else
      unit[cid][i][j].lmm.en1 = 0;
    return (0);
  case STATUS_LOAD: /* fsm pload */
    if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
      unit[cid][i][j].lmm.en0 = 1;
      unit[cid][i][j].lmm.rw0 = 1; /* write */
      unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = emax5[cid].fsm[j].lmwa;
    }
    else
      unit[cid][i][j].lmm.en0 = 0;
    return (0);
  case STATUS_REGV:
  case STATUS_START:
    return (0);
  case STATUS_EXEC:
    /* fsm pload */
    if (unit[cid][i][j].conf.cdw1.ea0op == OP_IMLD_PREF) {
      if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
	unit[cid][i][j].lmm.en0 = 1;
	unit[cid][i][j].lmm.rw0 = 1; /* write */
	unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = emax5[cid].fsm[j].lmwa;
      }
      else
	unit[cid][i][j].lmm.en0 = 0;
    }
    else if (unit[cid][i][j].conf.cdw1.ea0op) { /* normal load/store */
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
	base0 = (!unit[cid][i][j].conf.cdw1.ea0bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
	offs0 = (!unit[cid][i][j].conf.cdw1.ea0bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
	eag(&unit[cid][i][j].ea0dr, base0, offs0, unit[cid][i][j].conf.cdw1.ea0msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
	unit[cid][i][j].lmm.en0 = 1;
	unit[cid][i][j].lmm.rw0 = (unit[cid][i][j].conf.cdw1.ea0op & 0x10)!=0; /* read/write */
	unit[cid][i][j].axra = unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr;
      }
      else /* inactive */
	unit[cid][i][j].lmm.en0 = 0;
    }
    else /* inactive */
      unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = 0LL; /* always non-exec */

    /* fsm drain */
    if (unit[cid][i][j].conf.cdw1.ea1op == OP_IMST_DRAIN) {
      if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
	unit[cid][i][j].lmm.en1 = 1;
	unit[cid][i][j].lmm.rw1 = 0; /* read */
	unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = emax5[cid].fsm[j].lmra;
      }
      else
	unit[cid][i][j].lmm.en1 = 0;
    }
    else if (unit[cid][i][j].conf.cdw1.ea1op) { /* normal load */
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
	base1 = (!unit[cid][i][j].conf.cdw1.ea1bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
	offs1 = (!unit[cid][i][j].conf.cdw1.ea1bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
	eag(&unit[cid][i][j].ea1dr, base1, offs1, unit[cid][i][j].conf.cdw1.ea1msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
	unit[cid][i][j].lmm.en1 = 1;
	unit[cid][i][j].lmm.rw1 = 0; /* read */
	unit[cid][i][j].axwa = unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr;
      }
      else /* inactive */
	unit[cid][i][j].lmm.en1 = 0;
    }
    else /* inactive */
      unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = 0LL; /* always non-exec */
    return (0);
  case STATUS_TERM:
    return (0);
  }
}

siml_unit_trg(cid, i, j) Uint cid, i, j; /* 全bus計算後にtr更新 */
{
  int k;

  /* update: exdr,t,lmwd,lmlio/lmrio -> tr,mw */
  switch (emax5[cid].status) {
  case STATUS_IDLE:
    return (0);
  case STATUS_CONF:
    if (emax5[cid].fsm[j].row_select & (1LL<<i)) {
      for (k=0; k<UNIT_WIDTH; k++)
	*((Ull*)&unit[cid][i][j].conf+k) = emax5[cid].fsm[j].lmwd[k];
    }
    return (0);
  case STATUS_LMMI:
    return (0);
  case STATUS_DRAIN:
    return (0);
  case STATUS_LOAD:
    if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
      for (k=0; k<UNIT_WIDTH; k++)
	unit[cid][i][j].lmm.mw[k] = unit[cid][i][j].tr[k] = emax5[cid].fsm[j].lmwd[k];    
    }
    return (0);
  case STATUS_REGV:
    if (emax5[cid].fsm[j].row_select & (1LL<<i)) {
      for (k=0; k<UNIT_WIDTH; k++) {
	switch (emax5[cid].fsm[j].lmwa) {
	case 0: /* lower */
	  *((Ull*)&unit[cid][i][j].regv+0+k) = emax5[cid].fsm[j].lmwd[k];
	  break;
	case 1: /* upper */
	  *((Ull*)&unit[cid][i][j].regv+4+k) = emax5[cid].fsm[j].lmwd[k];
	  break;
	}
      }
    }
    return (0);
  case STATUS_START:
    return (0);
  case STATUS_EXEC:
    /* fsm pload */
    if (unit[cid][i][j].conf.cdw1.ea0op == OP_IMLD_PREF) {
      if (emax5[cid].fsm[j].row_lmm_en & (1LL<<i)) {
	for (k=0; k<UNIT_WIDTH; k++)
	  unit[cid][i][j].lmm.mw[k] = unit[cid][i][j].tr[k] = emax5[cid].fsm[j].lmwd[k];
      }
    }
    else if (unit[cid][i][j].conf.cdw1.ea0op & 0x10) { /* normal store */
      if (emax5[cid].unit1_exec & (1LL<<i)) { /* active */
	/* 0:exdr, 1:exdr0, 2:ts0, 3:lmli0, 4:lmwd0, 5:lmri0 */
	unit[cid][i][j].tr[0] = unit[cid][i][j].conf.cdw2.trs0==0 ? unit[cid][i][j].exdr
                              : unit[cid][i][j].conf.cdw2.trs0==1 ? unit[cid][i][0].exdr
                              : unit[cid][i][j].conf.cdw2.trs0==2 ? unit[cid][i][j].t[0]
                              : unit[cid][i][j].conf.cdw2.trs0==3 ? unit[cid][i][j].lmli[0]
                              : unit[cid][i][j].conf.cdw2.trs0==4 ? unit[cid][i][j].lmwd[0]
                              : unit[cid][i][j].conf.cdw2.trs0==5 ? unit[cid][i][j].lmri[0]
                              :                                     0LL;
	unit[cid][i][j].tr[1] = unit[cid][i][j].conf.cdw2.trs1==0 ? unit[cid][i][j].exdr
                              : unit[cid][i][j].conf.cdw2.trs1==1 ? unit[cid][i][1].exdr
                              : unit[cid][i][j].conf.cdw2.trs1==2 ? unit[cid][i][j].t[1]
                              : unit[cid][i][j].conf.cdw2.trs1==3 ? unit[cid][i][j].lmli[1]
                              : unit[cid][i][j].conf.cdw2.trs1==4 ? unit[cid][i][j].lmwd[1]
                              : unit[cid][i][j].conf.cdw2.trs1==5 ? unit[cid][i][j].lmri[1]
                              :                                     0LL;
	unit[cid][i][j].tr[2] = unit[cid][i][j].conf.cdw2.trs2==0 ? unit[cid][i][j].exdr
                              : unit[cid][i][j].conf.cdw2.trs2==1 ? unit[cid][i][2].exdr
                              : unit[cid][i][j].conf.cdw2.trs2==2 ? unit[cid][i][j].t[2]
                              : unit[cid][i][j].conf.cdw2.trs2==3 ? unit[cid][i][j].lmli[2]
                              : unit[cid][i][j].conf.cdw2.trs2==4 ? unit[cid][i][j].lmwd[2]
                              : unit[cid][i][j].conf.cdw2.trs2==5 ? unit[cid][i][j].lmri[2]
                              :                                     0LL;
	unit[cid][i][j].tr[3] = unit[cid][i][j].conf.cdw2.trs3==0 ? unit[cid][i][j].exdr
                              : unit[cid][i][j].conf.cdw2.trs3==1 ? unit[cid][i][3].exdr
                              : unit[cid][i][j].conf.cdw2.trs3==2 ? unit[cid][i][j].t[3]
                              : unit[cid][i][j].conf.cdw2.trs3==3 ? unit[cid][i][j].lmli[3]
                              : unit[cid][i][j].conf.cdw2.trs3==4 ? unit[cid][i][j].lmwd[3]
                              : unit[cid][i][j].conf.cdw2.trs3==5 ? unit[cid][i][j].lmri[3]
                              :                                     0LL;
	for (k=0; k<UNIT_WIDTH; k++)
	  unit[cid][i][j].lmm.mw[k] = unit[cid][i][j].tr[k];
      }
    }
    unit[cid][i][j].one_shot = 1; /* set one_shot here */
    return (0);
  case STATUS_TERM:
    return (0);
  }
}

siml_unit_lmm(cid,  i, j) Uint cid, i, j; /* 旧TR/旧EADRを使ったLMM動作 & TR更新 */
{
  Uint a, s, d, k, cycles = 0;

  /* write:  mw,ma                                -> LMM     */
  /* read:   exdr,mw/tr,ma/ea[01]dr,LMM -> mr[01] -> br,lmrd */
  switch (emax5[cid].status) {
  case STATUS_IDLE:
  case STATUS_CONF:
  case STATUS_LMMI:
  case STATUS_DRAIN:
  case STATUS_LOAD:
  case STATUS_REGV:
  case STATUS_START:
  case STATUS_EXEC:
  case STATUS_TERM:
    return (0);
@


1.45
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.44 2016/04/11 14:08:36 nakashim Exp nakashim $";
d1198 1
a1207 2
    
      /*------------------------ここまで----------------------------*/
d1210 4
a1213 1
      /*------------------------ここまで----------------------------*/
d1217 3
a1219 2
      if (emax5[cid].fsm[j].lmwa == 0) { /* lower */
	for (k=0; k<UNIT_WIDTH; k++)
d1221 2
a1222 3
      }
      else { /* upper */
	for (k=0; k<UNIT_WIDTH; k++)
d1224 2
d1232 43
a1278 41

  if (!(emax5[cid].unit1_exec & (1LL<<i))) { /* non-active */
    for (k=0; k<UNIT_WIDTH; k++)
      unit[cid][i][j].tr[k] = 0LL; /* always non-exec */
  }
  else { /* active */
    /* 0:exdr, 1:exdr0, 2:ts0, 3:lmli0, 4:lmwd0, 5:lmri0 */
    unit[cid][i][j].tr[0] = unit[cid][i][j].conf.cdw2.trs0==0 ? unit[cid][i][j].exdr
                          : unit[cid][i][j].conf.cdw2.trs0==1 ? unit[cid][i][0].exdr
                          : unit[cid][i][j].conf.cdw2.trs0==2 ? unit[cid][i][j].t[0]
                          : unit[cid][i][j].conf.cdw2.trs0==3 ? unit[cid][i][j].lmli[0]
                          : unit[cid][i][j].conf.cdw2.trs0==4 ? unit[cid][i][j].lmwd[0]
                          : unit[cid][i][j].conf.cdw2.trs0==5 ? unit[cid][i][j].lmri[0]
                          :                                     0LL;
    unit[cid][i][j].tr[1] = unit[cid][i][j].conf.cdw2.trs1==0 ? unit[cid][i][j].exdr
                          : unit[cid][i][j].conf.cdw2.trs1==1 ? unit[cid][i][1].exdr
                          : unit[cid][i][j].conf.cdw2.trs1==2 ? unit[cid][i][j].t[1]
                          : unit[cid][i][j].conf.cdw2.trs1==3 ? unit[cid][i][j].lmli[1]
                          : unit[cid][i][j].conf.cdw2.trs1==4 ? unit[cid][i][j].lmwd[1]
                          : unit[cid][i][j].conf.cdw2.trs1==5 ? unit[cid][i][j].lmri[1]
                          :                                     0LL;
    unit[cid][i][j].tr[2] = unit[cid][i][j].conf.cdw2.trs2==0 ? unit[cid][i][j].exdr
                          : unit[cid][i][j].conf.cdw2.trs2==1 ? unit[cid][i][2].exdr
                          : unit[cid][i][j].conf.cdw2.trs2==2 ? unit[cid][i][j].t[2]
                          : unit[cid][i][j].conf.cdw2.trs2==3 ? unit[cid][i][j].lmli[2]
                          : unit[cid][i][j].conf.cdw2.trs2==4 ? unit[cid][i][j].lmwd[2]
                          : unit[cid][i][j].conf.cdw2.trs2==5 ? unit[cid][i][j].lmri[2]
                          :                                     0LL;
    unit[cid][i][j].tr[3] = unit[cid][i][j].conf.cdw2.trs3==0 ? unit[cid][i][j].exdr
                          : unit[cid][i][j].conf.cdw2.trs3==1 ? unit[cid][i][3].exdr
                          : unit[cid][i][j].conf.cdw2.trs3==2 ? unit[cid][i][j].t[3]
                          : unit[cid][i][j].conf.cdw2.trs3==3 ? unit[cid][i][j].lmli[3]
                          : unit[cid][i][j].conf.cdw2.trs3==4 ? unit[cid][i][j].lmwd[3]
                          : unit[cid][i][j].conf.cdw2.trs3==5 ? unit[cid][i][j].lmri[3]
                          :                                     0LL;
    unit[cid][i][j].lmm.mw[0] = unit[cid][i][j].tr[0];
    unit[cid][i][j].lmm.mw[1] = unit[cid][i][j].tr[1];
    unit[cid][i][j].lmm.mw[2] = unit[cid][i][j].tr[2];
    unit[cid][i][j].lmm.mw[3] = unit[cid][i][j].tr[3];
    unit[cid][i][j].one_shot = 1; /* set one_shot here */
  }
@


1.44
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.43 2016/04/11 12:05:21 nakashim Exp nakashim $";
a1212 2


d1214 10
@


1.43
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.42 2016/04/11 12:00:01 nakashim Exp nakashim $";
a88 1

d129 3
a131 1
  Ull   rrdy         : 1;  /* wire *//* LMM data-valid for FSM */
d150 10
a159 6
    Ull   ma0;             /* internal reg  */
    Ull   ma1;             /* internal reg  */
    Ull   mw[UNIT_WIDTH];  /* internal reg  */
    Ull   mr0[UNIT_WIDTH]; /* internal wire */
    Ull   mr1[UNIT_WIDTH]; /* internal wire */
    Uchar m[LMEM_SIZE];    /* local memory  */
d982 1
d1114 4
a1117 2
  case STATUS_DRAIN:
    if (emax5[cid].fsm[j].row_select & (1LL<<i)) {
d1120 2
d1123 4
a1126 2
  case STATUS_LOAD:
    if (emax5[cid].fsm[j].row_select & (1LL<<i)) {
d1129 2
d1136 21
a1156 3
    if (!(emax5[cid].unit1_exec & (1LL<<i))) { /* non-active */
      unit[cid][i][j].axra = unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr = 0LL; /* always non-exec */
      unit[cid][i][j].axwa = unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr = 0LL; /* always non-exec */
d1158 24
a1181 9
    else { /* active */
      base0 = (!unit[cid][i][j].conf.cdw1.ea0bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
      offs0 = (!unit[cid][i][j].conf.cdw1.ea0bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
      base1 = (!unit[cid][i][j].conf.cdw1.ea1bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
      offs1 = (!unit[cid][i][j].conf.cdw1.ea1bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
      eag(&unit[cid][i][j].ea0dr, base0, offs0, unit[cid][i][j].conf.cdw1.ea0msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
      eag(&unit[cid][i][j].ea1dr, base1, offs1, unit[cid][i][j].conf.cdw1.ea1msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
      unit[cid][i][j].axra = unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr;
      unit[cid][i][j].axwa = unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr;
d1183 2
d1203 1
a1203 1
    break;
d1205 1
d1209 1
d1211 1
d1216 1
d1220 1
a1220 1
    break;
d1283 1
a1283 1
    break;
@


1.42
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.41 2016/04/11 08:50:58 nakashim Exp nakashim $";
a1279 468

#if 0

siml_unit_eag(cid, i, j) Uint cid, i, j;
{
  Uint s1, s2, s3, sc;

  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax4[cid].unit_edb_cmd) {
  case 1:
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
      switch (unit[cid][i][j].edb[0].d) {
      case 0: /* cword0 */
	unit[cid][i][j].ixb[0].sel_r = (unit[cid][i][j].edb[1].d >> 0) & 0xf; /* c->ixbc0_sel_r; */
	unit[cid][i][j].ixb[1].sel_r = (unit[cid][i][j].edb[1].d >> 4) & 0xf; /* c->ixbc1_sel_r; */
	unit[cid][i][j].ixb[2].sel_r = (unit[cid][i][j].edb[1].d >> 8) & 0xf; /* c->ixbc2_sel_r; */
	unit[cid][i][j].ixb[3].sel_r = (unit[cid][i][j].edb[1].d >>12) & 0xf; /* c->ixbc3_sel_r; */
	unit[cid][i][j].edb[0].sel_r = (unit[cid][i][j].edb[1].d >>16) & 0x3; /* c->edbc0_sel_r; */
	unit[cid][i][j].edb[0].dir_r = (unit[cid][i][j].edb[1].d >>18) & 0x3; /* c->edbc0_dir_r; */
	unit[cid][i][j].edb[1].sel_r = (unit[cid][i][j].edb[1].d >>20) & 0x3; /* c->edbc1_sel_r; */
	unit[cid][i][j].edb[1].dir_r = (unit[cid][i][j].edb[1].d >>22) & 0x3; /* c->edbc1_dir_r; */
	unit[cid][i][j].edc[0].sel_r = (unit[cid][i][j].edb[1].d >>24) & 0x1; /* c->edcc0_sel_r; */
	unit[cid][i][j].edc[0].dir_r = (unit[cid][i][j].edb[1].d >>25) & 0x3; /* c->edcc0_dir_r; */
	unit[cid][i][j].edc[1].sel_r = (unit[cid][i][j].edb[1].d >>27) & 0x1; /* c->edcc1_sel_r; */
	unit[cid][i][j].edc[1].dir_r = (unit[cid][i][j].edb[1].d >>28) & 0x3; /* c->edcc1_dir_r; */
	break;
      case 1: /* cword1 */
	unit[cid][i][j].edc[2].sel_r = (unit[cid][i][j].edb[1].d >> 0) & 0x1; /* c->edcc2_sel_r; */
	unit[cid][i][j].edc[2].dir_r = (unit[cid][i][j].edb[1].d >> 1) & 0x3; /* c->edcc2_dir_r; */
	unit[cid][i][j].cnd.bit0_v   = (unit[cid][i][j].edb[1].d >> 3) & 0x1; /* c->cndc_bit0_r; */
	unit[cid][i][j].cnd.bit0_r   = (unit[cid][i][j].edb[1].d >> 4) & 0x3; /* c->cndc_bit0_r; */
	unit[cid][i][j].cnd.bit1_v   = (unit[cid][i][j].edb[1].d >> 6) & 0x1; /* c->cndc_bit1_r; */
	unit[cid][i][j].cnd.bit1_r   = (unit[cid][i][j].edb[1].d >> 7) & 0x3; /* c->cndc_bit1_r; */
	unit[cid][i][j].cnd.bit2_v   = (unit[cid][i][j].edb[1].d >> 9) & 0x1; /* c->cndc_bit2_r; */
	unit[cid][i][j].cnd.bit2_r   = (unit[cid][i][j].edb[1].d >>10) & 0x3; /* c->cndc_bit2_r; */
	unit[cid][i][j].cnd.bit3_v   = (unit[cid][i][j].edb[1].d >>12) & 0x1; /* c->cndc_bit3_r; */
	unit[cid][i][j].cnd.bit3_r   = (unit[cid][i][j].edb[1].d >>13) & 0x3; /* c->cndc_bit3_r; */
	unit[cid][i][j].cnd.table    = (unit[cid][i][j].edb[1].d >>15) & 0xffff; /* c->cndc_table; */
	break;
      case 2: /* cword2 */
	unit[cid][i][j].ex1.s1_r     = (unit[cid][i][j].edb[1].d >> 0) & 0x7; /* c->ex1c_s1_r; */
	unit[cid][i][j].ex1.s1_fhl   = (unit[cid][i][j].edb[1].d >> 3) & 0x3; /* c->ex1c_s1_fhl; */
	unit[cid][i][j].ex1.s2_r     = (unit[cid][i][j].edb[1].d >> 5) & 0x7; /* c->ex1c_s2_r; */
	unit[cid][i][j].ex1.s2_fhl   = (unit[cid][i][j].edb[1].d >> 8) & 0x3; /* c->ex1c_s2_fhl; */
	unit[cid][i][j].ex1.s3_r     = (unit[cid][i][j].edb[1].d >>10) & 0x7; /* c->ex1c_s3_r; */
	unit[cid][i][j].ex1.s3_fhl   = (unit[cid][i][j].edb[1].d >>13) & 0x3; /* c->ex1c_s3_fhl; */
	unit[cid][i][j].ex1.urZ_r    = (unit[cid][i][j].edb[1].d >>15) & 0x1; /* c->ex1c_urZ_r; */
	unit[cid][i][j].ex1.op_r     = (unit[cid][i][j].edb[1].d >>16) & 0x3f;/* c->ex1c_op_r; */
	unit[cid][i][j].ex1.px1_r    = (unit[cid][i][j].edb[1].d >>22) & 0x3; /* c->ex1c_px1_r; */
	unit[cid][i][j].ex1.px2_r    = (unit[cid][i][j].edb[1].d >>24) & 0x3; /* c->ex1c_px2_r; */
	unit[cid][i][j].ex1.x1_r     = (unit[cid][i][j].edb[1].d >>26) & 0x7; /* c->ex1c_x1_r; */
	unit[cid][i][j].ex1.x2_r     = (unit[cid][i][j].edb[1].d >>29) & 0x7; /* c->ex1c_x2_r; */
	break;
      case 3: /* cword3 */
	unit[cid][i][j].ex1.x3_r     = (unit[cid][i][j].edb[1].d >> 0) & 0x7; /* c->ex1c_x3_r; */
	unit[cid][i][j].ex2.simmS_r  = (unit[cid][i][j].edb[1].d >> 3) & 0x1fff; /* c->ex2c_simmS_r; */
	unit[cid][i][j].ex2.immT_r   = (unit[cid][i][j].edb[1].d >>16) & 0x1f; /* c->ex2c_immT_r; */
	unit[cid][i][j].ex2.s1_r     = (unit[cid][i][j].edb[1].d >>21) & 0x7; /* c->ex2c_s1_r; */
	unit[cid][i][j].ex2.s2_r     = (unit[cid][i][j].edb[1].d >>24) & 0x7; /* c->ex2c_s2_r; */
	unit[cid][i][j].ex2.s3_r     = (unit[cid][i][j].edb[1].d >>27) & 0x7; /* c->ex2c_s3_r; */
	break;
      case 4: /* cword4 */
	unit[cid][i][j].ex2.op_r     = (unit[cid][i][j].edb[1].d >> 0) & 0x7; /* c->ex2c_op_r; */
	unit[cid][i][j].ex2.sft_r    = (unit[cid][i][j].edb[1].d >> 3) & 0x7; /* c->ex2c_sft_r; */
	unit[cid][i][j].ex2.dsel_r   = (unit[cid][i][j].edb[1].d >> 6) & 0x1; /* c->ex2c_dsel_r; */
	unit[cid][i][j].ex2.x1_r     = (unit[cid][i][j].edb[1].d >> 7) & 0x3; /* c->ex2c_x1_r; */
	unit[cid][i][j].ex2.x2_r     = (unit[cid][i][j].edb[1].d >> 9) & 0x3; /* c->ex2c_x2_r; */
	unit[cid][i][j].ex2.x3_r     = (unit[cid][i][j].edb[1].d >>11) & 0x3; /* c->ex2c_x3_r; */
	unit[cid][i][j].eag.s1_r     = (unit[cid][i][j].edb[1].d >>13) & 0x7; /* c->eagc_s1_r; */
	unit[cid][i][j].eag.s2_r     = (unit[cid][i][j].edb[1].d >>16) & 0x7; /* c->eagc_s2_r; */
	unit[cid][i][j].eag.s2_suffix= (unit[cid][i][j].edb[1].d >>19) & 0x7; /* c->eagc_s2_suffix; */
	unit[cid][i][j].eag.s3_r     = (unit[cid][i][j].edb[1].d >>22) & 0x7; /* c->eagc_s3_r; */
	break;
      case 5: /* cword5 */
	unit[cid][i][j].eag.op_r     = (unit[cid][i][j].edb[1].d >> 0) & 0x3ff; /* c->eagc_op_r; */
	unit[cid][i][j].eag.x1_r     = (unit[cid][i][j].edb[1].d >>10) & 0x7; /* c->eagc_x1_r; */
	unit[cid][i][j].eag.x2_r     = (unit[cid][i][j].edb[1].d >>13) & 0x7; /* c->eagc_x2_r; */
	unit[cid][i][j].eag.x3_r     = (unit[cid][i][j].edb[1].d >>16) & 0x7; /* c->eagc_x3_r; */
	unit[cid][i][j].lmm.ssel_r   = (unit[cid][i][j].edb[1].d >>19) & 0x1; /* c->lmmc_ssel_r; */
	unit[cid][i][j].lmm.dsel_r   = (unit[cid][i][j].edb[1].d >>20) & 0x1; /* c->lmmc_dsel_r; */
	unit[cid][i][j].lmm.x1_r     = (unit[cid][i][j].edb[1].d >>21) & 0x3; /* c->lmmc_x1_r; */
	unit[cid][i][j].lmm.x2_r     = (unit[cid][i][j].edb[1].d >>23) & 0x3; /* c->lmmc_x2_r; */
	unit[cid][i][j].lmm.x3_r     = (unit[cid][i][j].edb[1].d >>25) & 0x3; /* c->lmmc_x3_r; */
	unit[cid][i][j].emb[0].sel_r = (unit[cid][i][j].edb[1].d >>27) & 0x1; /* c->embc0_sel_r; */
	unit[cid][i][j].emb[0].dir_r = (unit[cid][i][j].edb[1].d >>28) & 0x3; /* c->embc0_dir_r; */
	break;
      case 6: /* cword6 */
	unit[cid][i][j].etb[0].sel_r = (unit[cid][i][j].edb[1].d >> 0) & 0x1; /* c->etbc0_sel_r; */
	unit[cid][i][j].etb[0].dir_r = (unit[cid][i][j].edb[1].d >> 1) & 0x3; /* c->etbc0_dir_r; */
	unit[cid][i][j].etb[1].sel_r = (unit[cid][i][j].edb[1].d >> 3) & 0x1; /* c->etbc1_sel_r; */
	unit[cid][i][j].etb[1].dir_r = (unit[cid][i][j].edb[1].d >> 4) & 0x3; /* c->etbc1_dir_r; */
	unit[cid][i][j].etb[2].sel_r = (unit[cid][i][j].edb[1].d >> 6) & 0x1; /* c->etbc2_sel_r; */
	unit[cid][i][j].etb[2].dir_r = (unit[cid][i][j].edb[1].d >> 7) & 0x3; /* c->etbc2_dir_r; */
	unit[cid][i][j].etb[3].sel_r = (unit[cid][i][j].edb[1].d >> 9) & 0x1; /* c->etbc3_sel_r; */
	unit[cid][i][j].etb[3].dir_r = (unit[cid][i][j].edb[1].d >>10) & 0x3; /* c->etbc3_dir_r; */
	unit[cid][i][j].etb[4].sel_r = (unit[cid][i][j].edb[1].d >>12) & 0x1; /* c->etbc4_sel_r; */
	unit[cid][i][j].etb[4].dir_r = (unit[cid][i][j].edb[1].d >>13) & 0x3; /* c->etbc4_dir_r; */
	unit[cid][i][j].etb[5].sel_r = (unit[cid][i][j].edb[1].d >>15) & 0x1; /* c->etbc5_sel_r; */
	unit[cid][i][j].etb[5].dir_r = (unit[cid][i][j].edb[1].d >>16) & 0x3; /* c->etbc5_dir_r; */
	break;
      case 7: /* cword7 */
	unit[cid][i][j].v1           = (unit[cid][i][j].edb[1].d >> 0) & 0x1; /* c->v1; */
	unit[cid][i][j].v2           = (unit[cid][i][j].edb[1].d >> 1) & 0x1; /* c->v2; */
      }
    }
    return (0);
  case 2:
    unit[cid][i][j].one_shot = 0;
  default:
    return (0);
  case 4:
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
      unit[cid][i][j].lmm.a = unit[cid][i][j].edb[0].d;
      unit[cid][i][j].lmm.s = unit[cid][i][j].edb[1].d;
    }
    return (0);
  case 6:
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
      unit[cid][i][j].lmm.a = unit[cid][i][j].edb[0].d;
    }
    return (0);
  case 5:
    break;
  }

  if (unit[cid][i][j].v1 && ((emax4[cid].unit1_exec & (1LL<<i)))) {
    switch (unit[cid][i][j].eag.x1_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].eag.t1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p1_r;    break;
    case 4: unit[cid][i][j].eag.t1 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].eag.t1 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].eag.t1 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].eag.t1 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].eag.t1 = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].eag.x2_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].eag.t2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p2_r;    break;
    case 4: unit[cid][i][j].eag.t2 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].eag.t2 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].eag.t2 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].eag.t2 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].eag.t2 = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].eag.x3_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].eag.t3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p3_r;    break;
    case 4: unit[cid][i][j].eag.t3 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].eag.t3 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].eag.t3 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].eag.t3 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].eag.t3 = 0xffffffff;                                                  break;
    }
    
    /*************/
    /* SIML EAG */
    /*************/
    switch (unit[cid][i][j].eag.s1_r) {
    case 0: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p1_r;                                         break;
    case 1: s1 = (!unit[cid][i][j].one_shot)?unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p1_r:unit[cid][i][j].eag.d; break;
    case 2: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s1 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s1 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s1 = 0xffffffff;                                                                                       break;
    }
    switch (unit[cid][i][j].eag.s2_r) {
    case 0: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p2_r;                                         break;
    case 2: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s2 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s2 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s2 = 0xffffffff;                                                                                       break;
    }
    switch (unit[cid][i][j].eag.s3_r) {
    case 0: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p3_r;                                         break;
    case 2: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s3 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s3 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s3 = 0xffffffff;                                                                                       break;
    }
    
    switch (unit[cid][i][j].eag.s2_suffix) {
    case 1: s2 =  s2      & 0xffff; break;
    case 2: s2 =  s2 >> 16;         break;
    case 4: s2 =  s2        & 0xff; break;
    case 5: s2 = (s2 >>  8) & 0xff; break;
    case 6: s2 = (s2 >> 16) & 0xff; break;
    case 7: s2 = (s2 >> 24) & 0xff; break;
    }
    
    unit[cid][i][j].eag.d = s1 + s2;
    
    /*********************/
    /* SIML input of LMM */
    /*********************/
    switch (unit[cid][i][j].lmm.ssel_r) {
    case 0: unit[cid][i][j].lmm.s = s3;                    break;
    case 1: unit[cid][i][j].lmm.s = unit[cid][i][j].ex1.d; break; /* in real HDL, connect to the output-wire (not reg-d) of ex1 */
    default:unit[cid][i][j].lmm.s = 0xffffffff;            break;
    }
    unit[cid][i][j].lmm.a = unit[cid][i][j].eag.d; /* in real HDL, connect to the output-wire (not reg-d) of eag */
    
    unit[cid][i][j].one_shot = 1; /* for self_loop_control */
  }
}

siml_unit_lmm(cid, trace, base, i, j) Uint cid, trace, base, i, j;
{
  Uint a, s, d, k, cycles = 0;

  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax4[cid].unit_edb_cmd) {
  case 2:
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
      switch (unit[cid][i][j].edb[0].d) {
      case 2: /* lmmv_p1_r */
	unit[cid][i][j].lmm.p1_r = unit[cid][i][j].edb[1].d;
	break;
      case 3: /* lmmv_p2_r */
	unit[cid][i][j].lmm.p2_r = unit[cid][i][j].edb[1].d;
	break;
      }
    }
    break;
  }

  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax4[cid].unit_edb_cmd_d1) {
  default:
    return (0);
  case 5:
    break;
  }

  if (unit[cid][i][j].v2 && (emax4[cid].unit2_exec & (1LL<<i))) {
    switch (unit[cid][i][j].lmm.x1_r) { /* mem-output-selector 0:fixed_for_constant 1:t1_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].lmm.p1_r = unit[cid][i][j].eag.t1;                                      break;
    case 2: unit[cid][i][j].lmm.p1_r = unit[cid][i][j].etb[3].d;                                    break;
    default:unit[cid][i][j].lmm.p1_r = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].lmm.x2_r) { /* mem-output-selector 0:fixed_for_constant 1:t2_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].lmm.p2_r = unit[cid][i][j].eag.t2;                                      break;
    case 2: unit[cid][i][j].lmm.p2_r = unit[cid][i][j].etb[4].d;                                    break;
    default:unit[cid][i][j].lmm.p2_r = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].lmm.x3_r) { /* mem-output-selector 0:fixed_for_constant 1:t3_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].lmm.p3_r = unit[cid][i][j].eag.t3;                                      break;
    case 2: unit[cid][i][j].lmm.p3_r = unit[cid][i][j].etb[5].d;                                    break;
    default:unit[cid][i][j].lmm.p3_r = 0xffffffff;                                                  break;
    }
  }

  if (unit[cid][i][j].cnd.exec && unit[cid][i][j].v2 && (emax4[cid].unit2_exec & (1LL<<i))) {
    /*************/
    /* SIML LMM */
    /*************/
    switch (emax4[cid].memi_new[i].mctr0[j].v) {
      /*  0:nop,  1:LMR,  2:LMW,  3:LMX, *4:LMP,  5:LMF(force read), *6:LMD */
      /* *8:MMR  *9:MMTR */
      /* For Macro-Pipelining, LMP and LMD should be implemented here */
      /* For EMAX4, MMR and MMTR should be implemented here */
    case 4: /* LMP */
      break;
    case 6: /* LMD */
      break;
    case 8: /* MMR */
      /* mem_adr=unit[cid][i][j].eag.d         */
      /* emax4[cid].memi_new[i].mctr0[j].bank  */
      /* emax4[cid].memi_new[i].mctr0[j].width */
#if 1
      switch (emax4[cid].memi_new[i].mctr0[j].width) {
      case 0:
	unit[cid][i][j  ].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d);
	break;
      case 1:
	unit[cid][i][j  ].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d);
	unit[cid][i][j+1].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d+sizeof(Uint));
	break;
      case 2:
	unit[cid][i][j  ].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d);
	unit[cid][i][j+1].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d+sizeof(Uint));
	unit[cid][i][j+2].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d+sizeof(Uint)*2);
	unit[cid][i][j+3].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d+sizeof(Uint)*3);
	break;
      }
#endif
      break;
    case 9: /* MMTR */
#if 1
      if (trace)
	printf("MMTR start=%08.8x p0=%08.8x p1=%08.8x p2=%08.8x p3=%08.8x\n", 
	       emax4[cid].memi_new[i].mem_top[j],
	       unit[cid][i][j  ].eag.d,
	       unit[cid][i][j+1].eag.d,
	       unit[cid][i][j+2].eag.d,
	       unit[cid][i][j+3].eag.d);
      for (k=0; k<MAX_TRANS_CBL; k++) {
	if (tcu[k].tcbid == emax4[cid].memi_new[i].mem_top[j]) {
	  break;
	}
      }
      if (k==MAX_TRANS_CBL) {
	printf("MMTR registered transaction not found: start=%08.8x\n", emax4[cid].memi_new[i].mem_top[j]);
	break;
      }
      tcu[k].reg[0] = unit[cid][i][j  ].eag.d;
      tcu[k].reg[1] = unit[cid][i][j+1].eag.d;
      tcu[k].reg[2] = unit[cid][i][j+2].eag.d;
      tcu[k].reg[3] = unit[cid][i][j+3].eag.d;
      tcu[k].pc = 0;
      tcu[k].status = TCU_BUSY;
      while (tcu[k].status == TCU_BUSY) {
	struct tconf insn = tcu[k].tconf[tcu[k].pc];
	Uint b, o, adder, d, c;

	cycles++;
	/* read regs */
	switch (insn.base_type) {
	case 0:
	  b = tcu[k].reg[insn.base];
	  break;
	case 1: /* reg_adr */
	  b = tcu[k].reg[insn.base];
	  break;
	case 2: /* mem_adr */
	  b = insn.base;
	  break;
	}
	o = (insn.offset_type==0)?tcu[k].reg[insn.offset]:insn.offset;
	o = (insn.offset_suffix==0)?o:(insn.offset_suffix==4)?o&0xff:(insn.offset_suffix==5)?(o>>8)&0xff:(insn.offset_suffix==6)?(o>>16)&0xff:(o>>24);
	o = o << insn.offset_sll;
	/* adder */
	adder = b + o;
	/* mem_access */
	switch (insn.rw) {
	case 0: /* read */
	  d = (insn.base_type==0) ? adder : *(Uint*)(base+adder);
	  break;
	case 1: /* write */
	  d = (insn.reg_type==0) ? tcu[k].reg[insn.reg] : insn.reg;
	  *(Uint*)(base+adder) = d;
	  break;
	}
	/* load->operation */
	if (insn.rw==0) {
	  switch (insn.op_type) {
	  case 0: /* none */
	    tcu[k].reg[insn.reg] = d;
	    c = 1;
	    break;
	  case 1: /* + */
	    tcu[k].reg[insn.reg] = d + ((insn.op_val_type==0)?tcu[k].reg[insn.op_val]:insn.op_val);
	    c = 1;
	    break;
	  case 2: /* ?eq */
	    tcu[k].reg[insn.reg] = d;
	    c = d == ((insn.op_val_type==0)?tcu[k].reg[insn.op_val]:insn.op_val);
	    break;
	  case 3: /* ?ne */
	    tcu[k].reg[insn.reg] = d;
	    c = d != ((insn.op_val_type==0)?tcu[k].reg[insn.op_val]:insn.op_val);
	    break;
	  case 4: /* ?ge */
	    tcu[k].reg[insn.reg] = d;
	    c = d >= ((insn.op_val_type==0)?tcu[k].reg[insn.op_val]:insn.op_val);
	    break;
	  }
	}
	else
	  c = 1;
	/* check condition */
	if (c) {
	  if (insn.t_action_type == 0) { /* none */
	    tcu[k].pc++;
	    if (tcu[k].pc >= TRANS_DEPTH) {
	      printf("tcu detects ERROR in tcu[%d] pc>=TRANS_DEPTH\n", k);
	      tcu[k].status = TCU_IDLE;
	    }
	  }
	  else if (insn.t_action_type == 1) /* term */
	    tcu[k].status = TCU_IDLE;
	  else if (insn.t_action_type == 2) { /* error */
	    printf("tcu detects ERROR in tcu[%d] pc=%d\n", k, tcu[k].pc);
	    tcu[k].status = TCU_IDLE;
	  }
	  else /* goto */
	    tcu[k].pc = insn.t_action;
	}
	else {
	  if (insn.f_action_type == 0) { /* none */
	    tcu[k].pc++;
	    if (tcu[k].pc >= TRANS_DEPTH) {
	      printf("tcu detects ERROR in tcu[%d] pc>=TRANS_DEPTH\n", k);
	      tcu[k].status = TCU_IDLE;
	    }
	  }
	  else if (insn.f_action_type == 1) /* term */
	    tcu[k].status = TCU_IDLE;
	  else if (insn.f_action_type == 2) { /* error */
	    printf("tcu detects ERROR in tcu[%d] pc=%d\n", k, tcu[k].pc);
	    tcu[k].status = TCU_IDLE;
	  }
	  else /* goto */
	    tcu[k].pc = insn.f_action;
	}
      }
#endif
      break;
    default:
      if (unit[cid][i][j].eag.op_r && unit[cid][i][j].eag.op_r<=OP_LD) {
	if (unit[cid][i][j].emb[0].sel_r==1)
	  d = unit[cid][i][j].emb[0].d;
	else if (unit[cid][i][j].lmm.dsel_r==0) /* lmm-selector 0:lmm direct 1:fifo */
	  d = unit[cid][i][j].lmm.o;
	else
	  d = lmm_fifo_access(cid, i, j, MEM_RD);
	switch (unit[cid][i][j].eag.op_r) {
	case OP_LDB:    unit[cid][i][j].lmm.d =  (int)(char)((d >> ((unit[cid][i][j].eag.d&3)*8))&  0xff); break;
	case OP_LDUB:   unit[cid][i][j].lmm.d =             ((d >> ((unit[cid][i][j].eag.d&3)*8))&  0xff); break;
	case OP_LDH:    unit[cid][i][j].lmm.d = (int)(short)((d >> ((unit[cid][i][j].eag.d&3)*8))&0xffff); break;
	case OP_LDUH:   unit[cid][i][j].lmm.d =             ((d >> ((unit[cid][i][j].eag.d&3)*8))&0xffff); break;
	case OP_LD:     unit[cid][i][j].lmm.d =               d;                                           break;
	default:                                                                                           break;
	}
      }
      break;
    }
  }
  return (cycles);
}

lmm_mem_access(cid, i, j, rw) Uint cid, i, j, rw;
{
  Uint k, a, s, bm, *wr;
  Ull rd;

  a = unit[cid][i][j].lmm.a;

  switch (rw) {
  case MEM_RD:
    if (emax4[cid].unit_edb_cmd_d1 == 6) /* lmm_drain */
      rd = *(Uint*)&unit[cid][i][j].lmm.m[a&(LMEM_SIZE-1)&~3];
    else if (unit[cid][i][j].lmm.dsel_r==0) /* lmm-selector 0:lmm direct 1:fifo */
      rd = *(Uint*)&unit[cid][i][j].lmm.m[a&(LMEM_SIZE-1)&~3];
    else /* fifo */
      rd = 0xffffffff; /* do nothing */
    return (rd);
  case MEM_WR:
    if (emax4[cid].unit_edb_cmd_d1 == 4) /* lmm_load */
      *(Uint*)&unit[cid][i][j].lmm.m[a&(LMEM_SIZE-1)&~3] = unit[cid][i][j].lmm.s;
    else {
      s = (Uint)unit[cid][i][j].lmm.s;
      wr = (Uint*)&unit[cid][i][j].lmm.m[a&(LMEM_SIZE-1)&~3];
      switch (unit[cid][i][j].eag.op_r) {
      case OP_STB: bm =   0xff<<((a&3)*8);      *wr = (*wr&~bm)|((s<<((a&3)*8))&bm); break;
      case OP_STH: bm = 0xffff<<((a&3)*8);      *wr = (*wr&~bm)|((s<<((a&3)*8))&bm); break;
      case OP_ST:                               *wr =             s<<((a&3)*8);      break;
      default:                                                                       break;
      }
    }
    return (0);
  default:
    return (0xffffffff);
  }
}
#endif
@


1.41
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.40 2016/04/11 07:51:41 nakashim Exp nakashim $";
d129 1
d137 1
d889 8
a896 8
      emax5[cid].cycles_conf     += emax5[cid].cycles_conf_part;
      emax5[cid].cycles_lmmi     += emax5[cid].cycles_lmmi_part;
      emax5[cid].cycles_drain    += emax5[cid].cycles_drain_part;
      emax5[cid].cycles_load     += emax5[cid].cycles_load_part;
      emax5[cid].cycles_regv     += emax5[cid].cycles_regv_part;
      emax5[cid].cycles_exec     += emax5[cid].cycles_exec_part;
      emax5[cid].cycles_term     += emax5[cid].cycles_term_part;
      emax5[cid].cycles_trans    += emax5[cid].cycles_trans_part;
d975 9
d1110 1
a1110 2
      unit[cid][i][j].ea1dr = emax5[cid].fsm[j].lmra;
      unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr;
d1114 4
d1123 2
a1124 2
      unit[cid][i][j].ea0dr = 0LL; /* always non-exec */
      unit[cid][i][j].ea1dr = 0LL; /* always non-exec */
d1133 2
a1134 2
      unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr;
      unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr;
@


1.40
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.39 2016/04/11 03:46:19 nakashim Exp nakashim $";
d88 1
a88 1
    Ull   lmm_en          :64; /* lmm enable for read/write */
a325 1
	      emax5[cid].fsm[j].row_select = 0LL;
d327 1
a372 1
	      emax5[cid].fsm[j].row_select = 0LL;
d374 1
d503 1
d512 1
a512 1
		emax5[cid].fsm[j].row_select = 0LL;
d514 1
a514 1
		if (emax5[cid].fsm[j].rrdy) { /* ack from lmm */
d528 2
d546 1
d604 1
a640 1
		emax5[cid].fsm[j].row_select = 0LL;
d643 2
d661 1
a686 1
	      emax5[cid].fsm[j].row_select = 0LL;
d688 1
d708 1
a709 1
	  emax5[cid].fsm[j].memif_status = MEMIF_DREQ;
d778 1
a824 1
		  emax5[cid].fsm[j].row_select = 0LL;
d827 2
d831 1
a831 1
		  emax5[cid].fsm[j].row_select = 0LL;
d836 8
a843 5
		  for (k=0; k<UNIT_WIDTH; k++)
		    *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k];
		  if (trace) {
		    printf("%03.3d:siml_emax5: pdrain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
a844 1
		  emax5[cid].fsm[j].rrdyc++;
d852 2
d871 1
@


1.39
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.38 2016/04/10 14:10:46 nakashim Exp nakashim $";
d88 2
a90 1
    Uint  rrdy;                /* LMM data-ready(read) from row_select */
d129 1
d253 2
d256 6
a261 6
	emax5[cid].unit2_stop |=                                        ( prev1_stop           &(1LL<<  i                          ))                                            ? (1LL<<i): 0;
	emax5[cid].unit1_stop |=                                        ( prev2_stop           &(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))                                            ? (1LL<<i): 0;
	emax5[cid].unit2_exec &=                                        (                                                                       emax5[cid].unit2_stop&(1LL<<i))  ?~(1LL<<i):~0;
	emax5[cid].unit2_exec |=                                        ((emax5[cid].unit1_exec&(1LL<<  i                               )) && !(emax5[cid].unit2_stop&(1LL<<i))) ? (1LL<<i): 0;
	emax5[cid].unit1_exec &=                                        (                                                                       emax5[cid].unit1_stop&(1LL<<i )) ?~(1LL<<i):~0;
	emax5[cid].unit1_exec |= ((emax5[cid].fsm[0].row_select&(1LL<<i)) || ((emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))) && !(emax5[cid].unit1_stop&(1LL<<i))))? (1LL<<i): 0;
d513 8
a520 5
		for (k=0; k<UNIT_WIDTH; k++)
		  *(Ull*)(base + emax5[cid].fsm[j].waddr + sizeof(Ull)*(emax5[cid].fsm[j].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[j].wdata[k] = emax5[cid].fsm[j].lmrd[k];
		if (trace) {
		  printf("%03.3d:siml_emax5: drain row=%d col=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			 tid, i, j, k, (Uint)(emax5[cid].fsm[j].lmrd[k]>>32), (Uint)emax5[cid].fsm[j].lmrd[k], emax5[cid].fsm[j].rrdyc, lmm_nreq);
a521 1
		emax5[cid].fsm[j].rrdyc++;
d1009 13
a1021 1
    break;
a1024 13

  if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active */
    unit[cid][i][j].cexd = 0; /* always non-exec */
  else { /* active */
    op_cx   = unit[cid][i][j].conf.cdw1.cop;
    c0      = unit[cid][i][j].c[0];
    c1      = unit[cid][i][j].c[1];
    c2      = unit[cid][i][j].c[2];
    c3      = unit[cid][i][j].c[3];
    pattern = unit[cid][i][j].conf.cdw1.cex_tab;
    cex(op_cx, c3, c2, c1, c0, pattern, &ex);
    unit[cid][i][j].cexd = ex;
  }
d1045 22
a1066 1
    break;
a1069 22

  if (!(emax5[cid].unit1_exec & (1LL<<i))) /* non-active */
    unit[cid][i][j].exdr = 0LL; /* always non-exec */
  else { /* active */
    op_ex1 = unit[cid][i][j].conf.cdw0.op1;
    op_ex2 = unit[cid][i][j].conf.cdw0.op2;
    op_ex3 = unit[cid][i][j].conf.cdw0.op3;
    r1     = (!unit[cid][i][j].conf.cdw0.ex1s || !unit[cid][i][j].one_shot)
           ? unit[cid][i][j].ex1 : unit[cid][i][j].exdr; /* self_loop */
    r2     = unit[cid][i][j].ex2;
    r3     = unit[cid][i][j].ex3;
    r4     = unit[cid][i][j].conf.cdw0.e2is==0 ? unit[cid][i][j].conf.cdw0.e2imm
           : unit[cid][i][j].conf.cdw0.e2is==1 ? unit[cid][i][j].ex2
           :                                     unit[cid][i][j].ex3;
    r5     = unit[cid][i][j].conf.cdw0.e3is==0 ? unit[cid][i][j].conf.cdw0.e3imm
           :                                     unit[cid][i][j].ex3;
    exp1   = unit[cid][i][j].conf.cdw0.ex1exp;
    exp2   = unit[cid][i][j].conf.cdw0.ex2exp;
    exp3   = unit[cid][i][j].conf.cdw0.ex3exp;
    exe(op_ex1, r1, exp1, r2, exp2, r3, exp3, op_ex2, r4, op_ex3, r5, &d);
    unit[cid][i][j].exdr = d;
  }
d1082 1
d1084 5
d1094 15
a1108 1
    break;
a1111 15

  if (!(emax5[cid].unit1_exec & (1LL<<i))) { /* non-active */
    unit[cid][i][j].ea0dr = 0LL; /* always non-exec */
    unit[cid][i][j].ea1dr = 0LL; /* always non-exec */
  }
  else { /* active */
    base0 = (!unit[cid][i][j].conf.cdw1.ea0bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea0b:unit[cid][i][j].ea0dr;
    offs0 = (!unit[cid][i][j].conf.cdw1.ea0bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea0o:0LL;
    base1 = (!unit[cid][i][j].conf.cdw1.ea1bs || !unit[cid][i][j].one_shot)?unit[cid][i][j].ea1b:unit[cid][i][j].ea1dr;
    offs1 = (!unit[cid][i][j].conf.cdw1.ea1bs ||  unit[cid][i][j].one_shot)?unit[cid][i][j].ea1o:0LL;
    eag(&unit[cid][i][j].ea0dr, base0, offs0, unit[cid][i][j].conf.cdw1.ea0msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
    eag(&unit[cid][i][j].ea1dr, base1, offs1, unit[cid][i][j].conf.cdw1.ea1msk); /* self_loop=0の場合の初期値はaddr+offs, self_loop=1かつ初回はaddr,以降addr+offs */
    unit[cid][i][j].lmm.ma0 = unit[cid][i][j].ea0dr;
    unit[cid][i][j].lmm.ma1 = unit[cid][i][j].ea1dr;
  }
d1123 2
a1124 4



      /*------------------------ここまで----------------------------*/
d1129 2
d1132 3
d1182 1
@


1.38
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.37 2016/04/10 12:16:15 nakashim Exp nakashim $";
d247 2
a249 1
      }
d908 1
a908 3
    s = unit[cid][i][j].conf.cdw1.ea0bs;  unit[cid][i][j].ea0b = (s==0)                        ? unit[cid][i][j].eab
					                       : (unit[cid][i][j].one_shot==0) ? unit[cid][i][j].regv.ea0br
	                                                       :                                 unit[cid][i][j].ea0dr;
d927 1
a927 3
    s = unit[cid][i][j].conf.cdw1.ea1bs;  unit[cid][i][j].ea1b = (s==0)                        ? unit[cid][i][j].eab
					                       : (unit[cid][i][j].one_shot==0) ? unit[cid][i][j].regv.ea1br
					                       :                                 unit[cid][i][j].ea1dr;
d1051 1
a1051 1
    r1     = (!unit[cid][i][j].one_shot || !unit[cid][i][j].conf.cdw0.ex1s)
d1070 3
d1094 8
a1101 2
    eag(&unit[cid][i][j].ea0dr, unit[cid][i][j].ea0b, unit[cid][i][j].ea0o, unit[cid][i][j].conf.cdw1.ea0msk);
    eag(&unit[cid][i][j].ea1dr, unit[cid][i][j].ea1b, unit[cid][i][j].ea1o, unit[cid][i][j].conf.cdw1.ea1msk);
d1107 1
a1107 3
  Uint s1, s2, s3, sc;

/*------------------------ここまで----------------------------*/
d1109 1
a1109 1
  /* update: exd,t,lmwd,lmlio/lmrio -> tr,mw */
d1113 7
d1125 1
d1127 1
d1129 41
a1169 1
    break;
@


1.37
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.36 2016/04/10 12:02:03 nakashim Exp nakashim $";
d1054 2
a1055 1
    r1     = (!unit[cid][i][j].one_shot)?unit[cid][i][j].ex1:unit[cid][i][j].exdr; /* self_loop */
a1072 5

/*------------------------ここまで----------------------------*/

  Uint s1, s2, s3, sc;

d1082 1
d1084 1
d1086 10
a1095 1
    break;
a1096 1
  
d1103 2
@


1.36
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.35 2016/04/10 04:01:07 nakashim Exp nakashim $";
a1180 489
siml_unit_ex1(cid, i, j) Uint cid, i, j;
{
  Uint k;
  Uint s1, s2, s3, t1, t2, d;
  Uint n, z, v, c;

  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax4[cid].unit_edb_cmd) {
  case 2:
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
      emax4[cid].unit1_stop &= ~(1LL<<i);
    }
  default:
    return (0);
  case 5:
    break;
  }

  if (unit[cid][i][j].v1 && ((emax4[cid].unit1_exec & (1LL<<i)))) {
    for (k=0; k<INT_XBR_BUS_NUM; k++) {
      switch (unit[cid][i][j].ixb[k].sel_r) { /* 0:off 1:prev_ex2.p1 2:prev_ex2.p2 3:prev_ex2.p3 4:prev_mem.p1 5:prev_mem.p2 6:prev_mem.p3 8:prev_ex2.d 9:prev_mem.d */
      case 0:                                                                                      break;
      case 1: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p1_r; break;
      case 2: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p2_r; break;
      case 3: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p3_r; break;
      case 4: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p1_r; break;
      case 5: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p2_r; break;
      case 6: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p3_r; break;
      case 8: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;    break;
      case 9: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;    break;
      default:unit[cid][i][j].ixb[k].d = 0xffffffff;                                               break;
      }
    }

    switch (unit[cid][i][j].ex1.x1_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].ex1.t1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p1_r;    break;
    case 4: unit[cid][i][j].ex1.t1 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].ex1.t1 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].ex1.t1 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].ex1.t1 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].ex1.t1 = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].ex1.x2_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].ex1.t2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p2_r;    break;
    case 4: unit[cid][i][j].ex1.t2 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].ex1.t2 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].ex1.t2 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].ex1.t2 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].ex1.t2 = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].ex1.x3_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].ex1.t3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p3_r;    break;
    case 4: unit[cid][i][j].ex1.t3 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].ex1.t3 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].ex1.t3 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].ex1.t3 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].ex1.t3 = 0xffffffff;                                                  break;
    }

    /*************/
    /* SIML ALU1 */
    /*************/
    switch (unit[cid][i][j].ex1.s1_r) {
    case 0: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p1_r;                                         break;
    case 1: s1 = (!unit[cid][i][j].one_shot)?unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p1_r:unit[cid][i][j].ex1.d; break;
    case 2: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s1 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s1 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s1 = 0xffffffff;                                                                                       break;
    }
    switch (unit[cid][i][j].ex1.s2_r) {
    case 0: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p2_r;                                         break;
    case 2: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s2 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s2 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s2 = 0xffffffff;                                                                                       break;
    }
    switch (unit[cid][i][j].ex1.s3_r) {
    case 0: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p3_r;                                         break;
    case 2: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s3 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s3 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s3 = 0xffffffff;                                                                                       break;
    }
    switch (unit[cid][i][j].ex1.px1_r) {
    case 0: unit[cid][i][j].ex1.dx1 = 0xffffffff;                                                                  break;
    case 2: unit[cid][i][j].ex1.dx1 = s2;                                                                          break;
    default:unit[cid][i][j].ex1.dx1 = 0xffffffff;                                                                  break;
      /* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
    }
    switch (unit[cid][i][j].ex1.px2_r) {
    case 0: unit[cid][i][j].ex1.dx2 = 0xffffffff;                                                                  break;
    case 3: unit[cid][i][j].ex1.dx2 = s3;                                                                          break;
    default:unit[cid][i][j].ex1.dx2 = 0xffffffff;                                                                  break;
      /* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
    }

    switch (unit[cid][i][j].ex1.s1_fhl) {
    case 1: s1 = ((s1<<8) & 0x00ff0000) | ( s1      & 0x000000ff); break; /* SUFLO */
    case 2: s1 = ((s1>>8) & 0x00ff0000) | ((s1>>16) & 0x000000ff); break; /* SUFHI */
    }
    switch (unit[cid][i][j].ex1.s2_fhl) {
    case 1: s2 = ((s2<<8) & 0x00ff0000) | ( s2      & 0x000000ff); break; /* SUFLO */
    case 2: s2 = ((s2>>8) & 0x00ff0000) | ((s2>>16) & 0x000000ff); break; /* SUFHI */
    }
    switch (unit[cid][i][j].ex1.s3_fhl) {
    case 1: s3 = ((s3<<8) & 0x00ff0000) | ( s3      & 0x000000ff); break; /* SUFLO */
    case 2: s3 = ((s3>>8) & 0x00ff0000) | ((s3>>16) & 0x000000ff); break; /* SUFHI */
    }
    
    if (unit[cid][i][j].ex1.urZ_r) {
      switch (unit[cid][i][j].ex1.op_r) {
      case OP_NOP:
	d = s1;
	break;
      case OP_ADD3:
	d = s1 + s2 + s3;
	break;
      case OP_SUB3:
	d = s1 - s2 - s3;
	break;
      case OP_MAUH3:
#if 0
	t1 = ((int) s1     >>16)+((int) s2     >>16)+((int) s3     >>16);
	if ((int)t1 > (int)0x00007fff) t1 = 0x7fff;
	if ((int)t1 < (int)0xffff8000) t1 = 0x8000;
	t2 = ((int)(s1<<16)>>16)+((int)(s2<<16)>>16)+((int)(s3<<16)>>16);
	if ((int)t2 > (int)0x00007fff) t2 = 0x7fff;
	if ((int)t2 < (int)0xffff8000) t2 = 0x8000;
#else
	t1 = ( s1     >>16)+( s2     >>16)+( s3     >>16);
	if (t1 > 0x0000ffff) t1 = 0xffff;
	t2 = ((s1<<16)>>16)+((s2<<16)>>16)+((s3<<16)>>16);
	if (t2 > 0x0000ffff) t2 = 0xffff;
#endif
	d = (t1<<16)|(t2&0xffff);
	break;
      case OP_MSUH3:
#if 0
	t1 = ((int) s1     >>16)-((int) s2     >>16)-((int) s3     >>16);
	if ((int)t1 > (int)0x00007fff) t1 = 0x7fff;
	if ((int)t1 < (int)0xffff8000) t1 = 0x8000;
	t2 = ((int)(s1<<16)>>16)-((int)(s2<<16)>>16)-((int)(s3<<16)>>16);
	if ((int)t2 > (int)0x00007fff) t2 = 0x7fff;
	if ((int)t2 < (int)0xffff8000) t2 = 0x8000;
#else
	t1 = ( s1     >>16)-( s2     >>16)-( s3     >>16);
	if (t1 > 0x0000ffff) t1 = 0x0000;
	t2 = ((s1<<16)>>16)-((s2<<16)>>16)-((s3<<16)>>16);
	if (t2 > 0x0000ffff) t2 = 0x0000;
#endif
	d = (t1<<16)|(t2&0xffff);
	break;
      case OP_MMRG3:
	d = ((s1&0xff)<<24) | ((s2&0xff)<<16) | ((s3&0xff)<<8);
	break;
      case OP_MINL3:
	if ((s3>>16)<(s3&0xffff)) d = (s1&0xffff0000)|(s3>>16);
	else                      d = (s2&0xffff0000)|(s3&0xffff);
	break;
      case OP_MMID3:
	t1 = ((s1&0xff000000)<(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	   | ((s1&0x00ff0000)<(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	   | ((s1&0x0000ff00)<(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	   | ((s1&0x000000ff)<(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	t2 = ((s1&0xff000000)>(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	   | ((s1&0x00ff0000)>(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	   | ((s1&0x0000ff00)>(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	   | ((s1&0x000000ff)>(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	d  = ((s3&0xff000000)<(t1&0xff000000)?(t1&0xff000000):((s3&0xff000000)<(t2&0xff000000)?(s3&0xff000000):(t2&0xff000000)))
	   | ((s3&0x00ff0000)<(t1&0x00ff0000)?(t1&0x00ff0000):((s3&0x00ff0000)<(t2&0x00ff0000)?(s3&0x00ff0000):(t2&0x00ff0000)))
	   | ((s3&0x0000ff00)<(t1&0x0000ff00)?(t1&0x0000ff00):((s3&0x0000ff00)<(t2&0x0000ff00)?(s3&0x0000ff00):(t2&0x0000ff00)))
	   | ((s3&0x000000ff)<(t1&0x000000ff)?(t1&0x000000ff):((s3&0x000000ff)<(t2&0x000000ff)?(s3&0x000000ff):(t2&0x000000ff)));
	break;
      case OP_MMAX3:
	t1 = ((s1&0xff000000)>(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	   | ((s1&0x00ff0000)>(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	   | ((s1&0x0000ff00)>(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	   | ((s1&0x000000ff)>(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	d  = ((t1&0xff000000)>(s3&0xff000000)?(t1&0xff000000):(s3&0xff000000))
	   | ((t1&0x00ff0000)>(s3&0x00ff0000)?(t1&0x00ff0000):(s3&0x00ff0000))
	   | ((t1&0x0000ff00)>(s3&0x0000ff00)?(t1&0x0000ff00):(s3&0x0000ff00))
	   | ((t1&0x000000ff)>(s3&0x000000ff)?(t1&0x000000ff):(s3&0x000000ff));
	break;
      case OP_MMIN3:
	t1 = ((s1&0xff000000)<(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	   | ((s1&0x00ff0000)<(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	   | ((s1&0x0000ff00)<(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	   | ((s1&0x000000ff)<(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	d  = ((t1&0xff000000)<(s3&0xff000000)?(t1&0xff000000):(s3&0xff000000))
	   | ((t1&0x00ff0000)<(s3&0x00ff0000)?(t1&0x00ff0000):(s3&0x00ff0000))
	   | ((t1&0x0000ff00)<(s3&0x0000ff00)?(t1&0x0000ff00):(s3&0x0000ff00))
	   | ((t1&0x000000ff)<(s3&0x000000ff)?(t1&0x000000ff):(s3&0x000000ff));
	break;
      case OP_FMA3:
	*(float*)&d  = *(float*)&s1 * *(float*)&s2 + *(float*)&s3;
	/* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
	break;
      default:
	break;
      }
    }
    else {
      switch (unit[cid][i][j].ex1.op_r) {
      case OP_NOP:
	d = s1;
	break;
      case OP_LDB:
      case OP_LDUB:
      case OP_LDH:
      case OP_LDUH:
      case OP_LD:
	d = s1 + s2;
	break;
      case OP_WHILE:
	d = s1 + s2;
	n = d>>31;
	z = d==0;
	v = (s1>>31&&s2>>31&&!(d>>31)) || (!(s1>>31)&&!(s2>>31)&&d>>31);
	c = (s1>>31&&s2>>31) || (!(d>>31)&&(s1>>31||s2>>31));
	if (z) emax4[cid].unit1_stop |= (1LL<<i);
	break;
      case OP_ADD:
	d = s1 + s2;
	n = d>>31;
	z = d==0;
	v = (s1>>31&&s2>>31&&!(d>>31)) || (!(s1>>31)&&!(s2>>31)&&d>>31);
	c = (s1>>31&&s2>>31) || (!(d>>31)&&(s1>>31||s2>>31));
	break;
      case OP_SUB:
	d = s1 - s2;
	n = d>>31;
	z = d==0;
	v = (s1>>31&&!(s2>>31)&&!(d>>31)) || (!(s1>>31)&&s2>>31&&d>>31);
	c = (!(s1>>31)&&s2>>31) || (d>>31&&(!(s1>>31)||s2>>31)); /* FRV */
	break;
      case OP_MAUH:
#if 0
	t1 = ((int) s1     >>16)+((int) s2     >>16);
	if ((int)t1 > (int)0x00007fff) t1 = 0x7fff;
	if ((int)t1 < (int)0xffff8000) t1 = 0x8000;
	t2 = ((int)(s1<<16)>>16)+((int)(s2<<16)>>16);
	if ((int)t2 > (int)0x00007fff) t2 = 0x7fff;
	if ((int)t2 < (int)0xffff8000) t2 = 0x8000;
#else
	t1 = ( s1     >>16)+( s2     >>16);
	if (t1 > 0x0000ffff) t1 = 0xffff;
	t2 = ((s1<<16)>>16)+((s2<<16)>>16);
	if (t2 > 0x0000ffff) t2 = 0xffff;
#endif
	d = (t1<<16)|(t2&0xffff);
	break;
      case OP_MSUH:
#if 0
	t1 = ((int) s1     >>16)-((int) s2     >>16);
	if ((int)t1 > (int)0x00007fff) t1 = 0x7fff;
	if ((int)t1 < (int)0xffff8000) t1 = 0x8000;
	t2 = ((int)(s1<<16)>>16)-((int)(s2<<16)>>16);
	if ((int)t2 > (int)0x00007fff) t2 = 0x7fff;
	if ((int)t2 < (int)0xffff8000) t2 = 0x8000;
#else
	t1 = ( s1     >>16)-( s2     >>16);
	if (t1 > 0x0000ffff) t1 = 0x0000;
	t2 = ((s1<<16)>>16)-((s2<<16)>>16);
	if (t2 > 0x0000ffff) t2 = 0x0000;
#endif
	d = (t1<<16)|(t2&0xffff);
	break;
      case OP_MLUH: /* MUL (8bit*9bit)[2] -> 16bit[2] */
	t1 = (( s1     >>16)&0x3ff)*(s2&0x1ff);
	if (t1 > 0x0000ffff) t1 = 0xffff;
	t2 = (((s1<<16)>>16)&0x3ff)*(s2&0x1ff);
	if (t2 > 0x0000ffff) t2 = 0xffff;
	d = (t1<<16)|t2;
	break;
      case OP_MSAD: /* SAD abs(8bit-8bit)[4] -> 16bit[2] */
#define ad(a,b) ((a)>(b)?((a)-(b)):((b)-(a)))
	d = ((ad(s1&0xff000000,s2&0xff000000)>>8)+ad(s1&0xff0000,s2&0xff0000))|((ad(s1&0xff00,s2&0xff00)>>8)+ad(s1&0xff,s2&0xff));
	break;
      case OP_MINL:
	if ((s1&0xffff)<(s2&0xffff)) d = s1;
	else                         d = s2;
	break;
      case OP_MH2BW:
	d = (((s1>>16   )<0x100 ? (s1>>16   )&0xff : 255)<<24)
	  | (((s1&0xffff)<0x100 ? (s1&0xffff)&0xff : 255)<<16)
	  | (((s2>>16   )<0x100 ? (s2>>16   )&0xff : 255)<< 8)
	  | (((s2&0xffff)<0x100 ? (s2&0xffff)&0xff : 255)    );
	break;
      case OP_MCAS:
	d = (s1<s2)?0:0xff;
	break;
      case OP_MMAX:
	d = ((s1&0xff000000)>(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	  | ((s1&0x00ff0000)>(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	  | ((s1&0x0000ff00)>(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	  | ((s1&0x000000ff)>(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	break;
      case OP_MMIN:
	d = ((s1&0xff000000)<(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	  | ((s1&0x00ff0000)<(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	  | ((s1&0x0000ff00)<(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	  | ((s1&0x000000ff)<(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	break;
      case OP_FMUL:
	*(float*)&d  = *(float*)&s1 * *(float*)&s2;
	/* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
	break;
      case OP_FADD:
	*(float*)&d  = *(float*)&s1 + *(float*)&s2;
	/* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
	break;
      case OP_CMPEQ:
	z = s1 == s2;
	break;
      case OP_CMPNE:
	z = s1 != s2;
	break;
      case OP_CMPLT:
	z = s1 < s2;
	break;
      case OP_CMPLE:
	z = s1 <= s2;
	break;
      case OP_CMPGT:
	z = s1 > s2;
	break;
      case OP_CMPGE:
	z = s1 >= s2;
	break;
      case OP_CMOV:
	d = unit[cid][i][j].cnd.exec ? s1 : s2;
	break;
      default:
	break;
      }
    }

    unit[cid][i][j].ex1.d = d;
    unit[cid][i][j].ex1.c = z; /* z is only used by conditional insn. */
  }
}

siml_unit_ex2(cid, i, j) Uint cid, i, j;
{
  Uint k;
  Uint s1, s2, s3, t1, t2, d1, d2, c1, c2;

  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax4[cid].unit_edb_cmd) {
  case 2:
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
      emax4[cid].unit2_stop &= ~(1LL<<i);
      switch (unit[cid][i][j].edb[0].d) {
      case 0: /* ex2v_p1_r */
	unit[cid][i][j].ex2.p1_r = unit[cid][i][j].edb[1].d;
	break;
      case 1: /* ex2v_p2_r */
	unit[cid][i][j].ex2.p2_r = unit[cid][i][j].edb[1].d;
	break;
      }
    }
  default:
    return (0);
  case 5:
    break;
  }
	
  if (unit[cid][i][j].v2 && (emax4[cid].unit2_exec & (1LL<<i))) {
    switch (unit[cid][i][j].ex2.x1_r) { /* ex2-output-selector 0:fixed_for_constant 1:t1_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].ex2.p1_r = unit[cid][i][j].ex1.t1;                                      break;
    case 2: unit[cid][i][j].ex2.p1_r = unit[cid][i][j].etb[0].d;                                    break;
    default:unit[cid][i][j].ex2.p1_r = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].ex2.x2_r) { /* ex2-output-selector 0:fixed_for_constant 1:t1_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].ex2.p2_r = unit[cid][i][j].ex1.t2;                                      break;
    case 2: unit[cid][i][j].ex2.p2_r = unit[cid][i][j].etb[1].d;                                    break;
    default:unit[cid][i][j].ex2.p2_r = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].ex2.x3_r) { /* ex2-output-selector 0:fixed_for_constant 1:t1_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].ex2.p3_r = unit[cid][i][j].ex1.t3;                                      break;
    case 2: unit[cid][i][j].ex2.p3_r = unit[cid][i][j].etb[2].d;                                    break;
    default:unit[cid][i][j].ex2.p3_r = 0xffffffff;                                                  break;
    }
  }
    
  if (unit[cid][i][j].v2 && (emax4[cid].unit2_exec & (1LL<<i))) {
    /*************/
    /* SIML ALU2 */
    /*************/
    switch (unit[cid][i][j].ex2.s1_r) {
    case 0: s1 = unit[cid][i][j].ex1.d;                                         break;
    default:s1 = 0xffffffff;                                                    break;
      /* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
    }
    switch (unit[cid][i][j].ex2.s2_r) {
    case 4: s2 = unit[cid][i][j].ex1.dx1;                                       break;
    case 5: s2 = unit[cid][i][j].ex1.dx2;                                       break;
    case 6: s2 = (int)(unit[cid][i][j].ex2.simmS_r<<19)>>19;                    break;
    default:s2 = 0xffffffff;                                                    break;
      /* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
    }
    switch (unit[cid][i][j].ex2.s3_r) {
    case 5: s3 = unit[cid][i][j].ex1.dx2;                                       break;
    case 7: s3 = unit[cid][i][j].ex2.immT_r;                                    break;
    default:s3 = 0xffffffff;                                                    break;
      /* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
    }
    
    if (unit[cid][i][j].ex1.op_r && unit[cid][i][j].ex1.op_r<=OP_LD) {
      d1 = ex2_fifo_access(cid, i, j, MEM_RD);
      switch (unit[cid][i][j].ex1.op_r) {
      case OP_LDB:    d2 =  (int)(char)((d1 >> ((unit[cid][i][j].ex1.d&3)*8))&  0xff); break;
      case OP_LDUB:   d2 =             ((d1 >> ((unit[cid][i][j].ex1.d&3)*8))&  0xff); break;
      case OP_LDH:    d2 = (int)(short)((d1 >> ((unit[cid][i][j].ex1.d&3)*8))&0xffff); break;
      case OP_LDUH:   d2 =             ((d1 >> ((unit[cid][i][j].ex1.d&3)*8))&0xffff); break;
      case OP_LD:     d2 =               d1;                                           break;
      default:                                                                         break;
      }
    }
    else {
      switch (unit[cid][i][j].ex2.op_r) {
      case OP_NOP:
	d1 = s1;
	c1 = unit[cid][i][j].ex1.c;
	/* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
	break;
      case OP_AND:
	d1 = s1 & s2;
	break;
      case OP_OR:
	d1 = s1 | s2;
	break;
      case OP_XOR:
	d1 = s1 ^ s2;
	break;
      case OP_SUMH: /* SUMH (H16bit+L16bit) -> H16bit */
	d1 = (s1&0xffff0000)+(s1<<16);
	break;
      case OP_SUML: /* SUML (H16bit+L16bit) -> L16bit */
	d1 = ((s1>>16)+(s1&0xffff))&0xffff;
	break;
      default:
	break;
      }
      
      switch (unit[cid][i][j].ex2.sft_r) {
      case OP_NOP:
	d2 = d1;
	c2 = c1;
	/* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
	break;
      case OP_SLL:
	d2 = d1 << s3;
	break;
      case OP_SRL:
	d2 = d1 >> s3;
	break;
      case OP_MSRL:
	d2 = ((d1 >> s3)&0xffff0000)|((d1&0x0000ffff) >> s3);
	break;
      case OP_SRA31:
	d2 = (int)d1 >> s3;
	break;
      case OP_SRA23:
	d2 = (int)(d1<<8)>>(8+s3);
	break;
      case OP_SRA15:
	d2 = (int)(d1<<16)>>(16+s3);
	break;
      case OP_SRA07:
	d2 = (int)(d1<<24)>>(24+s3);
	break;
      default:
	break;
      }
    }

    unit[cid][i][j].ex2.d = d2;
    unit[cid][i][j].ex2.c = c2;
  }
}

@


1.35
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.34 2016/04/08 08:03:13 nakashim Exp nakashim $";
d14 1
d990 4
a993 2
  Uint c0b0, c0b1, c0b2, c0b3, c0sel;
  Uint c1b0, c1b1, c1b2, c1b3, c1sel;
d995 1
a995 1
  /* regv(br) -> cexd */
d1014 8
a1021 20
    switch (unit[cid][i][j].conf.cdw1.cop) {
    case OP_NOP:
      unit[cid][i][j].cexd = 3; /* always exec */
      break;
    case OP_CEXE:
      c0b0 = unit[cid][i][j].c[0]   &1;
      c0b1 = unit[cid][i][j].c[1]   &1;
      c0b2 = unit[cid][i][j].c[2]   &1;
      c0b3 = unit[cid][i][j].c[3]   &1;
      c1b0 = unit[cid][i][j].c[0]>>1&1;
      c1b1 = unit[cid][i][j].c[1]>>1&1;
      c1b2 = unit[cid][i][j].c[2]>>1&1;
      c1b3 = unit[cid][i][j].c[3]>>1&1;

      c0sel = (c0b3<<3)|(c0b2<<2)|(c0b1<<1)|(c0b0);
      c1sel = (c1b3<<3)|(c1b2<<2)|(c1b1<<1)|(c1b0);

      unit[cid][i][j].cexd = (((unit[cid][i][j].conf.cdw1.cex_tab>>c1sel)&1)<<1)
	                   | (((unit[cid][i][j].conf.cdw1.cex_tab>>c0sel)&1)   );
    }
d1027 4
a1030 3
  Uint k;
  Uint s1, s2, s3, t1, t2, d;
  Uint n, z, v, c;
d1032 1
a1032 1
  /* ex[123] -> exd */
d1041 1
d1043 1
d1045 22
a1066 1
    break;
a1067 2
  
  /*------------------------ここまで----------------------------*/
d1072 3
a1090 1
  /*------------------------ここまで----------------------------*/
a1109 2
  
  /*------------------------ここまで----------------------------*/
a1129 2
  
  /*------------------------ここまで----------------------------*/
@


1.34
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.33 2016/04/07 15:00:28 nakashim Exp nakashim $";
d133 2
a135 1
  Ull   lmli[UNIT_WIDTH];  /* wire */
a136 2
  Ull   lmlo[UNIT_WIDTH];  /* wire */
  Ull   lmria           ;  /* wire */
a137 1
  Ull   lmroa           ;  /* wire */
d139 2
d953 1
a953 1
  int j, k;
d955 29
a983 18
  /* lmw[ad] -> lml[io]/lmr[io] */
  for (j=0; j<EMAX_WIDTH; j++) { /* 0:br0_0, 1:br0_1, ... 15:3_3 */

  switch (emax5[cid].status) {
  case STATUS_IDLE:
  case STATUS_CONF:
    for (j=0; j<UNIT_WIDTH; j++)
      if (emax5[cid].fsm[j].row_select & (1LL<<i)) { /* target */
      }      
    break;
  case STATUS_LMMI:
  case STATUS_DRAIN:
  case STATUS_LOAD:
  case STATUS_REGV:
  case STATUS_START:
  case STATUS_EXEC:
  case STATUS_TERM:
    break;
a984 2
  
  /*------------------------ここまで----------------------------*/
d989 2
a990 1
  Uint bit0, bit1, bit2, bit3;
d1001 1
d1003 1
d1005 26
a1030 1
    break;
a1031 2
  
  /*------------------------ここまで----------------------------*/
a1169 147
siml_unit_ex2_bus(cid, i) Uint cid, i; /* emb,etb,etc *//* ex2/lmmの計算前にEDB/EDCを確定させる */
{
  int j, k;

  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax4[cid].unit_edb_cmd_d1) {
  case 4:
    for (j=0; j<UNIT_WIDTH; j++) {
      if ((emax4[cid].unit_select_row_d1 & (1LL<<i)) && (emax4[cid].unit_select_col_d1 & (1<<j)))
	lmm_mem_access(cid, i, j, MEM_WR);
    }
    return (0);
  case 6:
    for (j=0; j<UNIT_WIDTH; j++) {
      if ((emax4[cid].unit_select_row_d1 & (1LL<<i)) && (emax4[cid].unit_select_col_d1 & (1<<j)))
	unit[cid][i][j].emb[0].d = lmm_mem_access(cid, i, j, MEM_RD);
    }
    return (0);
  default:
    return (0);
  case 5:
    break;
  }

  for (j=0; j<UNIT_WIDTH; j++) {
    if (unit[cid][i][j].cnd.exec && unit[cid][i][j].v2 && (emax4[cid].unit2_exec & (1LL<<i))) {
      if (unit[cid][i][j].eag.op_r) {
	if (unit[cid][i][j].eag.op_r<=OP_LD) { /* load */
	  switch (unit[cid][i][j].emb[0].sel_r) { /* 0:off 1:lmem */
	  case 0:                                                      unit[cid][i][j].lmm.o    = lmm_mem_access(cid, i, j, MEM_RD); break;
	  case 1: unit[cid][i][j].emb[0].a = unit[cid][i][j].eag.d>>2; unit[cid][i][j].emb[0].d = lmm_mem_access(cid, i, j, MEM_RD); break;
	  default:unit[cid][i][j].emb[0].a = 0x3fff;                   unit[cid][i][j].emb[0].d = 0xffffffff;                   break;
	  }
	}
	else /* store */
	  lmm_mem_access(cid, i, j, MEM_WR);
      }
    }
  }
  for (j=0; j<UNIT_WIDTH; j++) {
    if (j>0 && unit[cid][i][j-1].emb[0].dir_r==1) { /* 0:off 1:to-left 2:to-right 3:inhibited */
      unit[cid][i][j].emb[0].a = unit[cid][i][j-1].emb[0].a;
      unit[cid][i][j].emb[0].d = unit[cid][i][j-1].emb[0].d;
    }
  }
  for (j=UNIT_WIDTH-1; j>=0; j--) {
    if (j<UNIT_WIDTH-1 && unit[cid][i][j].emb[0].dir_r==2) { /* 0:off 1:to-left 2:to-right 3:inhibited */
      unit[cid][i][j].emb[0].a = unit[cid][i][j+1].emb[0].a;
      unit[cid][i][j].emb[0].d = unit[cid][i][j+1].emb[0].d;
    }
  }

  for (j=0; j<UNIT_WIDTH; j++) {
    if (unit[cid][i][j].v2) {
      switch (unit[cid][i][j].etb[0].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[0].d = unit[cid][i][j].ex1.t1; break;
      default:unit[cid][i][j].etb[0].d = 0xffffffff;             break;
      }
      switch (unit[cid][i][j].etb[1].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[1].d = unit[cid][i][j].ex1.t2; break;
      default:unit[cid][i][j].etb[1].d = 0xffffffff;             break;
      }
      switch (unit[cid][i][j].etb[2].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[2].d = unit[cid][i][j].ex1.t3; break;
      default:unit[cid][i][j].etb[2].d = 0xffffffff;             break;
      }
      switch (unit[cid][i][j].etb[3].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[3].d = unit[cid][i][j].eag.t1; break;
      default:unit[cid][i][j].etb[3].d = 0xffffffff;             break;
      }
      switch (unit[cid][i][j].etb[4].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[4].d = unit[cid][i][j].eag.t2; break;
      default:unit[cid][i][j].etb[4].d = 0xffffffff;             break;
      }
      switch (unit[cid][i][j].etb[5].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[5].d = unit[cid][i][j].eag.t3; break;
      default:unit[cid][i][j].etb[5].d = 0xffffffff;             break;
      }
    }
  }
  for (k=0; k<EXT_TMP_BUS_NUM; k++) {
    for (j=0; j<UNIT_WIDTH; j++) {
      if (j>0 && unit[cid][i][j-1].etb[k].dir_r==1) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].etb[k].d = unit[cid][i][j-1].etb[k].d;
    }
    for (j=UNIT_WIDTH-1; j>=0; j--) {
      if (j<UNIT_WIDTH-1 && unit[cid][i][j].etb[k].dir_r==2) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].etb[k].d = unit[cid][i][j+1].etb[k].d;
    }
  }
}

siml_unit_cnd(cid, i, j) Uint cid, i, j;
{
  Uint bit0, bit1, bit2, bit3;

  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax4[cid].unit_edb_cmd) {
  default:
    return (0);
  case 5:
    break;
  }

  if (unit[cid][i][j].v1 && ((emax4[cid].unit1_exec & (1LL<<i)))) {
    /*************/
    /* SIML ALU1 */
    /*************/
    switch (unit[cid][i][j].cnd.bit0_r) { /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    case 0: bit0 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.c; break;
    case 1: bit0 = unit[cid][i][j].edc[0].d;                              break;
    case 2: bit0 = unit[cid][i][j].edc[1].d;                              break;
    case 3: bit0 = unit[cid][i][j].edc[2].d;                              break;
    }
    switch (unit[cid][i][j].cnd.bit1_r) { /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    case 0: bit1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.c; break;
    case 1: bit1 = unit[cid][i][j].edc[0].d;                              break;
    case 2: bit1 = unit[cid][i][j].edc[1].d;                              break;
    case 3: bit1 = unit[cid][i][j].edc[2].d;                              break;
    }
    switch (unit[cid][i][j].cnd.bit2_r) { /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    case 0: bit2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.c; break;
    case 1: bit2 = unit[cid][i][j].edc[0].d;                              break;
    case 2: bit2 = unit[cid][i][j].edc[1].d;                              break;
    case 3: bit2 = unit[cid][i][j].edc[2].d;                              break;
    }
    switch (unit[cid][i][j].cnd.bit3_r) { /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    case 0: bit3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.c; break;
    case 1: bit3 = unit[cid][i][j].edc[0].d;                              break;
    case 2: bit3 = unit[cid][i][j].edc[1].d;                              break;
    case 3: bit3 = unit[cid][i][j].edc[2].d;                              break;
    }

    unit[cid][i][j].cnd.select = (bit3<<3)|(bit2<<2)|(bit1<<1)|(bit0);
    if (unit[cid][i][j].cnd.bit0_v | unit[cid][i][j].cnd.bit1_v | unit[cid][i][j].cnd.bit2_v | unit[cid][i][j].cnd.bit3_v)
      unit[cid][i][j].cnd.exec = (unit[cid][i][j].cnd.table>>unit[cid][i][j].cnd.select)&1;
    else
      unit[cid][i][j].cnd.exec = 1;
  }
}

@


1.33
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.32 2016/04/07 09:02:32 nakashim Exp nakashim $";
d956 2
@


1.32
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.31 2016/04/07 03:49:56 nakashim Exp nakashim $";
d884 2
a885 1
  int j, k;
d888 59
a946 59
  switch (emax5[cid].status) {
  case STATUS_IDLE:
  case STATUS_LMMI:
    return (0);
  case STATUS_CONF: /* row_select */
    for (j=0; j<UNIT_WIDTH; j++)
      if (emax5[cid].fsm[j].row_select & (1LL<<i)) { /* target */
      }      
	    
  case STATUS_DRAIN: /* row_select */
  case STATUS_LOAD: /* row_select */
  case STATUS_REGV: /* row_select */
  case STATUS_START: /* row_select */
  case STATUS_EXEC: /* row_select */
  case STATUS_TERM:
    break;
  }
  
#if 0
  /*------------------------ここまで----------------------------*/
  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax4[cid].unit_edb_cmd) {
  case 1:
  case 2:
  case 4: /* data and address */
    if (emax4[cid].unit_select_row & (1LL<<i)) {
      for (j=0; j<UNIT_WIDTH; j++)
	unit[cid][i][j].edb[1].d = emax4[cid].unit_edb1[j];
    }
  case 6: /* address only */
    if (emax4[cid].unit_select_row & (1LL<<i)) {
      unit[cid][i][0].edb[0].d = emax4[cid].unit_edb0; /* edb[0].d[1..3] not exist */
      for (j=1; j<UNIT_WIDTH; j++)
	unit[cid][i][j].edb[0].d = unit[cid][i][j-1].edb[0].d;
    }
  default:
    return (0);
  case 5:
    break;
  }

  for (k=0; k<EXT_DST_BUS_NUM; k++) {
    for (j=0; j<UNIT_WIDTH; j++) {
      if (unit[cid][i][j].v1) {
        switch (unit[cid][i][j].edb[k].sel_r) { /* 0:off 1:prev_ex2.d 2:prev_mem.d */
        case 0:                                                                                      break;
        case 1: unit[cid][i][j].edb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;    break;
        case 2: unit[cid][i][j].edb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;    break;
        default:unit[cid][i][j].edb[k].d = 0xffffffff;                                               break;
        }
      }
    }
    for (j=0; j<UNIT_WIDTH; j++) {
      if (j>0 && unit[cid][i][j-1].edb[k].dir_r==1) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].edb[k].d = unit[cid][i][j-1].edb[k].d;
    }
    for (j=UNIT_WIDTH-1; j>=0; j--) {
      if (j<UNIT_WIDTH-1 && unit[cid][i][j].edb[k].dir_r==2) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].edb[k].d = unit[cid][i][j+1].edb[k].d;
a948 1
#endif
d959 4
@


1.31
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.30 2016/04/06 09:49:38 nakashim Exp nakashim $";
d280 4
a283 4
	for (i=0; i<EMAX_WIDTH; i++) {
	  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[i].row_count    = 0;
	  emax5[cid].fsm[i].row_select   = 0LL;
d290 4
a293 4
	for (i=0; i<EMAX_WIDTH; i++) {
	  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[i].row_count    = 0;
	  emax5[cid].fsm[i].row_select   = 0LL;
d299 4
a302 4
      for (sync=1,i=0; i<EMAX_WIDTH; i++) {
	j = emax5[cid].fsm[i].row_count;
	if (j < EMAX_DEPTH) {	
	  switch (emax5[cid].fsm[i].memif_status) {
d304 4
a307 4
	    emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
	    emax5[cid].fsm[i].ardyc = 0;
	    emax5[cid].fsm[i].raddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*i; /* conf_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[i].rlen  =      sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
d310 3
a312 3
	    if (emax5[cid].fsm[i].ardyc < EMAX_DEPTH) { /* 1rrdy/1unit */
	      emax5[cid].fsm[i].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[i].row_count)%EMAX_DEPTH);
	      emax5[cid].fsm[i].lmwa = 0LL; /* fixed */
d314 4
a317 4
		emax5[cid].fsm[i].lmwd[k] = emax5[cid].fsm[i].rdata[k] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*(emax5[cid].fsm[i].ardyc*UNIT_WIDTH+k));
	      emax5[cid].fsm[i].last_dist = emax5[cid].fsm[i].rdata[3] & 0x3f; /* mapdist */
	      emax5[cid].fsm[i].row_count++;
	      emax5[cid].fsm[i].ardyc++;
d320 2
a321 2
	      emax5[cid].fsm[i].row_select = 0LL;
	      emax5[cid].fsm[i].memif_status = MEMIF_TERM;
d333 4
a336 4
	for (i=0; i<EMAX_WIDTH; i++) {
	  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[i].row_count    = 0;
	  emax5[cid].fsm[i].row_select   = 0LL;
d342 4
a345 4
      for (sync=1,i=0; i<EMAX_WIDTH; i++) {
	j = emax5[cid].fsm[i].row_count;
	if (j < EMAX_DEPTH) {	
	  switch (emax5[cid].fsm[i].memif_status) {
d347 4
a350 4
	    emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
	    emax5[cid].fsm[i].ardyc = 0;
	    emax5[cid].fsm[i].raddr = lmmi+sizeof(Ull)*2*EMAX_DEPTH*i; /* lmmi_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[i].rlen  =      sizeof(Ull)*2*EMAX_DEPTH*1; /* lmmi_topをfsmに渡すインタフェース */
d353 5
a357 5
	    if (emax5[cid].fsm[i].ardyc < EMAX_DEPTH/2) { /* 1rrdy/2unit */
	      *(((Ull*)&emax5[cid].fsm[i].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[i].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].fsm[i].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[i].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+1);
	      *(((Ull*)&emax5[cid].fsm[i].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].fsm[i].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].fsm[i].lmmo[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].fsm[i].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+1);
d359 6
a364 6
	      *(((Ull*)&emax5[cid].fsm[i].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+0) = emax5[cid].fsm[i].rdata[0] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+0);
	      *(((Ull*)&emax5[cid].fsm[i].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+1) = emax5[cid].fsm[i].rdata[1] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+1);
	      *(((Ull*)&emax5[cid].fsm[i].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+0) = emax5[cid].fsm[i].rdata[2] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+2);
	      *(((Ull*)&emax5[cid].fsm[i].lmmc[(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+1) = emax5[cid].fsm[i].rdata[3] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+3);
	      emax5[cid].fsm[i].row_count+=2;
	      emax5[cid].fsm[i].ardyc++;
d367 2
a368 2
	      emax5[cid].fsm[i].row_select = 0LL;
	      emax5[cid].fsm[i].memif_status = MEMIF_TERM;
d377 4
a380 4
	for (i=0; i<EMAX_WIDTH; i++) {
	  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[i].row_count    = 0;
	  emax5[cid].fsm[i].row_select   = 0LL;
d455 4
a458 4
      for (sync=1,i=0; i<EMAX_WIDTH; i++) {
	j = emax5[cid].fsm[i].row_count;
	if (j < EMAX_DEPTH) {
	  switch ((emax5[cid].fsm[i].lmmo[j].v<<3)|(emax5[cid].fsm[i].lmmo[j].rw<<2)|(emax5[cid].fsm[i].lmmo[j].f<<1)|(emax5[cid].fsm[i].lmmo[j].p)) {
d462 1
a462 1
	    if (emax5[cid].fsm[i].lmmd[j]) /* dirty exist */
d474 1
a474 1
	    switch (emax5[cid].fsm[i].memif_status) {
d476 5
a480 5
	      emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[i].ardyc = 0; /* LMM addr-request(read/write) counter */
	      emax5[cid].fsm[i].rrdyc = 0; /* LMM data-ready(read) counter */
	      emax5[cid].fsm[i].waddr = emax5[cid].fsm[i].lmmo[j].top;
	      emax5[cid].fsm[i].wlen  = emax5[cid].fsm[i].lmmo[j].len;
d494 4
a497 4
	      lmm_nreq = emax5[cid].fsm[i].lmmo[j].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	      if (emax5[cid].fsm[i].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		emax5[cid].fsm[i].row_select = 1LL<<j;
		emax5[cid].fsm[i].lmra = emax5[cid].fsm[i].waddr + sizeof(Ull)*(emax5[cid].fsm[i].ardyc*UNIT_WIDTH);
d499 2
a500 2
		  printf("%03.3d:siml_emax5: drain col=%d row=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			 tid, i, j, (Uint)(emax5[cid].fsm[i].lmra>>32), (Uint)emax5[cid].fsm[i].lmra, emax5[cid].fsm[i].ardyc, lmm_nreq);
d502 1
a502 1
		emax5[cid].fsm[i].ardyc++;
d505 2
a506 2
		emax5[cid].fsm[i].row_select = 0LL;
	      if (emax5[cid].fsm[i].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
d508 1
a508 1
		  *(Ull*)(base + emax5[cid].fsm[i].waddr + sizeof(Ull)*(emax5[cid].fsm[i].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[i].wdata[k] = emax5[cid].fsm[i].lmrd[k];
d510 2
a511 2
		  printf("%03.3d:siml_emax5: drain col=%d row=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			 tid, i, j, k, (Uint)(emax5[cid].fsm[i].lmrd[k]>>32), (Uint)emax5[cid].fsm[i].lmrd[k], emax5[cid].fsm[i].rrdyc, lmm_nreq);
d513 1
a513 1
		emax5[cid].fsm[i].rrdyc++;
d516 3
a518 3
		emax5[cid].fsm[i].lmmd[j] = 0;
		emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
		emax5[cid].fsm[i].row_count++;
d524 1
a524 1
	    emax5[cid].fsm[i].row_count++;
d531 4
a534 4
	for (i=0; i<EMAX_WIDTH; i++) {
	  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[i].row_count    = 0;
	  emax5[cid].fsm[i].row_select   = 0LL;
d540 4
a543 4
      for (sync=1,i=0; i<EMAX_WIDTH; i++) {
	j = emax5[cid].fsm[i].row_count;
	if (j < EMAX_DEPTH) {
	  switch ((emax5[cid].fsm[i].lmmc[j].v<<3)|(emax5[cid].fsm[i].lmmc[j].rw<<2)|(emax5[cid].fsm[i].lmmc[j].f<<1)|(emax5[cid].fsm[i].lmmc[j].p)) {
d546 4
a549 4
	    if (emax5[cid].fsm[i].lmmo[j].v
             && emax5[cid].fsm[i].lmmo[j].blk == emax5[cid].fsm[i].lmmc[j].blk
             && emax5[cid].fsm[i].lmmo[j].len == emax5[cid].fsm[i].lmmc[j].len
      	     && emax5[cid].fsm[i].lmmo[j].top == emax5[cid].fsm[i].lmmc[j].top) {
d551 2
a552 2
		printf("%03.3d:siml_emax5: load col=%d row=%d top=%08.8x_%08.8x found in LMM\n",
		       tid, i, j, (Uint)(emax5[cid].fsm[i].lmmc[j].top>>32), (Uint)emax5[cid].fsm[i].lmmc[j].top);
d569 1
a569 1
	    switch (emax5[cid].fsm[i].memif_status) {
d571 4
a574 4
	      emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[i].ardyc = 0; /* LMM addr-request(read/write) counter */
	      emax5[cid].fsm[i].raddr = emax5[cid].fsm[i].lmmc[j].top;
	      emax5[cid].fsm[i].rlen  = emax5[cid].fsm[i].lmmc[j].len;
d588 2
a589 2
	      lmm_nreq = emax5[cid].fsm[i].lmmc[j].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	      if (emax5[cid].fsm[i].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
d591 2
a592 2
		emax5[cid].fsm[i].row_select = 1LL<<j;
		emax5[cid].fsm[i].lmwa = emax5[cid].fsm[i].raddr + sizeof(Ull)*(emax5[cid].fsm[i].ardyc*UNIT_WIDTH);
d595 1
a595 1
		switch (emax5[cid].fsm[i].lmmc[j].blk) {
d597 1
a597 1
		  ofs =        (       emax5[cid].fsm[i].lmmc[j].top                                         ) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc   )*UNIT_WIDTH;
d600 1
a600 1
		  ofs = *(Ull*)(base + emax5[cid].fsm[i].lmmc[j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%16)*UNIT_WIDTH;
d603 1
a603 1
		  ofs = *(Ull*)(base + emax5[cid].fsm[i].lmmc[j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%32)*UNIT_WIDTH;
d606 1
a606 1
		  ofs = *(Ull*)(base + emax5[cid].fsm[i].lmmc[j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%64)*UNIT_WIDTH;
d611 1
a611 1
		  emax5[cid].fsm[i].lmwd[k] = emax5[cid].fsm[i].rdata[k] = *(Ull*)(base + emax5[cid].fsm[i].raddr + ofs + sizeof(Ull)*k);
d613 3
a615 3
		    printf("%03.3d:siml_emax5: load row=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			   tid, j, (Uint)(emax5[cid].fsm[i].lmwa>>32), (Uint)emax5[cid].fsm[i].lmwa,
			   k, (Uint)(emax5[cid].fsm[i].lmwd[k]>>32), (Uint)emax5[cid].fsm[i].lmwd[k], emax5[cid].fsm[i].ardyc, lmm_nreq);
d618 1
a618 1
		emax5[cid].fsm[i].ardyc++;
d621 10
a630 10
		emax5[cid].fsm[i].lmmo[j].v   = emax5[cid].fsm[i].lmmc[j].v;
		emax5[cid].fsm[i].lmmo[j].rw  = emax5[cid].fsm[i].lmmc[j].rw;
		emax5[cid].fsm[i].lmmo[j].f   = emax5[cid].fsm[i].lmmc[j].f;
		emax5[cid].fsm[i].lmmo[j].p   = emax5[cid].fsm[i].lmmc[j].p;
		emax5[cid].fsm[i].lmmo[j].blk = emax5[cid].fsm[i].lmmc[j].blk;
		emax5[cid].fsm[i].lmmo[j].len = emax5[cid].fsm[i].lmmc[j].len;
		emax5[cid].fsm[i].lmmo[j].top = emax5[cid].fsm[i].lmmc[j].top;
		emax5[cid].fsm[i].row_select = 0LL;
		emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
		emax5[cid].fsm[i].row_count++;
d636 1
a636 1
	    emax5[cid].fsm[i].row_count++;
d643 4
a646 4
	for (i=0; i<EMAX_WIDTH; i++) {
	  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[i].row_count    = 0;
	  emax5[cid].fsm[i].row_select   = 0LL;
d652 4
a655 4
      for (sync=1,i=0; i<EMAX_WIDTH; i++) {
	j = emax5[cid].fsm[i].row_count;
	if (j < EMAX_DEPTH) {	
	  switch (emax5[cid].fsm[i].memif_status) {
d657 4
a660 4
	    emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
	    emax5[cid].fsm[i].ardyc = 0;
	    emax5[cid].fsm[i].raddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*i; /* conf_topをfsmに渡すインタフェース */
	    emax5[cid].fsm[i].rlen  =      sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
d663 3
a665 3
	    if (emax5[cid].fsm[i].ardyc < EMAX_DEPTH*2) { /* 2rrdy/1unit */
	      emax5[cid].fsm[i].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[i].row_count)%EMAX_DEPTH);
	      emax5[cid].fsm[i].lmwa = emax5[cid].fsm[i].ardyc&1; /* even/odd */
d667 3
a669 3
		emax5[cid].fsm[i].lmwd[k] = emax5[cid].fsm[i].rdata[k] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*(emax5[cid].fsm[i].ardyc*UNIT_WIDTH+k));
	      emax5[cid].fsm[i].row_count+=(emax5[cid].fsm[i].ardyc&1); /* even/odd */
	      emax5[cid].fsm[i].ardyc++;
d672 2
a673 2
	      emax5[cid].fsm[i].row_select = 0LL;
	      emax5[cid].fsm[i].memif_status = MEMIF_TERM;
d682 4
a685 4
	for (i=0; i<EMAX_WIDTH; i++) {
	  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[i].row_count    = 0;
	  emax5[cid].fsm[i].row_select   = 0LL;
d690 2
a691 2
      for (i=0; i<EMAX_WIDTH; i++) {
	switch (emax5[cid].fsm[i].memif_status) {
d693 2
a694 2
	  emax5[cid].fsm[i].row_select = 1LL<<emax5[cid].last_row0; /* start row */
	  emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
d698 4
a701 4
	  for (i=0; i<EMAX_WIDTH; i++) {
	    emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	    emax5[cid].fsm[i].row_count    = 0;
	    emax5[cid].fsm[i].row_select   = 0LL;
d709 1
a709 1
      for (sync=1,i=0; i<EMAX_WIDTH; i++) {
d712 3
a714 3
	j = emax5[cid].fsm[i].row_count;
	if (j < EMAX_DEPTH) {
	  switch ((emax5[cid].fsm[i].lmmc[j].v<<3)|(emax5[cid].fsm[i].lmmc[j].rw<<2)|(emax5[cid].fsm[i].lmmc[j].f<<1)|(emax5[cid].fsm[i].lmmc[j].p)) {
d717 4
a720 4
	    if (emax5[cid].fsm[i].lmmo[j].v
             && emax5[cid].fsm[i].lmmo[j].blk == emax5[cid].fsm[i].lmmc[j].blk
             && emax5[cid].fsm[i].lmmo[j].len == emax5[cid].fsm[i].lmmc[j].len
      	     && emax5[cid].fsm[i].lmmo[j].top == emax5[cid].fsm[i].lmmc[j].top) {
d722 2
a723 2
		printf("%03.3d:siml_emax5: pload col=%d row=%d top=%08.8x_%08.8x found in LMM\n",
		       tid, i, j, (Uint)(emax5[cid].fsm[i].lmmc[j].top>>32), (Uint)emax5[cid].fsm[i].lmmc[j].top);
d730 1
a730 1
	    if (emax5[cid].fsm[i].lmmd[j]) /* dirty exist */
d740 2
a741 2
	  /* emax5[cid].fsm[i].lmmc[j].rw=0:pload  */
	  /* emax5[cid].fsm[i].lmmc[j].rw=1:pdrain */
d744 1
a744 1
	    switch (emax5[cid].fsm[i].memif_status) {
d746 5
a750 5
	      emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
	      emax5[cid].fsm[i].ardyc = 0; /* LMM addr-request(read/write) counter */
	      if (emax5[cid].fsm[i].lmmc[j].rw == 0) { /* pload */
		emax5[cid].fsm[i].raddr = emax5[cid].fsm[i].lmmc[j].top;
		emax5[cid].fsm[i].rlen  = emax5[cid].fsm[i].lmmc[j].len;
d753 3
a755 3
		emax5[cid].fsm[i].rrdyc = 0; /* LMM data-ready(read) counter */
		emax5[cid].fsm[i].waddr = emax5[cid].fsm[i].lmmc[j].top;
		emax5[cid].fsm[i].wlen  = emax5[cid].fsm[i].lmmc[j].len;
d759 2
a760 2
	      lmm_nreq = emax5[cid].fsm[i].lmmc[j].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
	      if (emax5[cid].fsm[i].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
d762 3
a764 3
		emax5[cid].fsm[i].row_select = 1LL<<j;
		if (emax5[cid].fsm[i].lmmc[j].rw == 0) { /* pload */
		  emax5[cid].fsm[i].lmwa = emax5[cid].fsm[i].raddr + sizeof(Ull)*(emax5[cid].fsm[i].ardyc*UNIT_WIDTH);
d767 1
a767 1
		  switch (emax5[cid].fsm[i].lmmc[j].blk) {
d769 1
a769 1
		    ofs =        (       emax5[cid].fsm[i].lmmc[j].top                                         ) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc   )*UNIT_WIDTH;
d772 1
a772 1
		    ofs = *(Ull*)(base + emax5[cid].fsm[i].lmmc[j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%16)*UNIT_WIDTH;
d775 1
a775 1
		    ofs = *(Ull*)(base + emax5[cid].fsm[i].lmmc[j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%32)*UNIT_WIDTH;
d778 1
a778 1
		    ofs = *(Ull*)(base + emax5[cid].fsm[i].lmmc[j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%64)*UNIT_WIDTH;
d783 1
a783 1
		    emax5[cid].fsm[i].lmwd[k] = emax5[cid].fsm[i].rdata[k] = *(Ull*)(base + emax5[cid].fsm[i].raddr + ofs + sizeof(Ull)*k);
d785 3
a787 3
		      printf("%03.3d:siml_emax5: pload row=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			     tid, j, (Uint)(emax5[cid].fsm[i].lmwa>>32), (Uint)emax5[cid].fsm[i].lmwa,
			     k, (Uint)(emax5[cid].fsm[i].lmwd[k]>>32), (Uint)emax5[cid].fsm[i].lmwd[k], emax5[cid].fsm[i].ardyc, lmm_nreq);
d792 1
a792 1
		  emax5[cid].fsm[i].lmra = emax5[cid].fsm[i].waddr + sizeof(Ull)*(emax5[cid].fsm[i].ardyc*UNIT_WIDTH);
d794 2
a795 2
		    printf("%03.3d:siml_emax5: pdrain col=%d row=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, (Uint)(emax5[cid].fsm[i].lmra>>32), (Uint)emax5[cid].fsm[i].lmra, emax5[cid].fsm[i].ardyc, lmm_nreq);
d798 1
a798 1
		emax5[cid].fsm[i].ardyc++;
d801 11
a811 11
		if (emax5[cid].fsm[i].lmmc[j].rw == 0) { /* pload */
		  emax5[cid].fsm[i].lmmo[j].v   = emax5[cid].fsm[i].lmmc[j].v;
		  emax5[cid].fsm[i].lmmo[j].rw  = emax5[cid].fsm[i].lmmc[j].rw;
		  emax5[cid].fsm[i].lmmo[j].f   = emax5[cid].fsm[i].lmmc[j].f;
		  emax5[cid].fsm[i].lmmo[j].p   = emax5[cid].fsm[i].lmmc[j].p;
		  emax5[cid].fsm[i].lmmo[j].blk = emax5[cid].fsm[i].lmmc[j].blk;
		  emax5[cid].fsm[i].lmmo[j].len = emax5[cid].fsm[i].lmmc[j].len;
		  emax5[cid].fsm[i].lmmo[j].top = emax5[cid].fsm[i].lmmc[j].top;
		  emax5[cid].fsm[i].row_select = 0LL;
		  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
		  emax5[cid].fsm[i].row_count++;
d814 1
a814 1
		  emax5[cid].fsm[i].row_select = 0LL;
d817 2
a818 2
	      if (emax5[cid].fsm[i].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		if (emax5[cid].fsm[i].lmmc[j].rw == 1) { /* pdrain */
d820 1
a820 1
		    *(Ull*)(base + emax5[cid].fsm[i].waddr + sizeof(Ull)*(emax5[cid].fsm[i].rrdyc*UNIT_WIDTH+k)) = emax5[cid].fsm[i].wdata[k] = emax5[cid].fsm[i].lmrd[k];
d822 2
a823 2
		    printf("%03.3d:siml_emax5: pdrain col=%d row=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			   tid, i, j, k, (Uint)(emax5[cid].fsm[i].lmrd[k]>>32), (Uint)emax5[cid].fsm[i].lmrd[k], emax5[cid].fsm[i].rrdyc, lmm_nreq);
d825 1
a825 1
		  emax5[cid].fsm[i].rrdyc++;
d829 4
a832 4
		if (emax5[cid].fsm[i].lmmc[j].rw == 1) { /* pdrain */
		  emax5[cid].fsm[i].lmmd[j] = 0;
		  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
		  emax5[cid].fsm[i].row_count++;
d839 1
a839 1
	    emax5[cid].fsm[i].row_count++;
d846 4
a849 4
	for (i=0; i<EMAX_WIDTH; i++) {
	  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	  emax5[cid].fsm[i].row_count    = 0;
	  emax5[cid].fsm[i].row_select   = 0LL;
d856 4
a859 4
      for (i=0; i<EMAX_WIDTH; i++) {
	emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	emax5[cid].fsm[i].row_count    = 0;
	emax5[cid].fsm[i].row_select   = 0LL;
a888 1
  case STATUS_CONF:
d890 11
a900 5
  case STATUS_DRAIN:
  case STATUS_LOAD:
  case STATUS_REGV:
  case STATUS_START:
  case STATUS_EXEC:
d905 1
d907 42
a1128 65
siml_unit_ex1_bus(cid, i) Uint cid, i; /* edb,edc *//* ex1/eagの計算前にEDB/EDCを確定させる */
{
  int j, k;

  switch (emax4[cid].unit_edb_cmd) {
  case 1:
  case 2:
  case 4: /* data and address */
    if (emax4[cid].unit_select_row & (1LL<<i)) {
      for (j=0; j<UNIT_WIDTH; j++)
	unit[cid][i][j].edb[1].d = emax4[cid].unit_edb1[j];
    }
  case 6: /* address only */
    if (emax4[cid].unit_select_row & (1LL<<i)) {
      unit[cid][i][0].edb[0].d = emax4[cid].unit_edb0; /* edb[0].d[1..3] not exist */
      for (j=1; j<UNIT_WIDTH; j++)
	unit[cid][i][j].edb[0].d = unit[cid][i][j-1].edb[0].d;
    }
  default:
    return (0);
  case 5:
    break;
  }

  for (k=0; k<EXT_DST_BUS_NUM; k++) {
    for (j=0; j<UNIT_WIDTH; j++) {
      if (unit[cid][i][j].v1) {
        switch (unit[cid][i][j].edb[k].sel_r) { /* 0:off 1:prev_ex2.d 2:prev_mem.d */
        case 0:                                                                                      break;
        case 1: unit[cid][i][j].edb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;    break;
        case 2: unit[cid][i][j].edb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;    break;
        default:unit[cid][i][j].edb[k].d = 0xffffffff;                                               break;
        }
      }
    }
    for (j=0; j<UNIT_WIDTH; j++) {
      if (j>0 && unit[cid][i][j-1].edb[k].dir_r==1) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].edb[k].d = unit[cid][i][j-1].edb[k].d;
    }
    for (j=UNIT_WIDTH-1; j>=0; j--) {
      if (j<UNIT_WIDTH-1 && unit[cid][i][j].edb[k].dir_r==2) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].edb[k].d = unit[cid][i][j+1].edb[k].d;
    }
  }

  for (k=0; k<EXT_DST_CCR_NUM; k++) {
    for (j=0; j<UNIT_WIDTH; j++) {
      if (unit[cid][i][j].v1) {
        switch (unit[cid][i][j].edc[k].sel_r) { /* 0:off 1:prev_ex2.c */
        case 0:                                                                                  break;
        case 1:unit[cid][i][j].edc[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.c; break;
        }
      }
    }
    for (j=0; j<UNIT_WIDTH; j++) {
      if (j>0 && unit[cid][i][j-1].edc[k].dir_r==1) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].edc[k].d = unit[cid][i][j-1].edc[k].d;
    }
    for (j=UNIT_WIDTH-1; j>=0; j--) {
      if (j<UNIT_WIDTH-1 && unit[cid][i][j].edc[k].dir_r==2) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].edc[k].d = unit[cid][i][j+1].edc[k].d;
    }
  }
}

@


1.30
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.29 2016/04/04 08:51:32 nakashim Exp nakashim $";
d113 1
d115 9
d141 1
d246 1
d882 1
a882 1
siml_unit_bus1(cid, i) Uint cid, i; /* cex/exe/eagの計算前に確定させる */
d886 1
a886 1
  /* br->
d897 1
d903 1
a903 1
siml_unit_bus2(cid, i) Uint cid, i; /* lmmの計算前に確定させる */
d907 1
a907 1
  /* lmwd->lmlio/lmrio */
d918 1
d924 1
a924 1
siml_unit_cex(cid, i, j) Uint cid, i, j;
d928 1
d939 1
d945 1
a945 1
siml_unit_exe(cid, i, j) Uint cid, i, j;
d951 1
d962 1
d968 1
a968 1
siml_unit_eag(cid, i, j) Uint cid, i, j;
d972 1
d983 1
d989 1
a989 1
siml_unit_lmm(cid,  i, j) Uint cid, i, j;
d991 1
a991 1
  Uint a, s, d, k, cycles = 0;
d993 1
d1004 1
d1010 1
a1010 1
lmm_mem_access(cid, i, j, rw) Uint cid, i, j, rw;
d1012 1
a1012 2
  Uint k, a, s, bm, *wr;
  Ull rd;
d1014 2
d1026 1
@


1.29
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.28 2016/04/03 23:25:35 nakashim Exp nakashim $";
a26 4
  struct lmmi lmmo[EMAX_WIDTH][EMAX_DEPTH]; /* previous lmmi */
  struct lmmi lmmc[EMAX_WIDTH][EMAX_DEPTH]; /* current lmmi */
  Uchar       lmmd[EMAX_WIDTH][EMAX_DEPTH]; /* 0:clean, 1:dirty,   exec後store箇所に1, drain直後0 */
  Uchar       lock[EMAX_WIDTH][EMAX_DEPTH]; /* 0:free,  1:lock, AREQ時に1, DREQ時にWAYが大きいものは0 */
d28 23
d79 4
a106 24

  Ull   unit1_exec; /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:exec */
  Ull   unit1_stop; /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:stop */
  Ull   unit2_exec; /* 1bit corresponds to each row (lmm),         0:wait 1:exec */
  Ull   unit2_stop; /* 1bit corresponds to each row (lmm),         0:wait 1:stop */

  Uint  cycles_tinit_part;
  Uint  cycles_conf_part;
  Uint  cycles_lmmi_part;
  Uint  cycles_drain_part;
  Uint  cycles_load_part;
  Uint  cycles_regv_part;
  Uint  cycles_exec_part;
  Uint  cycles_term_part;
  Uint  cycles_trans_part;
  Ull   cycles_tinit;
  Ull   cycles_conf;
  Ull   cycles_lmmi;
  Ull   cycles_drain;
  Ull   cycles_load;
  Ull   cycles_regv;
  Ull   cycles_exec;
  Ull   cycles_term;
  Ull   cycles_trans;
d111 21
a131 17
  struct regv regv;       /* ea0br,ea0or,ea1br,ea1or,br[UNIT_WIDTH] */
  Uint  one_shot     : 1; /* for self_loop_control 0:init 1:self_loop */
  Uint  cexd         : 2; /* bit1: 0:none 1:exec, bit0: 0:none 1:exec */
  Ull   exdr            ;
  Ull   ea0dr           ;
  Ull   ea1dr           ;
  Ull   lmwa            ; /* -> ea0dr */
  Ull   lmra            ; /* -> ea1dr */
  Ull   axra            ; /* <- ea0dr */
  Ull   axwa            ; /* <- ea1dr .. not used */
  Ull   lmwd[UNIT_WIDTH]; /* <- axi */
  Ull   lmrd[UNIT_WIDTH]; /* -> axi */
  Ull   lmli[UNIT_WIDTH];
  Ull   lmlo[UNIT_WIDTH];
  Ull   lmri[UNIT_WIDTH];
  Ull   lmro[UNIT_WIDTH];
  Ull   tr[UNIT_WIDTH];
d133 6
a138 6
    Ull   ma0;             /* internal reg */
    Ull   ma1;             /* internal reg */
    Ull   mw[UNIT_WIDTH];  /* internal reg */
    Ull   mr0[UNIT_WIDTH]; /* internal out */
    Ull   mr1[UNIT_WIDTH]; /* internal out */
    Uchar m[LMEM_SIZE];    /* LMM */
d342 4
a345 4
	      *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+1);
	      *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+0);
	      *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+1);
d347 4
a350 4
	      *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+0) = emax5[cid].fsm[i].rdata[0] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+0);
	      *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+0)%EMAX_DEPTH])+1) = emax5[cid].fsm[i].rdata[1] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+1);
	      *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+0) = emax5[cid].fsm[i].rdata[2] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+2);
	      *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].row_count+1)%EMAX_DEPTH])+1) = emax5[cid].fsm[i].rdata[3] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+3);
d446 1
a446 1
	  switch ((emax5[cid].lmmo[i][j].v<<3)|(emax5[cid].lmmo[i][j].rw<<2)|(emax5[cid].lmmo[i][j].f<<1)|(emax5[cid].lmmo[i][j].p)) {
d450 1
a450 1
	    if (emax5[cid].lmmd[i][j]) /* dirty exist */
d467 2
a468 2
	      emax5[cid].fsm[i].waddr = emax5[cid].lmmo[i][j].top;
	      emax5[cid].fsm[i].wlen  = emax5[cid].lmmo[i][j].len;
d482 1
a482 1
	      lmm_nreq = emax5[cid].lmmo[i][j].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
d504 1
a504 1
		emax5[cid].lmmd[i][j] = 0;
d531 1
a531 1
	  switch ((emax5[cid].lmmc[i][j].v<<3)|(emax5[cid].lmmc[i][j].rw<<2)|(emax5[cid].lmmc[i][j].f<<1)|(emax5[cid].lmmc[i][j].p)) {
d534 4
a537 4
	    if (emax5[cid].lmmo[i][j].v
             && emax5[cid].lmmo[i][j].blk == emax5[cid].lmmc[i][j].blk
             && emax5[cid].lmmo[i][j].len == emax5[cid].lmmc[i][j].len
      	     && emax5[cid].lmmo[i][j].top == emax5[cid].lmmc[i][j].top) {
d540 1
a540 1
		       tid, i, j, (Uint)(emax5[cid].lmmc[i][j].top>>32), (Uint)emax5[cid].lmmc[i][j].top);
d561 2
a562 2
	      emax5[cid].fsm[i].raddr = emax5[cid].lmmc[i][j].top;
	      emax5[cid].fsm[i].rlen  = emax5[cid].lmmc[i][j].len;
d576 1
a576 1
	      lmm_nreq = emax5[cid].lmmc[i][j].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
d583 1
a583 1
		switch (emax5[cid].lmmc[i][j].blk) {
d585 1
a585 1
		  ofs =        (       emax5[cid].lmmc[i][j].top                                         ) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc   )*UNIT_WIDTH;
d588 1
a588 1
		  ofs = *(Ull*)(base + emax5[cid].lmmc[i][j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%16)*UNIT_WIDTH;
d591 1
a591 1
		  ofs = *(Ull*)(base + emax5[cid].lmmc[i][j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%32)*UNIT_WIDTH;
d594 1
a594 1
		  ofs = *(Ull*)(base + emax5[cid].lmmc[i][j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%64)*UNIT_WIDTH;
d609 7
a615 7
		emax5[cid].lmmo[i][j].v   = emax5[cid].lmmc[i][j].v;
		emax5[cid].lmmo[i][j].rw  = emax5[cid].lmmc[i][j].rw;
		emax5[cid].lmmo[i][j].f   = emax5[cid].lmmc[i][j].f;
		emax5[cid].lmmo[i][j].p   = emax5[cid].lmmc[i][j].p;
		emax5[cid].lmmo[i][j].blk = emax5[cid].lmmc[i][j].blk;
		emax5[cid].lmmo[i][j].len = emax5[cid].lmmc[i][j].len;
		emax5[cid].lmmo[i][j].top = emax5[cid].lmmc[i][j].top;
d702 1
a702 1
	  switch ((emax5[cid].lmmc[i][j].v<<3)|(emax5[cid].lmmc[i][j].rw<<2)|(emax5[cid].lmmc[i][j].f<<1)|(emax5[cid].lmmc[i][j].p)) {
d705 4
a708 4
	    if (emax5[cid].lmmo[i][j].v
             && emax5[cid].lmmo[i][j].blk == emax5[cid].lmmc[i][j].blk
             && emax5[cid].lmmo[i][j].len == emax5[cid].lmmc[i][j].len
      	     && emax5[cid].lmmo[i][j].top == emax5[cid].lmmc[i][j].top) {
d711 1
a711 1
		       tid, i, j, (Uint)(emax5[cid].lmmc[i][j].top>>32), (Uint)emax5[cid].lmmc[i][j].top);
d718 1
a718 1
	    if (emax5[cid].lmmd[i][j]) /* dirty exist */
d728 2
a729 2
	  /* emax5[cid].lmmc[i][j].rw=0:pload  */
	  /* emax5[cid].lmmc[i][j].rw=1:pdrain */
d736 3
a738 3
	      if (emax5[cid].lmmc[i][j].rw == 0) { /* pload */
		emax5[cid].fsm[i].raddr = emax5[cid].lmmc[i][j].top;
		emax5[cid].fsm[i].rlen  = emax5[cid].lmmc[i][j].len;
d742 2
a743 2
		emax5[cid].fsm[i].waddr = emax5[cid].lmmc[i][j].top;
		emax5[cid].fsm[i].wlen  = emax5[cid].lmmc[i][j].len;
d747 1
a747 1
	      lmm_nreq = emax5[cid].lmmc[i][j].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
d751 1
a751 1
		if (emax5[cid].lmmc[i][j].rw == 0) { /* pload */
d755 1
a755 1
		  switch (emax5[cid].lmmc[i][j].blk) {
d757 1
a757 1
		    ofs =        (       emax5[cid].lmmc[i][j].top                                         ) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc   )*UNIT_WIDTH;
d760 1
a760 1
		    ofs = *(Ull*)(base + emax5[cid].lmmc[i][j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/16)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%16)*UNIT_WIDTH;
d763 1
a763 1
		    ofs = *(Ull*)(base + emax5[cid].lmmc[i][j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/32)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%32)*UNIT_WIDTH;
d766 1
a766 1
		    ofs = *(Ull*)(base + emax5[cid].lmmc[i][j].top+sizeof(Ull)*(emax5[cid].fsm[i].ardyc/64)) + sizeof(Ull)*(emax5[cid].fsm[i].ardyc%64)*UNIT_WIDTH;
d789 8
a796 8
		if (emax5[cid].lmmc[i][j].rw == 0) { /* pload */
		  emax5[cid].lmmo[i][j].v   = emax5[cid].lmmc[i][j].v;
		  emax5[cid].lmmo[i][j].rw  = emax5[cid].lmmc[i][j].rw;
		  emax5[cid].lmmo[i][j].f   = emax5[cid].lmmc[i][j].f;
		  emax5[cid].lmmo[i][j].p   = emax5[cid].lmmc[i][j].p;
		  emax5[cid].lmmo[i][j].blk = emax5[cid].lmmc[i][j].blk;
		  emax5[cid].lmmo[i][j].len = emax5[cid].lmmc[i][j].len;
		  emax5[cid].lmmo[i][j].top = emax5[cid].lmmc[i][j].top;
d806 1
a806 1
		if (emax5[cid].lmmc[i][j].rw == 1) { /* pdrain */
d817 2
a818 2
		if (emax5[cid].lmmc[i][j].rw == 1) { /* pdrain */
		  emax5[cid].lmmd[i][j] = 0;
d874 13
d894 14
d914 13
d935 13
d954 13
d973 13
d993 13
a1060 1
  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
@


1.28
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.27 2016/04/03 14:43:16 nakashim Exp nakashim $";
d699 1
a699 1
	  switch ((emax5[cid].lmmo[i][j].v<<3)|(emax5[cid].lmmo[i][j].rw<<2)|(emax5[cid].lmmo[i][j].f<<1)|(emax5[cid].lmmo[i][j].p)) {
a700 6
	  case 13: /* lmd */
	    if (emax5[cid].lmmd[i][j]) /* dirty exist */
	      flag = 1; /* pdrain */
	    else
	      flag = 0; /* skip pdrain */
	    break;
d714 6
d725 2
a726 2
	  /*------------------------ここまで----------------------------*/
	  /* drain/pload */
d728 94
d871 1
@


1.27
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.26 2016/04/02 14:04:00 nakashim Exp nakashim $";
d304 2
a305 1
	    else
d307 1
d351 2
a352 1
	    else
d354 1
d613 1
d656 2
a657 1
	    else
d659 1
d701 21
a721 2
	  /*------------------------ここまで----------------------------*/
	  case 12: /* ??? */
d725 2
@


1.26
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.25 2016/04/02 08:52:36 nakashim Exp nakashim $";
d285 22
a306 17
	switch (emax5[cid].fsm[i].memif_status) {
	case MEMIF_AREQ:
	  emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
	  emax5[cid].fsm[i].ardyc = 0;
	  emax5[cid].fsm[i].raddr = conf+sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*i; /* conf_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rlen  =      sizeof(Ull)*UNIT_WIDTH*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
	  break;
	case MEMIF_DREQ:
	  if (emax5[cid].fsm[i].ardyc < EMAX_DEPTH) { /* 1rrdy/1unit */
	    emax5[cid].fsm[i].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[i].row_count)%EMAX_DEPTH);
	    emax5[cid].fsm[i].lmwa = 0LL; /* fixed */
	    for (k=0; k<UNIT_WIDTH; k++)
	      emax5[cid].fsm[i].lmwd[k] = emax5[cid].fsm[i].rdata[k] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*(emax5[cid].fsm[i].ardyc*UNIT_WIDTH+k));
	    emax5[cid].fsm[i].last_dist = emax5[cid].fsm[i].rdata[3] & 0x3f; /* mapdist */
	    emax5[cid].fsm[i].row_count++;
	    emax5[cid].fsm[i].ardyc++;
	    sync = 0; /* not finished */
d308 1
a308 3
	  else
	    emax5[cid].fsm[i].memif_status = MEMIF_TERM;
	  break;
d326 26
a351 20
	switch (emax5[cid].fsm[i].memif_status) {
	case MEMIF_AREQ:
	  emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
	  emax5[cid].fsm[i].ardyc = 0;
	  emax5[cid].fsm[i].raddr = lmmi+sizeof(Ull)*2*EMAX_DEPTH*i; /* lmmi_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rlen  =      sizeof(Ull)*2*EMAX_DEPTH*1; /* lmmi_topをfsmに渡すインタフェース */
	  break;
	case MEMIF_DREQ:
	  if (emax5[cid].fsm[i].ardyc < EMAX_DEPTH/2) { /* 1rrdy/2unit */
	    *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+0);
	    *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+1);
	    *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+0);
	    *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+1);

	    *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+0) = emax5[cid].fsm[i].rdata[0] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+0);
	    *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+1) = emax5[cid].fsm[i].rdata[1] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+1);
	    *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+0) = emax5[cid].fsm[i].rdata[2] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+2);
	    *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+1) = emax5[cid].fsm[i].rdata[3] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*emax5[cid].fsm[i].ardyc*UNIT_WIDTH+3);
	    emax5[cid].fsm[i].ardyc++;
	    sync = 0; /* not finished */
d353 1
a353 3
	  else
	    emax5[cid].fsm[i].memif_status = MEMIF_TERM;
	  break;
a506 1

a617 1

d633 21
a653 16
	switch (emax5[cid].fsm[i].memif_status) {
	case MEMIF_AREQ:
	  emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
	  emax5[cid].fsm[i].ardyc = 0;
	  emax5[cid].fsm[i].raddr = regv+sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*i; /* conf_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rlen  =      sizeof(Ull)*UNIT_WIDTH*2*EMAX_DEPTH*1; /* conf_topをfsmに渡すインタフェース */
	  break;
	case MEMIF_DREQ:
	  if (emax5[cid].fsm[i].ardyc < EMAX_DEPTH*2) { /* 2rrdy/1unit */
	    emax5[cid].fsm[i].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[i].row_count/2)%EMAX_DEPTH);
	    emax5[cid].fsm[i].lmwa = emax5[cid].fsm[i].row_count&1; /* even/odd */
	    for (k=0; k<UNIT_WIDTH; k++)
	      emax5[cid].fsm[i].lmwd[k] = emax5[cid].fsm[i].rdata[k] = *(Ull*)(base + emax5[cid].fsm[i].raddr + sizeof(Ull)*(emax5[cid].fsm[i].ardyc*UNIT_WIDTH+k));
	    emax5[cid].fsm[i].row_count++;
	    emax5[cid].fsm[i].ardyc++;
	    sync = 0; /* not finished */
d655 1
a655 3
	  else
	    emax5[cid].fsm[i].memif_status = MEMIF_TERM;
	  break;
a667 1
      emax5[cid].status = STATUS_EXEC;
d669 14
a682 4
	emax5[cid].fsm[i].row_select = 1LL<<emax5[cid].last_row0; /* start row */
	emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
	emax5[cid].fsm[i].row_count    = 0;
	emax5[cid].fsm[i].row_select   = 0LL;
d687 21
a707 3
      for (sync=1,i=0; i<EMAX_WIDTH; i++)
	emax5[cid].fsm[i].row_select = 0LL; /* clear start flag */
      if (!(emax5[cid].unit1_exec | emax5[cid].unit2_exec)) { /* finished */
a714 1
      /*------------------------ここまで----------------------------*/
d836 1170
@


1.25
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.24 2016/03/29 13:20:25 nakashim Exp nakashim $";
d24 1
a24 1
  Ull   *last_conf           ; /* for insn_reuse */
d75 1
a75 1
    Ull   *raddr;              /* read-address  of mm      v   v   v   v           v                 */
d78 1
a78 1
    Ull   *waddr;              /* write-address of mm                      v                         */
d261 1
a261 1
      if (emax5[cid].last_conf != (Ull*)(base+conf) || emax5[cid].last_dist > 0) {
d264 1
a264 1
	emax5[cid].status  = STATUS_CONF;
d274 1
a274 1
	emax5[cid].status  = STATUS_LMMI;
d289 2
a290 2
	  emax5[cid].fsm[i].raddr = base+(conf+UNIT_WIDTH*EMAX_DEPTH*i); /* conf_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rlen  =           (UNIT_WIDTH*EMAX_DEPTH*1); /* conf_topをfsmに渡すインタフェース */
d295 1
a295 1
	    emax5[cid].fsm[i].lmwa = 0LL;
d297 2
a298 2
	      emax5[cid].fsm[i].lmwd[k] = emax5[cid].fsm[i].rdata[k] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*UNIT_WIDTH+k];
	    emax5[cid].fsm[i].last_dist  = emax5[cid].fsm[i].rdata[3] & 0x3f; /* mapdist */
d309 1
a309 1
	emax5[cid].last_conf = (Ull*)(base+conf);
d312 1
a312 1
	emax5[cid].status  = STATUS_LMMI;
d327 2
a328 2
	  emax5[cid].fsm[i].raddr = base+(lmmi+2*EMAX_DEPTH*i); /* lmmi_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rlen  =           (2*EMAX_DEPTH*1); /* lmmi_topをfsmに渡すインタフェース */
d337 4
a340 4
	    *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+0) = (emax5[cid].fsm[i].rdata[0] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*4+0]);
	    *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+1) = (emax5[cid].fsm[i].rdata[1] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*4+1]);
	    *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+0) = (emax5[cid].fsm[i].rdata[2] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*4+2]);
	    *(((Ull*)&emax5[cid].lmmc[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+1) = (emax5[cid].fsm[i].rdata[3] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*4+3]);
d350 1
a350 1
	emax5[cid].status  = STATUS_DRAIN;
d453 1
a453 1
	      emax5[cid].fsm[i].waddr = (Ull*)emax5[cid].lmmo[i][j].top; /* under 32bitOS: size mismatch */
d471 1
a471 1
		emax5[cid].fsm[i].lmra = (Ull)(emax5[cid].fsm[i].waddr+emax5[cid].fsm[i].ardyc*UNIT_WIDTH); /* under 32bitOS: size mismatch */
d482 1
a482 2
		  emax5[cid].fsm[i].waddr[emax5[cid].fsm[i].rrdyc*UNIT_WIDTH+k] = 
emax5[cid].fsm[i].wdata[k] = emax5[cid].fsm[i].lmrd[k];
d505 1
a505 1
	emax5[cid].status  = STATUS_LOAD;
d548 1
a548 1
	      emax5[cid].fsm[i].raddr = (Ull*)emax5[cid].lmmc[i][j].top; /* under 32bitOS: size mismatch */
d565 1
d567 1
a567 2
		emax5[cid].fsm[i].lmwa = (Ull)(emax5[cid].fsm[i].raddr+emax5[cid].fsm[i].ardyc*UNIT_WIDTH); /* under 32bitOS: size mismatch */
		for (k=0; k<UNIT_WIDTH; k++) {
d569 15
a583 16
		  /*** GATHER ************/
		  switch (emax5[cid].lmmc[i][j].blk) {
		  case 0: /* inf */
		    emax5[cid].fsm[i].lmwd[k] = emax5[cid].fsm[i].rdata[k] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*UNIT_WIDTH+k];
		    a =         (     emax5[cid].lmmc[i][j].top                                         )+(emax5[cid].fsm[i].ardyc   )*UNIT_WIDTH;
		    break;
		  case 1: /* 16 */
		    a = *(Uint*)(base+emax5[cid].lmmc[i][j].top+(emax5[cid].fsm[i].ardyc/16)*sizeof(Ull))+(emax5[cid].fsm[i].ardyc%16)*UNIT_WIDTH;
		    break;
		  case 2: /* 32 */
		    a = *(Uint*)(base+emax5[cid].lmmc[i][j].top+(emax5[cid].fsm[i].ardyc/32)*sizeof(Ull))+(emax5[cid].fsm[i].ardyc%32)*UNIT_WIDTH;
		    break;
		  case 3: /* 64 */
		    a = *(Uint*)(base+emax5[cid].lmmc[i][j].top+(emax5[cid].fsm[i].ardyc/64)*sizeof(Ull))+(emax5[cid].fsm[i].ardyc%64)*UNIT_WIDTH;
		    break;
		  }
d585 2
d617 1
a617 1
	emax5[cid].status  = STATUS_REGV;
a624 1
      /*------------------------ここまで----------------------------*/
d627 21
a647 8
      if (wrdyc[cid] < EMAX_DEPTH*sizeof(struct regv)/(sizeof(Uint)*EMAX_WIDTH)) { /* rrdy */
	emax5[cid].fsm_cmd = FSM_REGV;     /* 一旦latch.次のCLKでUNIT書き込み */
	emax5[cid].select_row = 1LL<<((emax5[cid].last_row0+wrdyc[cid]/(sizeof(struct regv)/(sizeof(Uint)*EMAX_WIDTH)))%EMAX_DEPTH);
	emax5[cid].unit_select_col = (1<<EMAX_WIDTH)-1; /* all-1 */
	emax5[cid].unit_edb0 = wrdyc[cid]%(sizeof(struct regv)/(sizeof(Uint)*EMAX_WIDTH));    /* select target registers */
	for (j=0; j<EMAX_WIDTH; j++) {
	  Uint *tp1 = emax5[cid].maddr;
	  emax5[cid].unit_edb1[j] = tp1[wrdyc[cid]*EMAX_WIDTH+j]; /* 一旦latch.次のCLKでUNIT書き込み */
a648 1
	wrdyc[cid]++;
d650 7
a656 5
      else {
	emax5[cid].pe0_status      = STATUS_MEMI;
	emax5[cid].fsm_cmd    = FSM_IDLE; 
	emax5[cid].maddr = (Uint*)(base+start+sizeof(conf)+sizeof(regv));
	wrdyc[cid] = 0;
d660 7
a666 4
      emax5[cid].pe0_status      = STATUS_EXEC;
      emax5[cid].fsm_cmd    = FSM_EXEC; /* 一旦latch.次のCLKでUNIT書き込み */
      emax5[cid].select_row = 1LL<<emax5[cid].last_row0;
      emax5[cid].unit_select_col = (1<<EMAX_WIDTH)-1; /* all-1 */
d668 1
a668 1
    case STATUS_EXEC:
d670 8
a677 24
      /* Step 8.5: (each unit) start execution                */
      /* simulate from stage15 to stage0, from col=3 to col=0 */
      /*  0:nop,  1:LMR,  2:LMW,  3:LMX, *4:LMP,  5:LMF(force read), *6:LMD */
      /* *8:MMR  *9:MMTR */
      /* LMM-STOREの同段にLMWと書くと, アレイ動作後にLMM->MEM書き出し動作 */
      /* LMM-STOREの前段にLMDと書き,次のアレイ動作中にLMM-MEM追い出しを行う */
      /* 最終結果をLMDで書き出すためには外側ループを1回余分に実行 */
      /*  case1:  LMR/F     EXE      LMW/X                       */
      /*  case2:  LMR   LMP EXE LMD        (seq read, seq write) */
      /*  case3:  LMR   LMP EXE MMTR       (seq read, rnd write) */
      /*  case4:        MMR EXE LMD        (rnd read, seq write) */
      /*  case5:        MMR EXE MMTR       (rnd read, rnd write) */
      {
	Ull all_status = 0LL;
	emax5[cid].select_row = 0; /* inhibit initial restart */
	emax5[cid].unit_select_col = 0; /* inhibit initial restart */
	
	all_status |= emax5[cid].unit1_exec | emax5[cid].unit2_exec;
	if (all_status==0) {
	  emax5[cid].pe0_status     = STATUS_DRAIN;
	  emax5[cid].fsm_cmd   = FSM_IDLE; 
	  emax5[cid].unit_ctl_count = 0;
	  wrdyc[cid] = 0;
	  rrdyc[cid] = 0;
d680 1
a682 1
      /* last_row0 設定 */
d684 10
a693 4
      emax5[cid].pe0_status  = STATUS_IDLE;
      printf(" %d %d %d %d %d %d %d %d\n",
	     emax5[cid].cycles_conf_part, emax5[cid].cycles_drain_part, emax5[cid].cycles_lmmi_part, emax5[cid].cycles_regv_part,
	     emax5[cid].cycles_load_part, emax5[cid].cycles_exec_part,  emax5[cid].cycles_term_part, emax5[cid].cycles_trans_part);
d695 1
d697 1
a697 1
      emax5[cid].cycles_lmmi     += emax5[cid].cycles_lmmi_part;
a698 1
      emax5[cid].cycles_load     += emax5[cid].cycles_load_part;
d760 1
a760 1
  printf("%03.3d:EMAX5 tinit=%08.8x_%08.8x conf=%08.8x_%08.8x drain=%08.8x_%08.8x  lmmi=%08.8x_%08.8x  regv=%08.8x_%08.8x\n",
d764 1
a765 3
	 (Uint)(emax5[cid].cycles_lmmi>>32),  (Uint)emax5[cid].cycles_lmmi,
	 (Uint)(emax5[cid].cycles_regv>>32),  (Uint)emax5[cid].cycles_regv);
  printf("           load=%08.8x_%08.8x exec=%08.8x_%08.8x  term=%08.8x_%08.8x trans=%08.8x_%08.8x\n",
d767 2
d772 1
a772 1
  total = emax5[cid].cycles_tinit+emax5[cid].cycles_conf+emax5[cid].cycles_drain+emax5[cid].cycles_lmmi+emax5[cid].cycles_regv+emax5[cid].cycles_load+emax5[cid].cycles_exec+emax5[cid].cycles_term+emax5[cid].cycles_trans;
d774 1
a774 1
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(icdlrlett)", 2400/EMAX5HOST_RATIO, (Uint)(total>>32), (Uint)total);
d776 1
a776 1
  printf(" TOTAL_CYCLE=%08.8x_%08.8x(icdlrlett)\033[0m\n", (Uint)(total>>32), (Uint)total);
d780 1
d782 1
a782 1
  emax5[cid].cycles_lmmi  = 0LL;
a783 1
  emax5[cid].cycles_load  = 0LL;
@


1.24
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.23 2016/03/28 15:02:56 nakashim Exp nakashim $";
a26 1
  Uchar       lmmd[EMAX_WIDTH][EMAX_DEPTH]; /* 0:clean,   1:suspended drain, exec後store箇所に1, drain時0 */
d28 3
a30 1
  struct lmmi lmmi[EMAX_WIDTH][EMAX_DEPTH]; /* current lmmi */
d122 6
a127 6
  Ull   axrd[UNIT_WIDTH]; /* <- axi */
  Ull   axwd[UNIT_WIDTH]; /* -> axi */
  Ull   axli[UNIT_WIDTH];
  Ull   axlo[UNIT_WIDTH];
  Ull   axri[UNIT_WIDTH];
  Ull   axro[UNIT_WIDTH];
d332 9
a340 9
	    *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+0);
	    *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+1);
	    *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+0) = *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+0);
	    *(((Ull*)&emax5[cid].lmmo[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+1) = *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+1);

	    *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+0) = (emax5[cid].fsm[i].rdata[0] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*4+0]);
	    *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+0)%EMAX_DEPTH])+1) = (emax5[cid].fsm[i].rdata[1] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*4+1]);
	    *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+0) = (emax5[cid].fsm[i].rdata[2] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*4+2]);
	    *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].ardyc*2+1)%EMAX_DEPTH])+1) = (emax5[cid].fsm[i].rdata[3] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*4+3]);
d439 1
a439 1
	      flag = 0; /* skip */
d442 1
a442 1
	    flag = 0; /* skip */
d473 2
a474 2
		  printf("%03.3d:siml_emax5: drain row=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			 tid, j, (Uint)(emax5[cid].fsm[i].lmra>>32), (Uint)emax5[cid].fsm[i].lmra, emax5[cid].fsm[i].ardyc, lmm_nreq);
d482 2
a483 1
		  emax5[cid].fsm[i].waddr[emax5[cid].fsm[i].rrdyc*UNIT_WIDTH+k] = emax5[cid].fsm[i].wdata[k] = emax5[cid].fsm[i].lmrd[k];
d485 2
a486 2
		  printf("%03.3d:siml_emax5: drain row=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			 tid, j, k, (Uint)(emax5[cid].fsm[i].lmrd[k]>>32), (Uint)emax5[cid].fsm[i].lmrd[k], emax5[cid].fsm[i].rrdyc, lmm_nreq);
d519 1
a519 1
	  switch ((emax5[cid].lmmi[i][j].v<<3)|(emax5[cid].lmmi[i][j].rw<<2)|(emax5[cid].lmmi[i][j].f<<1)|(emax5[cid].lmmi[i][j].p)) {
d523 3
a525 3
             && emax5[cid].lmmo[i][j].blk == emax5[cid].lmmi[i][j].blk
             && emax5[cid].lmmo[i][j].len == emax5[cid].lmmi[i][j].len
      	     && emax5[cid].lmmo[i][j].top == emax5[cid].lmmi[i][j].top) {
d527 2
a528 2
		printf("%03.3d:siml_emax5: load row=%d top=%08.8x_%08.8x found in LMM\n",
		       tid, j, (Uint)(emax5[cid].lmmi[i][j].top>>32), (Uint)emax5[cid].lmmi[i][j].top);
d549 2
a550 49
	      emax5[cid].fsm[i].raddr = (Ull*)emax5[cid].lmmi[i][j].top; /* under 32bitOS: size mismatch */
	      emax5[cid].fsm[i].rlen  = emax5[cid].lmmi[i][j].len;

#if 0
	      emax5[cid].unit_edb0 = emax5[cid].memi_new[i].lmm_top[j]+wrdyc[cid]*sizeof(Uint); /* select target registers */
	      /*** GATHER ************/
	      switch (emax5[cid].memi_new[i].mctr0[j].block) {
	      case 0: /* inf */
		a =         (     emax5[cid].lmmi[i][j].top                                         )+(emax5[cid].fsm[i].ardyc   )*UNIT_WIDTH;
		break;
	      case 1: /* 16 */
		a = *(Uint*)(base+emax5[cid].lmmi[i][j].top+(emax5[cid].fsm[i].ardyc/16)*sizeof(Ull))+(emax5[cid].fsm[i].ardyc%16)*UNIT_WIDTH;
		break;
	      case 2: /* 32 */
		a = *(Uint*)(base+emax5[cid].lmmi[i][j].top+(emax5[cid].fsm[i].ardyc/32)*sizeof(Ull))+(emax5[cid].fsm[i].ardyc%32)*UNIT_WIDTH;
		break;
	      case 3: /* 64 */
		a = *(Uint*)(base+emax5[cid].lmmi[i][j].top+(emax5[cid].fsm[i].ardyc/64)*sizeof(Ull))+(emax5[cid].fsm[i].ardyc%64)*UNIT_WIDTH;
		break;
	      }
#endif

#if 0
      /* 4D対応:同一ステージに,同一areaのlmmiが存在する場合,バスを使って放送するモデル  */
      /* 同一ステージでの競合回避手段が必要. 早いものWAY勝ちでよいとする.               */
      /* lmmd[][]と同様にlock[][]を追加.                                                */
      /*   MEMIF_AREQ: lockする(複数同時を許す)                                         */
      /*   MEMIF_DREQ: 複数lockを検査し,WAY番号がより大きいほうが解除. row_count++;     */
      for (k=j+1; k<EMAX_WIDTH; k++) {
	if (emax5[cid].memi_new[i].mctr0[k].v
	    && emax5[cid].memi_new[i].mctr0[k].bank  == emax5[cid].memi_new[i].mctr0[j].bank
	    && emax5[cid].memi_new[i].mctr0[k].width == emax5[cid].memi_new[i].mctr0[j].width
	    && emax5[cid].memi_new[i].mctr0[k].block == emax5[cid].memi_new[i].mctr0[j].block
	    && emax5[cid].memi_new[i].mctr0[k].dist  == emax5[cid].memi_new[i].mctr0[j].dist
	    && emax5[cid].memi_new[i].lmm_top[k]     == emax5[cid].memi_new[i].lmm_top[j]
	    && emax5[cid].memi_new[i].mem_top[k]     == emax5[cid].memi_new[i].mem_top[j]
	    && emax5[cid].memi_new[i].len[k]         == emax5[cid].memi_new[i].len[j]) {
	  emax5[cid].unit_select_col |= 1<<k;
	  emax5[cid].memi_old[i].mctr0[k]   = emax5[cid].memi_new[i].mctr0[j];
	  emax5[cid].memi_old[i].lmm_top[k] = emax5[cid].memi_new[i].lmm_top[j];
	  emax5[cid].memi_old[i].mem_top[k] = emax5[cid].memi_new[i].mem_top[j];
	  emax5[cid].memi_old[i].len[k]     = emax5[cid].memi_new[i].len[j];
	  if (trace)
	    printf("step 8.4: mctl[%d].ltop[%d] linked to col=%d\n", i, k, j);
	}
      }
#endif


d564 1
a564 1
	      lmm_nreq = emax5[cid].lmmi[i][j].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
d568 24
a591 6
		for (k=0; k<UNIT_WIDTH; k++)
		  emax5[cid].fsm[i].lmwd[k] = emax5[cid].fsm[i].rdata[k] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].ardyc*UNIT_WIDTH+k];
		if (trace) {
		  printf("%03.3d:siml_emax5: load row=%d lmwa=%08.8x_%08.8x lmwd[%d]=%08.8x_%08.8x (%d/%d)\n",
			 tid, j, (Uint)(emax5[cid].fsm[i].lmwa>>32), (Uint)emax5[cid].fsm[i].lmwa,
			 k, (Uint)(emax5[cid].fsm[i].lmwd[k]>>32), (Uint)emax5[cid].fsm[i].lmwd[k], emax5[cid].fsm[i].ardyc, lmm_nreq);
d596 7
a602 6
		emax5[cid].lmmo[i][j].rw  = emax5[cid].lmmi[i][j].rw;
		emax5[cid].lmmo[i][j].f   = emax5[cid].lmmi[i][j].f;
		emax5[cid].lmmo[i][j].p   = emax5[cid].lmmi[i][j].p;
		emax5[cid].lmmo[i][j].blk = emax5[cid].lmmi[i][j].blk;
		emax5[cid].lmmo[i][j].len = emax5[cid].lmmi[i][j].len;
		emax5[cid].lmmo[i][j].top = emax5[cid].lmmi[i][j].top;
@


1.23
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.22 2016/03/27 15:54:31 nakashim Exp nakashim $";
d549 47
a650 38
#if 0
      /* 4D対応:同一ステージに,同一アドレス+長さのLMMが存在する場合,ブロードキャストするモデル */
      for (k=j+1; k<EMAX_WIDTH; k++) {
	if (emax5[cid].memi_new[i].mctr0[k].v
	    && emax5[cid].memi_new[i].mctr0[k].bank  == emax5[cid].memi_new[i].mctr0[j].bank
	    && emax5[cid].memi_new[i].mctr0[k].width == emax5[cid].memi_new[i].mctr0[j].width
	    && emax5[cid].memi_new[i].mctr0[k].block == emax5[cid].memi_new[i].mctr0[j].block
	    && emax5[cid].memi_new[i].mctr0[k].dist  == emax5[cid].memi_new[i].mctr0[j].dist
	    && emax5[cid].memi_new[i].lmm_top[k]     == emax5[cid].memi_new[i].lmm_top[j]
	    && emax5[cid].memi_new[i].mem_top[k]     == emax5[cid].memi_new[i].mem_top[j]
	    && emax5[cid].memi_new[i].len[k]         == emax5[cid].memi_new[i].len[j]) {
	  emax5[cid].unit_select_col |= 1<<k;
	  emax5[cid].memi_old[i].mctr0[k]   = emax5[cid].memi_new[i].mctr0[j];
	  emax5[cid].memi_old[i].lmm_top[k] = emax5[cid].memi_new[i].lmm_top[j];
	  emax5[cid].memi_old[i].mem_top[k] = emax5[cid].memi_new[i].mem_top[j];
	  emax5[cid].memi_old[i].len[k]     = emax5[cid].memi_new[i].len[j];
	  if (trace)
	    printf("step 8.4: mctl[%d].ltop[%d] linked to col=%d\n", i, k, j);
	}
      }

      emax5[cid].unit_edb0 = emax5[cid].memi_new[i].lmm_top[j]+wrdyc[cid]*sizeof(Uint); /* select target registers */
      /*** GATHER ************/
      switch (emax5[cid].memi_new[i].mctr0[j].block) {
      case 0: /* inf */
	a =               emax5[cid].memi_new[i].mem_top[j]                         +(wrdyc[cid]   )*sizeof(Uint)*width*dist;
	break;
      case 1: /* 16 */
	a = *(Uint*)(base+emax5[cid].memi_new[i].mem_top[j]+(wrdyc[cid]/16)*sizeof(Uint))+(wrdyc[cid]%16)*sizeof(Uint)*width*dist;
	break;
      case 2: /* 32 */
	a = *(Uint*)(base+emax5[cid].memi_new[i].mem_top[j]+(wrdyc[cid]/32)*sizeof(Uint))+(wrdyc[cid]%32)*sizeof(Uint)*width*dist;
	break;
      case 3: /* 64 */
	a = *(Uint*)(base+emax5[cid].memi_new[i].mem_top[j]+(wrdyc[cid]/64)*sizeof(Uint))+(wrdyc[cid]%64)*sizeof(Uint)*width*dist;
	break;
      }
#endif
@


1.22
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.21 2016/03/20 04:16:40 nakashim Exp nakashim $";
d27 2
a29 2
  struct lmmi lmmo[EMAX_WIDTH][EMAX_DEPTH]; /* previous lmmi */
  Uchar       lmmd[EMAX_WIDTH][EMAX_DEPTH]; /* 0:clean,   1:suspended drain, exec後store箇所に1, drain時0 */
d31 1
a31 1
                               /* 未loadLMMが残っている場合,lmmiの前にdrain           */
d42 2
a43 2
                               /*(3):drain fsm_way毎に,fsm内部の全lmmiに未loadLMMがあるか検査         */
                               /*          未loadLMMが存在する場合,fsm_way毎に,last_row0から順にdrain */
d45 2
a46 2
                               /*(4):load  fsm_way毎に,fsm内部の全lmmiに未loadLMMがあるか検査         */
                               /*          未loadLMMが存在する場合,fsm_way毎に,last_row0から順にload  */
d190 1
a190 1
  int i, j, k, sync;
d418 1
a422 1
      /*      1  1  1  0 ... lmx       必ずdrainとregvの間にload                                        --            store:d=1            */
d435 39
a473 31
	    if (emax5[cid].lmmd[i][j]) { /* dirty exist */
	      Uint lmm_nreq;
	      switch (emax5[cid].fsm[i].memif_status) {
	      case MEMIF_AREQ:
		emax5[cid].fsm[i].memif_status = MEMIF_DREQ;
		emax5[cid].fsm[i].ardyc = 0; /* LMM addr-request(read/write) counter */
		emax5[cid].fsm[i].rrdyc = 0; /* LMM data-ready(read) counter */
		emax5[cid].fsm[i].waddr = (Ull*)emax5[cid].lmmo[i][j].top; /* under 32bitOS: size mismatch */
		emax5[cid].fsm[i].wlen  = emax5[cid].lmmo[i][j].len;
		break;
	      case MEMIF_DREQ:
		/* block 0:inf, 1:16, 2:32, 3:64 dword*UNIT_WIDTH*block=page(burst_size)    */
		/* 通常は,     block=0                                                      */
		/* tricountは, block=2                                                      */
		/* EMAX5では必ず64bit*4幅                                                   */
		/* align=8B,  block=0, blocking=none             ... 下位5bit無視 4倍幅load */
		/* align=16B, block=0, blocking=none             ... 下位5bit無視 4倍幅load */
		/* align=32B, block=0, blocking=none             ... align済 4倍幅load      */
		/* --- blocking-load --- : fsmがblock単位にburst起動                        */
		/* align=xxx, block=1, blocksize=8*4*16=512B     ... 下位5bit無視 4倍幅load */
		/* align=xxx, block=2, blocksize=8*4*32=1KB      ... 下位5bit無視 4倍幅load */
		/* align=xxx, block=3, blocksize=8*4*64=2KB      ... 下位5bit無視 4倍幅load */
		lmm_nreq = emax5[cid].lmmo[i][j].len/UNIT_WIDTH; /* dwords/4 -> 4dword/cycle */
		if (emax5[cid].fsm[i].ardyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		  emax5[cid].fsm[i].row_select = 1LL<<j;
		  emax5[cid].fsm[i].lmra = (Ull)(emax5[cid].fsm[i].waddr+emax5[cid].fsm[i].ardyc*UNIT_WIDTH); /* under 32bitOS: size mismatch */
		  if (trace) {
		    printf("%03.3d:siml_emax5: drain row=%d lmra=%08.8x_%08.8x (%d/%d)\n",
			   tid, j, (Uint)(emax5[cid].fsm[i].lmra>>32), (Uint)emax5[cid].fsm[i].lmra, emax5[cid].fsm[i].ardyc, lmm_nreq);
		  }
		  emax5[cid].fsm[i].ardyc++;
d475 10
a484 10
		else
		  emax5[cid].fsm[i].row_select = 0LL;
		if (emax5[cid].fsm[i].rrdyc < lmm_nreq) { /* 1wrdy/4dword(cycle) */
		  for (k=0; k<UNIT_WIDTH; k++)
		    emax5[cid].fsm[i].waddr[emax5[cid].fsm[i].rrdyc*UNIT_WIDTH+k] = emax5[cid].fsm[i].wdata[k] = emax5[cid].fsm[i].lmrd[k];
		  if (trace) {
		    printf("%03.3d:siml_emax5: drain row=%d lmrd[%d]=%08.8x_%08.8x (%d/%d)\n",
			   tid, j, k, (Uint)(emax5[cid].fsm[i].lmrd[k]>>32), (Uint)emax5[cid].fsm[i].lmrd[k], emax5[cid].fsm[i].rrdyc, lmm_nreq);
		  }
		  emax5[cid].fsm[i].rrdyc++;
d486 6
a491 6
		else {
		  emax5[cid].lmmd[i][j] = 0;
		  emax5[cid].fsm[i].memif_status = MEMIF_AREQ;
		  emax5[cid].fsm[i].row_count++;
		}
		break;
d493 1
a494 4
	    else {
	      emax5[cid].fsm[i].row_count++;
	    }
	    break;
d496 4
d514 25
a538 23
      /*------------------------ここまで----------------------------*/
      if (emax5[cid].unit_ctl_count < EMAX_DEPTH*EMAX_WIDTH) {
	Uint count;
	i = (emax5[cid].unit_ctl_count/EMAX_WIDTH)%EMAX_DEPTH;
	j = (emax5[cid].unit_ctl_count           )%EMAX_WIDTH;
	count = emax5[cid].memi_new[i].len[j];
	switch (emax5[cid].memi_new[i].mctr0[j].v) {
	  /*  0:nop, *1:LMR,  2:LMW, *3:LMX,  4:LMP, *5:LMF(force read),  6:LMD */
	  /*  8:MMR   9:MMTR */
	case 1: 
	case 3: 
	case 5: 
	  if (emax5[cid].memi_old[i].mctr0[j].v
	      && emax5[cid].memi_old[i].mctr0[j].bank  == emax5[cid].memi_new[i].mctr0[j].bank
	      && emax5[cid].memi_old[i].mctr0[j].width == emax5[cid].memi_new[i].mctr0[j].width
	      && emax5[cid].memi_old[i].mctr0[j].block == emax5[cid].memi_new[i].mctr0[j].block
	      && emax5[cid].memi_old[i].mctr0[j].dist  == emax5[cid].memi_new[i].mctr0[j].dist
	      && emax5[cid].memi_old[i].lmm_top[j]     == emax5[cid].memi_new[i].lmm_top[j]
	      && emax5[cid].memi_old[i].mem_top[j]     == emax5[cid].memi_new[i].mem_top[j]
	      && emax5[cid].memi_old[i].len[j]         >= emax5[cid].memi_new[i].len[j]) {
	    if (trace)
	      printf("step 8.4: mctl[%d].ltop[%d]=%08.8x mtop=%08.8x len=%08.8x found in LMM\n", i, j, emax5[cid].memi_new[i].lmm_top[j], emax5[cid].memi_new[i].mem_top[j], emax5[cid].memi_new[i].len[j]);
	    emax5[cid].unit_ctl_count++;
d540 32
a571 24
	  else if (wrdyc[cid] < count) { /* rrdy */
	    emax5[cid].fsm_cmd = FSM_LOAD; /* 一旦latch.次のCLKでUNIT書き込み */
#if 1
	    emax5[cid].select_row = 1LL<<i;
	    switch (emax5[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
	    case 0: /* memi_new.width=0の場合は 着目colのみ1bit-ON */
	      emax5[cid].unit_select_col = 1<<j;
	      /* 4D対応:同一ステージに,同一アドレス+長さのLMMが存在する場合,ブロードキャストするモデル */
	      for (k=j+1; k<EMAX_WIDTH; k++) {
		if (emax5[cid].memi_new[i].mctr0[k].v
		    && emax5[cid].memi_new[i].mctr0[k].bank  == emax5[cid].memi_new[i].mctr0[j].bank
		    && emax5[cid].memi_new[i].mctr0[k].width == emax5[cid].memi_new[i].mctr0[j].width
		    && emax5[cid].memi_new[i].mctr0[k].block == emax5[cid].memi_new[i].mctr0[j].block
		    && emax5[cid].memi_new[i].mctr0[k].dist  == emax5[cid].memi_new[i].mctr0[j].dist
		    && emax5[cid].memi_new[i].lmm_top[k]     == emax5[cid].memi_new[i].lmm_top[j]
		    && emax5[cid].memi_new[i].mem_top[k]     == emax5[cid].memi_new[i].mem_top[j]
		    && emax5[cid].memi_new[i].len[k]         == emax5[cid].memi_new[i].len[j]) {
		  emax5[cid].unit_select_col |= 1<<k;
		  emax5[cid].memi_old[i].mctr0[k]   = emax5[cid].memi_new[i].mctr0[j];
		  emax5[cid].memi_old[i].lmm_top[k] = emax5[cid].memi_new[i].lmm_top[j];
		  emax5[cid].memi_old[i].mem_top[k] = emax5[cid].memi_new[i].mem_top[j];
		  emax5[cid].memi_old[i].len[k]     = emax5[cid].memi_new[i].len[j];
		  if (trace)
		    printf("step 8.4: mctl[%d].ltop[%d] linked to col=%d\n", i, k, j);
d573 1
d575 9
a583 57
	      break;
	    case 1: /* memi_new.width=1の場合は 着目col=2,0の場合のみ col3,1も同時にON 2word同時転送 */
	      emax5[cid].unit_select_col = 3<<j;
	      break;
	    case 2: /* memi_new.width=2の場合は 着目col=0の場合のみ col3,2,1も同時にON 4word同時転送 */
	      emax5[cid].unit_select_col = 15<<j;
	      break;
	    }
#endif
	    emax5[cid].unit_edb0 = emax5[cid].memi_new[i].lmm_top[j]+wrdyc[cid]*sizeof(Uint); /* select target registers */
	    
	    /*** GATHER ************/
	    width = (1<<emax5[cid].memi_new[i].mctr0[j].width); /* 0:4bytes, 1:8bytes, 2:16bytes 3:undef */
	    dist  = (1<<emax5[cid].memi_new[i].mctr0[j].dist);  /* 0:dist=width, 1:dist=width*2, 2:dist=width*4 3:dist=width*8 */
	    switch (emax5[cid].memi_new[i].mctr0[j].block) {
	    case 0: /* inf */
	      a =               emax5[cid].memi_new[i].mem_top[j]                         +(wrdyc[cid]   )*sizeof(Uint)*width*dist;
	      break;
	    case 1: /* 16 */
	      a = *(Uint*)(base+emax5[cid].memi_new[i].mem_top[j]+(wrdyc[cid]/16)*sizeof(Uint))+(wrdyc[cid]%16)*sizeof(Uint)*width*dist;
	      break;
	    case 2: /* 32 */
	      a = *(Uint*)(base+emax5[cid].memi_new[i].mem_top[j]+(wrdyc[cid]/32)*sizeof(Uint))+(wrdyc[cid]%32)*sizeof(Uint)*width*dist;
	      break;
	    case 3: /* 64 */
	      a = *(Uint*)(base+emax5[cid].memi_new[i].mem_top[j]+(wrdyc[cid]/64)*sizeof(Uint))+(wrdyc[cid]%64)*sizeof(Uint)*width*dist;
	      break;
	    }
	    /***************/
	    switch (emax5[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
	    case 0: /* memi_new.width=0の場合は 着目colのみ1bit-ON */
	      emax5[cid].unit_edb1[j  ] = *(Uint*)(base+a); /* 一旦latch.次のCLKでUNIT書き込み */
	      for (k=j+1; k<EMAX_WIDTH; k++) {
		if (emax5[cid].unit_select_col & (1<<k))
		  emax5[cid].unit_edb1[k] = *(Uint*)(base+a); /* 一旦latch.次のCLKでUNIT書き込み */
	      }
	      if (trace)
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=1/1 val=%08.8x(%d/%d)->LMM\n", i, j, a, emax5[cid].unit_edb1[j], wrdyc[cid], count);
	      break;
	    case 1: /* memi_new.width=1の場合は 着目col=2,0の場合のみ col3,1も同時にON 2word同時転送 */
	      emax5[cid].unit_edb1[j  ] = *(Uint*)(base+a             ); /* 一旦latch.次のCLKでUNIT書き込み */
	      emax5[cid].unit_edb1[j+1] = *(Uint*)(base+a+sizeof(Uint)); /* 一旦latch.次のCLKでUNIT書き込み */
	      if (trace) {
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=1/2 val=%08.8x(%d/%d)->LMM\n", i, j, a,              emax5[cid].unit_edb1[j  ], wrdyc[cid], count);
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=2/2 val=%08.8x(%d/%d)->LMM\n", i, j, a+sizeof(Uint), emax5[cid].unit_edb1[j+1], wrdyc[cid], count);
	      }
	      break;
	    case 2: /* memi_new.width=2の場合は 着目col=0の場合のみ col3,2,1も同時にON 4word同時転送 */
	      emax5[cid].unit_edb1[j  ] = *(Uint*)(base+a               ); /* 一旦latch.次のCLKでUNIT書き込み */
	      emax5[cid].unit_edb1[j+1] = *(Uint*)(base+a+sizeof(Uint)  ); /* 一旦latch.次のCLKでUNIT書き込み */
	      emax5[cid].unit_edb1[j+2] = *(Uint*)(base+a+sizeof(Uint)*2); /* 一旦latch.次のCLKでUNIT書き込み */
	      emax5[cid].unit_edb1[j+3] = *(Uint*)(base+a+sizeof(Uint)*3); /* 一旦latch.次のCLKでUNIT書き込み */
	      if (trace) {
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=1/4 val=%08.8x(%d/%d)->LMM\n", i, j, a,                emax5[cid].unit_edb1[j  ], wrdyc[cid], count);
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=2/4 val=%08.8x(%d/%d)->LMM\n", i, j, a+sizeof(Uint)  , emax5[cid].unit_edb1[j+1], wrdyc[cid], count);
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=3/4 val=%08.8x(%d/%d)->LMM\n", i, j, a+sizeof(Uint)*2, emax5[cid].unit_edb1[j+2], wrdyc[cid], count);
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=4/4 val=%08.8x(%d/%d)->LMM\n", i, j, a+sizeof(Uint)*3, emax5[cid].unit_edb1[j+3], wrdyc[cid], count);
a586 1
	    wrdyc[cid]++;
d589 1
a589 9
	    if (emax5[cid].memi_new[i].mctr0[j].v < 4) { /* in the case of LMF, always renew */
	      emax5[cid].memi_old[i].mctr0[j]   = emax5[cid].memi_new[i].mctr0[j];
	      emax5[cid].memi_old[i].lmm_top[j] = emax5[cid].memi_new[i].lmm_top[j];
	      emax5[cid].memi_old[i].mem_top[j] = emax5[cid].memi_new[i].mem_top[j];
	      emax5[cid].memi_old[i].len[j]     = emax5[cid].memi_new[i].len[j];
	    }
	    emax5[cid].fsm_cmd = FSM_IDLE; 
	    emax5[cid].unit_ctl_count++;
	    wrdyc[cid] = 0;
d591 2
a592 9
	  break;
	case 0: 
	case 2: 
	case 4: 
	case 6: 
	case 8: 
	case 9: 
	  emax5[cid].unit_ctl_count++;
	  break;
d595 7
a601 5
      else {
	emax5[cid].pe0_status      = STATUS_START;
	emax5[cid].fsm_cmd    = FSM_IDLE; 
	emax5[cid].unit_ctl_count  = 0;
	wrdyc[cid] = 0;
d604 39
a644 1
      /* Step 8.2: fill local reg (regv[]) from SDRAM */
@


1.21
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.20 2016/03/17 10:58:33 nakashim Exp nakashim $";
d16 3
a18 2
enum { STATUS_IDLE, STATUS_CONF, STATUS_LMMI, STATUS_CKLD, STATUS_DRAIN, STATUS_LOAD, STATUS_REGV, STATUS_START, STATUS_EXEC, STATUS_TERM };
enum { FSM_IDLE,    FSM_CONF,    FSM_LMMI,    FSM_CKLD,    FSM_DRAIN,    FSM_LOAD,    FSM_REGV,    FSM_START,    FSM_EXEC,    FSM_TERM };
d23 1
a23 1
  Uint  status            : 3;
a30 3
  Uint  fsm_cmd           : 4; /* 0:idle, 1:conf, 2:lmmi, 3:chkld, 4:drain: 5:regv, 6:load, 7:start, 8:exec, 9:term */
  Uint  fsm_cmd_d1        : 4; /* delayed fsm_cmd    */
  Uint  fsm_cmd_d2        : 4; /* delayed fsm_cmd_d1 */
d42 1
a42 7
                               /* 3 :ckld  exec開始と同時にstore箇所にlmms.dirty=1                    */
                               /*          drain開始と同時に該当lmms.dirty=0                          */
                               /*          旧lmmoと新lmmiが一致ならload済                             */
                               /*          lmms.dirty=1がある場合,drain要が存在                       */
                               /*          - 未loadがある場合,drainが必要                             */
                               /*          - 未loadがない場合,drainはexec開始まで待機                 */
                               /*(4):drain fsm_way毎に,fsm内部の全lmmiに未loadLMMがあるか検査         */
d45 1
a45 1
                               /*(5):load  fsm_way毎に,fsm内部の全lmmiに未loadLMMがあるか検査         */
d48 1
a48 1
                               /* 6 :regv  全fsm_wayに,start準備をセット                              */
d50 2
a51 2
                               /* 7 :start 全fsm_wayに,startをセット                                  */
                               /* 8 :exec  全fsm_wayのlast_row0にflag=1をセット.EMAX5起動             */
d60 2
a61 1
    Uint  row_count       : 6; /* row counter 6bit */
d63 4
a66 8
    Ull   row_select_d1   :64; /* delayed row_select */
    Uint  rrdyc;               /* READ-READY  counter */
    Uint  wrdyc;               /* WRITE-READY counter */

    Ull   ckld_req_load   :64; /* 0:none, 1:load exists */
    Ull   ckld_dirty      :64; /* 0:none, 1:dirty exists */

                               /*                           CF+RV LI  PF  DR  TR  DM                 */
d74 3
a76 3
    Ull   *raddr;              /* read-address  of mm          v   v   v           v                 */
    Ull   rlen;                /* read-length   of mm          v   v   v           1                 */
    Ull   rdata[UNIT_WIDTH];   /* read-data     of mm          v   v   v           v                 */
d84 4
a87 4
  Ull   unit1_exec           ; /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:exec */
  Ull   unit1_stop           ; /* 1bit corresponds to each row (cex,exe,eag), 0:wait 1:stop */
  Ull   unit2_exec           ; /* 1bit corresponds to each row (lmm),         0:wait 1:exec */
  Ull   unit2_stop           ; /* 1bit corresponds to each row (lmm),         0:wait 1:stop */
a91 1
  Uint  cycles_ckld_part;
d93 1
a94 1
  Uint  cycles_load_part;
a100 1
  Ull   cycles_ckld;
d102 1
a103 1
  Ull   cycles_load;
d146 2
a147 2
  Uint status;
  Uint tcbid; /* 0:invalid, start address of trans */
d149 2
a150 2
  Uint pc;                 /* program counter */
  Ull  reg[MAX_TRANS_REG]; /* r0-r7 for param/work */
d190 2
a191 1
  int i, j, k, a, width, dist, sync;
d200 1
d202 1
a202 1
    emax5[cid].cycles_lmmi_part  = 0;
a203 1
    emax5[cid].cycles_load_part  = 0;
d233 1
a233 1
      if (emax5[cid].fsm_cmd == FSM_EXEC) {
a257 4
    emax5[cid].fsm_cmd_d1    = emax5[cid].fsm_cmd;
    for (i=0; i<EMAX_WIDTH; i++)
      emax5[cid].fsm[i].row_select_d1 = emax5[cid].fsm[i].row_select;

d261 3
d265 3
a267 3
	  emax5[cid].fsm[i].raddr = base+(conf+sizeof(struct conf)*EMAX_DEPTH*i)/sizeof(Ull); /* conf_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rlen  =           (sizeof(struct conf)*EMAX_DEPTH*1)/sizeof(Ull); /* conf_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rrdyc = 0;
a268 2
	emax5[cid].status  = STATUS_CONF;
	emax5[cid].fsm_cmd = FSM_IDLE; 
d271 3
d275 3
a277 3
	  emax5[cid].fsm[i].raddr = base+(lmmi+sizeof(struct lmmi)*EMAX_DEPTH*i)/sizeof(Ull); /* lmmi_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rlen  =           (sizeof(struct lmmi)*EMAX_DEPTH*1)/sizeof(Ull); /* lmmi_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rrdyc = 0;
a278 4
	if (trace)
	  printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x start\n", tid, (Uint)(conf>>32), (Uint)conf);
	emax5[cid].status  = STATUS_LMMI;
	emax5[cid].fsm_cmd = FSM_IDLE; 
a282 1
      emax5[cid].fsm_cmd = FSM_CONF; /* 一旦latch.次のCLKでUNIT書き込み */
d284 21
a304 7
	if (emax5[cid].fsm[i].rrdyc < EMAX_DEPTH*sizeof(struct conf)/(sizeof(Ull)*UNIT_WIDTH)) { /* 1unit/1rrdy */
	  emax5[cid].fsm[i].row_select = 1LL<<((emax5[cid].last_row0+emax5[cid].fsm[i].rrdyc)%EMAX_DEPTH);
	  for (j=0; j<UNIT_WIDTH; j++) 
	    emax5[cid].fsm[i].rdata[j] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].rrdyc*UNIT_WIDTH+j];
	  emax5[cid].fsm[i].last_dist  = emax5[cid].fsm[i].rdata[3] & 0x3f; /* mapdist */
	  emax5[cid].fsm[i].rrdyc++;
	  sync = 0; /* not finished */
a307 5
	for (i=0; i<EMAX_WIDTH; i++) {
	  emax5[cid].fsm[i].raddr = base+(lmmi+sizeof(struct lmmi)*EMAX_DEPTH*i)/sizeof(Ull); /* lmmi_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rlen  =           (sizeof(struct lmmi)*EMAX_DEPTH*1)/sizeof(Ull); /* lmmi_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rrdyc = 0;
	}
d312 5
a316 1
	emax5[cid].fsm_cmd = FSM_IDLE; 
a320 1
      emax5[cid].fsm_cmd = FSM_LMMI; /* UNITには書き込まない.FSM止まり */
d322 24
a345 7
	if (emax5[cid].fsm[i].rrdyc < EMAX_DEPTH*sizeof(struct lmmi)/(sizeof(Ull)*UNIT_WIDTH)) { /* 2unit/1rrdy */
	  *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].rrdyc*2+0)%EMAX_DEPTH])+0) = (emax5[cid].fsm[i].rdata[0] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].rrdyc*4+0]);
	  *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].rrdyc*2+0)%EMAX_DEPTH])+1) = (emax5[cid].fsm[i].rdata[1] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].rrdyc*4+1]);
	  *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].rrdyc*2+1)%EMAX_DEPTH])+0) = (emax5[cid].fsm[i].rdata[2] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].rrdyc*4+2]);
	  *(((Ull*)&emax5[cid].lmmi[i][(emax5[cid].last_row0+emax5[cid].fsm[i].rrdyc*2+1)%EMAX_DEPTH])+1) = (emax5[cid].fsm[i].rdata[3] = emax5[cid].fsm[i].raddr[emax5[cid].fsm[i].rrdyc*4+3]);
	  emax5[cid].fsm[i].rrdyc++;
	  sync = 0; /* not finished */
d349 6
a354 2
	emax5[cid].status  = STATUS_CKLD;
	emax5[cid].fsm_cmd = FSM_IDLE;
d357 14
a370 15
    case STATUS_CKLD:
      /*************************************************************************************************************************************************************/
      /* ●lmmi指示ルール (copy from conv-c2d/emac5.c)                                                                  lmmi-loc  v  top  blk  dist  len  rw  f  p */
      /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  dist  len   0  0  0 */
      /* LD with force-read=1 and ptop==NULL generates current(lmf) and does not reuse LMM. same as lmf in EMAX4            curr  1  top  blk  dist  len   0  1  0 */
      /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). same as lmp in EMAX4                     curr  1  top  blk  dist  len   0  0  0 */
      /*                                                                                                                  c+dist  1 ptop  blk  dist  len   0  0  1 */
      /*                                                                                              ptop!=NULL & force=1は，prefetchの意味がないので組合せがない */
      /*************************************************************************************************************************************************************/
      /* ST with force-read=0 and ptop==NULL writes back after execution. same as lmw in EMAX4                              curr  1  top  blk  dist  len   1  0  0 */
      /* ST with force-read=1 and ptop==NULL prefetches data to LMM in advance and write back. same as lmx in EMAX4         curr  1  top  blk  dist  len   1  1  0 */
      /* ST with force-read=0, top==NULL and ptop!=NULL late drain with next execution. same as lmd in EMAX4                curr  0  (check be empty)              */
      /*                                                   FSMは,dirtyおよびp-bitに従い,exec同時drainか,exec後drainを選択 c-dist  1 ptop  blk  dist  len   1  0  1 */
      /*                                                                                              deleyed-drain & force=1は，delayの意味がないので組合せがない */
      /*************************************************************************************************************************************************************/
d409 1
d411 4
a414 3
      /*      1  1  0  0 ... lmw                   必ず,regv前にdrain                                   store:d=1     --                   */
      /*      1  1  1  0 ... lmx                   必ず,regv前にdrain                                   store:d=1     --                   */
      /*      1  1  0  1 ... lmd                   無視してよい                                         drain済       --                   */
d416 9
a424 8
      /*      1  0  0  0 ... lmr lmmoとlmmiが不一致ならdrainとregvの間にload                            prefetch/--   reuse/mload          */
      /*      1  0  1  0 ... lmf                   必ずdrainとregvの間にload                            --            mload(always)        */
      /*      1  0  0  1 ... lmp lmmoとlmmiが不一致ならexecと同時にloadする                             prefetch/--   reuse/prefetch       */
      /* lmmi.v rw  f  p (以下ckld時は無視してよい)                                                     lmmo_cur      lmmi_cur             */
      /*      1  1  0  0 ... lmw                                              execと同時にckld_dirty=1  --            store:d=1            */
      /*      1  1  1  0 ... lmx                   必ずdrainとregvの間にload  execと同時にckld_dirty=1  --            store:d=1            */
      /*      1  1  0  1 ... lmd                                              execと同時にdrain         store:d=1     d=1時のみdrain       */
      /*                                    lmdは次のexecと同時実行. 最後のlmdを追い出すためには明示的drain指示(startとは別コマンド)が必要 */
a425 40
      emax5[cid].cycles_ckld_part++;
      emax5[cid].fsm_cmd = FSM_CKLD; /* dummy */
      for (i=0; i<EMAX_WIDTH; i++) {
	emax5[cid].fsm[i].ckld_req_load  = 0LL;
     /* emax5[cid].fsm[i].ckld_dirtyは,reset時に0LL */
	for (j=0; j<EMAX_DEPTH; j++) {
	  switch ((emax5[cid].lmmi[i][j].v<<3)|(emax5[cid].lmmi[i][j].rw<<2)|(emax5[cid].lmmi[i][j].f<<1)|(emax5[cid].lmmi[i][j].p)) {
	    /* v | rw | f | p */
	  case 8:  /* lmr */
	  case 14: /* lmx */
	    if (emax5[cid].lmmo[i][j].v
	     && emax5[cid].lmmo[i][j].top  == emax5[cid].lmmi[i][j].top
	     && emax5[cid].lmmo[i][j].blk  == emax5[cid].lmmi[i][j].blk
	     && emax5[cid].lmmo[i][j].dist == emax5[cid].lmmi[i][j].dist
	     && emax5[cid].lmmo[i][j].len  == emax5[cid].lmmi[i][j].len) {
	      break; /* reuse */
	    }
	  case 10: /* lmf */
	    /* load required */
	    emax5[cid].fsm[i].ckld_req_load |= 1LL<<j;
	    break;
	  }
	}
      }
      for (sync=1,i=0; i<EMAX_WIDTH; i++) {
	/* ckld_req_loadのみなら,drain不要 */
	/* ckld_dirtyのみなら,EXECと同時にdrain開始 */
	if (emax5[cid].fsm[i].ckld_req_load && emax5[cid].fsm[i].ckld_dirty) {
	  sync=0;
	}
      }
      if (!sync) { /* all FSM_CKLD finished and DRAIN required */
	emax5[cid].status  = STATUS_DRAIN;
	emax5[cid].fsm_cmd = FSM_IDLE;
      }
      else { /* all FSM_CKLD finished and no DRAIN required */
	emax5[cid].status  = STATUS_REGV;
	emax5[cid].fsm_cmd = FSM_IDLE;
      }
      break;
a427 1
   /* emax5[cid].fsm_cmd = FSM_DRAIN; */
d429 32
a460 36
	for (j=0; j<EMAX_DEPTH; j++) {
	  emax5[cid].fsm[i].row_select = 1LL<<j;
	  if (emax5[cid].fsm[i].ckld_dirty & emax5[cid].fsm[i].row_select) { /* dirty exist */

	    /*------------------------ここまで----------------------------*/
	  count = emax5[cid].memi_new[i].len[j];
	  switch (emax5[cid].memi_new[i].mctr0[j].v) {
	    /*  0:nop,  1:LMR, *2:LMW, *3:LMX,  4:LMP,  5:LMF(force read),  6:LMD */
	    /*  8:MMR   9:M2MTR */
	  case 2: 
	  case 3: 
	    if (wrdyc[cid] < count) { /* wrdy */
	      emax5[cid].fsm_cmd = FSM_DRAIN; /* 一旦latch.次のCLKでUNIT書き込み */
	      emax5[cid].unit_edb0 = emax5[cid].memi_new[i].lmm_top[j]+wrdyc[cid]*sizeof(Uint);    /* select target registers */
	      wrdyc[cid]++;
	    }
	    else {
	      emax5[cid].fsm_cmd = FSM_IDLE;
	    }
	    if (rrdyc[cid] < count) {
	      if (emax5[cid].fsm_cmd_d2 == FSM_DRAIN) { /* rrdyc[cid] */
		width = (1<<emax5[cid].memi_new[i].mctr0[j].width); /* 0:4bytes, 1:8bytes, 2:16bytes 3:undef */
		dist  = (1<<emax5[cid].memi_new[i].mctr0[j].dist);  /* 0:dist=width, 1:dist=width*2, 2:dist=width*4 3:dist=width*8 */
		a = emax5[cid].memi_new[i].mem_top[j]+(rrdyc[cid])*sizeof(Uint)*width*dist;
		switch (emax5[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
		case 0: /* memi_new.width=0の場合は 着目colのみ1bit-ON */
		  emax5[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		  *(Uint*)(base+a) = emax5[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		  if (trace)
		    printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/1 val=%08.8x(%d/%d)<-LMM\n", i, j, a, emax5[cid].unit_emb[0], rrdyc[cid], count);
		  break;
		case 1: /* memi_new.width=1の場合は 着目col=2,0の場合のみ col3,1も同時にON 2word同時転送 */
		  emax5[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		  emax5[cid].unit_emb[1] = unit[cid][i][j+1].emb[0].d;
		  *(Uint*)(base+a             ) = emax5[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		  *(Uint*)(base+a+sizeof(Uint)) = emax5[cid].unit_emb[1]; /* 一旦latch.次のCLKでUNIT書き込み */
d462 2
a463 2
		    printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/2 val=%08.8x(%d/%d)<-LMM\n", i, j, a,              emax5[cid].unit_emb[0], rrdyc[cid], count);
		    printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=2/2 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint), emax5[cid].unit_emb[1], rrdyc[cid], count);
d465 7
a471 10
		  break;
		case 2: /* memi_new.width=2の場合は 着目col=0の場合のみ col3,2,1も同時にON 4word同時転送 */
		  emax5[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		  emax5[cid].unit_emb[1] = unit[cid][i][j+1].emb[0].d;
		  emax5[cid].unit_emb[2] = unit[cid][i][j+2].emb[0].d;
		  emax5[cid].unit_emb[3] = unit[cid][i][j+3].emb[0].d;
		  *(Uint*)(base+a               ) = emax5[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		  *(Uint*)(base+a+sizeof(Uint)  ) = emax5[cid].unit_emb[1]; /* 一旦latch.次のCLKでUNIT書き込み */
		  *(Uint*)(base+a+sizeof(Uint)*2) = emax5[cid].unit_emb[2]; /* 一旦latch.次のCLKでUNIT書き込み */
		  *(Uint*)(base+a+sizeof(Uint)*3) = emax5[cid].unit_emb[3]; /* 一旦latch.次のCLKでUNIT書き込み */
d473 2
a474 4
		    printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a               , emax5[cid].unit_emb[0], rrdyc[cid], count);
		    printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=2/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)  , emax5[cid].unit_emb[1], rrdyc[cid], count);
		    printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=3/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)*2, emax5[cid].unit_emb[2], rrdyc[cid], count);
		    printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=4/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)*3, emax5[cid].unit_emb[3], rrdyc[cid], count);
d476 6
a481 1
		  break;
d483 1
a483 1
		rrdyc[cid]++;
d487 1
a487 3
	      emax5[cid].unit_ctl_count++;
	      wrdyc[cid] = 0;
	      rrdyc[cid] = 0;
a489 5
	  case 6: 
	  case 8: 
	  case 9: 
	    emax5[cid].unit_ctl_count++;
	    break;
d491 1
d496 5
a500 1
	emax5[cid].fsm_cmd = FSM_IDLE;
d504 2
a505 2
      emax5[cid].cycles_lmm_load_part++;
      /* Step 8.4: (each unit) fill local mem (data) from SDRAM */
@


1.20
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.19 2016/03/15 00:03:11 nakashim Exp nakashim $";
d16 2
a17 2
enum { STATUS_IDLE, STATUS_CONF, STATUS_LMMI, STATUS_CKLD, STATUS_DRAIN, STATUS_REGV, STATUS_LOAD, STATUS_START, STATUS_EXEC, STATUS_TERM };
enum { FSM_IDLE,    FSM_CONF,    FSM_LMMI,    FSM_CKLD,    FSM_DRAIN,    FSM_REGV,    FSM_LOAD,    FSM_START,    FSM_EXEC,    FSM_TERM };
d34 2
a35 2
                               /*  conf  | drain | lmmi | regv | load | exec        | */
                               /*        |       |      |      |      | pload       | */
d37 2
a38 2
                               /*  conf          | lmmi | regv |      | exec        | */
                               /*                |      |      |      | drain pload | */
d53 2
a54 1
                               /* 5 :regv  全fsm_wayに,start準備をセット                              */
d56 1
a56 2
                               /*(6):load  fsm_way毎に,fsm内部の全lmmiに未loadLMMがあるか検査         */
                               /*          未loadLMMが存在する場合,fsm_way毎に,last_row0から順にload  */
d353 1
a353 1
      /*                   FSMは，lmmiのexec-complete-bitおよびdrain-complete-bitに従い,exec同時drainか,exec後drainを選択 c-dist  1 ptop  blk  dist  len   1  0  1 */
d356 52
a407 40
      /* Example of Load+Store                                                               */ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                     */
      /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, NULL);   lmr                 */
      /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, NULL);   lmr                 */
      /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, NULL);   lmr                 */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                                */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmw                 */
      /* }                                                                                   */
      /* Example of Accumulate                                                               */ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                     */
      /*   mo4(LDRQ,  1, src1, D[y], x, msk, D[y], 0, XSIZE, 1, NULL);   lmf                 */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                                */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmw                 */
      /* }                                                                                   */
      /* Example of Partial Update                                                           */ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                     */
      /*   mo4(STRQ, ex, dst1, D[y], x, msk, D[y], 0, XSIZE, 0, NULL);   lmx(read-mod-write) */
      /* }                                                                                   */
      /* Example of Prefetch+Drain                                                           */ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]                     */
      /*   mo4(LDRQ,  1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, A[y+1]); lmr+lmp prefetch    */
      /*   mo4(LDRQ,  1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, B[y+1]); lmr+lmp prefetch    */
      /*   mo4(LDRQ,  1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, C[y+1]); lmr+lmp prefetch    */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                                */
      /*   mo4(STRQ,  1, dst1, D[y], x, msk, NULL, 0, XSIZE, 0, D[y-1]); lmd late drain      */
      /* }                                                                                   */
      /*************************************************************************************************************************************************************/
      /* v rw  f  p                                                                                lmmo_cur      lmmi_cur                                          */
      /* 1  0  0  0 ... lmr lmmoとlmmiが不一致なら,他drain後loadが必要                             prefetch/--   reuse/mload                                       */
      /* 1  0  1  0 ... lmf                   必ず,他drain後loadが必要                             --            mload(always)                                     */
      /* 1  0  0  1 ... lmp ckld時は無視してよい                                                   prefetch/--   reuse/mload                                       */
      /*                                                                                           --            prefetch(always)                                  */
      /*                   prefetchでカバーできないloadがある場合,安全のために全d=1をdrain後にload. drain先アドレス情報は,lmwとlmxはlmmoから取得.lmdはlmmiから取得 */
      /*                   prefetchでカバーできる場合,lmwをdrainするのは,exec+次lmc後. lmdが指定できないのはexecと競合するためなのでexecとは同時実行できない       */
      /*                                              lmxはmapdist=0かつ次回も参照する使用方法なので,毎回のdrainは不要                                             */
      /*                                                                 lmdは次のexecと同時実行. いずれにせよ最後のlmw/lmx結果を追い出すためには明示的drainが必要 */
      /* 1  1  0  0 ... lmw ckld時は無視してよい                        execと同時にckld_dirty=1   --            store:d=1                      d=1がFSM_DRAIN対象 */
      /* 1  1  1  0 ... lmx lmmoとlmmiが不一致なら,他drain後loadが必要  execと同時にckld_dirty=1   --            reuse/mload + store:d=1        d=1がFSM_DRAIN対象 */
      /* 1  1  0  1 ... lmd ckld時は無視してよい,ckld_dirtyのみ使用     execと同時にckld_dirty=1   store:d=1     d=1のみdrain                   d=1がFSM_DRAIN対象 */
      /*************************************************************************************************************************************************************/
d415 1
d455 2
a456 1
	    
@


1.19
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.18 2016/03/12 22:53:10 nakashim Exp nakashim $";
d356 40
a395 17
      /* Example of Prefetch+Drain                                                    */ 
      /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]              */
      /*   mo4(LDRQ, 1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, A[y+1]); /* prefetch   */
      /*   mo4(LDRQ, 1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, B[y+1]); /* prefetch   */
      /*   mo4(LDRQ, 1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, C[y+1]); /* prefetch   */
      /*   ex4(FMAQ, src1, src2, src3, dst1);                                         */
      /*   mo4(STRQ, 1, dst1, D[y], x, msk, NULL, 0, XSIZE, 0, D[y-1]); /* late drain */
      /* }                                                                            */
      /************************************************************************************************************************************************************/
      /*  v rw  f  p                                                                                                                                              */
      /*  1  0  0  0  ... lmr   lmmoとlmmiが不一致なら,他drain後loadが必要                                                                                        */
      /*  1  0  1  0  ... lmf                     必ず,他drain後loadが必要                                                                                        */
      /*  1  0  0  1  ... lmp   ckld時は無視してよい                                                                                                              */
      /*  1  1  0  0  ... lmw   ckld時は無視してよい                        execと同時にckld_dirty=1                                                              */
      /*  1  1  1  0  ... lmx   lmmoとlmmiが不一致なら,他drain後loadが必要  execと同時にckld_dirty=1                                                              */
      /*  1  1  0  1  ... lmd   ckld時は無視してよい,ckld_dirtyのみ使用     execと同時にckld_dirty=1                                                              */
      /************************************************************************************************************************************************************/
a435 1
      /*-----------------------------------ここまで-----------------------------------*/
d437 58
a494 66
      if (emax5[cid].unit_ctl_count < EMAX_DEPTH*EMAX_WIDTH) {
	Uint count;
	i = (emax5[cid].unit_ctl_count/EMAX_WIDTH)%EMAX_DEPTH;
	j = (emax5[cid].unit_ctl_count           )%EMAX_WIDTH;
	emax5[cid].select_row = 1LL<<i;
	switch (emax5[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
	case 0: /* memi_new.width=0の場合は 着目colのみ1bit-ON */
	  emax5[cid].unit_select_col = 1<<j;
	  break;
	case 1: /* memi_new.width=1の場合は 着目col=2,0の場合のみ col3,1も同時にON 2word同時転送 */
	  emax5[cid].unit_select_col = 3<<j;
	  break;
	case 2: /* memi_new.width=2の場合は 着目col=0の場合のみ col3,2,1も同時にON 4word同時転送 */
	  emax5[cid].unit_select_col = 15<<j;
	  break;
	}
	count = emax5[cid].memi_new[i].len[j];
	switch (emax5[cid].memi_new[i].mctr0[j].v) {
	  /*  0:nop,  1:LMR, *2:LMW, *3:LMX,  4:LMP,  5:LMF(force read),  6:LMD */
	  /*  8:MMR   9:MMTR */
	case 2: 
	case 3: 
	  if (wrdyc[cid] < count) { /* wrdy */
	    emax5[cid].fsm_cmd = FSM_DRAIN; /* 一旦latch.次のCLKでUNIT書き込み */
	    emax5[cid].unit_edb0 = emax5[cid].memi_new[i].lmm_top[j]+wrdyc[cid]*sizeof(Uint);    /* select target registers */
	    wrdyc[cid]++;
	  }
	  else {
	    emax5[cid].fsm_cmd = FSM_IDLE;
	  }
	  if (rrdyc[cid] < count) {
	    if (emax5[cid].fsm_cmd_d2 == FSM_DRAIN) { /* rrdyc[cid] */
	      width = (1<<emax5[cid].memi_new[i].mctr0[j].width); /* 0:4bytes, 1:8bytes, 2:16bytes 3:undef */
	      dist  = (1<<emax5[cid].memi_new[i].mctr0[j].dist);  /* 0:dist=width, 1:dist=width*2, 2:dist=width*4 3:dist=width*8 */
	      a = emax5[cid].memi_new[i].mem_top[j]+(rrdyc[cid])*sizeof(Uint)*width*dist;
	      switch (emax5[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
	      case 0: /* memi_new.width=0の場合は 着目colのみ1bit-ON */
		emax5[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		*(Uint*)(base+a) = emax5[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		if (trace)
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/1 val=%08.8x(%d/%d)<-LMM\n", i, j, a, emax5[cid].unit_emb[0], rrdyc[cid], count);
		break;
	      case 1: /* memi_new.width=1の場合は 着目col=2,0の場合のみ col3,1も同時にON 2word同時転送 */
		emax5[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		emax5[cid].unit_emb[1] = unit[cid][i][j+1].emb[0].d;
		*(Uint*)(base+a             ) = emax5[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)) = emax5[cid].unit_emb[1]; /* 一旦latch.次のCLKでUNIT書き込み */
		if (trace) {
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/2 val=%08.8x(%d/%d)<-LMM\n", i, j, a,              emax5[cid].unit_emb[0], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=2/2 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint), emax5[cid].unit_emb[1], rrdyc[cid], count);
		}
		break;
	      case 2: /* memi_new.width=2の場合は 着目col=0の場合のみ col3,2,1も同時にON 4word同時転送 */
		emax5[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		emax5[cid].unit_emb[1] = unit[cid][i][j+1].emb[0].d;
		emax5[cid].unit_emb[2] = unit[cid][i][j+2].emb[0].d;
		emax5[cid].unit_emb[3] = unit[cid][i][j+3].emb[0].d;
		*(Uint*)(base+a               ) = emax5[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)  ) = emax5[cid].unit_emb[1]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)*2) = emax5[cid].unit_emb[2]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)*3) = emax5[cid].unit_emb[3]; /* 一旦latch.次のCLKでUNIT書き込み */
		if (trace) {
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a               , emax5[cid].unit_emb[0], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=2/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)  , emax5[cid].unit_emb[1], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=3/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)*2, emax5[cid].unit_emb[2], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=4/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)*3, emax5[cid].unit_emb[3], rrdyc[cid], count);
d496 1
a496 1
		break;
a497 1
	      rrdyc[cid]++;
d499 9
a507 2
	  }
	  else {
d509 1
a509 2
	    wrdyc[cid] = 0;
	    rrdyc[cid] = 0;
a510 10
	  break;
	case 0: 
	case 1: 
	case 4: 
	case 5: 
	case 6: 
	case 8: 
	case 9: 
	  emax5[cid].unit_ctl_count++;
	  break;
d513 3
a515 27
      else {
	emax5[cid].pe0_status      = STATUS_TERM;
	emax5[cid].fsm_cmd    = FSM_IDLE; 
	emax5[cid].unit_ctl_count  = 0;
	wrdyc[cid] = 0;
	rrdyc[cid] = 0;
      }
      break;
    case STATUS_REGV:
      emax5[cid].cycles_regv_part++;
      /* Step 8.2: fill local reg (regv[]) from SDRAM */
      if (wrdyc[cid] < EMAX_DEPTH*sizeof(struct regv)/(sizeof(Uint)*EMAX_WIDTH)) { /* rrdy */
	emax5[cid].fsm_cmd = FSM_REGV;     /* 一旦latch.次のCLKでUNIT書き込み */
	emax5[cid].select_row = 1LL<<((emax5[cid].last_row0+wrdyc[cid]/(sizeof(struct regv)/(sizeof(Uint)*EMAX_WIDTH)))%EMAX_DEPTH);
	emax5[cid].unit_select_col = (1<<EMAX_WIDTH)-1; /* all-1 */
	emax5[cid].unit_edb0 = wrdyc[cid]%(sizeof(struct regv)/(sizeof(Uint)*EMAX_WIDTH));    /* select target registers */
	for (j=0; j<EMAX_WIDTH; j++) {
	  Uint *tp1 = emax5[cid].maddr;
	  emax5[cid].unit_edb1[j] = tp1[wrdyc[cid]*EMAX_WIDTH+j]; /* 一旦latch.次のCLKでUNIT書き込み */
	}
	wrdyc[cid]++;
      }
      else {
	emax5[cid].pe0_status      = STATUS_MEMI;
	emax5[cid].fsm_cmd    = FSM_IDLE; 
	emax5[cid].maddr = (Uint*)(base+start+sizeof(conf)+sizeof(regv));
	wrdyc[cid] = 0;
d661 21
@


1.18
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.17 2016/03/10 00:50:38 nakashim Exp nakashim $";
d44 1
a44 1
                               /* 3 :chkld exec開始と同時にstore箇所にlmms.dirty=1                    */
d73 4
a276 2
	emax5[cid].status  = STATUS_CONF;
	emax5[cid].fsm_cmd = FSM_IDLE; 
d282 2
a285 4
	if (trace)
	  printf("%03.3d:siml_emax5: conf=%08.8x_%08.8x resed\n", tid, (Uint)(conf>>32), (Uint)conf);
	emax5[cid].status  = STATUS_LMMI;
	emax5[cid].fsm_cmd = FSM_IDLE; 
d291 4
d311 5
a320 5
	for (i=0; i<EMAX_WIDTH; i++) {
	  emax5[cid].fsm[i].raddr = base+(lmmi+sizeof(struct lmmi)*EMAX_DEPTH*i)/sizeof(Ull); /* lmmi_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rlen  =           (sizeof(struct lmmi)*EMAX_DEPTH*1)/sizeof(Ull); /* lmmi_topをfsmに渡すインタフェース */
	  emax5[cid].fsm[i].rrdyc = 0;
	}
d336 1
a336 1
      if (sync) {
d342 54
d397 14
a410 34
	for (j=0; j<EMAX_DEPTH; j++) {
	  /*************************************************************************************************************************************************************/
	  /* ●lmmi指示ルール (copy from conv-c2d/emac5.c)                                                                  lmmi-loc  v  top  blk  dist  len  rw  f  p */
	  /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  dist  len   0  0  0 */
	  /* LD with force-read=1 and ptop==NULL generates current(lmf) and does not reuse LMM. same as lmf in EMAX4            curr  1  top  blk  dist  len   0  1  0 */
	  /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). same as lmp in EMAX4                     curr  1  top  blk  dist  len   0  0  0 */
	  /*                                                                                                                  c+dist  1 ptop  blk  dist  len   0  0  1 */
	  /*                                                                                              ptop!=NULL & force=1は，prefetchの意味がないので組合せがない */
	  /*************************************************************************************************************************************************************/
	  /* ST with force-read=0 and ptop==NULL writes back after execution. same as lmw in EMAX4                              curr  1  top  blk  dist  len   1  0  0 */
	  /* ST with force-read=1 and ptop==NULL prefetches data to LMM in advance and write back. same as lmx in EMAX4         curr  1  top  blk  dist  len   1  1  0 */
	  /* ST with force-read=0, top==NULL and ptop!=NULL late drain with next execution. same as lmd in EMAX4                curr  0  (check be empty)              */
	  /*                   FSMは，lmmiのexec-complete-bitおよびdrain-complete-bitに従い,exec同時drainか,exec後drainを選択 c-dist  1 ptop  blk  dist  len   1  0  1 */
	  /*                                                                                              deleyed-drain & force=1は，delayの意味がないので組合せがない */
	  /*************************************************************************************************************************************************************/
	  /* Example of Prefetch+Drain                                                    */ 
	  /* for (x=0; x<XSIZE; x+=4) { /* mapped to while() on BR[15][0][0]              */
	  /*   mo4(LDRQ, 1, src1, A[y], x, msk, A[y], 0, XSIZE, 0, A[y+1]); /* prefetch   */
	  /*   mo4(LDRQ, 1, src2, B[y], x, msk, B[y], 0, XSIZE, 0, B[y+1]); /* prefetch   */
	  /*   mo4(LDRQ, 1, src3, C[y], x, msk, C[y], 0, XSIZE, 0, C[y+1]); /* prefetch   */
	  /*   ex4(FMAQ, src1, src2, src3, dst1);                                         */
	  /*   mo4(STRQ, 1, dst1, D[y], x, msk, NULL, 0, XSIZE, 0, D[y-1]); /* late drain */
	  /* }                                                                            */
	  /************************************************************************************************************************************************************/


	  if (emax5[cid].lmmi[i][j].v && !emax5[cid].lmmi[i][j].rw /* valid+load */
	   && emax5[cid].lmmo[i][j].v
           && emax5[cid].lmmo[i][j].top  == emax5[cid].lmmo[i][j].top
           && emax5[cid].lmmo[i][j].blk  == emax5[cid].lmmo[i][j].blk
           && emax5[cid].lmmo[i][j].dist == emax5[cid].lmmo[i][j].dist
	   && emax5[cid].lmmo[i][j].len  == emax5[cid].lmmo[i][j].len) {
	    
      /*-----------------------------------ここまで-----------------------------------*/
d413 2
a414 1
      emax5[cid].cycles_lmm_drain_part++;
@


1.17
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.16 2016/03/09 13:30:16 nakashim Exp nakashim $";
d98 2
a100 1
  Uint  cycles_lmmi_part;
d108 2
a110 1
  Ull   cycles_lmmi;
d307 1
a307 1
	emax5[cid].last_conf = (Uint*)(base+conf);
d338 34
a371 1
      
@


1.16
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.15 2016/03/04 03:31:13 nakashim Exp nakashim $";
d67 1
d299 1
a299 1
	  emax5[cid].last_dist = emax5[cid].fsm[i].rdata[3] & 0x3f; /* mapdist */
d305 3
a640 2
      emax5[cid].last_conf   = (Uint*)(base+start);
      emax5[cid].last_row0 = (emax5[cid].last_row0+emax5[cid].last_dist)%EMAX_DEPTH;
@


1.15
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.13 2016/02/28 23:51:58 nakashim Exp nakashim $";
d26 3
a28 3
  struct lmmi lmmi[EMAX_DEPTH][EMAX_WIDTH]; /* current lmmi */
  struct lmmi lmmo[EMAX_DEPTH][EMAX_WIDTH]; /* previous lmmi */
  Uchar       lmmd[EMAX_DEPTH][EMAX_WIDTH]; /* 0:clean,   1:suspended drain, exec後store箇所に1, drain時0 */
d318 4
a321 3
	  /*-----------------------------------ここまで-----------------------------------*/
	  i = (emax5[cid].last_row0+wrdyc[cid]/(sizeof(struct memi)/(sizeof(Uint)*EMAX_WIDTH)))%EMAX_DEPTH;
	  *((Uint*)&emax5[cid].memi_new[i]+(wrdyc[cid]%(sizeof(struct memi)/(sizeof(Uint)*EMAX_WIDTH)))*EMAX_WIDTH+j) = tp2[wrdyc[cid]*EMAX_WIDTH+j]; /* UNIT外なので直ちに書き込み */
d326 3
a328 5
      else {
	emax5[cid].pe0_status      = STATUS_LMM_LOAD;
	emax5[cid].fsm_cmd    = FSM_IDLE; 
	emax5[cid].unit_ctl_count  = 0;
	wrdyc[cid] = 0;
d331 4
@


1.14
log
@*** empty log message ***
@
text
@d26 3
a28 1
  struct lmmi lmmi[EMAX_DEPTH][EMAX_WIDTH];
d30 1
a30 1
  Uint  fsm_cmd           : 4; /* 0:idle, 1:conf, 2:drain: 3:lmmi, 4:regv, 5:load, 6:start, 7:exec, 8:term */
d42 9
a50 1
                               /*(2):drain fsm_way毎に,fsm内部の全lmmiに未loadLMMがあるか検査         */
d53 1
a53 3
                               /* 3 :lmmi  fsm_way毎に,fsm内部のlmmiへ読み込み                        */
                               /*          4wayが全て完了するまで待機                                 */
                               /* 4 :regv  全fsm_wayに,start準備をセット                              */
d55 1
a55 1
                               /*(5):load  fsm_way毎に,fsm内部の全lmmiに未loadLMMがあるか検査         */
d58 2
a59 2
                               /* 6 :start 全fsm_wayに,startをセット                                  */
                               /* 7 :exec  全fsm_wayのlast_row0にflag=1をセット.EMAX5起動             */
d70 1
a71 1
    Uint  rrdyc;               /* READ-READY  counter */
d196 1
a196 1
  int i, j, k, a, width, dist;
d283 5
d293 2
a294 2
      for (i=0; i<EMAX_WIDTH; i++) {
	if (emax5[cid].fsm[i].rrdyc < EMAX_DEPTH) { /* rrdy */
d300 1
d302 8
a309 3
	else {
	  emax5[cid].status  = STATUS_LMMI;
	  emax5[cid].fsm_cmd = FSM_IDLE; 
a312 1
      /*-----------------------------------ここまで-----------------------------------*/
d314 6
a319 6
      emax5[cid].cycles_memi_part++;
      /* Step 8.3: fill local reg (memi[]) from SDRAM */
      if (wrdyc[cid] < EMAX_DEPTH*sizeof(struct memi)/(sizeof(Uint)*EMAX_WIDTH)) { /* rrdy */
	i = (emax5[cid].last_row0+wrdyc[cid]/(sizeof(struct memi)/(sizeof(Uint)*EMAX_WIDTH)))%EMAX_DEPTH;
	for (j=0; j<EMAX_WIDTH; j++) {
	  Uint *tp2 = emax5[cid].maddr;
d321 2
a323 1
	wrdyc[cid]++;
a333 1
      /* Step 8.6: (each unit) drain local mem to SDRAM */
@


1.13
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.12 2016/02/28 15:07:26 nakashim Exp nakashim $";
d16 2
a17 2
enum { STATUS_IDLE, STATUS_CONF, STATUS_DRAIN, STATUS_LMMI, STATUS_REGV, STATUS_LOAD, STATUS_START, STATUS_EXEC, STATUS_TERM };
enum { FSM_IDLE,    FSM_CONF,    FSM_DRAIN,    FSM_LMMI,    FSM_REGV,    FSM_LOAD,    FSM_START,    FSM_EXEC,    FSM_TERM };
a61 1
    Uchar *maddr;              /* address of main-memory space */
d64 16
a79 9
                               /*                           PF  DR  TR  DM                 */
    Ull   lmwa               ; /* -> ea0dr                   v                             */
    Ull   lmra               ; /* -> ea1dr                       v                         */
    Ull   axra               ; /* <- ea0dr                   -           v                 */
    Ull   axwa               ; /* <- ea1dr not used              -                         */
    Ull   axrl               ; /* -> axi rlength             v           1                 */
    Ull   axwl               ; /* -> axi wlength not used        v   -                     */
    Ull   axrd[UNIT_WIDTH]   ; /* <- axi rdata               v           v                 */
    Ull   axwd[UNIT_WIDTH]   ; /* -> axi wdata                   v   v                     */
d118 1
a118 1
  Ull   axwa            ; /* <- ea1dr not used */
d152 1
a152 1
trans_start(tid, cycle, trace, trace_pipe, base, start, end, gr2) Uint tid, cycle, trace, trace_pipe; Uchar *base; Ull start, end, gr2;
d185 1
a185 1
emax5_start(tid, cycle, trace, trace_pipe, base, conf, regv, lmmi) Uint tid, cycle, trace, trace_pipe; Uchar *base; Ull conf, regv, lmmi;
a204 4
  /*******************************************************************************************************************************/
  /* Step 8                                                                                                                      */
  /* EMAX5 HW starts execution according to unit[][].                                                                            */
  /*******************************************************************************************************************************/
d262 7
a268 5
	emax5[cid].status     = STATUS_CONF;
	emax5[cid].fsm_cmd    = FSM_IDLE; 
	for (i=0; i<EMAX_WIDTH; i++)
	  emax5[cid].fsm[i].maddr = base+conf+(Ull)(sizeof(struct conf)*EMAX_DEPTH*i); /* conf_topをfsmに渡すインタフェース */
	emax5[cid].fsm[i].wrdyc = 0;
a269 1
      /******************************************************ここまで*********************************************************************************************************************/
d272 3
a274 5
	  printf("step 8.0: skipping conf[][]\n");
	emax5[cid].pe0_status      = STATUS_REGV;
	emax5[cid].fsm_cmd    = FSM_IDLE; 
	emax5[cid].maddr = (Uint*)(base+start+sizeof(conf));
	wrdyc[cid] = 0;
d279 21
a299 6
      /* Step 8.1: fill local reg (conf[]) from SDRAM */
      if (wrdyc[cid] < EMAX_DEPTH*sizeof(struct conf)/(sizeof(Uint)*EMAX_WIDTH)) { /* rrdy */
	emax5[cid].fsm_cmd = FSM_CONF;     /* 一旦latch.次のCLKでUNIT書き込み */
	emax5[cid].select_row = 1LL<<((emax5[cid].last_row0+wrdyc[cid]/(sizeof(struct conf)/(sizeof(Uint)*EMAX_WIDTH)))%EMAX_DEPTH);
	emax5[cid].unit_select_col = (1<<EMAX_WIDTH)-1; /* all-1 */
	emax5[cid].unit_edb0 = wrdyc[cid]%(sizeof(struct conf)/(sizeof(Uint)*EMAX_WIDTH));    /* select target registers */
d301 41
a341 5
	  Uint *tp0 = emax5[cid].maddr;
	  emax5[cid].unit_edb1[j] = tp0[wrdyc[cid]*EMAX_WIDTH+j]; /* 一旦latch.次のCLKでUNIT書き込み */
	  if ((wrdyc[cid] & (sizeof(struct conf)/(sizeof(Uint)*EMAX_WIDTH)-1)) == (sizeof(struct conf)/(sizeof(Uint)*EMAX_WIDTH)-1)) { /* last word */
	    if ((emax5[cid].unit_edb1[j] & 0x00000003) && (emax5[cid].unit_edb1[j] & 0x0000003c))
	      emax5[cid].last_dist = (emax5[cid].unit_edb1[j] >> 2) & 0xf;
d343 60
a403 1
	wrdyc[cid]++;
d406 1
a406 1
	emax5[cid].pe0_status      = STATUS_REGV;
d408 1
a408 1
	emax5[cid].maddr = (Uint*)(base+start+sizeof(conf));
d410 1
a433 18
    case STATUS_LMMI:
      emax5[cid].cycles_memi_part++;
      /* Step 8.3: fill local reg (memi[]) from SDRAM */
      if (wrdyc[cid] < EMAX_DEPTH*sizeof(struct memi)/(sizeof(Uint)*EMAX_WIDTH)) { /* rrdy */
	i = (emax5[cid].last_row0+wrdyc[cid]/(sizeof(struct memi)/(sizeof(Uint)*EMAX_WIDTH)))%EMAX_DEPTH;
	for (j=0; j<EMAX_WIDTH; j++) {
	  Uint *tp2 = emax5[cid].maddr;
	  *((Uint*)&emax5[cid].memi_new[i]+(wrdyc[cid]%(sizeof(struct memi)/(sizeof(Uint)*EMAX_WIDTH)))*EMAX_WIDTH+j) = tp2[wrdyc[cid]*EMAX_WIDTH+j]; /* UNIT外なので直ちに書き込み */
	}
	wrdyc[cid]++;
      }
      else {
	emax5[cid].pe0_status      = STATUS_LMM_LOAD;
	emax5[cid].fsm_cmd    = FSM_IDLE; 
	emax5[cid].unit_ctl_count  = 0;
	wrdyc[cid] = 0;
      }
      break;
a611 100
    case STATUS_DRAIN:
      emax5[cid].cycles_lmm_drain_part++;
      /* Step 8.6: (each unit) drain local mem to SDRAM */
      if (emax5[cid].unit_ctl_count < EMAX_DEPTH*EMAX_WIDTH) {
	Uint count;
	i = (emax5[cid].unit_ctl_count/EMAX_WIDTH)%EMAX_DEPTH;
	j = (emax5[cid].unit_ctl_count           )%EMAX_WIDTH;
	emax5[cid].select_row = 1LL<<i;
	switch (emax5[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
	case 0: /* memi_new.width=0の場合は 着目colのみ1bit-ON */
	  emax5[cid].unit_select_col = 1<<j;
	  break;
	case 1: /* memi_new.width=1の場合は 着目col=2,0の場合のみ col3,1も同時にON 2word同時転送 */
	  emax5[cid].unit_select_col = 3<<j;
	  break;
	case 2: /* memi_new.width=2の場合は 着目col=0の場合のみ col3,2,1も同時にON 4word同時転送 */
	  emax5[cid].unit_select_col = 15<<j;
	  break;
	}
	count = emax5[cid].memi_new[i].len[j];
	switch (emax5[cid].memi_new[i].mctr0[j].v) {
	  /*  0:nop,  1:LMR, *2:LMW, *3:LMX,  4:LMP,  5:LMF(force read),  6:LMD */
	  /*  8:MMR   9:MMTR */
	case 2: 
	case 3: 
	  if (wrdyc[cid] < count) { /* wrdy */
	    emax5[cid].fsm_cmd = FSM_DRAIN; /* 一旦latch.次のCLKでUNIT書き込み */
	    emax5[cid].unit_edb0 = emax5[cid].memi_new[i].lmm_top[j]+wrdyc[cid]*sizeof(Uint);    /* select target registers */
	    wrdyc[cid]++;
	  }
	  else {
	    emax5[cid].fsm_cmd = FSM_IDLE;
	  }
	  if (rrdyc[cid] < count) {
	    if (emax5[cid].fsm_cmd_d2 == FSM_DRAIN) { /* rrdyc[cid] */
	      width = (1<<emax5[cid].memi_new[i].mctr0[j].width); /* 0:4bytes, 1:8bytes, 2:16bytes 3:undef */
	      dist  = (1<<emax5[cid].memi_new[i].mctr0[j].dist);  /* 0:dist=width, 1:dist=width*2, 2:dist=width*4 3:dist=width*8 */
	      a = emax5[cid].memi_new[i].mem_top[j]+(rrdyc[cid])*sizeof(Uint)*width*dist;
	      switch (emax5[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
	      case 0: /* memi_new.width=0の場合は 着目colのみ1bit-ON */
		emax5[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		*(Uint*)(base+a) = emax5[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		if (trace)
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/1 val=%08.8x(%d/%d)<-LMM\n", i, j, a, emax5[cid].unit_emb[0], rrdyc[cid], count);
		break;
	      case 1: /* memi_new.width=1の場合は 着目col=2,0の場合のみ col3,1も同時にON 2word同時転送 */
		emax5[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		emax5[cid].unit_emb[1] = unit[cid][i][j+1].emb[0].d;
		*(Uint*)(base+a             ) = emax5[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)) = emax5[cid].unit_emb[1]; /* 一旦latch.次のCLKでUNIT書き込み */
		if (trace) {
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/2 val=%08.8x(%d/%d)<-LMM\n", i, j, a,              emax5[cid].unit_emb[0], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=2/2 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint), emax5[cid].unit_emb[1], rrdyc[cid], count);
		}
		break;
	      case 2: /* memi_new.width=2の場合は 着目col=0の場合のみ col3,2,1も同時にON 4word同時転送 */
		emax5[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		emax5[cid].unit_emb[1] = unit[cid][i][j+1].emb[0].d;
		emax5[cid].unit_emb[2] = unit[cid][i][j+2].emb[0].d;
		emax5[cid].unit_emb[3] = unit[cid][i][j+3].emb[0].d;
		*(Uint*)(base+a               ) = emax5[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)  ) = emax5[cid].unit_emb[1]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)*2) = emax5[cid].unit_emb[2]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)*3) = emax5[cid].unit_emb[3]; /* 一旦latch.次のCLKでUNIT書き込み */
		if (trace) {
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a               , emax5[cid].unit_emb[0], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=2/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)  , emax5[cid].unit_emb[1], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=3/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)*2, emax5[cid].unit_emb[2], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=4/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)*3, emax5[cid].unit_emb[3], rrdyc[cid], count);
		}
		break;
	      }
	      rrdyc[cid]++;
	    }
	  }
	  else {
	    emax5[cid].unit_ctl_count++;
	    wrdyc[cid] = 0;
	    rrdyc[cid] = 0;
	  }
	  break;
	case 0: 
	case 1: 
	case 4: 
	case 5: 
	case 6: 
	case 8: 
	case 9: 
	  emax5[cid].unit_ctl_count++;
	  break;
	}
      }
      else {
	emax5[cid].pe0_status      = STATUS_TERM;
	emax5[cid].fsm_cmd    = FSM_IDLE; 
	emax5[cid].unit_ctl_count  = 0;
	wrdyc[cid] = 0;
	rrdyc[cid] = 0;
      }
      break;
@


1.12
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.11 2016/02/16 14:53:21 nakashim Exp nakashim $";
d62 1
a62 1
    Ull   maddr;               /* address of main-memory space */
d146 1
a146 1
trans_start(tid, cycle, trace, trace_pipe, base, start, end) Uint tid, cycle, trace, trace_pipe; Uchar *base; Ull start, end;
a175 3
static Uint wrdyc[MAXCORE], rrdyc[MAXCORE];
static Uint *p[MAXCORE];

d179 1
a179 1
emax5_start(tid, trace, trace_pipe, cycle, base, start, end) Uint tid, cycle, trace, trace_pipe; Uchar *base; Ull start, end;
d259 1
a259 1
      if (emax5[cid].last_conf != (Ull*)(base+start) || emax5[cid].last_dist > 0) {
d262 3
a264 2
	emax5[cid].maddr      = (Ull*)(base+start); /* conf_topをfsmに渡すインタフェース */
	wrdyc[cid] = 0;
@


1.11
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.10 2016/02/16 12:28:11 nakashim Exp nakashim $";
d29 2
d58 1
a58 1
  struct fsm_way {             /* load/drainは,複数rowを同時動作 */
d61 1
d74 1
a74 1
  } fsm_way[EMAX_WIDTH];
d146 1
a146 1
trans_start(tid, cycle, trace, trace_pipe, base, start, end) Uint tid, cycle, trace, trace_pipe; Uchar *base; Uint start, end;
d180 3
a182 1
emax5_start(tid, cycle, trace, trace_pipe, base, start, end) Uint tid, cycle, trace, trace_pipe; Uchar *base; Uint start, end;
d232 6
a237 6
	emax5[cid].unit2_stop |=                                      ( prev1_stop           &(1LL<<  i                          ))                                            ? (1LL<<i): 0;
	emax5[cid].unit1_stop |=                                      ( prev2_stop           &(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH)))                                            ? (1LL<<i): 0;
	emax5[cid].unit2_exec &=                                      (                                                                       emax5[cid].unit2_stop&(1LL<<i))  ?~(1LL<<i):~0;
	emax5[cid].unit2_exec |=                                      ((emax5[cid].unit1_exec&(1LL<<  i                               )) && !(emax5[cid].unit2_stop&(1LL<<i))) ? (1LL<<i): 0;
	emax5[cid].unit1_exec &=                                      (                                                                       emax5[cid].unit1_stop&(1LL<<i )) ?~(1LL<<i):~0;
	emax5[cid].unit1_exec |= ((emax5[cid].fsm_way[0].row_select&(1LL<<i)) || ((emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))) && !(emax5[cid].unit1_stop&(1LL<<i))))? (1LL<<i): 0;
a255 1
    emax5[cid].fsm_cmd_d2    = emax5[cid].fsm_cmd_d1;
d257 2
a258 2
    emax5[cid].select_row_d1 = emax5[cid].select_row;
    emax5[cid].unit_select_col_d1 = emax5[cid].unit_select_col;
d260 1
a260 1
    switch (emax5[cid].pe0_status) {
d262 2
a263 2
      if (emax5[cid].last_conf != (Uint*)(base+start) || emax5[cid].last_dist > 0) {
	emax5[cid].pe0_status      = STATUS_CONF;
d265 1
a265 1
	emax5[cid].maddr = (Uint*)(base+start);
d268 1
d356 8
a363 8
          if (emax5[cid].memi_old[i].mctr0[j].v
              && emax5[cid].memi_old[i].mctr0[j].bank  == emax5[cid].memi_new[i].mctr0[j].bank
              && emax5[cid].memi_old[i].mctr0[j].width == emax5[cid].memi_new[i].mctr0[j].width
              && emax5[cid].memi_old[i].mctr0[j].block == emax5[cid].memi_new[i].mctr0[j].block
              && emax5[cid].memi_old[i].mctr0[j].dist  == emax5[cid].memi_new[i].mctr0[j].dist
              && emax5[cid].memi_old[i].lmm_top[j]     == emax5[cid].memi_new[i].lmm_top[j]
              && emax5[cid].memi_old[i].mem_top[j]     == emax5[cid].memi_new[i].mem_top[j]
              && emax5[cid].memi_old[i].len[j]         >= emax5[cid].memi_new[i].len[j]) {
d366 2
a367 2
            emax5[cid].unit_ctl_count++;
          }
d404 1
a404 1

d509 1
a509 1

@


1.10
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.9 2016/02/16 09:49:14 nakashim Exp nakashim $";
d57 5
a61 5
    Uint  count           : 6; /* unit counter 6bit */
    Ull   select_row      :64; /* bitmap 0:off 1:selected */
    Ull   maddr;
    Uint  wrdyc;
    Uint  rrdyc;
d64 7
a70 7
    Ull   lmra               ; /* -> ea1dr                                                 */
    Ull   axra               ; /* <- ea0dr                   v                             */
    Ull   axwa               ; /* <- ea1dr not used                                        */
    Ull   axrl               ; /* -> axi rlength             v                             */
    Ull   axwl               ; /* -> axi wlength not used                                  */
    Ull   axrd[UNIT_WIDTH]   ; /* <- axi rdata               v                             */
    Ull   axwd[UNIT_WIDTH]   ; /* -> axi wdata                                             */
d73 4
a76 4
  Ull   unit1_exec           ; /* 1bit corresponds to each row   (cex,exe,eag), 0:wait 1:exec */
  Ull   unit1_stop           ; /* 1bit corresponds to each stage (cex,exe,eag), 0:wait 1:stop */
  Ull   unit2_exec           ; /* 1bit corresponds to each row   (lmm),         0:wait 1:exec */
  Ull   unit2_stop           ; /* 1bit corresponds to each stage (lmm),         0:wait 1:stop */
d232 1
a232 1
	emax5[cid].unit1_exec |= ((emax5[cid].select_row&(1LL<<i)) || ((emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))) && !(emax5[cid].unit1_stop&(1LL<<i))))? (1LL<<i): 0;
@


1.9
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.8 2016/02/15 14:56:52 nakashim Exp nakashim $";
d78 1
d82 1
a83 1
  Uint  cycles_regv_part;
a85 1
  Uint  cycles_tinit_part;
d87 1
d89 2
d92 1
a92 2
  Ull   cycles_memi;
  Ull   cycles_lmm_load;
d94 1
a94 2
  Ull   cycles_lmm_drain;
  Ull   cycles_tinit;
d188 1
a188 1
    emax5[cid].cycles_conf_part = 0;
d190 5
a194 5
    emax5[cid].cycles_lmmi_part = 0;
    emax5[cid].cycles_load_part = 0;
    emax5[cid].cycles_regv_part = 0;
    emax5[cid].cycles_exec_part = 0;
    emax5[cid].cycles_term_part = 0;
d621 3
a623 3
      printf(" %d %d %d %d %d %d %d\n",
	     emax5[cid].cycles_conf_part, emax5[cid].cycles_regv_part, emax5[cid].cycles_memi_part, emax5[cid].cycles_lmm_load_part,
	     emax5[cid].cycles_exec_part, emax5[cid].cycles_lmm_drain_part, emax5[cid].cycles_trans_part);
d625 2
d628 1
a628 2
      emax5[cid].cycles_memi     += emax5[cid].cycles_memi_part;
      emax5[cid].cycles_lmm_load += emax5[cid].cycles_lmm_load_part;
d630 1
a630 1
      emax5[cid].cycles_lmm_drain+= emax5[cid].cycles_lmm_drain_part;
d690 1
a690 1
  printf("%03.3d:EMAX5 tinit=%08.8x_%08.8x conf=%08.8x_%08.8x  regv=%08.8x_%08.8x  memi=%08.8x_%08.8x\n",
d694 5
a698 4
	 (Uint)(emax5[cid].cycles_regv>>32),  (Uint)emax5[cid].cycles_regv,
	 (Uint)(emax5[cid].cycles_memi>>32),  (Uint)emax5[cid].cycles_memi);
  printf("           load=%08.8x_%08.8x exec=%08.8x_%08.8x drain=%08.8x_%08.8x trans=%08.8x_%08.8x\n",
	 (Uint)(emax5[cid].cycles_lmm_load>>32),  (Uint)emax5[cid].cycles_lmm_load,
d700 1
a700 1
	 (Uint)(emax5[cid].cycles_lmm_drain>>32),  (Uint)emax5[cid].cycles_lmm_drain,
d702 1
a702 19
  total = emax5[cid].cycles_tinit+emax5[cid].cycles_conf+emax5[cid].cycles_regv+emax5[cid].cycles_memi+emax5[cid].cycles_lmm_load+emax5[cid].cycles_exec+emax5[cid].cycles_lmm_drain+emax5[cid].cycles_trans;
  total *= EMAX5HOST_RATIO; /* 200MHz -> 2.4GHz */
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(icrmledt)", 2400/EMAX5HOST_RATIO, (Uint)(total>>32), (Uint)total);
  total += pa_cycle;
  printf(" TOTAL_CYCLE=%08.8x_%08.8x(icrmledt)\033[0m\n", (Uint)(total>>32), (Uint)total);

  total = emax5[cid].cycles_tinit                  +emax5[cid].cycles_regv+emax5[cid].cycles_memi+emax5[cid].cycles_lmm_load+emax5[cid].cycles_exec+emax5[cid].cycles_lmm_drain+emax5[cid].cycles_trans;
  total *= EMAX5HOST_RATIO; /* 200MHz -> 2.4GHz */
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(i rmledt)", 2400/EMAX5HOST_RATIO, (Uint)(total>>32), (Uint)total);
  total += pa_cycle;
  printf(" TOTAL_CYCLE=%08.8x_%08.8x(i rmledt)\033[0m\n", (Uint)(total>>32), (Uint)total);

  total = emax5[cid].cycles_tinit                  +emax5[cid].cycles_regv+emax5[cid].cycles_memi                      +emax5[cid].cycles_exec                       +emax5[cid].cycles_trans;
  total *= EMAX5HOST_RATIO; /* 200MHz -> 2.4GHz */
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(i rm e t)", 2400/EMAX5HOST_RATIO, (Uint)(total>>32), (Uint)total);
  total += pa_cycle;
  printf(" TOTAL_CYCLE=%08.8x_%08.8x(i rm e t)\033[0m\n", (Uint)(total>>32), (Uint)total);

  total = emax5[cid].cycles_tinit                  +emax5[cid].cycles_regv+emax5[cid].cycles_memi                      +emax5[cid].cycles_exec;
d704 1
a704 1
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(i rm e  )", 2400/EMAX5HOST_RATIO, (Uint)(total>>32), (Uint)total);
d706 1
a706 1
  printf(" TOTAL_CYCLE=%08.8x_%08.8x(i rm e  )\033[0m\n", (Uint)(total>>32), (Uint)total);
d709 7
a715 6
  emax5[cid].cycles_conf = 0LL;
  emax5[cid].cycles_regv = 0LL;
  emax5[cid].cycles_memi = 0LL;
  emax5[cid].cycles_lmm_load = 0LL;
  emax5[cid].cycles_exec = 0LL;
  emax5[cid].cycles_lmm_drain = 0LL;
@


1.8
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.7 2016/02/08 14:28:27 nakashim Exp nakashim $";
d16 2
a17 2
enum { STATUS_IDLE, STATUS_CONF, STATUS_DRAIN, STATUS_LMMI, STATUS_LOAD, STATUS_REGV, STATUS_START, STATUS_EXEC, STATUS_TERM };
enum { FSM_IDLE, FSM_CONF, FSM_DRAIN, FSM_LMMI, FSM_LOAD, FSM_REGV, FSM_START, FSM_EXEC, FSM_TERM };
d28 1
a28 1
  Uint  fsm_cmd           : 4; /* 0:idle, 1:conf, 2:drain: 3:lmmi, 4:load, 5:start, 6:regv, 7:exec, 8:term */
d36 19
a54 13
                               /* 1:conf  fsm_way毎に,last_row0から順にEMAX本体に格納                */
                               /*         4wayが全て完了するまで待機                                 */
                               /* 2:drain fsm_way毎に,fsm内部の全lmmiに未loadLMMがあるか検査         */
                               /*         未loadLMMが存在する場合,fsm_way毎に,last_row0から順にdrain */
                               /*         4wayが全て完了するまで待機                                 */
                               /* 3:lmmi  fsm_way毎に,fsm内部のlmmiへ読み込み                        */
                               /*         4wayが全て完了するまで待機                                 */
                               /* 4:load  fsm_way毎に,fsm内部の全lmmiに未loadLMMがあるか検査         */
                               /*         未loadLMMが存在する場合,fsm_way毎に,last_row0から順にload  */
                               /*         4wayが全て完了するまで待機                                 */
                               /* 6:regv  全fsm_wayに,start準備をセット                              */
                               /*         4wayが全て完了するまで待機                                 */
                               /* 5:start 全fsm_wayに,start準備をセット                              */
@


1.7
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.6 2016/02/07 15:36:50 nakashim Exp nakashim $";
d16 2
a17 2
enum { STATUS_IDLE, STATUS_CONF, STATUS_DRAIN, STATUS_LMMI,
       STATUS_LOAD, STATUS_REGV, STATUS_EXEC,  STATUS_TERM };
d28 22
a49 7
  Uint  unit_fsm_cmd      : 3; /* 0:idle, 1:conf, 2:drain: 3:lmmi, 4:load, 5:regv, 6:exec, 7:term */
                               /* 未loadLMMが残っている場合,lmmiの前にdrain */
                               /*  start | drain | lmmi | load | regv | exec  | */
                               /*        |       |      |      |      | pload | */
                               /* 残っていない場合,execと同時にdrain開始 */
                               /*  start | lmmi | regv | exec        | */
                               /*        |      |      | drain pload | */
d53 3
d68 1
a69 1
  Ull   unit1_stop           ; /* 1bit corresponds to each stage (cex,exe,eag), 0:wait 1:stop */
d132 1
a132 1
  Uint reg[MAX_TRANS_REG]; /* r0-r7 for param/work */
d158 1
a158 1
  emax5[cid].cycles_tinit_part = sizeof(tconf)/(sizeof(Uint)*EMAX_WIDTH);
d178 1
a178 1
  if (emax5[cid].pe0_status == STATUS_IDLE) {
a193 1

d201 3
a203 3
    for (i=(emax5[cid].unit_offset+EMAX_DEPTH-1)%EMAX_DEPTH;; i=(i+EMAX_DEPTH-1)%EMAX_DEPTH) { /* for each unit */
      siml_unit_ex1_bus(cid, i); /* edb,edc */
      siml_unit_ex2_bus(cid, i); /* emb,etb,etc */
d206 1
a206 1
	/****** do ex2/lmm ********/
d208 1
a208 3
	siml_unit_ex2(cid, i, j); /* ex2 */
	/* siml_unit_lmm(trace, base, i, j); /* lmm */
	emax5[cid].pa_cycles_trans += siml_unit_lmm(cid, trace, base, i, j); /* lmm */
d212 1
a212 1
	/****** do ex1/eag ********/
d214 2
a215 2
	siml_unit_cnd(cid, i, j); /* cnd */
	siml_unit_ex1(cid, i, j); /* ex1 */
d219 1
a219 1
      if (emax5[cid].unit_edb_cmd == 5) {
d225 1
a225 1
	emax5[cid].unit1_exec |= ((emax5[cid].unit_select_row&(1LL<<i)) || ((emax5[cid].unit2_exec&(1LL<<((i+EMAX_DEPTH-1)%EMAX_DEPTH))) && !(emax5[cid].unit1_stop&(1LL<<i))))? (1LL<<i): 0;
d227 1
a227 1
      if (i==emax5[cid].unit_offset)
d244 3
a246 3
    emax5[cid].unit_edb_cmd_d2    = emax5[cid].unit_edb_cmd_d1;
    emax5[cid].unit_edb_cmd_d1    = emax5[cid].unit_edb_cmd;
    emax5[cid].unit_select_row_d1 = emax5[cid].unit_select_row;
d253 2
a254 2
	emax5[cid].unit_edb_cmd    = 0; 
	p[cid] = (Uint*)(base+start);
d261 2
a262 2
	emax5[cid].unit_edb_cmd    = 0; 
	p[cid] = (Uint*)(base+start+sizeof(conf));
d267 1
a267 1
      emax5[cid].pa_cycles_conf++;
d270 2
a271 2
	emax5[cid].unit_edb_cmd = 1;     /* 一旦latch.次のCLKでUNIT書き込み */
	emax5[cid].unit_select_row = 1LL<<((emax5[cid].unit_offset+wrdyc[cid]/(sizeof(struct conf)/(sizeof(Uint)*EMAX_WIDTH)))%EMAX_DEPTH);
d275 1
a275 1
	  Uint *tp0 = p[cid];
d286 2
a287 2
	emax5[cid].unit_edb_cmd    = 0; 
	p[cid] = (Uint*)(base+start+sizeof(conf));
d292 1
a292 1
      emax5[cid].pa_cycles_regv++;
d295 2
a296 2
	emax5[cid].unit_edb_cmd = 2;     /* 一旦latch.次のCLKでUNIT書き込み */
	emax5[cid].unit_select_row = 1LL<<((emax5[cid].unit_offset+wrdyc[cid]/(sizeof(struct regv)/(sizeof(Uint)*EMAX_WIDTH)))%EMAX_DEPTH);
d300 1
a300 1
	  Uint *tp1 = p[cid];
d307 2
a308 2
	emax5[cid].unit_edb_cmd    = 0; 
	p[cid] = (Uint*)(base+start+sizeof(conf)+sizeof(regv));
d312 2
a313 2
    case STATUS_MEMI:
      emax5[cid].pa_cycles_memi++;
d316 1
a316 1
	i = (emax5[cid].unit_offset+wrdyc[cid]/(sizeof(struct memi)/(sizeof(Uint)*EMAX_WIDTH)))%EMAX_DEPTH;
d318 1
a318 1
	  Uint *tp2 = p[cid];
d325 1
a325 1
	emax5[cid].unit_edb_cmd    = 0; 
d330 2
a331 2
    case STATUS_LMM_LOAD:
      emax5[cid].pa_cycles_lmm_load++;
d357 1
a357 1
	    emax5[cid].unit_edb_cmd = 4; /* 一旦latch.次のCLKでUNIT書き込み */
d359 1
a359 1
	    emax5[cid].unit_select_row = 1LL<<i;
d451 1
a451 1
	    emax5[cid].unit_edb_cmd = 0; 
d468 1
a468 1
	emax5[cid].unit_edb_cmd    = 0; 
d475 2
a476 2
      emax5[cid].unit_edb_cmd    = 5; /* 一旦latch.次のCLKでUNIT書き込み */
      emax5[cid].unit_select_row = 1LL<<emax5[cid].unit_offset;
d480 1
a480 1
      emax5[cid].pa_cycles_exec++;
d495 1
a495 1
	emax5[cid].unit_select_row = 0; /* inhibit initial restart */
d500 2
a501 2
	  emax5[cid].pe0_status     = STATUS_LMM_DRAIN;
	  emax5[cid].unit_edb_cmd   = 0; 
d508 2
a509 2
    case STATUS_LMM_DRAIN:
      emax5[cid].pa_cycles_lmm_drain++;
d515 1
a515 1
	emax5[cid].unit_select_row = 1LL<<i;
d534 1
a534 1
	    emax5[cid].unit_edb_cmd = 6; /* 一旦latch.次のCLKでUNIT書き込み */
d539 1
a539 1
	    emax5[cid].unit_edb_cmd = 0;
d542 1
a542 1
	    if (emax5[cid].unit_edb_cmd_d2 == 6) { /* rrdyc[cid] */
d602 1
a602 1
	emax5[cid].unit_edb_cmd    = 0; 
d609 1
a609 1
      /* unit_offset 設定 */
d613 1
a613 1
      emax5[cid].unit_offset = (emax5[cid].unit_offset+emax5[cid].last_dist)%EMAX_DEPTH;
d615 9
a623 9
	     emax5[cid].pa_cycles_conf, emax5[cid].pa_cycles_regv, emax5[cid].pa_cycles_memi, emax5[cid].pa_cycles_lmm_load,
	     emax5[cid].pa_cycles_exec, emax5[cid].pa_cycles_lmm_drain, emax5[cid].pa_cycles_trans);
      emax5[cid].cycles_conf     += emax5[cid].pa_cycles_conf;
      emax5[cid].cycles_regv     += emax5[cid].pa_cycles_regv;
      emax5[cid].cycles_memi     += emax5[cid].pa_cycles_memi;
      emax5[cid].cycles_lmm_load += emax5[cid].pa_cycles_lmm_load;
      emax5[cid].cycles_exec     += emax5[cid].pa_cycles_exec;
      emax5[cid].cycles_lmm_drain+= emax5[cid].pa_cycles_lmm_drain;
      emax5[cid].cycles_trans    += emax5[cid].pa_cycles_trans;
d665 1
a665 1
siml_unit_lmm(cid, trace, base, i, j) Uint cid, trace, base, i, j;
@


1.6
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.5 2016/02/07 14:37:16 nakashim Exp nakashim $";
d30 2
d33 2
d38 9
a46 8
    Ull   lmwa               ; /* -> ea0dr */
    Ull   lmra               ; /* -> ea1dr */
    Ull   axra               ; /* <- ea0dr */
    Ull   axwa               ; /* <- ea1dr not used */
    Ull   axrl               ; /* -> axi rlength */
    Ull   axwl               ; /* -> axi wlength not used */
    Ull   axrd[UNIT_WIDTH]   ; /* <- axi rdata */
    Ull   axwd[UNIT_WIDTH]   ; /* -> axi wdata */
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.4 2016/02/07 12:15:17 nakashim Exp nakashim $";
d20 6
a25 6
  Uint v                 :  1; /* 0:empty, 1:unuse */
  Uint tid               : 12; /* owner thread of EMAX */
  Uint status            :  3;
  Ull  *last_conf            ; /* for insn_reuse */
  Uint last_dist         :  6; /* latest map_dist */
  Uint last_row0         :  6; /* physical top of logical unit[][0] */
d28 1
a28 1
  Uint unit_fsm_cmd      :  3; /* 0:idle, 1:conf, 2:drain: 3:lmmi, 4:load, 5:regv, 6:exec, 7:term */
d32 10
a41 8
    Uint count           :  6; /* unit counter 6bit */
    Ull  select_row      : 64; /* bitmap 0:off 1:selected */
    Ull  lmwa                ; /* -> ea0dr */
    Ull  lmra                ; /* -> ea1dr */
    Ull  axra                ; /* <- ea0dr */
    Ull  axwa                ; /* <- ea1dr not used */
    Ull  axrd[UNIT_WIDTH]    ; /* <- axi */
    Ull  axwd[UNIT_WIDTH]    ; /* -> axi */
d44 22
a65 22
  Ull  unit1_exec            ; /* 1bit corresponds to each row   (cex,exe,eag), 0:wait 1:exec */
  Ull  unit2_exec            ; /* 1bit corresponds to each row   (lmm),         0:wait 1:exec */
  Ull  unit1_stop            ; /* 1bit corresponds to each stage (cex,exe,eag), 0:wait 1:stop */
  Ull  unit2_stop            ; /* 1bit corresponds to each stage (lmm),         0:wait 1:stop */

  Uint cycles_conf_part;
  Uint cycles_drain_part;
  Uint cycles_lmmi_part;
  Uint cycles_load_part;
  Uint cycles_regv_part;
  Uint cycles_exec_part;
  Uint cycles_term_part;
  Uint cycles_tinit_part;
  Uint cycles_trans_part;
  Ull cycles_conf;
  Ull cycles_regv;
  Ull cycles_memi;
  Ull cycles_lmm_load;
  Ull cycles_exec;
  Ull cycles_lmm_drain;
  Ull cycles_tinit;
  Ull cycles_trans;
@


1.4
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.3 2016/02/04 07:53:34 nakashim Exp nakashim $";
d15 1
a15 1
/* cgra */
d38 2
a39 2
    Ull  lmwd[UNIT_WIDTH]    ; /* <- axi */
    Ull  lmrd[UNIT_WIDTH]    ; /* -> axi */
d42 4
a45 4
  Ull  unit1_exec; /* 1bit corresponds to each row   (cex,exe,eag), 0:wait 1:exec */
  Ull  unit2_exec; /* 1bit corresponds to each row   (lmm),         0:wait 1:exec */
  Ull  unit1_stop; /* 1bit corresponds to each stage (cex,exe,eag), 0:wait 1:stop */
  Ull  unit2_stop; /* 1bit corresponds to each stage (lmm),         0:wait 1:stop */
d78 2
a79 2
  Ull   lmwd[UNIT_WIDTH]; /* <- axi */
  Ull   lmrd[UNIT_WIDTH]; /* -> axi */
d95 1
a95 1
/* transaction */
d110 1
d144 1
d611 1
a611 1
siml_unit_ex1_bus(cid, i) Uint cid, i; /* edb,edc *//* ex1/eagの計算前にEDB/EDCを確定させる */
d617 1
a617 1
siml_unit_ex2_bus(cid, i) Uint cid, i; /* emb,etb,etc *//* ex2/lmmの計算前にEDB/EDCを確定させる */
d623 1
a623 1
siml_unit_cnd(cid, i, j) Uint cid, i, j;
d629 1
a629 1
siml_unit_ex1(cid, i, j) Uint cid, i, j;
a636 7
siml_unit_ex2(cid, i, j) Uint cid, i, j;
{
  Uint k;
  Uint s1, s2, s3, t1, t2, d1, d2, c1, c2;

}

@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.2 2016/02/03 10:00:09 nakashim Exp nakashim $";
d15 3
a17 72
/* unit */
struct unit { /* final information for EMAX5 hardware */
  struct cnd {
    Uint bit0_v : 1;  /* valid */
    Uint bit0_r : 2;  /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    Uint bit1_v : 1;  /* valid */
    Uint bit1_r : 2;  /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    Uint bit2_v : 1;  /* valid */
    Uint bit2_r : 2;  /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    Uint bit3_v : 1;  /* valid */
    Uint bit3_r : 2;  /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    Uint select : 4;
    Uint table : 16;
    Uint exec  :  1;  /* 0:none 1:exec */
  } cnd;

  struct ex1 {
    Uint s1_r  : 3;  /* 5to1 selector 0:prev_p1 1:self_loop 2:idb0 3:idb1 4:edb0 5:edb1 */
    Uint s1_fhl: 2;  /*       1:SUFLO 2:SUFHI 3:ri/SUFFL */
    Uint s2_r  : 3;  /* 5to1 selector 0:prev_p2             2:idb0 3:idb1 4:edb0 5:edb1 */
    Uint s2_fhl: 2;  /* 0:imm 1:SUFLO 2:SUFHI 3:ri/SUFFL */
    Uint s3_r  : 3;  /* 5to1 selector 0:prev_p3             2:idb0 3:idb1 4:edb0 5:edb1 */
    Uint s3_fhl: 2;  /*       1:SUFLO 2:SUFHI 3:ri/SUFFL */
    Uint urZ_r : 1;  /* opcd-extension */
    Uint op_r  : 6;  /* ex1_opcd */
    Uint d     : 32; /* ex1 intermediate(data) */
    Uint c     : 1;  /* ex1 intermediate(cc)   */
    Uint px1_r : 2;  /* 0:off 2:s2 */
    Uint dx1   : 32; /* ex1 intermediate(extension) */
    Uint px2_r : 2;  /* 0:off 3:s3 */
    Uint dx2   : 32; /* ex1 intermediate(extension) */
    Uint x1_r  : 3;  /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    Uint t1    : 32; /* ex1 intermediate */
    Uint x2_r  : 3;  /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    Uint t2    : 32; /* ex1 intermediate */
    Uint x3_r  : 3;  /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    Uint t3    : 32; /* ex1 intermediate */
  } ex1;

  struct ex2 {
    /* inputs are connected to ex1.d*_r */
    Uint simmS_r: 13;
    Uint immT_r: 5;
    Uint s1_r  : 3;  /* 0:d_r(ex1) 4:dx1_r(ex1) 5:dx2_r(ex1) 6:simmS_r 7:immT_r */
    Uint s2_r  : 3;  /* 0:d_r(ex1) 4:dx1_r(ex1) 5:dx2_r(ex1) 6:simmS_r 7:immT_r */
    Uint s3_r  : 3;  /* 0:d_r(ex1) 4:dx1_r(ex1) 5:dx2_r(ex1) 6:simmS_r 7:immT_r */
    Uint op_r  : 3;  /* ex2_opcd */
    Uint sft_r : 3;  /* sft_opcd */
    Uint d     : 32; /* ex2 output(data) */
    Uint c     : 1;  /* ex2 output(cc)   */
    Uint x1_r  : 2;  /* ex2-output-selector 0:fixed_for_constant 1:t1_direct 2:from etb[] */
    Uint x2_r  : 2;  /* ex2-output-selector 0:fixed_for_constant 1:t2_direct 2:from etb[] */
    Uint x3_r  : 2;  /* ex2-output-selector 0:fixed_for_constant 1:t3_direct 2:from etb[] */
    Uint p1_r  : 32; /* ex2 output(prop) */
    Uint p2_r  : 32; /* ex2 output(prop) */
    Uint p3_r  : 32; /* ex2 output(prop) */
  } ex2;

  struct eag {
    Uint s1_r  : 3;  /* 5to1 selector 0:prev_p1 1:self_loop 2:idb0 3:idb1 4:edb0 5:edb1 */
    Uint s2_r  : 3;  /* 5to1 selector 0:prev_p2             2:idb0 3:idb1 4:edb0 5:edb1 */
    Uint s2_suffix:3;/* 0:imm 1:SUFLO 2:SUFHI 3:SUFFL 4:SUFB0 5:SUFB1 6:SUFB2 7:SUFB3 */
    Uint s3_r  : 3;  /* 5to1 selector 0:prev_p3             2:idb0 3:idb1 4:edb0 5:edb1 */
    Uint op_r  : 10; /* mem_opcd */
    Uint d     : 32; /* eag intermediate(data) */
    Uint x1_r  : 3;  /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    Uint x2_r  : 3;  /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    Uint x3_r  : 3;  /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    Uint t1    : 32; /* eag intermediate */
    Uint t2    : 32; /* eag intermediate */
    Uint t3    : 32; /* eag intermediate */
  } eag;
d19 1
a19 22
  struct lmm {
    Uint ssel_r: 1;   /* lmem-selector */
    Uint s     : 32;  /* lmem-internal-latch store_data */
    Uint a     : 32;  /* lmem-internal-latch address */
    Uchar m[LMEM_SIZE];
    Uint o     : 32;  /* output of m[] */
    Uint d     : 32; /* mem output(data) */
    Uint x1_r  : 2;  /* mem-output-selector 0:fixed_for_constant 1:t1_direct 2:from etb[] */
    Uint x2_r  : 2;  /* mem-output-selector 0:fixed_for_constant 1:t2_direct 2:from etb[] */
    Uint x3_r  : 2;  /* mem-output-selector 0:fixed_for_constant 1:t3_direct 2:from etb[] */
    Uint p1_r  : 32; /* mem output(prop) */
    Uint p2_r  : 32; /* mem output(prop) */
    Uint p3_r  : 32; /* mem output(prop) */
  } lmm;
  Uint v1          : 1; /* unit 1/2 (ex1/eag) on */
  Uint v2          : 1; /* unit 2/2 (ex2/lmm) on */
  Uint one_shot    : 1; /* for self_loop_control 0:init 1:self_loop */
} unit[MAXCORE][EMAX_DEPTH][EMAX_WIDTH];

enum { STATUS_IDLE, STATUS_CONF, STATUS_REGV, STATUS_MEMI, STATUS_LMM_LOAD, STATUS_START, STATUS_EXEC, STATUS_LMM_DRAIN, STATUS_TERM };

struct emax5 {
d21 3
a23 3
  Uint tid               : 12; /* owner of EMAX */
  Uint pe0_status        :  4;
  Uint *last_conf            ; /* for insn_reuse */
d25 2
a26 31
  Uint unit_offset       :  6; /* current mapped insn_row[0] */

  Uint unit_edb_cmd      :  3; /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  Uint unit_edb_cmd_d1   :  3; /* delay1 */
  Uint unit_edb_cmd_d2   :  3; /* delay2 */
  Uint unit_ctl_count    :  9; /* unit counter */
  Ull  unit_select_row   : 64; /* bitmap 0:off 1:selected */
  Uint unit_select_col   :  4; /* bitmap 0:off 1:selected */
  Ull  unit_select_row_d1: 64; /* delay1 */
  Uint unit_select_col_d1:  4; /* delay1 */
  Uint unit_edb_valid    :  1; /* edb valid (for HDL only) */
  Uint unit_edb0         : 32; /* write_data regno/lmm_address */
  Uint unit_edb1[EMAX_WIDTH] ; /* config/write_data to unit */
  Uint unit_emb_valid    :  1; /* emb valid (for HDL only) */
  Uint unit_emb[EMAX_WIDTH]  ; /* read_data from unit */

  struct memi memi_new[EMAX_DEPTH], memi_old[EMAX_DEPTH];

  Ull  unit1_exec; /* 1bit corresponds to each stage (ex1,eag), 0:wait 1:exec */
  Ull  unit2_exec; /* 1bit corresponds to each stage (ex2,lmm), 0:wait 1:exec */
  Ull  unit1_stop; /* 1bit corresponds to each stage (ex1,eag), 0:wait 1:stop */
  Ull  unit2_stop; /* 1bit corresponds to each stage (ex2,lmm), 0:wait 1:stop */

  Uint pa_cycles_tinit;
  Uint pa_cycles_conf;
  Uint pa_cycles_regv;
  Uint pa_cycles_memi;
  Uint pa_cycles_lmm_load;
  Uint pa_cycles_exec;
  Uint pa_cycles_lmm_drain;
  Uint pa_cycles_trans;
d28 28
a55 1
  Ull cycles_tinit;
d62 1
d66 29
d96 2
a100 2
enum { TCU_IDLE, TCU_BUSY };

d115 1
a115 1
  emax5[cid].pa_cycles_tinit = 0;
d132 2
a133 2
  emax5[cid].pa_cycles_tinit = sizeof(tconf)/(sizeof(Uint)*EMAX_WIDTH);
  emax5[cid].cycles_tinit += emax5[cid].pa_cycles_tinit;
d154 8
a161 7
    emax5[cid].pa_cycles_conf = 0;
    emax5[cid].pa_cycles_regv = 0;
    emax5[cid].pa_cycles_memi = 0;
    emax5[cid].pa_cycles_lmm_load = 0;
    emax5[cid].pa_cycles_exec = 0;
    emax5[cid].pa_cycles_lmm_drain = 0;
    emax5[cid].pa_cycles_trans = 0;
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/emax5.c,v 1.1 2016/02/02 15:07:18 nakashim Exp nakashim $";
a673 60
  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax5[cid].unit_edb_cmd) {
  case 1:
  case 2:
  case 4: /* data and address */
    if (emax5[cid].unit_select_row & (1LL<<i)) {
      for (j=0; j<EMAX_WIDTH; j++)
	unit[cid][i][j].edb[1].d = emax5[cid].unit_edb1[j];
    }
  case 6: /* address only */
    if (emax5[cid].unit_select_row & (1LL<<i)) {
      unit[cid][i][0].edb[0].d = emax5[cid].unit_edb0; /* edb[0].d[1..3] not exist */
      for (j=1; j<EMAX_WIDTH; j++)
	unit[cid][i][j].edb[0].d = unit[cid][i][j-1].edb[0].d;
    }
  default:
    return (0);
  case 5:
    break;
  }

  for (k=0; k<EXT_DST_BUS_NUM; k++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (unit[cid][i][j].v1) {
        switch (unit[cid][i][j].edb[k].sel_r) { /* 0:off 1:prev_ex2.d 2:prev_mem.d */
        case 0:                                                                                      break;
        case 1: unit[cid][i][j].edb[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.d;    break;
        case 2: unit[cid][i][j].edb[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.d;    break;
        default:unit[cid][i][j].edb[k].d = 0xffffffff;                                               break;
        }
      }
    }
    for (j=0; j<EMAX_WIDTH; j++) {
      if (j>0 && unit[cid][i][j-1].edb[k].dir_r==1) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].edb[k].d = unit[cid][i][j-1].edb[k].d;
    }
    for (j=EMAX_WIDTH-1; j>=0; j--) {
      if (j<EMAX_WIDTH-1 && unit[cid][i][j].edb[k].dir_r==2) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].edb[k].d = unit[cid][i][j+1].edb[k].d;
    }
  }

  for (k=0; k<EXT_DST_CCR_NUM; k++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (unit[cid][i][j].v1) {
        switch (unit[cid][i][j].edc[k].sel_r) { /* 0:off 1:prev_ex2.c */
        case 0:                                                                                  break;
        case 1:unit[cid][i][j].edc[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.c; break;
        }
      }
    }
    for (j=0; j<EMAX_WIDTH; j++) {
      if (j>0 && unit[cid][i][j-1].edc[k].dir_r==1) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].edc[k].d = unit[cid][i][j-1].edc[k].d;
    }
    for (j=EMAX_WIDTH-1; j>=0; j--) {
      if (j<EMAX_WIDTH-1 && unit[cid][i][j].edc[k].dir_r==2) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].edc[k].d = unit[cid][i][j+1].edc[k].d;
    }
  }
a679 92
  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax5[cid].unit_edb_cmd_d1) {
  case 4:
    for (j=0; j<EMAX_WIDTH; j++) {
      if ((emax5[cid].unit_select_row_d1 & (1LL<<i)) && (emax5[cid].unit_select_col_d1 & (1<<j)))
	lmm_mem_access(cid, i, j, MEM_WR);
    }
    return (0);
  case 6:
    for (j=0; j<EMAX_WIDTH; j++) {
      if ((emax5[cid].unit_select_row_d1 & (1LL<<i)) && (emax5[cid].unit_select_col_d1 & (1<<j)))
	unit[cid][i][j].emb[0].d = lmm_mem_access(cid, i, j, MEM_RD);
    }
    return (0);
  default:
    return (0);
  case 5:
    break;
  }

  for (j=0; j<EMAX_WIDTH; j++) {
    if (unit[cid][i][j].cnd.exec && unit[cid][i][j].v2 && (emax5[cid].unit2_exec & (1LL<<i))) {
      if (unit[cid][i][j].eag.op_r) {
	if (unit[cid][i][j].eag.op_r<=OP_LD) { /* load */
	  switch (unit[cid][i][j].emb[0].sel_r) { /* 0:off 1:lmem */
	  case 0:                                                      unit[cid][i][j].lmm.o    = lmm_mem_access(cid, i, j, MEM_RD); break;
	  case 1: unit[cid][i][j].emb[0].a = unit[cid][i][j].eag.d>>2; unit[cid][i][j].emb[0].d = lmm_mem_access(cid, i, j, MEM_RD); break;
	  default:unit[cid][i][j].emb[0].a = 0x3fff;                   unit[cid][i][j].emb[0].d = 0xffffffff;                   break;
	  }
	}
	else /* store */
	  lmm_mem_access(cid, i, j, MEM_WR);
      }
    }
  }
  for (j=0; j<EMAX_WIDTH; j++) {
    if (j>0 && unit[cid][i][j-1].emb[0].dir_r==1) { /* 0:off 1:to-left 2:to-right 3:inhibited */
      unit[cid][i][j].emb[0].a = unit[cid][i][j-1].emb[0].a;
      unit[cid][i][j].emb[0].d = unit[cid][i][j-1].emb[0].d;
    }
  }
  for (j=EMAX_WIDTH-1; j>=0; j--) {
    if (j<EMAX_WIDTH-1 && unit[cid][i][j].emb[0].dir_r==2) { /* 0:off 1:to-left 2:to-right 3:inhibited */
      unit[cid][i][j].emb[0].a = unit[cid][i][j+1].emb[0].a;
      unit[cid][i][j].emb[0].d = unit[cid][i][j+1].emb[0].d;
    }
  }

  for (j=0; j<EMAX_WIDTH; j++) {
    if (unit[cid][i][j].v2) {
      switch (unit[cid][i][j].etb[0].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[0].d = unit[cid][i][j].ex1.t1; break;
      default:unit[cid][i][j].etb[0].d = 0xffffffff;             break;
      }
      switch (unit[cid][i][j].etb[1].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[1].d = unit[cid][i][j].ex1.t2; break;
      default:unit[cid][i][j].etb[1].d = 0xffffffff;             break;
      }
      switch (unit[cid][i][j].etb[2].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[2].d = unit[cid][i][j].ex1.t3; break;
      default:unit[cid][i][j].etb[2].d = 0xffffffff;             break;
      }
      switch (unit[cid][i][j].etb[3].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[3].d = unit[cid][i][j].eag.t1; break;
      default:unit[cid][i][j].etb[3].d = 0xffffffff;             break;
      }
      switch (unit[cid][i][j].etb[4].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[4].d = unit[cid][i][j].eag.t2; break;
      default:unit[cid][i][j].etb[4].d = 0xffffffff;             break;
      }
      switch (unit[cid][i][j].etb[5].sel_r) { /* 0:off 1:t[1-3] */
      case 0:                                                    break;
      case 1: unit[cid][i][j].etb[5].d = unit[cid][i][j].eag.t3; break;
      default:unit[cid][i][j].etb[5].d = 0xffffffff;             break;
      }
    }
  }
  for (k=0; k<EXT_TMP_BUS_NUM; k++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (j>0 && unit[cid][i][j-1].etb[k].dir_r==1) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].etb[k].d = unit[cid][i][j-1].etb[k].d;
    }
    for (j=EMAX_WIDTH-1; j>=0; j--) {
      if (j<EMAX_WIDTH-1 && unit[cid][i][j].etb[k].dir_r==2) /* 0:off 1:to-left 2:to-right 3:inhibited */
        unit[cid][i][j].etb[k].d = unit[cid][i][j+1].etb[k].d;
    }
  }
a685 43
  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax5[cid].unit_edb_cmd) {
  default:
    return (0);
  case 5:
    break;
  }

  if (unit[cid][i][j].v1 && ((emax5[cid].unit1_exec & (1LL<<i)))) {
    /*************/
    /* SIML ALU1 */
    /*************/
    switch (unit[cid][i][j].cnd.bit0_r) { /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    case 0: bit0 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.c; break;
    case 1: bit0 = unit[cid][i][j].edc[0].d;                              break;
    case 2: bit0 = unit[cid][i][j].edc[1].d;                              break;
    case 3: bit0 = unit[cid][i][j].edc[2].d;                              break;
    }
    switch (unit[cid][i][j].cnd.bit1_r) { /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    case 0: bit1 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.c; break;
    case 1: bit1 = unit[cid][i][j].edc[0].d;                              break;
    case 2: bit1 = unit[cid][i][j].edc[1].d;                              break;
    case 3: bit1 = unit[cid][i][j].edc[2].d;                              break;
    }
    switch (unit[cid][i][j].cnd.bit2_r) { /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    case 0: bit2 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.c; break;
    case 1: bit2 = unit[cid][i][j].edc[0].d;                              break;
    case 2: bit2 = unit[cid][i][j].edc[1].d;                              break;
    case 3: bit2 = unit[cid][i][j].edc[2].d;                              break;
    }
    switch (unit[cid][i][j].cnd.bit3_r) { /* 4to1 selector 0:idc0 1:edc0 2:edc1 3:edc2 */
    case 0: bit3 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.c; break;
    case 1: bit3 = unit[cid][i][j].edc[0].d;                              break;
    case 2: bit3 = unit[cid][i][j].edc[1].d;                              break;
    case 3: bit3 = unit[cid][i][j].edc[2].d;                              break;
    }

    unit[cid][i][j].cnd.select = (bit3<<3)|(bit2<<2)|(bit1<<1)|(bit0);
    if (unit[cid][i][j].cnd.bit0_v | unit[cid][i][j].cnd.bit1_v | unit[cid][i][j].cnd.bit2_v | unit[cid][i][j].cnd.bit3_v)
      unit[cid][i][j].cnd.exec = (unit[cid][i][j].cnd.table>>unit[cid][i][j].cnd.select)&1;
    else
      unit[cid][i][j].cnd.exec = 1;
  }
a693 338
  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax5[cid].unit_edb_cmd) {
  case 2:
    if ((emax5[cid].unit_select_row & (1LL<<i)) && (emax5[cid].unit_select_col & (1<<j))) {
      emax5[cid].unit1_stop &= ~(1LL<<i);
    }
  default:
    return (0);
  case 5:
    break;
  }

  if (unit[cid][i][j].v1 && ((emax5[cid].unit1_exec & (1LL<<i)))) {
    for (k=0; k<INT_XBR_BUS_NUM; k++) {
      switch (unit[cid][i][j].ixb[k].sel_r) { /* 0:off 1:prev_ex2.p1 2:prev_ex2.p2 3:prev_ex2.p3 4:prev_mem.p1 5:prev_mem.p2 6:prev_mem.p3 8:prev_ex2.d 9:prev_mem.d */
      case 0:                                                                                      break;
      case 1: unit[cid][i][j].ixb[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.p1_r; break;
      case 2: unit[cid][i][j].ixb[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.p2_r; break;
      case 3: unit[cid][i][j].ixb[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.p3_r; break;
      case 4: unit[cid][i][j].ixb[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.p1_r; break;
      case 5: unit[cid][i][j].ixb[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.p2_r; break;
      case 6: unit[cid][i][j].ixb[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.p3_r; break;
      case 8: unit[cid][i][j].ixb[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.d;    break;
      case 9: unit[cid][i][j].ixb[k].d = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.d;    break;
      default:unit[cid][i][j].ixb[k].d = 0xffffffff;                                               break;
      }
    }

    switch (unit[cid][i][j].ex1.x1_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].ex1.t1 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.p1_r;    break;
    case 4: unit[cid][i][j].ex1.t1 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].ex1.t1 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].ex1.t1 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].ex1.t1 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].ex1.t1 = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].ex1.x2_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].ex1.t2 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.p2_r;    break;
    case 4: unit[cid][i][j].ex1.t2 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].ex1.t2 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].ex1.t2 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].ex1.t2 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].ex1.t2 = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].ex1.x3_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].ex1.t3 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.p3_r;    break;
    case 4: unit[cid][i][j].ex1.t3 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].ex1.t3 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].ex1.t3 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].ex1.t3 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].ex1.t3 = 0xffffffff;                                                  break;
    }

    /*************/
    /* SIML ALU1 */
    /*************/
    switch (unit[cid][i][j].ex1.s1_r) {
    case 0: s1 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.p1_r;                                         break;
    case 1: s1 = (!unit[cid][i][j].one_shot)?unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.p1_r:unit[cid][i][j].ex1.d; break;
    case 2: s1 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s1 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s1 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s1 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s1 = 0xffffffff;                                                                                       break;
    }
    switch (unit[cid][i][j].ex1.s2_r) {
    case 0: s2 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.p2_r;                                         break;
    case 2: s2 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s2 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s2 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s2 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s2 = 0xffffffff;                                                                                       break;
    }
    switch (unit[cid][i][j].ex1.s3_r) {
    case 0: s3 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.p3_r;                                         break;
    case 2: s3 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s3 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s3 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s3 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s3 = 0xffffffff;                                                                                       break;
    }
    switch (unit[cid][i][j].ex1.px1_r) {
    case 0: unit[cid][i][j].ex1.dx1 = 0xffffffff;                                                                  break;
    case 2: unit[cid][i][j].ex1.dx1 = s2;                                                                          break;
    default:unit[cid][i][j].ex1.dx1 = 0xffffffff;                                                                  break;
      /* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
    }
    switch (unit[cid][i][j].ex1.px2_r) {
    case 0: unit[cid][i][j].ex1.dx2 = 0xffffffff;                                                                  break;
    case 3: unit[cid][i][j].ex1.dx2 = s3;                                                                          break;
    default:unit[cid][i][j].ex1.dx2 = 0xffffffff;                                                                  break;
      /* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
    }

    switch (unit[cid][i][j].ex1.s1_fhl) {
    case 1: s1 = ((s1<<8) & 0x00ff0000) | ( s1      & 0x000000ff); break; /* SUFLO */
    case 2: s1 = ((s1>>8) & 0x00ff0000) | ((s1>>16) & 0x000000ff); break; /* SUFHI */
    }
    switch (unit[cid][i][j].ex1.s2_fhl) {
    case 1: s2 = ((s2<<8) & 0x00ff0000) | ( s2      & 0x000000ff); break; /* SUFLO */
    case 2: s2 = ((s2>>8) & 0x00ff0000) | ((s2>>16) & 0x000000ff); break; /* SUFHI */
    }
    switch (unit[cid][i][j].ex1.s3_fhl) {
    case 1: s3 = ((s3<<8) & 0x00ff0000) | ( s3      & 0x000000ff); break; /* SUFLO */
    case 2: s3 = ((s3>>8) & 0x00ff0000) | ((s3>>16) & 0x000000ff); break; /* SUFHI */
    }
    
    if (unit[cid][i][j].ex1.urZ_r) {
      switch (unit[cid][i][j].ex1.op_r) {
      case OP_NOP:
	d = s1;
	break;
      case OP_ADD3:
	d = s1 + s2 + s3;
	break;
      case OP_SUB3:
	d = s1 - s2 - s3;
	break;
      case OP_MAUH3:
#if 0
	t1 = ((int) s1     >>16)+((int) s2     >>16)+((int) s3     >>16);
	if ((int)t1 > (int)0x00007fff) t1 = 0x7fff;
	if ((int)t1 < (int)0xffff8000) t1 = 0x8000;
	t2 = ((int)(s1<<16)>>16)+((int)(s2<<16)>>16)+((int)(s3<<16)>>16);
	if ((int)t2 > (int)0x00007fff) t2 = 0x7fff;
	if ((int)t2 < (int)0xffff8000) t2 = 0x8000;
#else
	t1 = ( s1     >>16)+( s2     >>16)+( s3     >>16);
	if (t1 > 0x0000ffff) t1 = 0xffff;
	t2 = ((s1<<16)>>16)+((s2<<16)>>16)+((s3<<16)>>16);
	if (t2 > 0x0000ffff) t2 = 0xffff;
#endif
	d = (t1<<16)|(t2&0xffff);
	break;
      case OP_MSUH3:
#if 0
	t1 = ((int) s1     >>16)-((int) s2     >>16)-((int) s3     >>16);
	if ((int)t1 > (int)0x00007fff) t1 = 0x7fff;
	if ((int)t1 < (int)0xffff8000) t1 = 0x8000;
	t2 = ((int)(s1<<16)>>16)-((int)(s2<<16)>>16)-((int)(s3<<16)>>16);
	if ((int)t2 > (int)0x00007fff) t2 = 0x7fff;
	if ((int)t2 < (int)0xffff8000) t2 = 0x8000;
#else
	t1 = ( s1     >>16)-( s2     >>16)-( s3     >>16);
	if (t1 > 0x0000ffff) t1 = 0x0000;
	t2 = ((s1<<16)>>16)-((s2<<16)>>16)-((s3<<16)>>16);
	if (t2 > 0x0000ffff) t2 = 0x0000;
#endif
	d = (t1<<16)|(t2&0xffff);
	break;
      case OP_MMRG3:
	d = ((s1&0xff)<<24) | ((s2&0xff)<<16) | ((s3&0xff)<<8);
	break;
      case OP_MINL3:
	if ((s3>>16)<(s3&0xffff)) d = (s1&0xffff0000)|(s3>>16);
	else                      d = (s2&0xffff0000)|(s3&0xffff);
	break;
      case OP_MMID3:
	t1 = ((s1&0xff000000)<(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	   | ((s1&0x00ff0000)<(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	   | ((s1&0x0000ff00)<(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	   | ((s1&0x000000ff)<(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	t2 = ((s1&0xff000000)>(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	   | ((s1&0x00ff0000)>(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	   | ((s1&0x0000ff00)>(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	   | ((s1&0x000000ff)>(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	d  = ((s3&0xff000000)<(t1&0xff000000)?(t1&0xff000000):((s3&0xff000000)<(t2&0xff000000)?(s3&0xff000000):(t2&0xff000000)))
	   | ((s3&0x00ff0000)<(t1&0x00ff0000)?(t1&0x00ff0000):((s3&0x00ff0000)<(t2&0x00ff0000)?(s3&0x00ff0000):(t2&0x00ff0000)))
	   | ((s3&0x0000ff00)<(t1&0x0000ff00)?(t1&0x0000ff00):((s3&0x0000ff00)<(t2&0x0000ff00)?(s3&0x0000ff00):(t2&0x0000ff00)))
	   | ((s3&0x000000ff)<(t1&0x000000ff)?(t1&0x000000ff):((s3&0x000000ff)<(t2&0x000000ff)?(s3&0x000000ff):(t2&0x000000ff)));
	break;
      case OP_MMAX3:
	t1 = ((s1&0xff000000)>(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	   | ((s1&0x00ff0000)>(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	   | ((s1&0x0000ff00)>(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	   | ((s1&0x000000ff)>(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	d  = ((t1&0xff000000)>(s3&0xff000000)?(t1&0xff000000):(s3&0xff000000))
	   | ((t1&0x00ff0000)>(s3&0x00ff0000)?(t1&0x00ff0000):(s3&0x00ff0000))
	   | ((t1&0x0000ff00)>(s3&0x0000ff00)?(t1&0x0000ff00):(s3&0x0000ff00))
	   | ((t1&0x000000ff)>(s3&0x000000ff)?(t1&0x000000ff):(s3&0x000000ff));
	break;
      case OP_MMIN3:
	t1 = ((s1&0xff000000)<(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	   | ((s1&0x00ff0000)<(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	   | ((s1&0x0000ff00)<(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	   | ((s1&0x000000ff)<(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	d  = ((t1&0xff000000)<(s3&0xff000000)?(t1&0xff000000):(s3&0xff000000))
	   | ((t1&0x00ff0000)<(s3&0x00ff0000)?(t1&0x00ff0000):(s3&0x00ff0000))
	   | ((t1&0x0000ff00)<(s3&0x0000ff00)?(t1&0x0000ff00):(s3&0x0000ff00))
	   | ((t1&0x000000ff)<(s3&0x000000ff)?(t1&0x000000ff):(s3&0x000000ff));
	break;
      case OP_FMA3:
	*(float*)&d  = *(float*)&s1 * *(float*)&s2 + *(float*)&s3;
	/* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
	break;
      default:
	break;
      }
    }
    else {
      switch (unit[cid][i][j].ex1.op_r) {
      case OP_NOP:
	d = s1;
	break;
      case OP_LDB:
      case OP_LDUB:
      case OP_LDH:
      case OP_LDUH:
      case OP_LD:
	d = s1 + s2;
	break;
      case OP_WHILE:
	d = s1 + s2;
	n = d>>31;
	z = d==0;
	v = (s1>>31&&s2>>31&&!(d>>31)) || (!(s1>>31)&&!(s2>>31)&&d>>31);
	c = (s1>>31&&s2>>31) || (!(d>>31)&&(s1>>31||s2>>31));
	if (z) emax5[cid].unit1_stop |= (1LL<<i);
	break;
      case OP_ADD:
	d = s1 + s2;
	n = d>>31;
	z = d==0;
	v = (s1>>31&&s2>>31&&!(d>>31)) || (!(s1>>31)&&!(s2>>31)&&d>>31);
	c = (s1>>31&&s2>>31) || (!(d>>31)&&(s1>>31||s2>>31));
	break;
      case OP_SUB:
	d = s1 - s2;
	n = d>>31;
	z = d==0;
	v = (s1>>31&&!(s2>>31)&&!(d>>31)) || (!(s1>>31)&&s2>>31&&d>>31);
	c = (!(s1>>31)&&s2>>31) || (d>>31&&(!(s1>>31)||s2>>31)); /* FRV */
	break;
      case OP_MAUH:
#if 0
	t1 = ((int) s1     >>16)+((int) s2     >>16);
	if ((int)t1 > (int)0x00007fff) t1 = 0x7fff;
	if ((int)t1 < (int)0xffff8000) t1 = 0x8000;
	t2 = ((int)(s1<<16)>>16)+((int)(s2<<16)>>16);
	if ((int)t2 > (int)0x00007fff) t2 = 0x7fff;
	if ((int)t2 < (int)0xffff8000) t2 = 0x8000;
#else
	t1 = ( s1     >>16)+( s2     >>16);
	if (t1 > 0x0000ffff) t1 = 0xffff;
	t2 = ((s1<<16)>>16)+((s2<<16)>>16);
	if (t2 > 0x0000ffff) t2 = 0xffff;
#endif
	d = (t1<<16)|(t2&0xffff);
	break;
      case OP_MSUH:
#if 0
	t1 = ((int) s1     >>16)-((int) s2     >>16);
	if ((int)t1 > (int)0x00007fff) t1 = 0x7fff;
	if ((int)t1 < (int)0xffff8000) t1 = 0x8000;
	t2 = ((int)(s1<<16)>>16)-((int)(s2<<16)>>16);
	if ((int)t2 > (int)0x00007fff) t2 = 0x7fff;
	if ((int)t2 < (int)0xffff8000) t2 = 0x8000;
#else
	t1 = ( s1     >>16)-( s2     >>16);
	if (t1 > 0x0000ffff) t1 = 0x0000;
	t2 = ((s1<<16)>>16)-((s2<<16)>>16);
	if (t2 > 0x0000ffff) t2 = 0x0000;
#endif
	d = (t1<<16)|(t2&0xffff);
	break;
      case OP_MLUH: /* MUL (8bit*9bit)[2] -> 16bit[2] */
	t1 = (( s1     >>16)&0x3ff)*(s2&0x1ff);
	if (t1 > 0x0000ffff) t1 = 0xffff;
	t2 = (((s1<<16)>>16)&0x3ff)*(s2&0x1ff);
	if (t2 > 0x0000ffff) t2 = 0xffff;
	d = (t1<<16)|t2;
	break;
      case OP_MSAD: /* SAD abs(8bit-8bit)[4] -> 16bit[2] */
#define ad(a,b) ((a)>(b)?((a)-(b)):((b)-(a)))
	d = ((ad(s1&0xff000000,s2&0xff000000)>>8)+ad(s1&0xff0000,s2&0xff0000))|((ad(s1&0xff00,s2&0xff00)>>8)+ad(s1&0xff,s2&0xff));
	break;
      case OP_MINL:
	if ((s1&0xffff)<(s2&0xffff)) d = s1;
	else                         d = s2;
	break;
      case OP_MH2BW:
	d = (((s1>>16   )<0x100 ? (s1>>16   )&0xff : 255)<<24)
	  | (((s1&0xffff)<0x100 ? (s1&0xffff)&0xff : 255)<<16)
	  | (((s2>>16   )<0x100 ? (s2>>16   )&0xff : 255)<< 8)
	  | (((s2&0xffff)<0x100 ? (s2&0xffff)&0xff : 255)    );
	break;
      case OP_MCAS:
	d = (s1<s2)?0:0xff;
	break;
      case OP_MMAX:
	d = ((s1&0xff000000)>(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	  | ((s1&0x00ff0000)>(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	  | ((s1&0x0000ff00)>(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	  | ((s1&0x000000ff)>(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	break;
      case OP_MMIN:
	d = ((s1&0xff000000)<(s2&0xff000000)?(s1&0xff000000):(s2&0xff000000))
	  | ((s1&0x00ff0000)<(s2&0x00ff0000)?(s1&0x00ff0000):(s2&0x00ff0000))
	  | ((s1&0x0000ff00)<(s2&0x0000ff00)?(s1&0x0000ff00):(s2&0x0000ff00))
	  | ((s1&0x000000ff)<(s2&0x000000ff)?(s1&0x000000ff):(s2&0x000000ff));
	break;
      case OP_FMUL:
	*(float*)&d  = *(float*)&s1 * *(float*)&s2;
	/* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
	break;
      case OP_FADD:
	*(float*)&d  = *(float*)&s1 + *(float*)&s2;
	/* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
	break;
      case OP_CMPEQ:
	z = s1 == s2;
	break;
      case OP_CMPNE:
	z = s1 != s2;
	break;
      case OP_CMPLT:
	z = s1 < s2;
	break;
      case OP_CMPLE:
	z = s1 <= s2;
	break;
      case OP_CMPGT:
	z = s1 > s2;
	break;
      case OP_CMPGE:
	z = s1 >= s2;
	break;
      case OP_CMOV:
	d = unit[cid][i][j].cnd.exec ? s1 : s2;
	break;
      default:
	break;
      }
    }

    unit[cid][i][j].ex1.d = d;
    unit[cid][i][j].ex1.c = z; /* z is only used by conditional insn. */
  }
a700 136
  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax5[cid].unit_edb_cmd) {
  case 2:
    if ((emax5[cid].unit_select_row & (1LL<<i)) && (emax5[cid].unit_select_col & (1<<j))) {
      emax5[cid].unit2_stop &= ~(1LL<<i);
      switch (unit[cid][i][j].edb[0].d) {
      case 0: /* ex2v_p1_r */
	unit[cid][i][j].ex2.p1_r = unit[cid][i][j].edb[1].d;
	break;
      case 1: /* ex2v_p2_r */
	unit[cid][i][j].ex2.p2_r = unit[cid][i][j].edb[1].d;
	break;
      }
    }
  default:
    return (0);
  case 5:
    break;
  }
	
  if (unit[cid][i][j].v2 && (emax5[cid].unit2_exec & (1LL<<i))) {
    switch (unit[cid][i][j].ex2.x1_r) { /* ex2-output-selector 0:fixed_for_constant 1:t1_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].ex2.p1_r = unit[cid][i][j].ex1.t1;                                      break;
    case 2: unit[cid][i][j].ex2.p1_r = unit[cid][i][j].etb[0].d;                                    break;
    default:unit[cid][i][j].ex2.p1_r = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].ex2.x2_r) { /* ex2-output-selector 0:fixed_for_constant 1:t1_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].ex2.p2_r = unit[cid][i][j].ex1.t2;                                      break;
    case 2: unit[cid][i][j].ex2.p2_r = unit[cid][i][j].etb[1].d;                                    break;
    default:unit[cid][i][j].ex2.p2_r = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].ex2.x3_r) { /* ex2-output-selector 0:fixed_for_constant 1:t1_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].ex2.p3_r = unit[cid][i][j].ex1.t3;                                      break;
    case 2: unit[cid][i][j].ex2.p3_r = unit[cid][i][j].etb[2].d;                                    break;
    default:unit[cid][i][j].ex2.p3_r = 0xffffffff;                                                  break;
    }
  }
    
  if (unit[cid][i][j].v2 && (emax5[cid].unit2_exec & (1LL<<i))) {
    /*************/
    /* SIML ALU2 */
    /*************/
    switch (unit[cid][i][j].ex2.s1_r) {
    case 0: s1 = unit[cid][i][j].ex1.d;                                         break;
    default:s1 = 0xffffffff;                                                    break;
      /* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
    }
    switch (unit[cid][i][j].ex2.s2_r) {
    case 4: s2 = unit[cid][i][j].ex1.dx1;                                       break;
    case 5: s2 = unit[cid][i][j].ex1.dx2;                                       break;
    case 6: s2 = (int)(unit[cid][i][j].ex2.simmS_r<<19)>>19;                    break;
    default:s2 = 0xffffffff;                                                    break;
      /* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
    }
    switch (unit[cid][i][j].ex2.s3_r) {
    case 5: s3 = unit[cid][i][j].ex1.dx2;                                       break;
    case 7: s3 = unit[cid][i][j].ex2.immT_r;                                    break;
    default:s3 = 0xffffffff;                                                    break;
      /* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
    }
    
    if (unit[cid][i][j].ex1.op_r && unit[cid][i][j].ex1.op_r<=OP_LD) {
      d1 = ex2_fifo_access(cid, i, j, MEM_RD);
      switch (unit[cid][i][j].ex1.op_r) {
      case OP_LDB:    d2 =  (int)(char)((d1 >> ((unit[cid][i][j].ex1.d&3)*8))&  0xff); break;
      case OP_LDUB:   d2 =             ((d1 >> ((unit[cid][i][j].ex1.d&3)*8))&  0xff); break;
      case OP_LDH:    d2 = (int)(short)((d1 >> ((unit[cid][i][j].ex1.d&3)*8))&0xffff); break;
      case OP_LDUH:   d2 =             ((d1 >> ((unit[cid][i][j].ex1.d&3)*8))&0xffff); break;
      case OP_LD:     d2 =               d1;                                           break;
      default:                                                                         break;
      }
    }
    else {
      switch (unit[cid][i][j].ex2.op_r) {
      case OP_NOP:
	d1 = s1;
	c1 = unit[cid][i][j].ex1.c;
	/* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
	break;
      case OP_AND:
	d1 = s1 & s2;
	break;
      case OP_OR:
	d1 = s1 | s2;
	break;
      case OP_XOR:
	d1 = s1 ^ s2;
	break;
      case OP_SUMH: /* SUMH (H16bit+L16bit) -> H16bit */
	d1 = (s1&0xffff0000)+(s1<<16);
	break;
      case OP_SUML: /* SUML (H16bit+L16bit) -> L16bit */
	d1 = ((s1>>16)+(s1&0xffff))&0xffff;
	break;
      default:
	break;
      }
      
      switch (unit[cid][i][j].ex2.sft_r) {
      case OP_NOP:
	d2 = d1;
	c2 = c1;
	/* Verilogでは，FMUL/FADD/FMA3の場合,上記設定を無視してdx1/dx2をパイプラインレジスタとして使用 */
	break;
      case OP_SLL:
	d2 = d1 << s3;
	break;
      case OP_SRL:
	d2 = d1 >> s3;
	break;
      case OP_MSRL:
	d2 = ((d1 >> s3)&0xffff0000)|((d1&0x0000ffff) >> s3);
	break;
      case OP_SRA31:
	d2 = (int)d1 >> s3;
	break;
      case OP_SRA23:
	d2 = (int)(d1<<8)>>(8+s3);
	break;
      case OP_SRA15:
	d2 = (int)(d1<<16)>>(16+s3);
	break;
      case OP_SRA07:
	d2 = (int)(d1<<24)>>(24+s3);
	break;
      default:
	break;
      }
    }

    unit[cid][i][j].ex2.d = d2;
    unit[cid][i][j].ex2.c = c2;
  }
a706 196
  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax5[cid].unit_edb_cmd) {
  case 1:
    if ((emax5[cid].unit_select_row & (1LL<<i)) && (emax5[cid].unit_select_col & (1<<j))) {
      switch (unit[cid][i][j].edb[0].d) {
      case 0: /* cword0 */
	unit[cid][i][j].ixb[0].sel_r = (unit[cid][i][j].edb[1].d >> 0) & 0xf; /* c->ixbc0_sel_r; */
	unit[cid][i][j].ixb[1].sel_r = (unit[cid][i][j].edb[1].d >> 4) & 0xf; /* c->ixbc1_sel_r; */
	unit[cid][i][j].ixb[2].sel_r = (unit[cid][i][j].edb[1].d >> 8) & 0xf; /* c->ixbc2_sel_r; */
	unit[cid][i][j].ixb[3].sel_r = (unit[cid][i][j].edb[1].d >>12) & 0xf; /* c->ixbc3_sel_r; */
	unit[cid][i][j].edb[0].sel_r = (unit[cid][i][j].edb[1].d >>16) & 0x3; /* c->edbc0_sel_r; */
	unit[cid][i][j].edb[0].dir_r = (unit[cid][i][j].edb[1].d >>18) & 0x3; /* c->edbc0_dir_r; */
	unit[cid][i][j].edb[1].sel_r = (unit[cid][i][j].edb[1].d >>20) & 0x3; /* c->edbc1_sel_r; */
	unit[cid][i][j].edb[1].dir_r = (unit[cid][i][j].edb[1].d >>22) & 0x3; /* c->edbc1_dir_r; */
	unit[cid][i][j].edc[0].sel_r = (unit[cid][i][j].edb[1].d >>24) & 0x1; /* c->edcc0_sel_r; */
	unit[cid][i][j].edc[0].dir_r = (unit[cid][i][j].edb[1].d >>25) & 0x3; /* c->edcc0_dir_r; */
	unit[cid][i][j].edc[1].sel_r = (unit[cid][i][j].edb[1].d >>27) & 0x1; /* c->edcc1_sel_r; */
	unit[cid][i][j].edc[1].dir_r = (unit[cid][i][j].edb[1].d >>28) & 0x3; /* c->edcc1_dir_r; */
	break;
      case 1: /* cword1 */
	unit[cid][i][j].edc[2].sel_r = (unit[cid][i][j].edb[1].d >> 0) & 0x1; /* c->edcc2_sel_r; */
	unit[cid][i][j].edc[2].dir_r = (unit[cid][i][j].edb[1].d >> 1) & 0x3; /* c->edcc2_dir_r; */
	unit[cid][i][j].cnd.bit0_v   = (unit[cid][i][j].edb[1].d >> 3) & 0x1; /* c->cndc_bit0_r; */
	unit[cid][i][j].cnd.bit0_r   = (unit[cid][i][j].edb[1].d >> 4) & 0x3; /* c->cndc_bit0_r; */
	unit[cid][i][j].cnd.bit1_v   = (unit[cid][i][j].edb[1].d >> 6) & 0x1; /* c->cndc_bit1_r; */
	unit[cid][i][j].cnd.bit1_r   = (unit[cid][i][j].edb[1].d >> 7) & 0x3; /* c->cndc_bit1_r; */
	unit[cid][i][j].cnd.bit2_v   = (unit[cid][i][j].edb[1].d >> 9) & 0x1; /* c->cndc_bit2_r; */
	unit[cid][i][j].cnd.bit2_r   = (unit[cid][i][j].edb[1].d >>10) & 0x3; /* c->cndc_bit2_r; */
	unit[cid][i][j].cnd.bit3_v   = (unit[cid][i][j].edb[1].d >>12) & 0x1; /* c->cndc_bit3_r; */
	unit[cid][i][j].cnd.bit3_r   = (unit[cid][i][j].edb[1].d >>13) & 0x3; /* c->cndc_bit3_r; */
	unit[cid][i][j].cnd.table    = (unit[cid][i][j].edb[1].d >>15) & 0xffff; /* c->cndc_table; */
	break;
      case 2: /* cword2 */
	unit[cid][i][j].ex1.s1_r     = (unit[cid][i][j].edb[1].d >> 0) & 0x7; /* c->ex1c_s1_r; */
	unit[cid][i][j].ex1.s1_fhl   = (unit[cid][i][j].edb[1].d >> 3) & 0x3; /* c->ex1c_s1_fhl; */
	unit[cid][i][j].ex1.s2_r     = (unit[cid][i][j].edb[1].d >> 5) & 0x7; /* c->ex1c_s2_r; */
	unit[cid][i][j].ex1.s2_fhl   = (unit[cid][i][j].edb[1].d >> 8) & 0x3; /* c->ex1c_s2_fhl; */
	unit[cid][i][j].ex1.s3_r     = (unit[cid][i][j].edb[1].d >>10) & 0x7; /* c->ex1c_s3_r; */
	unit[cid][i][j].ex1.s3_fhl   = (unit[cid][i][j].edb[1].d >>13) & 0x3; /* c->ex1c_s3_fhl; */
	unit[cid][i][j].ex1.urZ_r    = (unit[cid][i][j].edb[1].d >>15) & 0x1; /* c->ex1c_urZ_r; */
	unit[cid][i][j].ex1.op_r     = (unit[cid][i][j].edb[1].d >>16) & 0x3f;/* c->ex1c_op_r; */
	unit[cid][i][j].ex1.px1_r    = (unit[cid][i][j].edb[1].d >>22) & 0x3; /* c->ex1c_px1_r; */
	unit[cid][i][j].ex1.px2_r    = (unit[cid][i][j].edb[1].d >>24) & 0x3; /* c->ex1c_px2_r; */
	unit[cid][i][j].ex1.x1_r     = (unit[cid][i][j].edb[1].d >>26) & 0x7; /* c->ex1c_x1_r; */
	unit[cid][i][j].ex1.x2_r     = (unit[cid][i][j].edb[1].d >>29) & 0x7; /* c->ex1c_x2_r; */
	break;
      case 3: /* cword3 */
	unit[cid][i][j].ex1.x3_r     = (unit[cid][i][j].edb[1].d >> 0) & 0x7; /* c->ex1c_x3_r; */
	unit[cid][i][j].ex2.simmS_r  = (unit[cid][i][j].edb[1].d >> 3) & 0x1fff; /* c->ex2c_simmS_r; */
	unit[cid][i][j].ex2.immT_r   = (unit[cid][i][j].edb[1].d >>16) & 0x1f; /* c->ex2c_immT_r; */
	unit[cid][i][j].ex2.s1_r     = (unit[cid][i][j].edb[1].d >>21) & 0x7; /* c->ex2c_s1_r; */
	unit[cid][i][j].ex2.s2_r     = (unit[cid][i][j].edb[1].d >>24) & 0x7; /* c->ex2c_s2_r; */
	unit[cid][i][j].ex2.s3_r     = (unit[cid][i][j].edb[1].d >>27) & 0x7; /* c->ex2c_s3_r; */
	break;
      case 4: /* cword4 */
	unit[cid][i][j].ex2.op_r     = (unit[cid][i][j].edb[1].d >> 0) & 0x7; /* c->ex2c_op_r; */
	unit[cid][i][j].ex2.sft_r    = (unit[cid][i][j].edb[1].d >> 3) & 0x7; /* c->ex2c_sft_r; */
	unit[cid][i][j].ex2.dsel_r   = (unit[cid][i][j].edb[1].d >> 6) & 0x1; /* c->ex2c_dsel_r; */
	unit[cid][i][j].ex2.x1_r     = (unit[cid][i][j].edb[1].d >> 7) & 0x3; /* c->ex2c_x1_r; */
	unit[cid][i][j].ex2.x2_r     = (unit[cid][i][j].edb[1].d >> 9) & 0x3; /* c->ex2c_x2_r; */
	unit[cid][i][j].ex2.x3_r     = (unit[cid][i][j].edb[1].d >>11) & 0x3; /* c->ex2c_x3_r; */
	unit[cid][i][j].eag.s1_r     = (unit[cid][i][j].edb[1].d >>13) & 0x7; /* c->eagc_s1_r; */
	unit[cid][i][j].eag.s2_r     = (unit[cid][i][j].edb[1].d >>16) & 0x7; /* c->eagc_s2_r; */
	unit[cid][i][j].eag.s2_suffix= (unit[cid][i][j].edb[1].d >>19) & 0x7; /* c->eagc_s2_suffix; */
	unit[cid][i][j].eag.s3_r     = (unit[cid][i][j].edb[1].d >>22) & 0x7; /* c->eagc_s3_r; */
	break;
      case 5: /* cword5 */
	unit[cid][i][j].eag.op_r     = (unit[cid][i][j].edb[1].d >> 0) & 0x3ff; /* c->eagc_op_r; */
	unit[cid][i][j].eag.x1_r     = (unit[cid][i][j].edb[1].d >>10) & 0x7; /* c->eagc_x1_r; */
	unit[cid][i][j].eag.x2_r     = (unit[cid][i][j].edb[1].d >>13) & 0x7; /* c->eagc_x2_r; */
	unit[cid][i][j].eag.x3_r     = (unit[cid][i][j].edb[1].d >>16) & 0x7; /* c->eagc_x3_r; */
	unit[cid][i][j].lmm.ssel_r   = (unit[cid][i][j].edb[1].d >>19) & 0x1; /* c->lmmc_ssel_r; */
	unit[cid][i][j].lmm.dsel_r   = (unit[cid][i][j].edb[1].d >>20) & 0x1; /* c->lmmc_dsel_r; */
	unit[cid][i][j].lmm.x1_r     = (unit[cid][i][j].edb[1].d >>21) & 0x3; /* c->lmmc_x1_r; */
	unit[cid][i][j].lmm.x2_r     = (unit[cid][i][j].edb[1].d >>23) & 0x3; /* c->lmmc_x2_r; */
	unit[cid][i][j].lmm.x3_r     = (unit[cid][i][j].edb[1].d >>25) & 0x3; /* c->lmmc_x3_r; */
	unit[cid][i][j].emb[0].sel_r = (unit[cid][i][j].edb[1].d >>27) & 0x1; /* c->embc0_sel_r; */
	unit[cid][i][j].emb[0].dir_r = (unit[cid][i][j].edb[1].d >>28) & 0x3; /* c->embc0_dir_r; */
	break;
      case 6: /* cword6 */
	unit[cid][i][j].etb[0].sel_r = (unit[cid][i][j].edb[1].d >> 0) & 0x1; /* c->etbc0_sel_r; */
	unit[cid][i][j].etb[0].dir_r = (unit[cid][i][j].edb[1].d >> 1) & 0x3; /* c->etbc0_dir_r; */
	unit[cid][i][j].etb[1].sel_r = (unit[cid][i][j].edb[1].d >> 3) & 0x1; /* c->etbc1_sel_r; */
	unit[cid][i][j].etb[1].dir_r = (unit[cid][i][j].edb[1].d >> 4) & 0x3; /* c->etbc1_dir_r; */
	unit[cid][i][j].etb[2].sel_r = (unit[cid][i][j].edb[1].d >> 6) & 0x1; /* c->etbc2_sel_r; */
	unit[cid][i][j].etb[2].dir_r = (unit[cid][i][j].edb[1].d >> 7) & 0x3; /* c->etbc2_dir_r; */
	unit[cid][i][j].etb[3].sel_r = (unit[cid][i][j].edb[1].d >> 9) & 0x1; /* c->etbc3_sel_r; */
	unit[cid][i][j].etb[3].dir_r = (unit[cid][i][j].edb[1].d >>10) & 0x3; /* c->etbc3_dir_r; */
	unit[cid][i][j].etb[4].sel_r = (unit[cid][i][j].edb[1].d >>12) & 0x1; /* c->etbc4_sel_r; */
	unit[cid][i][j].etb[4].dir_r = (unit[cid][i][j].edb[1].d >>13) & 0x3; /* c->etbc4_dir_r; */
	unit[cid][i][j].etb[5].sel_r = (unit[cid][i][j].edb[1].d >>15) & 0x1; /* c->etbc5_sel_r; */
	unit[cid][i][j].etb[5].dir_r = (unit[cid][i][j].edb[1].d >>16) & 0x3; /* c->etbc5_dir_r; */
	break;
      case 7: /* cword7 */
	unit[cid][i][j].v1           = (unit[cid][i][j].edb[1].d >> 0) & 0x1; /* c->v1; */
	unit[cid][i][j].v2           = (unit[cid][i][j].edb[1].d >> 1) & 0x1; /* c->v2; */
      }
    }
    return (0);
  case 2:
    unit[cid][i][j].one_shot = 0;
  default:
    return (0);
  case 4:
    if ((emax5[cid].unit_select_row & (1LL<<i)) && (emax5[cid].unit_select_col & (1<<j))) {
      unit[cid][i][j].lmm.a = unit[cid][i][j].edb[0].d;
      unit[cid][i][j].lmm.s = unit[cid][i][j].edb[1].d;
    }
    return (0);
  case 6:
    if ((emax5[cid].unit_select_row & (1LL<<i)) && (emax5[cid].unit_select_col & (1<<j))) {
      unit[cid][i][j].lmm.a = unit[cid][i][j].edb[0].d;
    }
    return (0);
  case 5:
    break;
  }

  if (unit[cid][i][j].v1 && ((emax5[cid].unit1_exec & (1LL<<i)))) {
    switch (unit[cid][i][j].eag.x1_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].eag.t1 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.p1_r;    break;
    case 4: unit[cid][i][j].eag.t1 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].eag.t1 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].eag.t1 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].eag.t1 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].eag.t1 = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].eag.x2_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].eag.t2 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.p2_r;    break;
    case 4: unit[cid][i][j].eag.t2 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].eag.t2 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].eag.t2 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].eag.t2 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].eag.t2 = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].eag.x3_r) { /* 5to1 selector 0:prev_p[p] 4:ixb0 5:ixb1 6:ixb2 7:ixb3 */
    case 0: unit[cid][i][j].eag.t3 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.p3_r;    break;
    case 4: unit[cid][i][j].eag.t3 = unit[cid][i][j].ixb[0].d;                                    break;
    case 5: unit[cid][i][j].eag.t3 = unit[cid][i][j].ixb[1].d;                                    break;
    case 6: unit[cid][i][j].eag.t3 = unit[cid][i][j].ixb[2].d;                                    break;
    case 7: unit[cid][i][j].eag.t3 = unit[cid][i][j].ixb[3].d;                                    break;
    default:unit[cid][i][j].eag.t3 = 0xffffffff;                                                  break;
    }
    
    /*************/
    /* SIML EAG */
    /*************/
    switch (unit[cid][i][j].eag.s1_r) {
    case 0: s1 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.p1_r;                                         break;
    case 1: s1 = (!unit[cid][i][j].one_shot)?unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.p1_r:unit[cid][i][j].eag.d; break;
    case 2: s1 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s1 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s1 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s1 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s1 = 0xffffffff;                                                                                       break;
    }
    switch (unit[cid][i][j].eag.s2_r) {
    case 0: s2 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.p2_r;                                         break;
    case 2: s2 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s2 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s2 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s2 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s2 = 0xffffffff;                                                                                       break;
    }
    switch (unit[cid][i][j].eag.s3_r) {
    case 0: s3 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.p3_r;                                         break;
    case 2: s3 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s3 = unit[cid][(i+(EMAX_DEPTH-1))&(EMAX_DEPTH-1)][j].lmm.d;                                            break;
    case 4: s3 = unit[cid][i][j].edb[0].d;                                                                         break;
    case 5: s3 = unit[cid][i][j].edb[1].d;                                                                         break;
    default:s3 = 0xffffffff;                                                                                       break;
    }
    
    switch (unit[cid][i][j].eag.s2_suffix) {
    case 1: s2 =  s2      & 0xffff; break;
    case 2: s2 =  s2 >> 16;         break;
    case 4: s2 =  s2        & 0xff; break;
    case 5: s2 = (s2 >>  8) & 0xff; break;
    case 6: s2 = (s2 >> 16) & 0xff; break;
    case 7: s2 = (s2 >> 24) & 0xff; break;
    }
    
    unit[cid][i][j].eag.d = s1 + s2;
    
    /*********************/
    /* SIML input of LMM */
    /*********************/
    switch (unit[cid][i][j].lmm.ssel_r) {
    case 0: unit[cid][i][j].lmm.s = s3;                    break;
    case 1: unit[cid][i][j].lmm.s = unit[cid][i][j].ex1.d; break; /* in real HDL, connect to the output-wire (not reg-d) of ex1 */
    default:unit[cid][i][j].lmm.s = 0xffffffff;            break;
    }
    unit[cid][i][j].lmm.a = unit[cid][i][j].eag.d; /* in real HDL, connect to the output-wire (not reg-d) of eag */
    
    unit[cid][i][j].one_shot = 1; /* for self_loop_control */
  }
a712 222
  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax5[cid].unit_edb_cmd) {
  case 2:
    if ((emax5[cid].unit_select_row & (1LL<<i)) && (emax5[cid].unit_select_col & (1<<j))) {
      switch (unit[cid][i][j].edb[0].d) {
      case 2: /* lmmv_p1_r */
	unit[cid][i][j].lmm.p1_r = unit[cid][i][j].edb[1].d;
	break;
      case 3: /* lmmv_p2_r */
	unit[cid][i][j].lmm.p2_r = unit[cid][i][j].edb[1].d;
	break;
      }
    }
    break;
  }

  /* 0:idle, 1:conf, 2:regv, 3:memi, 4:lmm_load, 5:exec, 6:lmm_drain */
  switch (emax5[cid].unit_edb_cmd_d1) {
  default:
    return (0);
  case 5:
    break;
  }

  if (unit[cid][i][j].v2 && (emax5[cid].unit2_exec & (1LL<<i))) {
    switch (unit[cid][i][j].lmm.x1_r) { /* mem-output-selector 0:fixed_for_constant 1:t1_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].lmm.p1_r = unit[cid][i][j].eag.t1;                                      break;
    case 2: unit[cid][i][j].lmm.p1_r = unit[cid][i][j].etb[3].d;                                    break;
    default:unit[cid][i][j].lmm.p1_r = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].lmm.x2_r) { /* mem-output-selector 0:fixed_for_constant 1:t2_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].lmm.p2_r = unit[cid][i][j].eag.t2;                                      break;
    case 2: unit[cid][i][j].lmm.p2_r = unit[cid][i][j].etb[4].d;                                    break;
    default:unit[cid][i][j].lmm.p2_r = 0xffffffff;                                                  break;
    }
    switch (unit[cid][i][j].lmm.x3_r) { /* mem-output-selector 0:fixed_for_constant 1:t3_direct 2:from etb[] */
    case 0:                                                                                         break;
    case 1: unit[cid][i][j].lmm.p3_r = unit[cid][i][j].eag.t3;                                      break;
    case 2: unit[cid][i][j].lmm.p3_r = unit[cid][i][j].etb[5].d;                                    break;
    default:unit[cid][i][j].lmm.p3_r = 0xffffffff;                                                  break;
    }
  }

  if (unit[cid][i][j].cnd.exec && unit[cid][i][j].v2 && (emax5[cid].unit2_exec & (1LL<<i))) {
    /*************/
    /* SIML LMM */
    /*************/
    switch (emax5[cid].memi_new[i].mctr0[j].v) {
      /*  0:nop,  1:LMR,  2:LMW,  3:LMX, *4:LMP,  5:LMF(force read), *6:LMD */
      /* *8:MMR  *9:MMTR */
      /* For Macro-Pipelining, LMP and LMD should be implemented here */
      /* For EMAX5, MMR and MMTR should be implemented here */
    case 4: /* LMP */
      break;
    case 6: /* LMD */
      break;
    case 8: /* MMR */
      /* mem_adr=unit[cid][i][j].eag.d         */
      /* emax5[cid].memi_new[i].mctr0[j].bank  */
      /* emax5[cid].memi_new[i].mctr0[j].width */
#if 1
      switch (emax5[cid].memi_new[i].mctr0[j].width) {
      case 0:
	unit[cid][i][j  ].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d);
	break;
      case 1:
	unit[cid][i][j  ].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d);
	unit[cid][i][j+1].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d+sizeof(Uint));
	break;
      case 2:
	unit[cid][i][j  ].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d);
	unit[cid][i][j+1].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d+sizeof(Uint));
	unit[cid][i][j+2].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d+sizeof(Uint)*2);
	unit[cid][i][j+3].lmm.d = *(Uint*)(base+unit[cid][i][j].eag.d+sizeof(Uint)*3);
	break;
      }
#endif
      break;
    case 9: /* MMTR */
#if 1
      if (trace)
	printf("MMTR start=%08.8x p0=%08.8x p1=%08.8x p2=%08.8x p3=%08.8x\n", 
	       emax5[cid].memi_new[i].mem_top[j],
	       unit[cid][i][j  ].eag.d,
	       unit[cid][i][j+1].eag.d,
	       unit[cid][i][j+2].eag.d,
	       unit[cid][i][j+3].eag.d);
      for (k=0; k<MAX_TRANS_CBL; k++) {
	if (tcu[k].tcbid == emax5[cid].memi_new[i].mem_top[j]) {
	  break;
	}
      }
      if (k==MAX_TRANS_CBL) {
	printf("MMTR registered transaction not found: start=%08.8x\n", emax5[cid].memi_new[i].mem_top[j]);
	break;
      }
      tcu[k].reg[0] = unit[cid][i][j  ].eag.d;
      tcu[k].reg[1] = unit[cid][i][j+1].eag.d;
      tcu[k].reg[2] = unit[cid][i][j+2].eag.d;
      tcu[k].reg[3] = unit[cid][i][j+3].eag.d;
      tcu[k].pc = 0;
      tcu[k].status = TCU_BUSY;
      while (tcu[k].status == TCU_BUSY) {
	struct tconf insn = tcu[k].tconf[tcu[k].pc];
	Uint b, o, adder, d, c;

	cycles++;
	/* read regs */
	switch (insn.base_type) {
	case 0:
	  b = tcu[k].reg[insn.base];
	  break;
	case 1: /* reg_adr */
	  b = tcu[k].reg[insn.base];
	  break;
	case 2: /* mem_adr */
	  b = insn.base;
	  break;
	}
	o = (insn.offset_type==0)?tcu[k].reg[insn.offset]:insn.offset;
	o = (insn.offset_suffix==0)?o:(insn.offset_suffix==4)?o&0xff:(insn.offset_suffix==5)?(o>>8)&0xff:(insn.offset_suffix==6)?(o>>16)&0xff:(o>>24);
	o = o << insn.offset_sll;
	/* adder */
	adder = b + o;
	/* mem_access */
	switch (insn.rw) {
	case 0: /* read */
	  d = (insn.base_type==0) ? adder : *(Uint*)(base+adder);
	  break;
	case 1: /* write */
	  d = (insn.reg_type==0) ? tcu[k].reg[insn.reg] : insn.reg;
	  *(Uint*)(base+adder) = d;
	  break;
	}
	/* load->operation */
	if (insn.rw==0) {
	  switch (insn.op_type) {
	  case 0: /* none */
	    tcu[k].reg[insn.reg] = d;
	    c = 1;
	    break;
	  case 1: /* + */
	    tcu[k].reg[insn.reg] = d + ((insn.op_val_type==0)?tcu[k].reg[insn.op_val]:insn.op_val);
	    c = 1;
	    break;
	  case 2: /* ?eq */
	    tcu[k].reg[insn.reg] = d;
	    c = d == ((insn.op_val_type==0)?tcu[k].reg[insn.op_val]:insn.op_val);
	    break;
	  case 3: /* ?ne */
	    tcu[k].reg[insn.reg] = d;
	    c = d != ((insn.op_val_type==0)?tcu[k].reg[insn.op_val]:insn.op_val);
	    break;
	  case 4: /* ?ge */
	    tcu[k].reg[insn.reg] = d;
	    c = d >= ((insn.op_val_type==0)?tcu[k].reg[insn.op_val]:insn.op_val);
	    break;
	  }
	}
	else
	  c = 1;
	/* check condition */
	if (c) {
	  if (insn.t_action_type == 0) { /* none */
	    tcu[k].pc++;
	    if (tcu[k].pc >= TRANS_DEPTH) {
	      printf("tcu detects ERROR in tcu[%d] pc>=TRANS_DEPTH\n", k);
	      tcu[k].status = TCU_IDLE;
	    }
	  }
	  else if (insn.t_action_type == 1) /* term */
	    tcu[k].status = TCU_IDLE;
	  else if (insn.t_action_type == 2) { /* error */
	    printf("tcu detects ERROR in tcu[%d] pc=%d\n", k, tcu[k].pc);
	    tcu[k].status = TCU_IDLE;
	  }
	  else /* goto */
	    tcu[k].pc = insn.t_action;
	}
	else {
	  if (insn.f_action_type == 0) { /* none */
	    tcu[k].pc++;
	    if (tcu[k].pc >= TRANS_DEPTH) {
	      printf("tcu detects ERROR in tcu[%d] pc>=TRANS_DEPTH\n", k);
	      tcu[k].status = TCU_IDLE;
	    }
	  }
	  else if (insn.f_action_type == 1) /* term */
	    tcu[k].status = TCU_IDLE;
	  else if (insn.f_action_type == 2) { /* error */
	    printf("tcu detects ERROR in tcu[%d] pc=%d\n", k, tcu[k].pc);
	    tcu[k].status = TCU_IDLE;
	  }
	  else /* goto */
	    tcu[k].pc = insn.f_action;
	}
      }
#endif
      break;
    default:
      if (unit[cid][i][j].eag.op_r && unit[cid][i][j].eag.op_r<=OP_LD) {
	if (unit[cid][i][j].emb[0].sel_r==1)
	  d = unit[cid][i][j].emb[0].d;
	else if (unit[cid][i][j].lmm.dsel_r==0) /* lmm-selector 0:lmm direct 1:fifo */
	  d = unit[cid][i][j].lmm.o;
	else
	  d = lmm_fifo_access(cid, i, j, MEM_RD);
	switch (unit[cid][i][j].eag.op_r) {
	case OP_LDB:    unit[cid][i][j].lmm.d =  (int)(char)((d >> ((unit[cid][i][j].eag.d&3)*8))&  0xff); break;
	case OP_LDUB:   unit[cid][i][j].lmm.d =             ((d >> ((unit[cid][i][j].eag.d&3)*8))&  0xff); break;
	case OP_LDH:    unit[cid][i][j].lmm.d = (int)(short)((d >> ((unit[cid][i][j].eag.d&3)*8))&0xffff); break;
	case OP_LDUH:   unit[cid][i][j].lmm.d =             ((d >> ((unit[cid][i][j].eag.d&3)*8))&0xffff); break;
	case OP_LD:     unit[cid][i][j].lmm.d =               d;                                           break;
	default:                                                                                           break;
	}
      }
      break;
    }
  }
  return (cycles);
a719 107
  a = unit[cid][i][j].lmm.a;

  switch (rw) {
  case MEM_RD:
    if (emax5[cid].unit_edb_cmd_d1 == 6) /* lmm_drain */
      rd = *(Uint*)&unit[cid][i][j].lmm.m[a&(LMEM_SIZE-1)&~3];
    else if (unit[cid][i][j].lmm.dsel_r==0) /* lmm-selector 0:lmm direct 1:fifo */
      rd = *(Uint*)&unit[cid][i][j].lmm.m[a&(LMEM_SIZE-1)&~3];
    else /* fifo */
      rd = 0xffffffff; /* do nothing */
    return (rd);
  case MEM_WR:
    if (emax5[cid].unit_edb_cmd_d1 == 4) /* lmm_load */
      *(Uint*)&unit[cid][i][j].lmm.m[a&(LMEM_SIZE-1)&~3] = unit[cid][i][j].lmm.s;
    else {
      s = (Uint)unit[cid][i][j].lmm.s;
      wr = (Uint*)&unit[cid][i][j].lmm.m[a&(LMEM_SIZE-1)&~3];
      switch (unit[cid][i][j].eag.op_r) {
      case OP_STB: bm =   0xff<<((a&3)*8);      *wr = (*wr&~bm)|((s<<((a&3)*8))&bm); break;
      case OP_STH: bm = 0xffff<<((a&3)*8);      *wr = (*wr&~bm)|((s<<((a&3)*8))&bm); break;
      case OP_ST:                               *wr =             s<<((a&3)*8);      break;
      default:                                                                       break;
      }
    }
    return (0);
  default:
    return (0xffffffff);
  }
}

lmm_fifo_access(cid, i, j, rw) Uint cid, i, j, rw;
{
  Uint k, a, s, bm, *wr;
  Ull rd;

  a = unit[cid][i][j].lmm.a;

  switch (rw) {
  case MEM_RD:
    if (emax5[cid].unit_edb_cmd_d1 == 6) /* lmm_drain */
      rd = 0xffffffff; /* do nothing */
    else if (unit[cid][i][j].lmm.dsel_r==0) /* lmm-selector 0:lmm direct 1:fifo */
      rd = 0xffffffff; /* do nothing */
    else { /* fifo */
      /* struct lmm_fifo { Uint v : 1; Uint tag : 16; Uint d : 32;} lmm_fifo[FIFO_DEPTH]; */
      for (k=0; k<FIFO_DEPTH; k++) {
        if (unit[cid][i][j].lmm.lmm_fifo[k].v && unit[cid][i][j].lmm.lmm_fifo[k].tag == ((a&(LMEM_SIZE-1))>>2))
          break;
      }
      if (k < FIFO_DEPTH) rd = unit[cid][i][j].lmm.lmm_fifo[k].d;
      else                rd = 0xffffffff;
      /* update fifo */
      if (unit[cid][i][j].lmm.lmm_fifo[0].v && (unit[cid][i][j].lmm.lmm_fifo[0].tag == unit[cid][i][j].emb[0].a)) {
        /* do nothing (for expand4k) */
      }
      else {
        for (k=FIFO_DEPTH-1; k>0; k--)
          unit[cid][i][j].lmm.lmm_fifo[k] = unit[cid][i][j].lmm.lmm_fifo[k-1];
        unit[cid][i][j].lmm.lmm_fifo[0].v   = 1;
        unit[cid][i][j].lmm.lmm_fifo[0].tag = unit[cid][i][j].emb[0].a; /* 14bit */
        unit[cid][i][j].lmm.lmm_fifo[0].d   = unit[cid][i][j].emb[0].d;
      }
    }
    return (rd);
  case MEM_WR:
    /* do nothing */
    return (0);
  default:
    return (0xffffffff);
  }
}

ex2_fifo_access(cid, i, j, rw) Uint cid, i, j, rw;
{
  Uint k, a, s, bm, rd, *wr;

  a = unit[cid][i][j].ex1.d;

  switch (rw) {
  case MEM_RD:
    if (unit[cid][i][j].ex2.dsel_r==0) /* ex2-selector 0:ex2 direct 1:fifo */
      rd = 0xffffffff; /* no path to lmm */
    else { /* fifo */
      /* struct ex2_fifo { Uint v : 1; Uint tag : 16; Uint d : 32;} ex2_fifo[FIFO_DEPTH]; */
      for (k=0; k<FIFO_DEPTH; k++) {
        if (unit[cid][i][j].ex2.ex2_fifo[k].v && unit[cid][i][j].ex2.ex2_fifo[k].tag == ((a&(LMEM_SIZE-1))>>2))
          break;
      }
      if (k < FIFO_DEPTH) rd = unit[cid][i][j].ex2.ex2_fifo[k].d;
      else                rd = 0xffffffff;
      /* update fifo */
      if (unit[cid][i][j].ex2.ex2_fifo[0].v && (unit[cid][i][j].ex2.ex2_fifo[0].tag == unit[cid][i][j].emb[0].a)) {
        /* do nothing (for expand4k) */
      }
      else {
        for (k=FIFO_DEPTH-1; k>0; k--)
          unit[cid][i][j].ex2.ex2_fifo[k] = unit[cid][i][j].ex2.ex2_fifo[k-1];
        unit[cid][i][j].ex2.ex2_fifo[0].v   = 1;
        unit[cid][i][j].ex2.ex2_fifo[0].tag = unit[cid][i][j].emb[0].a; /* 14bit */
        unit[cid][i][j].ex2.ex2_fifo[0].d   = (Uint)unit[cid][i][j].emb[0].d;
      }
    }
    return (rd);
  default:
    /* can not write */
    return (0xffffffff);
  }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm32/src/bsim/RCS/emax4.c,v 1.12 2015/07/01 14:15:13 nakashim Exp nakashim $";
d4 1
a4 1
/* EMAX4 Simulator                     */
d9 1
a9 1
/* emax4.c 2012/9/22 */ 
d13 1
a13 1
#include "../conv-a2c/emax4.h"
d16 1
a16 18
struct unit { /* final information for EMAX4 hardware */
  struct ixb { /* select any portion in the same unit */
    Uint sel_r : 4;  /* 0:off 1:prev_ex2.p1 2:prev_ex2.p2 3:prev_ex2.p3 4:prev_mem.p1 5:prev_mem.p2 6:prev_mem.p3 8:prev_ex2.d 9:prev_mem.d */
    Uint d     : 32; /* internal wire */
  } ixb[INT_XBR_BUS_NUM];

  struct edb { /* select dst portion among neighbor units */
    Uint sel_r : 2;  /* 0:off 1:prev_ex2.d 2:prev_mem.d */
    Uint dir_r : 2;  /* 0:off 1:to-left 2:to-right 3:inhibited */
    Uint d;           /* internal wire edb[0]:32bit edb[1]:32bit */
  } edb[EXT_DST_BUS_NUM];

  struct edc { /* select dst portion among neighbor units */
    Uint sel_r : 1; /* 0:off 1:prev_ex2.c */
    Uint dir_r : 2; /* 0:off 1:to-left 2:to-right 3:inhibited */
    Uint d     : 1; /* internal wire */
  } edc[EXT_DST_CCR_NUM];

a62 6
    struct ex2_fifo {
      Uint v   : 1;
      Uint tag : 14; /* 64KB/4 */
      Uint d   : 32;
    } ex2_fifo[FIFO_DEPTH];
    Uint dsel_r: 1;  /* ex2-selector 0:ex2 direct 1:fifo */
a93 6
    struct lmm_fifo {
      Uint v   : 1;
      Uint tag : 14; /* 64KB/4 */
      Uint d   : 32;
    } lmm_fifo[FIFO_DEPTH];
    Uint dsel_r: 1;  /* lmm-selector 0:lmm direct 1:fifo */
a101 14

  struct emb { /* select memory portion among neighbor units */
    Uint sel_r : 1;  /* 0:off 1:lmem */
    Uint dir_r : 2;  /* 0:off 1:to-left    2:to-right   3:inhibited */
    Uint a     : 14; /* internal wire */
    Uint d;          /* internal wire */
  } emb[EXT_MEM_BUS_NUM];

  struct etb { /* select same portion among neighbor units */
    Uint sel_r : 1;  /* 0:off 1:t[1-3] */
    Uint dir_r : 2;  /* 0:off 1:to-left    2:to-right   3:inhibited */
    Uint d     : 32; /* internal wire */
  } etb[EXT_TMP_BUS_NUM];

d105 1
a105 1
} unit[MAXCORE][UNIT_DEPTH][UNIT_WIDTH];
d109 1
a109 1
struct emax4 {
d127 1
a127 1
  Uint unit_edb1[UNIT_WIDTH] ; /* config/write_data to unit */
d129 1
a129 1
  Uint unit_emb[UNIT_WIDTH]  ; /* read_data from unit */
d131 1
a131 1
  struct memi memi_new[UNIT_DEPTH], memi_old[UNIT_DEPTH];
d155 1
a155 1
} emax4[MAXCORE];
d164 1
a164 1
struct tcu { /* final information for EMAX4 hardware */
d177 1
a177 1
  emax4[cid].pa_cycles_tinit = 0;
d194 2
a195 2
  emax4[cid].pa_cycles_tinit = sizeof(tconf)/(sizeof(Uint)*UNIT_WIDTH);
  emax4[cid].cycles_tinit += emax4[cid].pa_cycles_tinit;
d205 1
a205 1
emax4_start(tid, cycle, trace, trace_pipe, base, start, end) Uint tid, cycle, trace, trace_pipe; Uchar *base; Uint start, end;
d210 1
a210 1
  if (emax4[cid].v && emax4[cid].tid != tid)
d213 10
a222 10
  if (emax4[cid].pe0_status == STATUS_IDLE) {
    emax4[cid].v = 1; /* lock */
    emax4[cid].tid = tid;
    emax4[cid].pa_cycles_conf = 0;
    emax4[cid].pa_cycles_regv = 0;
    emax4[cid].pa_cycles_memi = 0;
    emax4[cid].pa_cycles_lmm_load = 0;
    emax4[cid].pa_cycles_exec = 0;
    emax4[cid].pa_cycles_lmm_drain = 0;
    emax4[cid].pa_cycles_trans = 0;
d226 1
a226 1
  /* EMAX4 HW starts execution according to unit[][].                                                                            */
d234 3
a236 3
    prev1_stop =  emax4[cid].unit1_stop;
    prev2_stop =  emax4[cid].unit2_stop;
    for (i=(emax4[cid].unit_offset+UNIT_DEPTH-1)%UNIT_DEPTH;; i=(i+UNIT_DEPTH-1)%UNIT_DEPTH) { /* for each unit */
d239 1
a239 1
      for (j=UNIT_WIDTH-1; j>=0; j--) { /* for each unit */
d245 1
a245 1
	emax4[cid].pa_cycles_trans += siml_unit_lmm(cid, trace, base, i, j); /* lmm */
d247 1
a247 1
      for (j=UNIT_WIDTH-1; j>=0; j--) { /* for each unit */
d256 7
a262 7
      if (emax4[cid].unit_edb_cmd == 5) {
	emax4[cid].unit2_stop |=                                      ( prev1_stop           &(1LL<<  i                          ))                                            ? (1LL<<i): 0;
	emax4[cid].unit1_stop |=                                      ( prev2_stop           &(1LL<<((i+UNIT_DEPTH-1)%UNIT_DEPTH)))                                            ? (1LL<<i): 0;
	emax4[cid].unit2_exec &=                                      (                                                                       emax4[cid].unit2_stop&(1LL<<i))  ?~(1LL<<i):~0;
	emax4[cid].unit2_exec |=                                      ((emax4[cid].unit1_exec&(1LL<<  i                               )) && !(emax4[cid].unit2_stop&(1LL<<i))) ? (1LL<<i): 0;
	emax4[cid].unit1_exec &=                                      (                                                                       emax4[cid].unit1_stop&(1LL<<i )) ?~(1LL<<i):~0;
	emax4[cid].unit1_exec |= ((emax4[cid].unit_select_row&(1LL<<i)) || ((emax4[cid].unit2_exec&(1LL<<((i+UNIT_DEPTH-1)%UNIT_DEPTH))) && !(emax4[cid].unit1_stop&(1LL<<i))))? (1LL<<i): 0;
d264 1
a264 1
      if (i==emax4[cid].unit_offset)
d270 1
a270 1
      for (i=0; i<UNIT_DEPTH; i++) /* for each instructions to be assigned */
d281 4
a284 4
    emax4[cid].unit_edb_cmd_d2    = emax4[cid].unit_edb_cmd_d1;
    emax4[cid].unit_edb_cmd_d1    = emax4[cid].unit_edb_cmd;
    emax4[cid].unit_select_row_d1 = emax4[cid].unit_select_row;
    emax4[cid].unit_select_col_d1 = emax4[cid].unit_select_col;
d286 1
a286 1
    switch (emax4[cid].pe0_status) {
d288 3
a290 3
      if (emax4[cid].last_conf != (Uint*)(base+start) || emax4[cid].last_dist > 0) {
	emax4[cid].pe0_status      = STATUS_CONF;
	emax4[cid].unit_edb_cmd    = 0; 
d297 2
a298 2
	emax4[cid].pe0_status      = STATUS_REGV;
	emax4[cid].unit_edb_cmd    = 0; 
d304 1
a304 1
      emax4[cid].pa_cycles_conf++;
d306 6
a311 6
      if (wrdyc[cid] < UNIT_DEPTH*sizeof(struct conf)/(sizeof(Uint)*UNIT_WIDTH)) { /* rrdy */
	emax4[cid].unit_edb_cmd = 1;     /* 一旦latch.次のCLKでUNIT書き込み */
	emax4[cid].unit_select_row = 1LL<<((emax4[cid].unit_offset+wrdyc[cid]/(sizeof(struct conf)/(sizeof(Uint)*UNIT_WIDTH)))%UNIT_DEPTH);
	emax4[cid].unit_select_col = (1<<UNIT_WIDTH)-1; /* all-1 */
	emax4[cid].unit_edb0 = wrdyc[cid]%(sizeof(struct conf)/(sizeof(Uint)*UNIT_WIDTH));    /* select target registers */
	for (j=0; j<UNIT_WIDTH; j++) {
d313 4
a316 4
	  emax4[cid].unit_edb1[j] = tp0[wrdyc[cid]*UNIT_WIDTH+j]; /* 一旦latch.次のCLKでUNIT書き込み */
	  if ((wrdyc[cid] & (sizeof(struct conf)/(sizeof(Uint)*UNIT_WIDTH)-1)) == (sizeof(struct conf)/(sizeof(Uint)*UNIT_WIDTH)-1)) { /* last word */
	    if ((emax4[cid].unit_edb1[j] & 0x00000003) && (emax4[cid].unit_edb1[j] & 0x0000003c))
	      emax4[cid].last_dist = (emax4[cid].unit_edb1[j] >> 2) & 0xf;
d322 2
a323 2
	emax4[cid].pe0_status      = STATUS_REGV;
	emax4[cid].unit_edb_cmd    = 0; 
d329 1
a329 1
      emax4[cid].pa_cycles_regv++;
d331 6
a336 6
      if (wrdyc[cid] < UNIT_DEPTH*sizeof(struct regv)/(sizeof(Uint)*UNIT_WIDTH)) { /* rrdy */
	emax4[cid].unit_edb_cmd = 2;     /* 一旦latch.次のCLKでUNIT書き込み */
	emax4[cid].unit_select_row = 1LL<<((emax4[cid].unit_offset+wrdyc[cid]/(sizeof(struct regv)/(sizeof(Uint)*UNIT_WIDTH)))%UNIT_DEPTH);
	emax4[cid].unit_select_col = (1<<UNIT_WIDTH)-1; /* all-1 */
	emax4[cid].unit_edb0 = wrdyc[cid]%(sizeof(struct regv)/(sizeof(Uint)*UNIT_WIDTH));    /* select target registers */
	for (j=0; j<UNIT_WIDTH; j++) {
d338 1
a338 1
	  emax4[cid].unit_edb1[j] = tp1[wrdyc[cid]*UNIT_WIDTH+j]; /* 一旦latch.次のCLKでUNIT書き込み */
d343 2
a344 2
	emax4[cid].pe0_status      = STATUS_MEMI;
	emax4[cid].unit_edb_cmd    = 0; 
d350 1
a350 1
      emax4[cid].pa_cycles_memi++;
d352 3
a354 3
      if (wrdyc[cid] < UNIT_DEPTH*sizeof(struct memi)/(sizeof(Uint)*UNIT_WIDTH)) { /* rrdy */
	i = (emax4[cid].unit_offset+wrdyc[cid]/(sizeof(struct memi)/(sizeof(Uint)*UNIT_WIDTH)))%UNIT_DEPTH;
	for (j=0; j<UNIT_WIDTH; j++) {
d356 1
a356 1
	  *((Uint*)&emax4[cid].memi_new[i]+(wrdyc[cid]%(sizeof(struct memi)/(sizeof(Uint)*UNIT_WIDTH)))*UNIT_WIDTH+j) = tp2[wrdyc[cid]*UNIT_WIDTH+j]; /* UNIT外なので直ちに書き込み */
d361 3
a363 3
	emax4[cid].pe0_status      = STATUS_LMM_LOAD;
	emax4[cid].unit_edb_cmd    = 0; 
	emax4[cid].unit_ctl_count  = 0;
d368 1
a368 1
      emax4[cid].pa_cycles_lmm_load++;
d370 1
a370 1
      if (emax4[cid].unit_ctl_count < UNIT_DEPTH*UNIT_WIDTH) {
d372 4
a375 4
	i = (emax4[cid].unit_ctl_count/UNIT_WIDTH)%UNIT_DEPTH;
	j = (emax4[cid].unit_ctl_count           )%UNIT_WIDTH;
	count = emax4[cid].memi_new[i].len[j];
	switch (emax4[cid].memi_new[i].mctr0[j].v) {
d381 8
a388 8
          if (emax4[cid].memi_old[i].mctr0[j].v
              && emax4[cid].memi_old[i].mctr0[j].bank  == emax4[cid].memi_new[i].mctr0[j].bank
              && emax4[cid].memi_old[i].mctr0[j].width == emax4[cid].memi_new[i].mctr0[j].width
              && emax4[cid].memi_old[i].mctr0[j].block == emax4[cid].memi_new[i].mctr0[j].block
              && emax4[cid].memi_old[i].mctr0[j].dist  == emax4[cid].memi_new[i].mctr0[j].dist
              && emax4[cid].memi_old[i].lmm_top[j]     == emax4[cid].memi_new[i].lmm_top[j]
              && emax4[cid].memi_old[i].mem_top[j]     == emax4[cid].memi_new[i].mem_top[j]
              && emax4[cid].memi_old[i].len[j]         >= emax4[cid].memi_new[i].len[j]) {
d390 2
a391 2
	      printf("step 8.4: mctl[%d].ltop[%d]=%08.8x mtop=%08.8x len=%08.8x found in LMM\n", i, j, emax4[cid].memi_new[i].lmm_top[j], emax4[cid].memi_new[i].mem_top[j], emax4[cid].memi_new[i].len[j]);
            emax4[cid].unit_ctl_count++;
d394 1
a394 1
	    emax4[cid].unit_edb_cmd = 4; /* 一旦latch.次のCLKでUNIT書き込み */
d396 2
a397 2
	    emax4[cid].unit_select_row = 1LL<<i;
	    switch (emax4[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
d399 1
a399 1
	      emax4[cid].unit_select_col = 1<<j;
d401 14
a414 14
	      for (k=j+1; k<UNIT_WIDTH; k++) {
		if (emax4[cid].memi_new[i].mctr0[k].v
		    && emax4[cid].memi_new[i].mctr0[k].bank  == emax4[cid].memi_new[i].mctr0[j].bank
		    && emax4[cid].memi_new[i].mctr0[k].width == emax4[cid].memi_new[i].mctr0[j].width
		    && emax4[cid].memi_new[i].mctr0[k].block == emax4[cid].memi_new[i].mctr0[j].block
		    && emax4[cid].memi_new[i].mctr0[k].dist  == emax4[cid].memi_new[i].mctr0[j].dist
		    && emax4[cid].memi_new[i].lmm_top[k]     == emax4[cid].memi_new[i].lmm_top[j]
		    && emax4[cid].memi_new[i].mem_top[k]     == emax4[cid].memi_new[i].mem_top[j]
		    && emax4[cid].memi_new[i].len[k]         == emax4[cid].memi_new[i].len[j]) {
		  emax4[cid].unit_select_col |= 1<<k;
		  emax4[cid].memi_old[i].mctr0[k]   = emax4[cid].memi_new[i].mctr0[j];
		  emax4[cid].memi_old[i].lmm_top[k] = emax4[cid].memi_new[i].lmm_top[j];
		  emax4[cid].memi_old[i].mem_top[k] = emax4[cid].memi_new[i].mem_top[j];
		  emax4[cid].memi_old[i].len[k]     = emax4[cid].memi_new[i].len[j];
d421 1
a421 1
	      emax4[cid].unit_select_col = 3<<j;
d424 1
a424 1
	      emax4[cid].unit_select_col = 15<<j;
d428 1
a428 1
	    emax4[cid].unit_edb0 = emax4[cid].memi_new[i].lmm_top[j]+wrdyc[cid]*sizeof(Uint); /* select target registers */
d431 3
a433 3
	    width = (1<<emax4[cid].memi_new[i].mctr0[j].width); /* 0:4bytes, 1:8bytes, 2:16bytes 3:undef */
	    dist  = (1<<emax4[cid].memi_new[i].mctr0[j].dist);  /* 0:dist=width, 1:dist=width*2, 2:dist=width*4 3:dist=width*8 */
	    switch (emax4[cid].memi_new[i].mctr0[j].block) {
d435 1
a435 1
	      a =               emax4[cid].memi_new[i].mem_top[j]                         +(wrdyc[cid]   )*sizeof(Uint)*width*dist;
d438 1
a438 1
	      a = *(Uint*)(base+emax4[cid].memi_new[i].mem_top[j]+(wrdyc[cid]/16)*sizeof(Uint))+(wrdyc[cid]%16)*sizeof(Uint)*width*dist;
d441 1
a441 1
	      a = *(Uint*)(base+emax4[cid].memi_new[i].mem_top[j]+(wrdyc[cid]/32)*sizeof(Uint))+(wrdyc[cid]%32)*sizeof(Uint)*width*dist;
d444 1
a444 1
	      a = *(Uint*)(base+emax4[cid].memi_new[i].mem_top[j]+(wrdyc[cid]/64)*sizeof(Uint))+(wrdyc[cid]%64)*sizeof(Uint)*width*dist;
d448 1
a448 1
	    switch (emax4[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
d450 4
a453 4
	      emax4[cid].unit_edb1[j  ] = *(Uint*)(base+a); /* 一旦latch.次のCLKでUNIT書き込み */
	      for (k=j+1; k<UNIT_WIDTH; k++) {
		if (emax4[cid].unit_select_col & (1<<k))
		  emax4[cid].unit_edb1[k] = *(Uint*)(base+a); /* 一旦latch.次のCLKでUNIT書き込み */
d456 1
a456 1
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=1/1 val=%08.8x(%d/%d)->LMM\n", i, j, a, emax4[cid].unit_edb1[j], wrdyc[cid], count);
d459 2
a460 2
	      emax4[cid].unit_edb1[j  ] = *(Uint*)(base+a             ); /* 一旦latch.次のCLKでUNIT書き込み */
	      emax4[cid].unit_edb1[j+1] = *(Uint*)(base+a+sizeof(Uint)); /* 一旦latch.次のCLKでUNIT書き込み */
d462 2
a463 2
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=1/2 val=%08.8x(%d/%d)->LMM\n", i, j, a,              emax4[cid].unit_edb1[j  ], wrdyc[cid], count);
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=2/2 val=%08.8x(%d/%d)->LMM\n", i, j, a+sizeof(Uint), emax4[cid].unit_edb1[j+1], wrdyc[cid], count);
d467 4
a470 4
	      emax4[cid].unit_edb1[j  ] = *(Uint*)(base+a               ); /* 一旦latch.次のCLKでUNIT書き込み */
	      emax4[cid].unit_edb1[j+1] = *(Uint*)(base+a+sizeof(Uint)  ); /* 一旦latch.次のCLKでUNIT書き込み */
	      emax4[cid].unit_edb1[j+2] = *(Uint*)(base+a+sizeof(Uint)*2); /* 一旦latch.次のCLKでUNIT書き込み */
	      emax4[cid].unit_edb1[j+3] = *(Uint*)(base+a+sizeof(Uint)*3); /* 一旦latch.次のCLKでUNIT書き込み */
d472 4
a475 4
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=1/4 val=%08.8x(%d/%d)->LMM\n", i, j, a,                emax4[cid].unit_edb1[j  ], wrdyc[cid], count);
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=2/4 val=%08.8x(%d/%d)->LMM\n", i, j, a+sizeof(Uint)  , emax4[cid].unit_edb1[j+1], wrdyc[cid], count);
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=3/4 val=%08.8x(%d/%d)->LMM\n", i, j, a+sizeof(Uint)*2, emax4[cid].unit_edb1[j+2], wrdyc[cid], count);
		printf("step 8.4: mctl[%d].adr[%d]=%08.8x w=4/4 val=%08.8x(%d/%d)->LMM\n", i, j, a+sizeof(Uint)*3, emax4[cid].unit_edb1[j+3], wrdyc[cid], count);
d482 5
a486 5
	    if (emax4[cid].memi_new[i].mctr0[j].v < 4) { /* in the case of LMF, always renew */
	      emax4[cid].memi_old[i].mctr0[j]   = emax4[cid].memi_new[i].mctr0[j];
	      emax4[cid].memi_old[i].lmm_top[j] = emax4[cid].memi_new[i].lmm_top[j];
	      emax4[cid].memi_old[i].mem_top[j] = emax4[cid].memi_new[i].mem_top[j];
	      emax4[cid].memi_old[i].len[j]     = emax4[cid].memi_new[i].len[j];
d488 2
a489 2
	    emax4[cid].unit_edb_cmd = 0; 
	    emax4[cid].unit_ctl_count++;
d499 1
a499 1
	  emax4[cid].unit_ctl_count++;
d504 3
a506 3
	emax4[cid].pe0_status      = STATUS_START;
	emax4[cid].unit_edb_cmd    = 0; 
	emax4[cid].unit_ctl_count  = 0;
d511 4
a514 4
      emax4[cid].pe0_status      = STATUS_EXEC;
      emax4[cid].unit_edb_cmd    = 5; /* 一旦latch.次のCLKでUNIT書き込み */
      emax4[cid].unit_select_row = 1LL<<emax4[cid].unit_offset;
      emax4[cid].unit_select_col = (1<<UNIT_WIDTH)-1; /* all-1 */
d517 1
a517 1
      emax4[cid].pa_cycles_exec++;
d532 2
a533 2
	emax4[cid].unit_select_row = 0; /* inhibit initial restart */
	emax4[cid].unit_select_col = 0; /* inhibit initial restart */
d535 1
a535 1
	all_status |= emax4[cid].unit1_exec | emax4[cid].unit2_exec;
d537 3
a539 3
	  emax4[cid].pe0_status     = STATUS_LMM_DRAIN;
	  emax4[cid].unit_edb_cmd   = 0; 
	  emax4[cid].unit_ctl_count = 0;
d546 1
a546 1
      emax4[cid].pa_cycles_lmm_drain++;
d548 1
a548 1
      if (emax4[cid].unit_ctl_count < UNIT_DEPTH*UNIT_WIDTH) {
d550 4
a553 4
	i = (emax4[cid].unit_ctl_count/UNIT_WIDTH)%UNIT_DEPTH;
	j = (emax4[cid].unit_ctl_count           )%UNIT_WIDTH;
	emax4[cid].unit_select_row = 1LL<<i;
	switch (emax4[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
d555 1
a555 1
	  emax4[cid].unit_select_col = 1<<j;
d558 1
a558 1
	  emax4[cid].unit_select_col = 3<<j;
d561 1
a561 1
	  emax4[cid].unit_select_col = 15<<j;
d564 2
a565 2
	count = emax4[cid].memi_new[i].len[j];
	switch (emax4[cid].memi_new[i].mctr0[j].v) {
d571 2
a572 2
	    emax4[cid].unit_edb_cmd = 6; /* 一旦latch.次のCLKでUNIT書き込み */
	    emax4[cid].unit_edb0 = emax4[cid].memi_new[i].lmm_top[j]+wrdyc[cid]*sizeof(Uint);    /* select target registers */
d576 1
a576 1
	    emax4[cid].unit_edb_cmd = 0;
d579 5
a583 5
	    if (emax4[cid].unit_edb_cmd_d2 == 6) { /* rrdyc[cid] */
	      width = (1<<emax4[cid].memi_new[i].mctr0[j].width); /* 0:4bytes, 1:8bytes, 2:16bytes 3:undef */
	      dist  = (1<<emax4[cid].memi_new[i].mctr0[j].dist);  /* 0:dist=width, 1:dist=width*2, 2:dist=width*4 3:dist=width*8 */
	      a = emax4[cid].memi_new[i].mem_top[j]+(rrdyc[cid])*sizeof(Uint)*width*dist;
	      switch (emax4[cid].memi_new[i].mctr0[j].width) { /* EDB[1]のword3,2,1,0が各々unit[][3],[][2],[][1],[][0]に対応 */
d585 2
a586 2
		emax4[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		*(Uint*)(base+a) = emax4[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
d588 1
a588 1
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/1 val=%08.8x(%d/%d)<-LMM\n", i, j, a, emax4[cid].unit_emb[0], rrdyc[cid], count);
d591 4
a594 4
		emax4[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		emax4[cid].unit_emb[1] = unit[cid][i][j+1].emb[0].d;
		*(Uint*)(base+a             ) = emax4[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)) = emax4[cid].unit_emb[1]; /* 一旦latch.次のCLKでUNIT書き込み */
d596 2
a597 2
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/2 val=%08.8x(%d/%d)<-LMM\n", i, j, a,              emax4[cid].unit_emb[0], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=2/2 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint), emax4[cid].unit_emb[1], rrdyc[cid], count);
d601 8
a608 8
		emax4[cid].unit_emb[0] = unit[cid][i][j  ].emb[0].d;
		emax4[cid].unit_emb[1] = unit[cid][i][j+1].emb[0].d;
		emax4[cid].unit_emb[2] = unit[cid][i][j+2].emb[0].d;
		emax4[cid].unit_emb[3] = unit[cid][i][j+3].emb[0].d;
		*(Uint*)(base+a               ) = emax4[cid].unit_emb[0]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)  ) = emax4[cid].unit_emb[1]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)*2) = emax4[cid].unit_emb[2]; /* 一旦latch.次のCLKでUNIT書き込み */
		*(Uint*)(base+a+sizeof(Uint)*3) = emax4[cid].unit_emb[3]; /* 一旦latch.次のCLKでUNIT書き込み */
d610 4
a613 4
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=1/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a               , emax4[cid].unit_emb[0], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=2/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)  , emax4[cid].unit_emb[1], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=3/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)*2, emax4[cid].unit_emb[2], rrdyc[cid], count);
		  printf("step 8.6: mctl[%d].adr[%d]=%08.8x w=4/4 val=%08.8x(%d/%d)<-LMM\n", i, j, a+sizeof(Uint)*3, emax4[cid].unit_emb[3], rrdyc[cid], count);
d621 1
a621 1
	    emax4[cid].unit_ctl_count++;
d633 1
a633 1
	  emax4[cid].unit_ctl_count++;
d638 3
a640 3
	emax4[cid].pe0_status      = STATUS_TERM;
	emax4[cid].unit_edb_cmd    = 0; 
	emax4[cid].unit_ctl_count  = 0;
d647 4
a650 4
      emax4[cid].v = 0; /* unlock */
      emax4[cid].pe0_status  = STATUS_IDLE;
      emax4[cid].last_conf   = (Uint*)(base+start);
      emax4[cid].unit_offset = (emax4[cid].unit_offset+emax4[cid].last_dist)%UNIT_DEPTH;
d652 10
a661 10
	     emax4[cid].pa_cycles_conf, emax4[cid].pa_cycles_regv, emax4[cid].pa_cycles_memi, emax4[cid].pa_cycles_lmm_load,
	     emax4[cid].pa_cycles_exec, emax4[cid].pa_cycles_lmm_drain, emax4[cid].pa_cycles_trans);
      emax4[cid].cycles_conf     += emax4[cid].pa_cycles_conf;
      emax4[cid].cycles_regv     += emax4[cid].pa_cycles_regv;
      emax4[cid].cycles_memi     += emax4[cid].pa_cycles_memi;
      emax4[cid].cycles_lmm_load += emax4[cid].pa_cycles_lmm_load;
      emax4[cid].cycles_exec     += emax4[cid].pa_cycles_exec;
      emax4[cid].cycles_lmm_drain+= emax4[cid].pa_cycles_lmm_drain;
      emax4[cid].cycles_trans    += emax4[cid].pa_cycles_trans;
      return (0); /* EMAX4 terminated */
d667 1
a667 1
  return (2); /* EMAX4 busy */
d675 1
a675 1
  switch (emax4[cid].unit_edb_cmd) {
d679 3
a681 3
    if (emax4[cid].unit_select_row & (1LL<<i)) {
      for (j=0; j<UNIT_WIDTH; j++)
	unit[cid][i][j].edb[1].d = emax4[cid].unit_edb1[j];
d684 3
a686 3
    if (emax4[cid].unit_select_row & (1LL<<i)) {
      unit[cid][i][0].edb[0].d = emax4[cid].unit_edb0; /* edb[0].d[1..3] not exist */
      for (j=1; j<UNIT_WIDTH; j++)
d696 1
a696 1
    for (j=0; j<UNIT_WIDTH; j++) {
d700 2
a701 2
        case 1: unit[cid][i][j].edb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;    break;
        case 2: unit[cid][i][j].edb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;    break;
d706 1
a706 1
    for (j=0; j<UNIT_WIDTH; j++) {
d710 2
a711 2
    for (j=UNIT_WIDTH-1; j>=0; j--) {
      if (j<UNIT_WIDTH-1 && unit[cid][i][j].edb[k].dir_r==2) /* 0:off 1:to-left 2:to-right 3:inhibited */
d717 1
a717 1
    for (j=0; j<UNIT_WIDTH; j++) {
d721 1
a721 1
        case 1:unit[cid][i][j].edc[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.c; break;
d725 1
a725 1
    for (j=0; j<UNIT_WIDTH; j++) {
d729 2
a730 2
    for (j=UNIT_WIDTH-1; j>=0; j--) {
      if (j<UNIT_WIDTH-1 && unit[cid][i][j].edc[k].dir_r==2) /* 0:off 1:to-left 2:to-right 3:inhibited */
d741 1
a741 1
  switch (emax4[cid].unit_edb_cmd_d1) {
d743 2
a744 2
    for (j=0; j<UNIT_WIDTH; j++) {
      if ((emax4[cid].unit_select_row_d1 & (1LL<<i)) && (emax4[cid].unit_select_col_d1 & (1<<j)))
d749 2
a750 2
    for (j=0; j<UNIT_WIDTH; j++) {
      if ((emax4[cid].unit_select_row_d1 & (1LL<<i)) && (emax4[cid].unit_select_col_d1 & (1<<j)))
d760 2
a761 2
  for (j=0; j<UNIT_WIDTH; j++) {
    if (unit[cid][i][j].cnd.exec && unit[cid][i][j].v2 && (emax4[cid].unit2_exec & (1LL<<i))) {
d775 1
a775 1
  for (j=0; j<UNIT_WIDTH; j++) {
d781 2
a782 2
  for (j=UNIT_WIDTH-1; j>=0; j--) {
    if (j<UNIT_WIDTH-1 && unit[cid][i][j].emb[0].dir_r==2) { /* 0:off 1:to-left 2:to-right 3:inhibited */
d788 1
a788 1
  for (j=0; j<UNIT_WIDTH; j++) {
d823 1
a823 1
    for (j=0; j<UNIT_WIDTH; j++) {
d827 2
a828 2
    for (j=UNIT_WIDTH-1; j>=0; j--) {
      if (j<UNIT_WIDTH-1 && unit[cid][i][j].etb[k].dir_r==2) /* 0:off 1:to-left 2:to-right 3:inhibited */
d839 1
a839 1
  switch (emax4[cid].unit_edb_cmd) {
d846 1
a846 1
  if (unit[cid][i][j].v1 && ((emax4[cid].unit1_exec & (1LL<<i)))) {
d851 1
a851 1
    case 0: bit0 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.c; break;
d857 1
a857 1
    case 0: bit1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.c; break;
d863 1
a863 1
    case 0: bit2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.c; break;
d869 1
a869 1
    case 0: bit3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.c; break;
d890 1
a890 1
  switch (emax4[cid].unit_edb_cmd) {
d892 2
a893 2
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
      emax4[cid].unit1_stop &= ~(1LL<<i);
d901 1
a901 1
  if (unit[cid][i][j].v1 && ((emax4[cid].unit1_exec & (1LL<<i)))) {
d905 8
a912 8
      case 1: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p1_r; break;
      case 2: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p2_r; break;
      case 3: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p3_r; break;
      case 4: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p1_r; break;
      case 5: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p2_r; break;
      case 6: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p3_r; break;
      case 8: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;    break;
      case 9: unit[cid][i][j].ixb[k].d = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;    break;
d918 1
a918 1
    case 0: unit[cid][i][j].ex1.t1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p1_r;    break;
d926 1
a926 1
    case 0: unit[cid][i][j].ex1.t2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p2_r;    break;
d934 1
a934 1
    case 0: unit[cid][i][j].ex1.t3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p3_r;    break;
d946 4
a949 4
    case 0: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p1_r;                                         break;
    case 1: s1 = (!unit[cid][i][j].one_shot)?unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p1_r:unit[cid][i][j].ex1.d; break;
    case 2: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
d955 3
a957 3
    case 0: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p2_r;                                         break;
    case 2: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
d963 3
a965 3
    case 0: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.p3_r;                                         break;
    case 2: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
d1106 1
a1106 1
	if (z) emax4[cid].unit1_stop |= (1LL<<i);
d1235 1
a1235 1
  switch (emax4[cid].unit_edb_cmd) {
d1237 2
a1238 2
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
      emax4[cid].unit2_stop &= ~(1LL<<i);
d1254 1
a1254 1
  if (unit[cid][i][j].v2 && (emax4[cid].unit2_exec & (1LL<<i))) {
d1275 1
a1275 1
  if (unit[cid][i][j].v2 && (emax4[cid].unit2_exec & (1LL<<i))) {
d1377 1
a1377 1
  switch (emax4[cid].unit_edb_cmd) {
d1379 1
a1379 1
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
d1480 1
a1480 1
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
d1486 1
a1486 1
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
d1494 1
a1494 1
  if (unit[cid][i][j].v1 && ((emax4[cid].unit1_exec & (1LL<<i)))) {
d1496 1
a1496 1
    case 0: unit[cid][i][j].eag.t1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p1_r;    break;
d1504 1
a1504 1
    case 0: unit[cid][i][j].eag.t2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p2_r;    break;
d1512 1
a1512 1
    case 0: unit[cid][i][j].eag.t3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p3_r;    break;
d1524 4
a1527 4
    case 0: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p1_r;                                         break;
    case 1: s1 = (!unit[cid][i][j].one_shot)?unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p1_r:unit[cid][i][j].eag.d; break;
    case 2: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s1 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
d1533 3
a1535 3
    case 0: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p2_r;                                         break;
    case 2: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s2 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
d1541 3
a1543 3
    case 0: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.p3_r;                                         break;
    case 2: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].ex2.d;                                            break;
    case 3: s3 = unit[cid][(i+(UNIT_DEPTH-1))&(UNIT_DEPTH-1)][j].lmm.d;                                            break;
d1579 1
a1579 1
  switch (emax4[cid].unit_edb_cmd) {
d1581 1
a1581 1
    if ((emax4[cid].unit_select_row & (1LL<<i)) && (emax4[cid].unit_select_col & (1<<j))) {
d1595 1
a1595 1
  switch (emax4[cid].unit_edb_cmd_d1) {
d1602 1
a1602 1
  if (unit[cid][i][j].v2 && (emax4[cid].unit2_exec & (1LL<<i))) {
d1623 1
a1623 1
  if (unit[cid][i][j].cnd.exec && unit[cid][i][j].v2 && (emax4[cid].unit2_exec & (1LL<<i))) {
d1627 1
a1627 1
    switch (emax4[cid].memi_new[i].mctr0[j].v) {
d1631 1
a1631 1
      /* For EMAX4, MMR and MMTR should be implemented here */
d1638 2
a1639 2
      /* emax4[cid].memi_new[i].mctr0[j].bank  */
      /* emax4[cid].memi_new[i].mctr0[j].width */
d1641 1
a1641 1
      switch (emax4[cid].memi_new[i].mctr0[j].width) {
d1662 1
a1662 1
	       emax4[cid].memi_new[i].mem_top[j],
d1668 1
a1668 1
	if (tcu[k].tcbid == emax4[cid].memi_new[i].mem_top[j]) {
d1673 1
a1673 1
	printf("MMTR registered transaction not found: start=%08.8x\n", emax4[cid].memi_new[i].mem_top[j]);
d1811 1
a1811 1
    if (emax4[cid].unit_edb_cmd_d1 == 6) /* lmm_drain */
d1819 1
a1819 1
    if (emax4[cid].unit_edb_cmd_d1 == 4) /* lmm_load */
d1846 1
a1846 1
    if (emax4[cid].unit_edb_cmd_d1 == 6) /* lmm_drain */
d1916 1
a1916 1
show_emax4_pa(cid, pa_cycle) Uint cid; Ull pa_cycle;
d1920 1
a1920 1
  printf("%03.3d:EMAX4 tinit=%08.8x_%08.8x conf=%08.8x_%08.8x  regv=%08.8x_%08.8x  memi=%08.8x_%08.8x\n",
d1922 4
a1925 4
	 (Uint)(emax4[cid].cycles_tinit>>32), (Uint)emax4[cid].cycles_tinit,
	 (Uint)(emax4[cid].cycles_conf>>32),  (Uint)emax4[cid].cycles_conf,
	 (Uint)(emax4[cid].cycles_regv>>32),  (Uint)emax4[cid].cycles_regv,
	 (Uint)(emax4[cid].cycles_memi>>32),  (Uint)emax4[cid].cycles_memi);
d1927 7
a1933 7
	 (Uint)(emax4[cid].cycles_lmm_load>>32),  (Uint)emax4[cid].cycles_lmm_load,
	 (Uint)(emax4[cid].cycles_exec>>32),  (Uint)emax4[cid].cycles_exec,
	 (Uint)(emax4[cid].cycles_lmm_drain>>32),  (Uint)emax4[cid].cycles_lmm_drain,
	 (Uint)(emax4[cid].cycles_trans>>32), (Uint)emax4[cid].cycles_trans);
  total = emax4[cid].cycles_tinit+emax4[cid].cycles_conf+emax4[cid].cycles_regv+emax4[cid].cycles_memi+emax4[cid].cycles_lmm_load+emax4[cid].cycles_exec+emax4[cid].cycles_lmm_drain+emax4[cid].cycles_trans;
  total *= EMAX4HOST_RATIO; /* 200MHz -> 2.4GHz */
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(icrmledt)", 2400/EMAX4HOST_RATIO, (Uint)(total>>32), (Uint)total);
d1937 3
a1939 3
  total = emax4[cid].cycles_tinit                  +emax4[cid].cycles_regv+emax4[cid].cycles_memi+emax4[cid].cycles_lmm_load+emax4[cid].cycles_exec+emax4[cid].cycles_lmm_drain+emax4[cid].cycles_trans;
  total *= EMAX4HOST_RATIO; /* 200MHz -> 2.4GHz */
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(i rmledt)", 2400/EMAX4HOST_RATIO, (Uint)(total>>32), (Uint)total);
d1943 3
a1945 3
  total = emax4[cid].cycles_tinit                  +emax4[cid].cycles_regv+emax4[cid].cycles_memi                      +emax4[cid].cycles_exec                       +emax4[cid].cycles_trans;
  total *= EMAX4HOST_RATIO; /* 200MHz -> 2.4GHz */
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(i rm e t)", 2400/EMAX4HOST_RATIO, (Uint)(total>>32), (Uint)total);
d1949 3
a1951 3
  total = emax4[cid].cycles_tinit                  +emax4[cid].cycles_regv+emax4[cid].cycles_memi                      +emax4[cid].cycles_exec;
  total *= EMAX4HOST_RATIO; /* 200MHz -> 2.4GHz */
  printf(" \033[33mEMAX%dMHz=%08.8x_%08.8x(i rm e  )", 2400/EMAX4HOST_RATIO, (Uint)(total>>32), (Uint)total);
d1955 8
a1962 8
  emax4[cid].cycles_tinit = 0LL;
  emax4[cid].cycles_conf = 0LL;
  emax4[cid].cycles_regv = 0LL;
  emax4[cid].cycles_memi = 0LL;
  emax4[cid].cycles_lmm_load = 0LL;
  emax4[cid].cycles_exec = 0LL;
  emax4[cid].cycles_lmm_drain = 0LL;
  emax4[cid].cycles_trans = 0LL;
a1976 272

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|\033[1;%dmex1.exec=%01.1x-\033[1;%dm-ex1.stop=%01.1x-\033[0m\033[1;%dm-ex2.exec=%01.1x-\033[0m\033[1;%dm-ex2.stop=%01.1x-\033[0m",
	   unit[cid][row][col].v1?37:34,
	   (emax4[cid].unit1_exec&(1LL<<row))?1:0,
	   unit[cid][row][col].v1?37:34,
	   (emax4[cid].unit1_stop&(1LL<<row))?1:0,
	   unit[cid][row][col].v2?37:34,
	   (emax4[cid].unit2_exec&(1LL<<row))?1:0,
	   unit[cid][row][col].v2?37:34,
	   (emax4[cid].unit2_stop&(1LL<<row))?1:0);
  }
  printf("\n");

  /* unit */
  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|ixb:\033[1;%dm%01.1x.%08.8x\033[0m:\033[1;%dm%01.1x.%08.8x\033[0m:\033[1;%dm%01.1x.%08.8x\033[0m:\033[1;%dm%01.1x.%08.8x\033[0m",
	   unit[cid][row][col].ixb[0].sel_r?36:34,
	   unit[cid][row][col].ixb[0].sel_r,
	   unit[cid][row][col].ixb[0].d,
	   unit[cid][row][col].ixb[1].sel_r?36:34,
	   unit[cid][row][col].ixb[1].sel_r,
	   unit[cid][row][col].ixb[1].d,
	   unit[cid][row][col].ixb[2].sel_r?36:34,
	   unit[cid][row][col].ixb[2].sel_r,
	   unit[cid][row][col].ixb[2].d,
	   unit[cid][row][col].ixb[3].sel_r?36:34,
	   unit[cid][row][col].ixb[3].sel_r,
	   unit[cid][row][col].ixb[3].d
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|edb:\033[1;%dm%01.1x.%01.1x.%08.8x\033[0m:\033[1;%dm%01.1x.%01.1x.%08.8x\033[0m edc:\033[1;%dm%01.1x\033[0m\033[1;%dm%01.1x\033[0m\033[1;%dm%01.1x\033[0m  c:\033[1;%dm%01.1x %04.4x\033[0m",
	   (unit[cid][row][col].edb[0].sel_r||unit[cid][row][col].edb[0].dir_r==2||(col>0&&unit[cid][row][col-1].edb[0].dir_r==1))?36:34,
	   unit[cid][row][col].edb[0].sel_r,
	   unit[cid][row][col].edb[0].dir_r,
	   unit[cid][row][col].edb[0].d,
	   (unit[cid][row][col].edb[1].sel_r||unit[cid][row][col].edb[1].dir_r==2||(col>0&&unit[cid][row][col-1].edb[1].dir_r==1))?36:34,
	   unit[cid][row][col].edb[1].sel_r,
	   unit[cid][row][col].edb[1].dir_r,
	   unit[cid][row][col].edb[1].d,
	   (unit[cid][row][col].edc[0].sel_r||unit[cid][row][col].edc[0].dir_r==2||(col>0&&unit[cid][row][col-1].edc[0].dir_r==1))?36:34,
	   (unit[cid][row][col].edc[0].sel_r<<3)|(unit[cid][row][col].edc[0].dir_r<<1)|unit[cid][row][col].edc[0].d,
	   (unit[cid][row][col].edc[1].sel_r||unit[cid][row][col].edc[1].dir_r==2||(col>0&&unit[cid][row][col-1].edc[1].dir_r==1))?36:34,
	   (unit[cid][row][col].edc[1].sel_r<<3)|(unit[cid][row][col].edc[1].dir_r<<1)|unit[cid][row][col].edc[1].d,
	   (unit[cid][row][col].edc[2].sel_r||unit[cid][row][col].edc[2].dir_r==2||(col>0&&unit[cid][row][col-1].edc[2].dir_r==1))?36:34,
	   (unit[cid][row][col].edc[2].sel_r<<3)|(unit[cid][row][col].edc[2].dir_r<<1)|unit[cid][row][col].edc[2].d,
	   unit[cid][row][col].cnd.exec?35:34,
	   unit[cid][row][col].cnd.select,
	   unit[cid][row][col].cnd.table
	   );
  }
  printf("\n");


  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|ex1:\033[1;%dm%01.1x.%01.1x.%01.1x.%01.1x.%02.2x\033[0m \033[1;%dm%01.1x.%08.8x\033[0m:\033[1;%dm%01.1x.%08.8x\033[0m \033[1;%dm%08.8x.%01.1x\033[0m",
	   unit[cid][row][col].ex1.op_r?36:34,
	   unit[cid][row][col].ex1.s1_r,
	   unit[cid][row][col].ex1.s2_r,
	   unit[cid][row][col].ex1.s3_r,
	   unit[cid][row][col].ex1.urZ_r,
	   unit[cid][row][col].ex1.op_r,
	   unit[cid][row][col].ex1.px1_r?36:34,
	   unit[cid][row][col].ex1.px1_r,
	   unit[cid][row][col].ex1.dx1,
	   unit[cid][row][col].ex1.px2_r?36:34,
	   unit[cid][row][col].ex1.px2_r,
	   unit[cid][row][col].ex1.dx2,
	   unit[cid][row][col].ex1.op_r?33:34,
	   unit[cid][row][col].ex1.d,
	   unit[cid][row][col].ex1.c
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|t1:%01.1x.%08.8x t2:%01.1x:%08.8x t3:%01.1x.%08.8x      ",
	   unit[cid][row][col].ex1.x1_r,
	   unit[cid][row][col].ex1.t1,
	   unit[cid][row][col].ex1.x2_r,
	   unit[cid][row][col].ex1.t2,
	   unit[cid][row][col].ex1.x3_r,
	   unit[cid][row][col].ex1.t3
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|ex2:%04.4x %02.2x \033[1;%dm%08.8x\033[0m-\033[1;%dm%08.8x\033[0m-\033[1;%dm%08.8x\033[0m-\033[1;%dm%08.8x\033[0m",
	   unit[cid][row][col].ex2.simmS_r,
	   unit[cid][row][col].ex2.immT_r,
	   unit[cid][row][col].ex2.ex2_fifo[0].v?36:34,
	   unit[cid][row][col].ex2.ex2_fifo[0].d,
	   unit[cid][row][col].ex2.ex2_fifo[1].v?36:34,
	   unit[cid][row][col].ex2.ex2_fifo[1].d,
	   unit[cid][row][col].ex2.ex2_fifo[2].v?36:34,
	   unit[cid][row][col].ex2.ex2_fifo[2].d,
	   unit[cid][row][col].ex2.ex2_fifo[3].v?36:34,
	   unit[cid][row][col].ex2.ex2_fifo[3].d
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|  \033[1;%dm%01.1x.%01.1x.%01.1x.%01.1x\033[0m \033[1;%dm%01.1x\033[0m \033[1;%dm%08.8x\033[0m-\033[1;%dm%08.8x\033[0m-\033[1;%dm%08.8x\033[0m-\033[1;%dm%08.8x\033[0m",
	   unit[cid][row][col].ex2.op_r?36:34,
	   unit[cid][row][col].ex2.s1_r,
	   unit[cid][row][col].ex2.s2_r,
	   unit[cid][row][col].ex2.s3_r,
	   unit[cid][row][col].ex2.op_r,
	   unit[cid][row][col].ex2.sft_r?36:34,
	   unit[cid][row][col].ex2.sft_r,
	   unit[cid][row][col].ex2.ex2_fifo[4].v?36:34,
	   unit[cid][row][col].ex2.ex2_fifo[4].d,
	   unit[cid][row][col].ex2.ex2_fifo[5].v?36:34,
	   unit[cid][row][col].ex2.ex2_fifo[5].d,
	   unit[cid][row][col].ex2.ex2_fifo[6].v?36:34,
	   unit[cid][row][col].ex2.ex2_fifo[6].d,
	   unit[cid][row][col].ex2.ex2_fifo[7].v?36:34,
	   unit[cid][row][col].ex2.ex2_fifo[7].d
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|XP%01.1x.%08.8x %01.1x.%08.8x %01.1x.%08.8x %01.1x.%08.8x.%01.1x",
	   unit[cid][row][col].ex2.x1_r,
	   unit[cid][row][col].ex2.p1_r,
	   unit[cid][row][col].ex2.x2_r,
	   unit[cid][row][col].ex2.p2_r,
	   unit[cid][row][col].ex2.x3_r,
	   unit[cid][row][col].ex2.p3_r,
	   unit[cid][row][col].ex2.dsel_r,
	   unit[cid][row][col].ex2.d,
	   unit[cid][row][col].ex2.c
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|eag:\033[1;%dms1:%01.1x s2:%01.1x.%01.1x s3:%01.1x op%03.3x\033[0m \033[1;%dm          %08.8x\033[0m  ",
	   unit[cid][row][col].eag.op_r?36:34,
	   unit[cid][row][col].eag.s1_r,
	   unit[cid][row][col].eag.s2_r,
	   unit[cid][row][col].eag.s2_suffix,
	   unit[cid][row][col].eag.s3_r,
	   unit[cid][row][col].eag.op_r,
	   unit[cid][row][col].eag.op_r?33:34,
	   unit[cid][row][col].eag.d
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|t1:%01.1x.%08.8x t2:%01.1x.%08.8x t3:%01.1x.%08.8x      ",
	   unit[cid][row][col].eag.x1_r,
	   unit[cid][row][col].eag.t1,
	   unit[cid][row][col].eag.x2_r,
	   unit[cid][row][col].eag.t2,
	   unit[cid][row][col].eag.x3_r,
	   unit[cid][row][col].eag.t3
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|mem:\033[1;%dmsel%01.1x s%08.8x.a%08.8x\033[0m emb:\033[1;%dm%01.1x.%01.1x.%01.1x.%08.8x\033[0m",
	   unit[cid][row][col].eag.op_r?36:34,
	   unit[cid][row][col].lmm.ssel_r,
	   unit[cid][row][col].lmm.s,
	   unit[cid][row][col].lmm.a,
	   (unit[cid][row][col].emb[0].sel_r||unit[cid][row][col].emb[0].dir_r==2||(col>0&&unit[cid][row][col-1].emb[0].dir_r==1))?36:34,
	   unit[cid][row][col].emb[0].sel_r,
	   unit[cid][row][col].emb[0].dir_r,
	   unit[cid][row][col].emb[0].a&0xf,
	   unit[cid][row][col].emb[0].d
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|\033[1;%dm%02.2x.%08.8x\033[0m-\033[1;%dm%02.2x.%08.8x\033[0m-\033[1;%dm%02.2x.%08.8x\033[0m-\033[1;%dm%02.2x.%08.8x\033[0m",
	   unit[cid][row][col].lmm.lmm_fifo[0].v?36:34,
	   unit[cid][row][col].lmm.lmm_fifo[0].tag<<2&0xff,
	   unit[cid][row][col].lmm.lmm_fifo[0].d,
	   unit[cid][row][col].lmm.lmm_fifo[1].v?36:34,
	   unit[cid][row][col].lmm.lmm_fifo[1].tag<<2&0xff,
	   unit[cid][row][col].lmm.lmm_fifo[1].d,
	   unit[cid][row][col].lmm.lmm_fifo[2].v?36:34,
	   unit[cid][row][col].lmm.lmm_fifo[2].tag<<2&0xff,
	   unit[cid][row][col].lmm.lmm_fifo[2].d,
	   unit[cid][row][col].lmm.lmm_fifo[3].v?36:34,
	   unit[cid][row][col].lmm.lmm_fifo[3].tag<<2&0xff,
	   unit[cid][row][col].lmm.lmm_fifo[3].d
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|\033[1;%dm%02.2x.%08.8x\033[0m-\033[1;%dm%02.2x.%08.8x\033[0m-\033[1;%dm%02.2x.%08.8x\033[0m-\033[1;%dm%02.2x.%08.8x\033[0m",
	   unit[cid][row][col].lmm.lmm_fifo[4].v?36:34,
	   unit[cid][row][col].lmm.lmm_fifo[4].tag<<2&0xff,
	   unit[cid][row][col].lmm.lmm_fifo[4].d,
	   unit[cid][row][col].lmm.lmm_fifo[5].v?36:34,
	   unit[cid][row][col].lmm.lmm_fifo[5].tag<<2&0xff,
	   unit[cid][row][col].lmm.lmm_fifo[5].d,
	   unit[cid][row][col].lmm.lmm_fifo[6].v?36:34,
	   unit[cid][row][col].lmm.lmm_fifo[6].tag<<2&0xff,
	   unit[cid][row][col].lmm.lmm_fifo[6].d,
	   unit[cid][row][col].lmm.lmm_fifo[7].v?36:34,
	   unit[cid][row][col].lmm.lmm_fifo[7].tag<<2&0xff,
	   unit[cid][row][col].lmm.lmm_fifo[7].d
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|etb:\033[1;%dm%01.1x.%01.1x.%08.8x\033[0m:\033[1;%dm%01.1x.%01.1x.%08.8x\033[0m:\033[1;%dm%01.1x.%01.1x.%08.8x\033[0m     ",
	   (unit[cid][row][col].etb[0].sel_r||unit[cid][row][col].etb[0].dir_r==2||(col>0&&unit[cid][row][col-1].etb[0].dir_r==1))?36:34,
	   unit[cid][row][col].etb[0].sel_r,
	   unit[cid][row][col].etb[0].dir_r,
	   unit[cid][row][col].etb[0].d,
	   (unit[cid][row][col].etb[1].sel_r||unit[cid][row][col].etb[1].dir_r==2||(col>0&&unit[cid][row][col-1].etb[1].dir_r==1))?36:34,
	   unit[cid][row][col].etb[1].sel_r,
	   unit[cid][row][col].etb[1].dir_r,
	   unit[cid][row][col].etb[1].d,
	   (unit[cid][row][col].etb[2].sel_r||unit[cid][row][col].etb[2].dir_r==2||(col>0&&unit[cid][row][col-1].etb[2].dir_r==1))?36:34,
	   unit[cid][row][col].etb[2].sel_r,
	   unit[cid][row][col].etb[2].dir_r,
	   unit[cid][row][col].etb[2].d
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|    \033[1;%dm%01.1x.%01.1x.%08.8x\033[0m:\033[1;%dm%01.1x.%01.1x.%08.8x\033[0m:\033[1;%dm%01.1x.%01.1x.%08.8x\033[0m     ",
	   (unit[cid][row][col].etb[3].sel_r||unit[cid][row][col].etb[3].dir_r==2||(col>0&&unit[cid][row][col-1].etb[3].dir_r==1))?36:34,
	   unit[cid][row][col].etb[3].sel_r,
	   unit[cid][row][col].etb[3].dir_r,
	   unit[cid][row][col].etb[3].d,
	   (unit[cid][row][col].etb[4].sel_r||unit[cid][row][col].etb[4].dir_r==2||(col>0&&unit[cid][row][col-1].etb[4].dir_r==1))?36:34,
	   unit[cid][row][col].etb[4].sel_r,
	   unit[cid][row][col].etb[4].dir_r,
	   unit[cid][row][col].etb[4].d,
	   (unit[cid][row][col].etb[5].sel_r||unit[cid][row][col].etb[5].dir_r==2||(col>0&&unit[cid][row][col-1].etb[5].dir_r==1))?36:34,
	   unit[cid][row][col].etb[5].sel_r,
	   unit[cid][row][col].etb[5].dir_r,
	   unit[cid][row][col].etb[5].d
	   );
  }
  printf("\n");

  for (col=UNIT_WIDTH-1; col>=0; col--) {
    printf("|XP%01.1x.%08.8x %01.1x.%08.8x %01.1x.%08.8x %01.1x.%08.8x  ",
	   unit[cid][row][col].lmm.x1_r,
	   unit[cid][row][col].lmm.p1_r,
	   unit[cid][row][col].lmm.x2_r,
	   unit[cid][row][col].lmm.p2_r,
	   unit[cid][row][col].lmm.x3_r,
	   unit[cid][row][col].lmm.p3_r,
	   unit[cid][row][col].lmm.dsel_r,
	   unit[cid][row][col].lmm.d
	   );
  }
  printf("\n");

  printf("==== ^stage%02.2d pe0_status=%01.1x offset:%02.2x edb_cmd:%01.1x->%01.1x select_row:%04.4x select_col:%01.1x ",
	 row, emax4[cid].pe0_status, emax4[cid].unit_offset, emax4[cid].unit_edb_cmd, emax4[cid].unit_edb_cmd_d1, emax4[cid].unit_select_row, emax4[cid].unit_select_col);
  printf("=================================================================================================================\n");
@
