head	1.109;
access;
symbols;
locks
	nakashim:1.109; strict;
comment	@ * @;


1.109
date	2022.10.11.08.06.49;	author nakashim;	state Exp;
branches;
next	1.108;

1.108
date	2019.10.19.12.39.55;	author nakashim;	state Exp;
branches;
next	1.107;

1.107
date	2019.10.14.01.06.44;	author nakashim;	state Exp;
branches;
next	1.106;

1.106
date	2019.02.07.13.36.59;	author nakashim;	state Exp;
branches;
next	1.105;

1.105
date	2017.04.21.03.28.57;	author nakashim;	state Exp;
branches;
next	1.104;

1.104
date	2016.11.20.06.54.35;	author nakashim;	state Exp;
branches;
next	1.103;

1.103
date	2016.11.18.16.04.34;	author nakashim;	state Exp;
branches;
next	1.102;

1.102
date	2016.06.08.03.41.26;	author nakashim;	state Exp;
branches;
next	1.101;

1.101
date	2016.05.29.05.07.22;	author nakashim;	state Exp;
branches;
next	1.100;

1.100
date	2016.05.28.15.50.12;	author nakashim;	state Exp;
branches;
next	1.99;

1.99
date	2016.05.28.14.45.25;	author nakashim;	state Exp;
branches;
next	1.98;

1.98
date	2016.05.28.08.15.06;	author nakashim;	state Exp;
branches;
next	1.97;

1.97
date	2016.05.28.06.35.32;	author nakashim;	state Exp;
branches;
next	1.96;

1.96
date	2016.05.28.02.32.12;	author nakashim;	state Exp;
branches;
next	1.95;

1.95
date	2016.05.28.01.01.36;	author nakashim;	state Exp;
branches;
next	1.94;

1.94
date	2016.05.27.14.54.56;	author nakashim;	state Exp;
branches;
next	1.93;

1.93
date	2016.05.27.08.04.22;	author nakashim;	state Exp;
branches;
next	1.92;

1.92
date	2016.05.26.23.47.09;	author nakashim;	state Exp;
branches;
next	1.91;

1.91
date	2016.05.17.05.34.34;	author nakashim;	state Exp;
branches;
next	1.90;

1.90
date	2016.05.11.14.58.55;	author nakashim;	state Exp;
branches;
next	1.89;

1.89
date	2016.05.11.14.37.57;	author nakashim;	state Exp;
branches;
next	1.88;

1.88
date	2016.05.11.12.12.13;	author nakashim;	state Exp;
branches;
next	1.87;

1.87
date	2016.05.08.11.02.17;	author nakashim;	state Exp;
branches;
next	1.86;

1.86
date	2015.10.20.23.48.02;	author nakashim;	state Exp;
branches;
next	1.85;

1.85
date	2015.09.20.23.39.05;	author nakashim;	state Exp;
branches;
next	1.84;

1.84
date	2015.09.20.11.00.53;	author nakashim;	state Exp;
branches;
next	1.83;

1.83
date	2015.09.20.09.20.06;	author nakashim;	state Exp;
branches;
next	1.82;

1.82
date	2015.09.20.08.03.18;	author nakashim;	state Exp;
branches;
next	1.81;

1.81
date	2015.09.20.06.45.12;	author nakashim;	state Exp;
branches;
next	1.80;

1.80
date	2015.09.20.05.10.19;	author nakashim;	state Exp;
branches;
next	1.79;

1.79
date	2015.09.20.04.39.20;	author nakashim;	state Exp;
branches;
next	1.78;

1.78
date	2015.09.20.03.48.25;	author nakashim;	state Exp;
branches;
next	1.77;

1.77
date	2015.09.20.02.29.28;	author nakashim;	state Exp;
branches;
next	1.76;

1.76
date	2015.09.19.17.13.30;	author nakashim;	state Exp;
branches;
next	1.75;

1.75
date	2015.09.19.14.03.58;	author nakashim;	state Exp;
branches;
next	1.74;

1.74
date	2015.09.19.11.49.58;	author nakashim;	state Exp;
branches;
next	1.73;

1.73
date	2015.09.19.09.34.18;	author nakashim;	state Exp;
branches;
next	1.72;

1.72
date	2015.09.19.09.14.03;	author nakashim;	state Exp;
branches;
next	1.71;

1.71
date	2015.09.19.08.46.30;	author nakashim;	state Exp;
branches;
next	1.70;

1.70
date	2015.09.19.08.16.27;	author nakashim;	state Exp;
branches;
next	1.69;

1.69
date	2015.09.19.07.37.48;	author nakashim;	state Exp;
branches;
next	1.68;

1.68
date	2015.09.19.04.25.46;	author nakashim;	state Exp;
branches;
next	1.67;

1.67
date	2015.09.18.05.16.18;	author nakashim;	state Exp;
branches;
next	1.66;

1.66
date	2015.09.18.04.05.38;	author nakashim;	state Exp;
branches;
next	1.65;

1.65
date	2015.09.16.14.04.52;	author nakashim;	state Exp;
branches;
next	1.64;

1.64
date	2015.09.16.13.52.08;	author nakashim;	state Exp;
branches;
next	1.63;

1.63
date	2015.09.15.14.39.57;	author nakashim;	state Exp;
branches;
next	1.62;

1.62
date	2015.09.15.12.54.59;	author nakashim;	state Exp;
branches;
next	1.61;

1.61
date	2015.09.15.12.52.39;	author nakashim;	state Exp;
branches;
next	1.60;

1.60
date	2015.09.13.14.29.07;	author nakashim;	state Exp;
branches;
next	1.59;

1.59
date	2015.09.13.10.03.52;	author nakashim;	state Exp;
branches;
next	1.58;

1.58
date	2015.09.13.07.37.47;	author nakashim;	state Exp;
branches;
next	1.57;

1.57
date	2015.09.12.15.12.00;	author nakashim;	state Exp;
branches;
next	1.56;

1.56
date	2015.09.08.09.32.50;	author nakashim;	state Exp;
branches;
next	1.55;

1.55
date	2015.09.08.06.45.45;	author nakashim;	state Exp;
branches;
next	1.54;

1.54
date	2015.09.08.06.17.30;	author nakashim;	state Exp;
branches;
next	1.53;

1.53
date	2015.09.06.10.18.56;	author nakashim;	state Exp;
branches;
next	1.52;

1.52
date	2015.09.06.07.45.55;	author nakashim;	state Exp;
branches;
next	1.51;

1.51
date	2015.09.06.05.41.35;	author nakashim;	state Exp;
branches;
next	1.50;

1.50
date	2015.09.06.04.46.05;	author nakashim;	state Exp;
branches;
next	1.49;

1.49
date	2015.09.05.14.54.19;	author nakashim;	state Exp;
branches;
next	1.48;

1.48
date	2015.09.03.23.55.02;	author nakashim;	state Exp;
branches;
next	1.47;

1.47
date	2015.09.03.14.01.21;	author nakashim;	state Exp;
branches;
next	1.46;

1.46
date	2015.09.01.06.36.18;	author nakashim;	state Exp;
branches;
next	1.45;

1.45
date	2015.09.01.06.13.33;	author nakashim;	state Exp;
branches;
next	1.44;

1.44
date	2015.09.01.06.05.16;	author nakashim;	state Exp;
branches;
next	1.43;

1.43
date	2015.09.01.05.35.03;	author nakashim;	state Exp;
branches;
next	1.42;

1.42
date	2015.09.01.01.49.37;	author nakashim;	state Exp;
branches;
next	1.41;

1.41
date	2015.08.31.13.41.16;	author nakashim;	state Exp;
branches;
next	1.40;

1.40
date	2015.08.31.05.00.07;	author nakashim;	state Exp;
branches;
next	1.39;

1.39
date	2015.08.31.04.16.21;	author nakashim;	state Exp;
branches;
next	1.38;

1.38
date	2015.08.31.03.30.20;	author nakashim;	state Exp;
branches;
next	1.37;

1.37
date	2015.08.30.23.57.26;	author nakashim;	state Exp;
branches;
next	1.36;

1.36
date	2015.08.30.13.24.30;	author nakashim;	state Exp;
branches;
next	1.35;

1.35
date	2015.08.30.13.15.31;	author nakashim;	state Exp;
branches;
next	1.34;

1.34
date	2015.08.30.11.00.22;	author nakashim;	state Exp;
branches;
next	1.33;

1.33
date	2015.08.29.15.52.28;	author nakashim;	state Exp;
branches;
next	1.32;

1.32
date	2015.08.29.14.21.22;	author nakashim;	state Exp;
branches;
next	1.31;

1.31
date	2015.08.28.00.26.45;	author nakashim;	state Exp;
branches;
next	1.30;

1.30
date	2015.08.28.00.03.46;	author nakashim;	state Exp;
branches;
next	1.29;

1.29
date	2015.08.27.06.47.08;	author nakashim;	state Exp;
branches;
next	1.28;

1.28
date	2015.08.26.08.33.20;	author nakashim;	state Exp;
branches;
next	1.27;

1.27
date	2015.08.26.00.19.51;	author nakashim;	state Exp;
branches;
next	1.26;

1.26
date	2015.08.25.13.36.46;	author nakashim;	state Exp;
branches;
next	1.25;

1.25
date	2015.08.25.11.04.16;	author nakashim;	state Exp;
branches;
next	1.24;

1.24
date	2015.08.25.10.42.04;	author nakashim;	state Exp;
branches;
next	1.23;

1.23
date	2015.08.25.09.58.40;	author nakashim;	state Exp;
branches;
next	1.22;

1.22
date	2015.08.25.08.06.35;	author nakashim;	state Exp;
branches;
next	1.21;

1.21
date	2015.08.25.07.13.32;	author nakashim;	state Exp;
branches;
next	1.20;

1.20
date	2015.08.25.06.50.05;	author nakashim;	state Exp;
branches;
next	1.19;

1.19
date	2015.08.25.04.23.36;	author nakashim;	state Exp;
branches;
next	1.18;

1.18
date	2015.08.24.23.41.06;	author nakashim;	state Exp;
branches;
next	1.17;

1.17
date	2015.08.24.13.19.00;	author nakashim;	state Exp;
branches;
next	1.16;

1.16
date	2015.08.24.06.02.10;	author nakashim;	state Exp;
branches;
next	1.15;

1.15
date	2015.08.24.05.01.30;	author nakashim;	state Exp;
branches;
next	1.14;

1.14
date	2015.08.23.14.16.57;	author nakashim;	state Exp;
branches;
next	1.13;

1.13
date	2015.08.23.09.04.56;	author nakashim;	state Exp;
branches;
next	1.12;

1.12
date	2015.08.23.09.04.07;	author nakashim;	state Exp;
branches;
next	1.11;

1.11
date	2015.08.23.05.57.44;	author nakashim;	state Exp;
branches;
next	1.10;

1.10
date	2015.08.23.04.11.54;	author nakashim;	state Exp;
branches;
next	1.9;

1.9
date	2015.08.22.13.52.55;	author nakashim;	state Exp;
branches;
next	1.8;

1.8
date	2015.08.22.11.47.27;	author nakashim;	state Exp;
branches;
next	1.7;

1.7
date	2015.08.22.04.49.17;	author nakashim;	state Exp;
branches;
next	1.6;

1.6
date	2015.08.20.09.29.03;	author nakashim;	state Exp;
branches;
next	1.5;

1.5
date	2015.08.17.12.34.08;	author nakashim;	state Exp;
branches;
next	1.4;

1.4
date	2015.08.16.12.50.07;	author nakashim;	state Exp;
branches;
next	1.3;

1.3
date	2015.08.16.03.35.25;	author nakashim;	state Exp;
branches;
next	1.2;

1.2
date	2015.08.15.15.03.22;	author nakashim;	state Exp;
branches;
next	1.1;

1.1
date	2015.07.21.05.44.37;	author nakashim;	state Exp;
branches;
next	;


desc
@@


1.109
log
@*** empty log message ***
@
text
@
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/decode.c,v 1.108 2019/10/19 12:39:55 nakashim Exp nakashim $";

/* ARM Instruction Simulator           */
/*        Copyright (C) 2007 by NAIST. */
/*         Primary writer: Y.Nakashima */
/*                nakashim@@is.naist.jp */

/* decode.c 2005/3/22 */ 

/* armi[Q_ARMI] ¤«¤é hst1[Q_HSTC] ¤Ø */

#include "csim.h"

insn_decode(tid, mc, pc, i, rob) Uint tid, mc, pc; union armf i; struct rob *rob;
{
  /* return 0:normal end, 1:continue (ex. LDP/STP), 2:error */
  Uint cid = tid2cid(tid);
  Uint robid = rob-&c[cid].rob[0];
  Uint s, rm, obits, bits;
  Uint s1, s2, s3, v0, v1;
  int  j, k, l;

  rob->stat   = ROB_MAPPED;
  rob->term   = 1;
  rob->tid    = tid;
  rob->pc     = pc;
  rob->target = pc+4;
  rob->bpred  = 0; /* not taken */
  rob->cond   = 14; /* always */
  rob->sop    = 0;
  rob->ptw    = 0;
  rob->size   = 0;
  rob->idx    = 0;
  rob->rep    = 0;
  rob->dir    = 0;
  rob->iinv   = 0; /* invert operand2 */
  rob->oinv   = 0; /* invert result */
  rob->dbl    = 0; /* 0:single, 1:double */
  rob->plus   = 0; /* EAG */
  rob->pre    = 0; /* EAG */
  rob->wb     = 0; /* EAG */
  rob->updt   = 0; /* update CC */
  rob->sr[0].t  = 0; /* src1 */
  rob->sr[1].t  = 0; /* src2 */
  rob->sr[2].t  = 0; /* src3 */
  rob->sr[3].t  = 0; /* aux-src */
  rob->sr[4].t  = 0; /* aux-src */
  rob->sr[5].t  = 0; /* in-cc for conditional exec */
  rob->dr[1].t    = 0; /* out-reg */
  rob->dr[1].p    = robid;
  rob->dr[1].mask[0] = 0x00000000;
  rob->dr[1].val[0] = 0x00000000;
  rob->dr[1].mask[1] = 0x00000000;
  rob->dr[1].val[1] = 0x00000000;
  rob->dr[2].t    = 0;
  rob->dr[2].p    = robid;
  rob->dr[2].mask[0] = 0x00000000;
  rob->dr[2].val[0]  = 0x00000000;
  rob->dr[2].mask[1] = 0x00000000;
  rob->dr[2].val[1]  = 0x00000000;
  rob->dr[3].t    = 0; /* out-cc */
  rob->dr[3].p    = robid;
  rob->dr[3].mask[0] = 0x00000000;
  rob->dr[3].val[0]  = 0x00000000;
  rob->dr[3].mask[1] = 0x00000000;
  rob->dr[3].val[1]  = 0x00000000;
  rob->ls_addr  = 0;
  rob->stbf.t   = 0;

  /* 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 */
  /*  1     0  0  1  0  0  0  0  0  0                 1  1  1  1  1  1 stlxr                         */
  /*  1     0  0  1  0  0  0  0  1  0  1  1  1  1  1  1  1  1  1  1  1 ldaxr                         */
  /*           0  1  0  1  0           and_shifted                                                   */
  /*           0  1  0  1  1        0  add_sub_shifted                                               */
  /*           0  1  0  1  1  0  0  1  add_sub_extreg                                                */
  /*        1  0  1  0  0              ldp_stp                                                       */
  /*        1  0  1  1  0              ldp_stp(simd&fp)                                              */
  /*  0     0  0  1  1  0  0        0  ld1_st1_mult                                                  */
  /*  0     0  0  1  1  0  1           ld1_st1_sing   x  x     x                                     */
  /*  0     0  0  1  1  0  1           ld1_st1_(repl) 1  1     0                                     */
  /*  0     0  0  1  1  1  0  0  0  0                 0  0  0  0  0  1 dup_vec                       */
  /*  0     0  0  1  1  1  0  0  0  0                 0  0  0  0  1  1 dup_general                   */
  /*  0  1  0  0  1  1  1  0  0  0  0                 0  0  0  1  1  1 mov/ins                       */
  /*  0     0  0  1  1  1  0  0  0  0                 0  0  1  1  1  1 mov/umov                      */
  /*  0     0  0  1  1  1  0        1                 0  0  0  1  1  1 and/orr(vector)               */
  /*  0     0  0  1  1  1  0        1  0  0  0  0  1  0  0  1  0  1  0 xtn,xtn2                      */
  /*  0        0  1  1  1  0        1                 0  1  1  0     1 maxmin                        */
  /*  0        0  1  1  1  0        1                 1  0  0  0  0  1 add/sub(vector)               */
  /*  0        0  1  1  1  0        1                 1  0  0  1  0  1 mla/mls(vector)               */
  /*  0        0  1  1  1  0        1                 1  1  0  1  0  1 fadd(vector)                  */
  /*  0     0  0  1  1  1  0        1                 1  1  0  0  1  1 fmla(vector)                  */
  /*  0        0  1  1  1  0        1                 1  0  0  0  1  1 cmtst/eq(vector)              */
  /*  0        0  1  1  1  0        1                 0  0  1  1  0  1 cmgt/hi(vector)               */
  /*  0        0  1  1  1  0        1                 0  0  1  1  1  1 cmge/hs(vector)               */
  /*  0     1  0  1  1  1  0        1                 0  0  0  1  1  1 bitwise(eor/bsl/bit/bif)      */
  /*  0     1  0  1  1  1  0  0     1                 1  1  0  1  1  1 fmul(vector)                  */
  /*  0        0  1  1  1  1  0  0  0  0  0                       0  1 movi                          */
  /*  0        0  1  1  1  1  0  -immh!=0--           0  0  0  0  0  1 sshr,ushr(vector)             */
  /*  0        0  1  1  1  1  0  -immh!=0--           1  0  1  0  0  1 ushll,ushll2                  */
  /*           1  0  0  0  0           adr                                                           */
  /*           1  0  0  0  1           add_sub_imm                                                   */
  /*           1  0  0  1  0  0        and_imm                                                       */
  /*           1  0  0  1  0  1        mov                                                           */
  /*           1  0  0  1  1  0        sft_imm                                                       */
  /*     0  0  1  0  0  1  1  1     0  ror_imm                                                       */
  /*     0  0  1  0  1                 bl                                                            */
  /*     0  1  1  0  1  0              cbz                                                           */
  /*     0  1  1  0  1  1              tbz                                                           */
  /*  0  1  0  1  0  1  0  0           b_cond                                          0             */
  /*  1  1  0  1  0  1  0  0  0  0  0                                  svc             0  0  0  0  1 */
  /*  1  1  0  1  0  1  1  0  0        1  1  1  1  1  0  0  0  0  0  0 blr             0  0  0  0  0 */
  /*        0  1  1  0  0  0           ldr_str_literal                                               */
  /*        1  1  1  0  0  0        1  ldr_str_reg                1  0                               */
  /*        1  1  1  1  0  0        1  ldr_str_reg(simd)          1  0                               */
  /*        1  1  1  0  0  0        0  ldr_str_unsc               0  0                               */
  /*        1  1  1  0  0  0        0  ldr_str_imm(post)          0  1                               */
  /*        1  1  1  0  0  0        0  ldr_str_imm(pre)           1  1                               */
  /*        1  1  1  0  0  1           ldr_str_imm(uns)                                              */
  /*           1  1  0  1  0  0  0  0  adc_sbc        0  0  0  0  0  0                               */
  /*        1  1  1  0  1  0  0  1  0  ccm                                             0             */
  /*        0  1  1  0  1  0  1  0  0  csel                       0                                  */
  /*     0  0  1  1  0  1  0  1  1  0  sft_reg        0  0  1  0                                     */
  /*  1  0  0  1  1  0  1  0  1  1  0                 0  0  0  0  1  0 udiv                          */
  /*  1  0  0  1  1  0  1  0  1  1  0                 0  0  0  0  1  1 sdiv                          */
  /*     1  0  1  1  0  1  0  1  1  0  0  0  0  0  0  0  0  0  0       rev                           */
  /*     1  0  1  1  0  1  0  1  1  0  0  0  0  0  0  0  0  0  1  0    cls                           */
  /*     0  0  1  1  0  1  1  0  0  0  mad                                                           */
  /*  1  0  0  1  1  0  1  1     0  1  mad                                                           */
  /*  1  0  0  1  1  0  1  1  0  1  0                 0  1  1  1  1  1 smulh                         */
  /*  1  0  0  1  1  0  1  1  1  1  0                 0  1  1  1  1  1 umulh                         */
  /*        0  1  1  1  0  0           ldr_str_literal(simd&fp)                                      */
  /*        1  1  1  1  0  0     1  0  ldur(simd&fp)              0  0                               */
  /*        1  1  1  1  0  0        0  ldr_str_imm(post,simd&fp)  0  1                               */
  /*        1  1  1  1  0  0        0  ldr_str_imm(pre,simd&fp)   1  1                               */
  /*        1  1  1  1  0  1           ldr_str_imm(uns,simd&fp)                                      */
  /*     0  0  1  1  1  1  0        1  fmov(general)  0  0  0  0  0  0                               */
  /*  0  0  0  1  1  1  1  0        1  fmov(scalar,immediate)  1  0  0  0  0  0  0  0                */
  /*  0  0  0  1  1  1  1  0        1  fadds          0  0  1     1  0                               */
  /*  0  0  0  1  1  1  1  0        1  fmul(scalar)      0  0  0  1  0                               */
  /*  0  0  0  1  1  1  1  0        1  fdiv(scalar)   0  0  0  1  1  0                               */
  /*  0  0  0  1  1  1  1  0  0  x  1                 0  0  1  0  0  0 fcmp            0  x  0  0  0 */
  /*  0  0  0  1  1  1  1  0  0  x  1                 0  0  1  0  0  0 fcmpe           1  x  0  0  0 */
  /*  0  0  0  1  1  1  1  0  0  x  1  0  0  0  0        1  0  0  0  0 fmov(register)                */
  /*  0  0  0  1  1  1  1  0        1  0  0  0  1        1  0  0  0  0 fcvt(scalar)                  */
  /*  0  0  0  1  1  1  1  0  0  x  1  0  0  1  0  1  0  1  0  0  0  0 frintm(scalar)                */
  /*  0  1     1  1  1  1  0        1                 1  0  0  0  0  1 add/sub(scalar)               */
  /*  0  1     1  1  1  1  0  1  1  1                 1  0  0  0  1  1 cmtst/eq(scalar)              */
  /*  0  1     1  1  1  1  0  1  1  1                 0  0  1  1  0  1 cmgt/hi(scalar)               */
  /*  0  1     1  1  1  1  0  1  1  1                 0  0  1  1  1  1 cmge/hs(scalar)               */
  /*  0  0  0  1  1  1  1  1                                           fmadd                         */
  /*  0  1     1  1  1  1  1  0  -immh!=0--           0  0  0  0  0  1 sshr,ushr(scalar)             */
  /*  0  1  0  1  1  1  1  1  0  -immh!=0--           0  1  0  1  0  1 shl(scalar)                   */

  if (i.adr.op28_24==0x10) { /* C6.6.9 ADR, C6.6.10 ADRP */
    Ull offset = i.adr.op ? (Sll)(((Ull)i.adr.immhi<<45)|((Ull)i.adr.immlo<<43))>>31 : (Sll)(((Ull)i.adr.immhi<<45)|((Ull)i.adr.immlo<<43))>>43;
    rob->type  = 0; /* ALU */
    rob->opcd  = 4; /* ADD */
    rob->sop   = 0; /* LSL */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 1; /* always 64bit */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = 1; /* PC */
    rob->sr[0].x = 0; /* renamig N.A. */
    rob->sr[0].n = i.adr.op ? pc&0xfffff000 : pc; /* PC */
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = offset;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = 0; /* LSL 0 */
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = i.adr.rd;
    t[tid].map[i.adr.rd].x = 1;
    t[tid].map[i.adr.rd].rob = robid;
    return (0);
  }
  else if (i.add_sub_imm.op28_24==0x11) { /* C6.6.4 ADD(immediate), C6.6.7 ADDS(immediate), C6.6.42 CMN(immediate), C6.6.45 CMP(immediate), C6.6.121 MOV(to/from SP), C6.6.195 SUB(immediate), C6.6.198 SUBS(immediate) */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.add_sub_imm.op==0?4:2; /* ADD/SUB */
    rob->sop   = 0; /* LSL */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.add_sub_imm.sf; /* 0:add32, 1:add64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = i.add_sub_imm.S;
    rob->sr[0].t = !t[tid].map[i.add_sub_imm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.add_sub_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.add_sub_imm.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.add_sub_imm.rn].x ? i.add_sub_imm.rn : t[tid].map[i.add_sub_imm.rn].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = i.add_sub_imm.shift==0?(Ull)i.add_sub_imm.imm12:(Ull)(i.add_sub_imm.imm12<<12);
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = 0; /* LSL 0 */
    /* dest */
    if (i.add_sub_imm.rd!=31 || !i.add_sub_imm.S) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.add_sub_imm.rd;
      t[tid].map[i.add_sub_imm.rd].x = 1;
      t[tid].map[i.add_sub_imm.rd].rob = robid;
    }
    if (i.add_sub_imm.S) {
      rob->dr[3].t = 1; /* nzcv */
      rob->dr[3].n = CPSREGTOP;
      t[tid].map[CPSREGTOP].x = 3;
      t[tid].map[CPSREGTOP].rob = robid;
    }
    return (0);
  }
  else if (i.adc_sbc.op28_21==0xd0 && i.adc_sbc.op15_10==0) { /* C6.6.1 ADC, C6.6.2 ADCS, C6.6.137 NGC, C6.6.138 NGCS, C6.6.155 SBC, C6.6.156 SBCS */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.adc_sbc.op==0?5:6; /* ADC/SBC */
    rob->sop   = 0; /* LSL */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.adc_sbc.sf; /* 0:adc32, 1:adc64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = i.adc_sbc.S;
    rob->sr[0].t = i.adc_sbc.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.adc_sbc.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.adc_sbc.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.adc_sbc.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.adc_sbc.rn].x; /* reg */
    rob->sr[0].n = i.adc_sbc.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.adc_sbc.rn].x ? i.adc_sbc.rn : t[tid].map[i.adc_sbc.rn].rob;
    rob->sr[1].t = i.adc_sbc.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.adc_sbc.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.adc_sbc.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.adc_sbc.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.adc_sbc.rm].x; /* reg */
    rob->sr[1].n = i.adc_sbc.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.adc_sbc.rm].x ? i.adc_sbc.rm : t[tid].map[i.adc_sbc.rm].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = 0; /* LSL 0 */
    rob->sr[5].t = !t[tid].map[CPSREGTOP].x ? 2 : (c[cid].rob[t[tid].map[CPSREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* cpsr */
    rob->sr[5].x =  t[tid].map[CPSREGTOP].x; /* cpsr */
    rob->sr[5].n = !t[tid].map[CPSREGTOP].x ? CPSREGTOP : t[tid].map[CPSREGTOP].rob;
    /* dest */
    if (i.adc_sbc.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.adc_sbc.rd;
      t[tid].map[i.adc_sbc.rd].x = 1;
      t[tid].map[i.adc_sbc.rd].rob = robid;
    }
    if (i.adc_sbc.S) {
      rob->dr[3].t = 1; /* nzcv */
      rob->dr[3].n = CPSREGTOP;
      t[tid].map[CPSREGTOP].x = 3;
      t[tid].map[CPSREGTOP].rob = robid;
    }
    return (0);
  }
  else if (i.csel.op29_21==0x0d4 && i.csel.op11==0) { /* C6.6.36 CINC, C6.6.37 CINV, C6.6.47 CNEG, C6.6.50 CSEL, C6.6.51 CSET, C6.6.52 CSETM, C6.6.53 CSINC, C6.6.54 CSINV, C6.6.55 CSNEG */
    rob->type  = 0; /* ALU */
    rob->opcd  =10; /* CSEL */
    rob->sop   = 0; /* LSL */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = i.csel.op; /* 0:result, 1:~result */
    rob->dbl   = i.csel.sf; /* 0:csel32, 1:csel64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.csel.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.csel.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.csel.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.csel.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.csel.rn].x; /* reg */
    rob->sr[0].n = i.csel.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.csel.rn].x ? i.csel.rn : t[tid].map[i.csel.rn].rob;
    rob->sr[1].t = i.csel.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.csel.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.csel.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.csel.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.csel.rm].x; /* reg */
    rob->sr[1].n = i.csel.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.csel.rm].x ? i.csel.rm : t[tid].map[i.csel.rm].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = 0; /* LSL 0 */
    rob->sr[3].t = 1; /* immediate */
    rob->sr[3].x = 0; /* renamig N.A. */
    rob->sr[3].n = i.csel.cond;
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = i.csel.o2; /* o2(inc=1) */
    rob->sr[5].t = !t[tid].map[CPSREGTOP].x ? 2 : (c[cid].rob[t[tid].map[CPSREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* cpsr */
    rob->sr[5].x =  t[tid].map[CPSREGTOP].x; /* cpsr */
    rob->sr[5].n = !t[tid].map[CPSREGTOP].x ? CPSREGTOP : t[tid].map[CPSREGTOP].rob;
    /* dest */
    if (i.csel.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.csel.rd;
      t[tid].map[i.csel.rd].x = 1;
      t[tid].map[i.csel.rd].rob = robid;
    }
    return (0);
  }
  else if (i.ccm.op29_21==0x1d2 && i.ccm.op4==0) { /* C6.6.32 CCMN(immediate), C6.6.33 CCMN(register), C6.6.34 CCMP(immediate), C6.6.35 CCMP(register) */
    rob->type  = 0; /* ALU */
    rob->opcd  =11; /* CCMN/CCMP */
    rob->sop   = 0; /* LSL */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.ccm.op==1; /* CCMP */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.ccm.sf; /* 0:ccmp32, 1:ccmp64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.ccm.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.ccm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ccm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.ccm.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.ccm.rn].x; /* reg */
    rob->sr[0].n = i.ccm.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.ccm.rn].x ? i.ccm.rn : t[tid].map[i.ccm.rn].rob;
    switch (i.ccm.op11_10) {
    case 0: /* register */
      rob->sr[1].t = i.ccm.rm_imm5==31 ? 1 : /* ZERO */
                     !t[tid].map[i.ccm.rm_imm5].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ccm.rm_imm5].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[1].x = i.ccm.rm_imm5==31 ? 0 : /* ZERO */
                     t[tid].map[i.ccm.rm_imm5].x; /* reg */
      rob->sr[1].n = i.ccm.rm_imm5==31 ? 0 : /* ZERO */
                     !t[tid].map[i.ccm.rm_imm5].x ? i.ccm.rm_imm5 : t[tid].map[i.ccm.rm_imm5].rob;
      break;
    case 2: /* immediate */
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = i.ccm.rm_imm5;
      break;
    default:
      i_xxx(rob);
      return (0);
    }
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = 0; /* LSL 0 */
    rob->sr[3].t = 1; /* immediate */
    rob->sr[3].x = 0; /* renamig N.A. */
    rob->sr[3].n = i.ccm.cond;
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = i.ccm.nzcv;
    rob->sr[5].t = !t[tid].map[CPSREGTOP].x ? 2 : (c[cid].rob[t[tid].map[CPSREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* cpsr */
    rob->sr[5].x =  t[tid].map[CPSREGTOP].x; /* cpsr */
    rob->sr[5].n = !t[tid].map[CPSREGTOP].x ? CPSREGTOP : t[tid].map[CPSREGTOP].rob;
    /* dest */
    rob->dr[3].t = 1; /* nzcv */
    rob->dr[3].n = CPSREGTOP;
    t[tid].map[CPSREGTOP].x = 3;
    t[tid].map[CPSREGTOP].rob = robid;
    return (0);
  }
  else if (i.mov.op28_23==0x25) { /* C6.6.122 MOV(inverted wide immediate), C6.6.123 MOV(wide immediate), C6.6.126 MOVK, C6.6.127 MOVN, C6.6.128 MOVZ */
    rob->type  = 0; /* ALU */
    rob->opcd  = 7; /* MOVN, MOVZ, MOVK */
    rob->sop   = 0; /* LSL */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = i.mov.opc==0; /* MOVN */
    rob->dbl   = i.mov.sf; /* 0:add32, 1:add64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    {
      Uint pos = i.mov.hw<<4;
      Uint inzero;
      switch (i.mov.opc) {
      case 0: inzero=1; break; /* MOVN */
      case 2: inzero=1; break; /* MOVZ */
      case 3: inzero=0; break; /* MOVK */
      default:
        i_xxx(rob);
        return (0);
      }
      rob->sr[0].t = inzero ? 1 : /* ZERO */
                     !t[tid].map[i.mov.rd].x ? 2 :
                     (c[cid].rob[t[tid].map[i.mov.rd].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = inzero ? 0 : /* ZERO */
                     t[tid].map[i.mov.rd].x; /* reg */
      rob->sr[0].n = inzero ? 0 : /* ZERO */
                     !t[tid].map[i.mov.rd].x ? i.mov.rd : t[tid].map[i.mov.rd].rob;
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = (Ull)i.mov.imm16<<pos; /* POS 0,16,32,48 -> wmask in alu.c */
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = 0; /* LSL 0 */
      rob->sr[3].t = 1; /* immediate */
      rob->sr[3].x = 0; /* renamig N.A. */
      rob->sr[3].n = 0x000000000000FFFFLL<<pos; /* POS 0,16,32,48 -> wmask in alu.c */
    }
    /* dest */
    if (i.mov.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.mov.rd;
      t[tid].map[i.mov.rd].x = 1;
      t[tid].map[i.mov.rd].rob = robid;
    }
    return (0);
  }
  else if (i.rev.op30_12==0x5ac00) { /* C6.6.147 RBIT, C6.6.149 REV, C6.6.150 REV16, C6.6.151 REV32 */
    rob->type  = 0; /* ALU */
    rob->opcd  =12; /* REV */
    rob->sop   = 0; /* LSL */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.rev.sf; /* 0:rev32, 1:rev64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.rev.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.rev.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.rev.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.rev.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.rev.rn].x; /* reg */
    rob->sr[0].n = i.rev.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.rev.rn].x ? i.rev.rn : t[tid].map[i.rev.rn].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = i.rev.opc; /* 0:REV, 1:REV16, 2:REV32, 3:REV64 */
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = 0; /* LSL 0 */
    /* dest */
    if (i.rev.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.rev.rd;
      t[tid].map[i.rev.rd].x = 1;
      t[tid].map[i.rev.rd].rob = robid;
    }
    return (0);
  }
  else if (i.cls.op30_11==0xb5802) { /* C6.6.39 CLS, C6.6.40 CLZ */
    rob->type  = 0; /* ALU */
    rob->opcd  =13; /* CLS/CLZ */
    rob->sop   = 0; /* LSL */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.cls.sf; /* 0:cls32, 1:cls64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.cls.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.cls.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.cls.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.cls.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.cls.rn].x; /* reg */
    rob->sr[0].n = i.cls.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.cls.rn].x ? i.cls.rn : t[tid].map[i.cls.rn].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = i.cls.op; /* 0:CLZ, 1:CLS */
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = 0; /* LSL 0 */
    /* dest */
    if (i.cls.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.cls.rd;
      t[tid].map[i.cls.rd].x = 1;
      t[tid].map[i.cls.rd].rob = robid;
    }
    return (0);
  }
  else if (i.add_sub_shifted.op28_24==0x0b && i.add_sub_shifted.op21==0) { /* C6.6.5 ADD(shifted register), C6.6.8 ADDS(shifted register), C6.6.43 CMN(shifted register), C6.6.46 CMP(shifted register), C6.6.135 NEG(shifted register), C6.6.136 NEGS(shifted register), C6.6.196 SUB(shifted register), C6.6.199 SUBS(shifted register) */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.add_sub_shifted.op==0?4:2; /* ADD/SUB */
    rob->sop   = i.add_sub_shifted.shift; /* LSL/LSR/ASR/ROR */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.add_sub_shifted.sf; /* 0:add32, 1:add64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = i.add_sub_shifted.S; /* updtCC */
    rob->sr[0].t = i.add_sub_shifted.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.add_sub_shifted.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.add_sub_shifted.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.add_sub_shifted.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.add_sub_shifted.rn].x; /* reg */
    rob->sr[0].n = i.add_sub_shifted.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.add_sub_shifted.rn].x ? i.add_sub_shifted.rn : t[tid].map[i.add_sub_shifted.rn].rob;
    rob->sr[1].t = i.add_sub_shifted.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.add_sub_shifted.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.add_sub_shifted.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.add_sub_shifted.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.add_sub_shifted.rm].x; /* reg */
    rob->sr[1].n = i.add_sub_shifted.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.add_sub_shifted.rm].x ? i.add_sub_shifted.rm : t[tid].map[i.add_sub_shifted.rm].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = i.add_sub_shifted.imm6; /* LSL/LSR/ASR/ROR */
    /* dest */
    if (i.add_sub_shifted.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.add_sub_shifted.rd;
      t[tid].map[i.add_sub_shifted.rd].x = 1;
      t[tid].map[i.add_sub_shifted.rd].rob = robid;
    }
    if (i.add_sub_shifted.S) { /* updtCC */
      rob->dr[3].t = 1; /* nzcv */
      rob->dr[3].n = CPSREGTOP;
      t[tid].map[CPSREGTOP].x = 3;
      t[tid].map[CPSREGTOP].rob = robid;
    }
    return (0);
  }
  else if (i.add_sub_extreg.op28_24==0x0b && i.add_sub_extreg.op23_22==0 && i.add_sub_extreg.op21==1) { /* C6.6.3 ADD(extended register), C6.6.6 ADDS(extended register), C6.6.41 CMN(extended register), C6.6.44 CMP(extended register), C6.6.194 SUB(extended register), C6.6.197 SUBS(extended register) */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.add_sub_extreg.op==0?4:2; /* ADD/SUB */
    rob->sop   = 8|i.add_sub_extreg.option; /* 0:uxtb, 1:uxth, 2:uxtw, 3:uxtx, 4:sxtb, 5:sxth, 6:sxtw, 7:sxtx */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.add_sub_extreg.sf; /* 0:add32, 1:add64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = i.add_sub_extreg.S; /* updtCC */
    rob->sr[0].t = !t[tid].map[i.add_sub_extreg.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.add_sub_extreg.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.add_sub_extreg.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.add_sub_extreg.rn].x ? i.add_sub_extreg.rn : t[tid].map[i.add_sub_extreg.rn].rob;
    rob->sr[1].t = i.add_sub_extreg.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.add_sub_extreg.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.add_sub_extreg.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.add_sub_extreg.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.add_sub_extreg.rm].x; /* reg */
    rob->sr[1].n = i.add_sub_extreg.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.add_sub_extreg.rm].x ? i.add_sub_extreg.rm : t[tid].map[i.add_sub_extreg.rm].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = i.add_sub_extreg.imm3; /* extend_reg_shift(0,1,2,3,4) */
    /* dest */
    if (i.add_sub_extreg.rd!=31 || !i.add_sub_extreg.S) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.add_sub_extreg.rd;
      t[tid].map[i.add_sub_extreg.rd].x = 1;
      t[tid].map[i.add_sub_extreg.rd].rob = robid;
    }
    if (i.add_sub_extreg.S) { /* updtCC */
      rob->dr[3].t = 1; /* nzcv */
      rob->dr[3].n = CPSREGTOP;
      t[tid].map[CPSREGTOP].x = 3;
      t[tid].map[CPSREGTOP].rob = robid;
    }
    return (0);
  }
  else if (i.and_shifted.op28_24==0x0a) { /* C6.6.12 AND(shifted register), C6.6.14 ANDS(shifted register), C6.6.24 BIC(shifted register), C6.6.25 BICS(shifted register), C6.6.63 EON(shifted register), C6.6.65 EOR(shifted register), C6.6.125 MOV(register), C6.6.134 MVN(register), C6.6.140 ORN(shifted register), C6.6.142 ORR(shifted register), C6.6.210 TST(shifted register) */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.and_shifted.opc==0?0:i.and_shifted.opc==1?3:i.and_shifted.opc==2?1:0; /* AND/ORR/EOR/ANDS */
    rob->sop   = i.and_shifted.shift; /* LSL/LSR/ASR/ROR */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.and_shifted.N; /* invert */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.and_shifted.sf; /* 0:and32, 1:and64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = i.and_shifted.opc==3; /* ANDS */
    rob->sr[0].t = i.and_shifted.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.and_shifted.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.and_shifted.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.and_shifted.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.and_shifted.rn].x; /* reg */
    rob->sr[0].n = i.and_shifted.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.and_shifted.rn].x ? i.and_shifted.rn : t[tid].map[i.and_shifted.rn].rob;
    rob->sr[1].t = i.and_shifted.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.and_shifted.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.and_shifted.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.and_shifted.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.and_shifted.rm].x; /* reg */
    rob->sr[1].n = i.and_shifted.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.and_shifted.rm].x ? i.and_shifted.rm : t[tid].map[i.and_shifted.rm].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = i.and_shifted.imm6; /* LSL/LSR/ASR/ROR */
    /* dest */
    if (i.and_shifted.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.and_shifted.rd;
      t[tid].map[i.and_shifted.rd].x = 1;
      t[tid].map[i.and_shifted.rd].rob = robid;
    }
    if (i.and_shifted.opc==3) { /* ANDS */
      rob->dr[3].t = 1; /* nzcv */
      rob->dr[3].n = CPSREGTOP;
      t[tid].map[CPSREGTOP].x = 3;
      t[tid].map[CPSREGTOP].rob = robid;
    }
    return (0);
  }
  else if (i.and_imm.op28_23==0x24) { /* C6.6.11 AND(immediate), C6.6.13 ANDS(immediate), C6.6.64 EOR(immediate), C6.6.124 MOV(bitmask immediate), C6.6.141 ORR(immediate), C6.6.209 TST(immediate) */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.and_imm.opc==0?0:i.and_imm.opc==1?3:i.and_imm.opc==2?1:0; /* AND/ORR/EOR/ANDS */
    rob->sop   = 0; /* LSL */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0;
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.and_imm.sf; /* 0:and32, 1:and64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = i.and_imm.opc==3; /* ANDS */
    rob->sr[0].t = i.and_imm.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.and_imm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.and_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.and_imm.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.and_imm.rn].x; /* reg */
    rob->sr[0].n = i.and_imm.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.and_imm.rn].x ? i.and_imm.rn : t[tid].map[i.and_imm.rn].rob;
    {
      int imm, len, levels, esize;
      Uint S, R;
      Ull welem, wmask;
      imm = (i.and_imm.N<<6)|((~i.and_imm.imms)&0x3f);
      for (len=6; len>=0; len--) {
        if ((imm>>len)&1)
          break;
      }
      if (len < 1) { /* reserved */
        i_xxx(rob);
        return (0);
      }
                                                           /* len=1  len=2  len=3  len=4  len=5  len=6  */
      levels = (Uint)((int)0x80000000>>(len-1))>>(32-len); /* 000001,000011,000111,001111,011111,111111 */
      S = (Uint)(i.and_imm.imms & levels);
      R = (Uint)(i.and_imm.immr & levels);
      esize = 1 << len; /* 2..64 (len=1..6) */
      welem = (Ull)((Sll)0x8000000000000000LL>>S)>>(63-S); /* width:esize-bits */
      if (R>0) welem = (welem<<(esize-R))|(welem>>R);
      wmask = welem;
      for (len=0; len<64; len+=esize)
        wmask = (wmask<<esize) | welem;
      if (!i.and_imm.sf)
        wmask &= 0x00000000ffffffffLL;

      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = wmask;
    }
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = 0; /* LSL 0 */
    /* dest */
    if (i.and_imm.rd!=31 || i.and_imm.opc!=3) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.and_imm.rd;
      t[tid].map[i.and_imm.rd].x = 1;
      t[tid].map[i.and_imm.rd].rob = robid;
    }
    if (i.and_imm.opc==3) { /* ANDS */
      rob->dr[3].t = 1; /* nzcv */
      rob->dr[3].n = CPSREGTOP;
      t[tid].map[CPSREGTOP].x = 3;
      t[tid].map[CPSREGTOP].rob = robid;
    }
    return (0);
  }
  else if (i.sft_imm.op28_23==0x26) { /* C6.6.16 ASR(immediate), C6.6.21 BFI, C6.6.22 BFM, C6.6.23 BFXIL, C6.6.114 LSL(immediate), C6.6.117 LSR(immediate), C6.6.157 SBFIZ, C6.6.158 SBFM, C6.6.159 SBFX, C6.6.201 SXTB, C6.6.202 SXTH, C6.6.203 SXTW, C6.6.211 UBFIZ, C6.6.212 UBFM, C6.6.213 UBFX, C6.6.220 UXTB, C6.6.221 UXTH */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.sft_imm.opc==0?8:9; /* 8:SBFM/9:BFM/UBFM */
    rob->sop   = 3; /* ROR */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0;
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.sft_imm.sf; /* 0:sft32, 1:sft64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    {
      int imm, len, levels, esize;
      Uint S, R, d, inzero, extend;
      Ull welem, wmask, telem, tmask;
      imm = (i.sft_imm.N<<6)|((~i.sft_imm.imms)&0x3f);
      for (len=6; len>=0; len--) {
        if ((imm>>len)&1)
          break;
      }
      if (len < 1) { /* reserved */
        i_xxx(rob);
        return (0);
      }
                                                           /* len=1  len=2  len=3  len=4  len=5  len=6  */
      levels = (Uint)((int)0x80000000>>(len-1))>>(32-len); /* 000001,000011,000111,001111,011111,111111 */
      S = (Uint)(i.sft_imm.imms & levels);
      R = (Uint)(i.sft_imm.immr & levels);
      esize = 1 << len; /* 2..64 (len=1..6) */
      /*welem = ZeroExtend(Ones(S + 1), esize);*/
      /*wmask = Replicate(ROR(welem, R));*/
      welem = (Ull)((Sll)0x8000000000000000LL>>S)>>(63-S); /* width:esize-bits */
      if (R>0) welem = (welem<<(esize-R))|(welem>>R);
      wmask = welem;
      for (len=0; len<64; len+=esize)
        wmask = (wmask<<esize) | welem;
      if (!i.sft_imm.sf)
        wmask &= 0x00000000ffffffffLL;

      d = (S - R)&levels;
      /*telem = ZeroExtend(Ones(d + 1), esize);*/
      /*tmask = Replicate(telem);*/
      telem = (Ull)((Sll)0x8000000000000000LL>>d)>>(63-d); /* width:esize-bits */
      tmask = telem;
      for (len=0; len<64; len+=esize)
        tmask = (tmask<<esize) | telem;
      if (!i.sft_imm.sf)
        tmask &= 0x00000000ffffffffLL;

      switch (i.sft_imm.opc) {
      case 0: inzero=1; extend=1; break; /* SBFM */
      case 1: inzero=0; extend=0; break; /* BFM */
      case 2: inzero=1; extend=0; break; /* UBFM */
      default:
        i_xxx(rob);
        return (0);
      }
      rob->sr[0].t = inzero ? 1 : /* ZERO */
                     !t[tid].map[i.sft_imm.rd].x ? 2 :
                     (c[cid].rob[t[tid].map[i.sft_imm.rd].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = inzero ? 0 : /* ZERO */
                     t[tid].map[i.sft_imm.rd].x; /* reg */
      rob->sr[0].n = inzero ? 0 : /* ZERO */
                     !t[tid].map[i.sft_imm.rd].x ? i.sft_imm.rd : t[tid].map[i.sft_imm.rd].rob;
      rob->sr[1].t = i.sft_imm.rn==31 ? 1 : /* ZERO */
                     !t[tid].map[i.sft_imm.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.sft_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[1].x = i.sft_imm.rn==31 ? 0 : /* ZERO */
                     t[tid].map[i.sft_imm.rn].x; /* reg */
      rob->sr[1].n = i.sft_imm.rn==31 ? 0 : /* ZERO */
                     !t[tid].map[i.sft_imm.rn].x ? i.sft_imm.rn : t[tid].map[i.sft_imm.rn].rob;
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = (S<<8)|R; /* S for sign_extention | R for ROR */
      rob->sr[3].t = 1; /* immediate */
      rob->sr[3].x = 0; /* renamig N.A. */
      rob->sr[3].n = wmask;
      rob->sr[4].t = 1; /* immediate */
      rob->sr[4].x = 0; /* renamig N.A. */
      rob->sr[4].n = tmask;
    }
    /* dest */
    if (i.sft_imm.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.sft_imm.rd;
      t[tid].map[i.sft_imm.rd].x = 1;
      t[tid].map[i.sft_imm.rd].rob = robid;
    }
    return (0);
  }
  else if (i.ror_imm.op30_23==0x27 && i.ror_imm.op21==0) { /* C6.6.67 EXTR(immediate), C6.6.152 ROR(immediate) */
    rob->type  = 0; /* ALU */
    rob->opcd  =14; /* EXT */
    rob->sop   = 0; /* LSL 0 */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.ror_imm.sf; /* 0:ext32, 1:ext64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.ror_imm.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.ror_imm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ror_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.ror_imm.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.ror_imm.rn].x; /* reg */
    rob->sr[0].n = i.ror_imm.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.ror_imm.rn].x ? i.ror_imm.rn : t[tid].map[i.ror_imm.rn].rob;
    rob->sr[1].t = i.ror_imm.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.ror_imm.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ror_imm.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.ror_imm.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.ror_imm.rm].x; /* reg */
    rob->sr[1].n = i.ror_imm.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.ror_imm.rm].x ? i.ror_imm.rm : t[tid].map[i.ror_imm.rm].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = 0; /* LSL 0 */
    rob->sr[3].t = 1; /* immediate */
    rob->sr[3].x = 0; /* renamig N.A. */
    rob->sr[3].n = i.ror_imm.imms; /* ROR */
    /* dest */
    if (i.ror_imm.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.ror_imm.rd;
      t[tid].map[i.ror_imm.rd].x = 1;
      t[tid].map[i.ror_imm.rd].rob = robid;
    }
    return (0);
  }
  else if (i.sft_reg.op30_21==0x0d6 && i.sft_reg.op15_12==2) { /* C6.6.15 ASR, C6.6.17 ASRV, C6.6.113 LSL(register), C6.6.115 LSLV, C6.6.116 LSR(register), C6.6.118 LSRV */
    rob->type  = 0; /* ALU */
    rob->opcd  = 3; /* ORR */
    rob->sop   = i.sft_reg.op2; /* LSL/LSR/ASR/ROR */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.sft_reg.sf; /* 0:lsl32, 1:lsl64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = 1; /* immediate */
    rob->sr[0].x = 0; /* renamig N.A. */
    rob->sr[0].n = 0; /* ORR 0 */
    rob->sr[1].t = i.sft_reg.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.sft_reg.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.sft_reg.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.sft_reg.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.sft_reg.rn].x; /* reg */
    rob->sr[1].n = i.sft_reg.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.sft_reg.rn].x ? i.sft_reg.rn : t[tid].map[i.sft_reg.rn].rob;
    rob->sr[2].t = i.sft_reg.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.sft_reg.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.sft_reg.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = i.sft_reg.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.sft_reg.rm].x; /* reg */
    rob->sr[2].n = i.sft_reg.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.sft_reg.rm].x ? i.sft_reg.rm : t[tid].map[i.sft_reg.rm].rob;
    /* dest */
    if (i.sft_reg.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.sft_reg.rd;
      t[tid].map[i.sft_reg.rd].x = 1;
      t[tid].map[i.sft_reg.rd].rob = robid;
    }
    return (0);
  }
  else if (i.b_cond.op31_24==0x54 && i.b_cond.op4==0) { /* C6.6.19 B.cond */
    rob->target = pc + ((Sll)((Ull)i.b_cond.imm19<<45)>>43);
    if (i.b_cond.cond==14||i.b_cond.cond==15) /* unconditional */
      rob->bpred = 1;
    else if (i.b_cond.imm19&0x40000) /* conditional backward */
      rob->bpred = 1;
    rob->cond  = i.b_cond.cond;
    rob->type  = 5; /* BRANCH */
    rob->opcd  = 0; /* B */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    if (i.b_cond.cond!=14&&i.b_cond.cond!=15) { /* conditional exec */
      rob->sr[5].t = !t[tid].map[CPSREGTOP].x ? 2 : (c[cid].rob[t[tid].map[CPSREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* cpsr */
      rob->sr[5].x =  t[tid].map[CPSREGTOP].x; /* cpsr */
      rob->sr[5].n = !t[tid].map[CPSREGTOP].x ? CPSREGTOP : t[tid].map[CPSREGTOP].rob;
    }
    return (0);
  }
  else if (i.bl.op30_26==0x05) { /* C6.6.20 B, C6.6.26 BL */
    rob->target = pc + ((Sll)((Ull)i.bl.imm26<<38)>>36);
    rob->bpred = 1;
    rob->type  = 5; /* BRANCH */
    rob->opcd  = i.bl.op; /* B/BL */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    /* dest */
    if (i.bl.op) { /* BL */
      rob->dr[1].t = 1;
      rob->dr[1].n = 30;
      t[tid].map[30].x = 1;
      t[tid].map[30].rob = robid;
    }
    return (0);
  }
  else if (i.cbz.op30_25==0x1a) { /* C6.6.30 CBNZ, C6.6.31 CBZ */
    rob->target = pc + ((Sll)((Ull)i.cbz.imm19<<45)>>43);
    if (i.cbz.imm19&0x40000) /* conditional backward */
      rob->bpred = 1;
    rob->type  = 5; /* BRANCH */
    rob->opcd  = i.cbz.op==0?2:3; /* CBZ/CBNZ */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.cbz.sf; /* 0:cbz32, 1:cbz64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.cbz.rt==31 ? 1 : /* ZERO */
                   !t[tid].map[i.cbz.rt].x ? 2 :
                   (c[cid].rob[t[tid].map[i.cbz.rt].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.cbz.rt==31 ? 0 : /* ZERO */
                   t[tid].map[i.cbz.rt].x; /* reg */
    rob->sr[0].n = i.cbz.rt==31 ? 0 : /* ZERO */
                   !t[tid].map[i.cbz.rt].x ? i.cbz.rt : t[tid].map[i.cbz.rt].rob;
    return (0);
  }
  else if (i.tbz.op30_25==0x1b) { /* C6.6.206 TBNZ, C6.6.207 TBZ */
    rob->target = pc + ((Sll)((Ull)i.tbz.imm14<<50)>>48);
    if (i.tbz.imm14&0x2000) /* conditional backward */
      rob->bpred = 1;
    rob->type  = 5; /* BRANCH */
    rob->opcd  = i.tbz.op==0?4:5; /* TBZ/TBNZ */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.tbz.b5; /* 0:tbz32, 1:tbz64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.tbz.rt==31 ? 1 : /* ZERO */
                   !t[tid].map[i.tbz.rt].x ? 2 :
                   (c[cid].rob[t[tid].map[i.tbz.rt].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.tbz.rt==31 ? 0 : /* ZERO */
                   t[tid].map[i.tbz.rt].x; /* reg */
    rob->sr[0].n = i.tbz.rt==31 ? 0 : /* ZERO */
                   !t[tid].map[i.tbz.rt].x ? i.tbz.rt : t[tid].map[i.tbz.rt].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = (i.tbz.b5<<5)|i.tbz.b40;
    return (0);
  }
  else if (i.blr.op31_23==0x1ac && i.blr.op20_10==0x7c0 && i.blr.op4_0==0) { /* C6.6.27 BLR, C6.6.28 BR, C6.6.148 RET */
    rob->type  = 5; /* BRANCH */
    rob->opcd  = i.blr.op==1?6:7; /* CALL/JMP/RET */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.blr.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.blr.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.blr.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.blr.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.blr.rn].x; /* reg */
    rob->sr[0].n = i.blr.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.blr.rn].x ? i.blr.rn : t[tid].map[i.blr.rn].rob;
    if (i.blr.op==1) { /* CALL */
      rob->dr[1].t = 1;
      rob->dr[1].n = 30;
      t[tid].map[30].x = 1;
      t[tid].map[30].rob = robid;
    }
    return (0);
  }
  else if (i.svc.op31_21==0x6a0 && i.svc.op4_0==0x01) { /* C6.6.200 SVC */
    rob->target = pc + 4; /* for restart */
    rob->bpred = 0; /* not used */
    rob->type  = (i.svc.type==0)?6:7; /* SVC/PTHREAD(csim special) */
    rob->opcd  = 0; /* not used */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = i.svc.imm12;
    return (0);
  }
  else if (i.ldaxr_stlxr.op29_24==0x08 && i.ldaxr_stlxr.o2==0 && i.ldaxr_stlxr.o1==0 && i.ldaxr_stlxr.o0==1 && i.ldaxr_stlxr.rt2==31) { /* C6.6.77 LDAXR, C6.6.173 STLXR */
    switch (i.ldaxr_stlxr.size) {
    case 0:
    case 1:
      i_xxx(rob);
      return (0);
    case 2:
    case 3:
      break;
    }
    /* LDREX */ /* i.base.r1 -> Rn(addr)       */
                /* i.base.r2 -> Rt(dest reg)   */
                /* Rt = load4(A=Rn) */
                /* store¤ËÆÉ¤ßÂØ¤¨¤ÆL1(v=1,d=1,s=0)¤Ø¤ÎÊÑ¹¹¤ò»î¤ß¤ë */
    /* STREX */ /* i.base.r1 -> Rn(addr)       */
                /* i.base.r2 -> Rd(result)     */
                /* i.base.r4 -> Rt(store data) */
                /* L1(v=1,d=1,s=0)¤Ø¤ÎÀêÍ­store¤ò»î¤ß¤ë.¼ºÇÔ¤Ê¤é */
                /* if (success) { store4(A=Rn) = Rt; Rd = 0; } */
                /* if (failed)  {                    Rd = 1; } */
    rob->type  = i.ldaxr_stlxr.L?3:4; /* LD/ST */
    rob->opcd  = 7; /* LDREX/STREX */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 1; /* plus */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = !t[tid].map[i.ldaxr_stlxr.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldaxr_stlxr.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ldaxr_stlxr.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ldaxr_stlxr.rn].x ? i.ldaxr_stlxr.rn : t[tid].map[i.ldaxr_stlxr.rn].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = 0; /* ZERO */
    if (i.ldaxr_stlxr.L==0) { /* ST */
      rob->sr[3].t = i.ldaxr_stlxr.rt==31 ? 1 : /* ZERO */
                     !t[tid].map[i.ldaxr_stlxr.rt].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ldaxr_stlxr.rt].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[3].x = i.ldaxr_stlxr.rt==31 ? 0 : /* ZERO */
                     t[tid].map[i.ldaxr_stlxr.rt].x; /* reg */
      rob->sr[3].n = i.ldaxr_stlxr.rt==31 ? 0 : /* ZERO */
                     !t[tid].map[i.ldaxr_stlxr.rt].x ? i.ldaxr_stlxr.rt : t[tid].map[i.ldaxr_stlxr.rt].rob;
    }
    /* dest */
    if (i.ldaxr_stlxr.L && i.ldaxr_stlxr.rt!=31) { /* LD */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.ldaxr_stlxr.rt;
      t[tid].map[i.ldaxr_stlxr.rt].x = 1;
      t[tid].map[i.ldaxr_stlxr.rt].rob = robid;
    }
    if (!i.ldaxr_stlxr.L && i.ldaxr_stlxr.rs!=31) { /* ST */
      rob->dr[2].t = 1;
      rob->dr[2].n = i.ldaxr_stlxr.rs;
      t[tid].map[i.ldaxr_stlxr.rs].x = 2;
      t[tid].map[i.ldaxr_stlxr.rs].rob = robid;
    }
    return (0);
  }
  else if (i.ldp_stp.op29_25==0x14) { /* C6.6.81 LDP, C6.6.82 LDPSW, C6.6.177 STP */
    int post_index = i.ldp_stp.op24_23==1;
    int pre_index  = i.ldp_stp.op24_23==3;
    int sig_offset = i.ldp_stp.op24_23==2;
    Ull offset     = (Sll)((Ull)i.ldp_stp.imm7<<57)>>(i.ldp_stp.opc==2?54:55);
    switch (mc) { /* multi-cycle */
    case 0: /* start */
      rob->type  = 0; /* ALU */
      rob->opcd  = 4; /* ADD */
      rob->sop   = 0; /* LSL 0 */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = 0; /* not used */
      rob->plus  = 0; /* not used */
      rob->pre   = 0; /* not used */
      rob->wb    = 0; /* not used */
      rob->updt  = 0; /* inhibit cc-update */
      rob->sr[0].t = !t[tid].map[i.ldp_stp.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ldp_stp.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[i.ldp_stp.rn].x; /* reg */
      rob->sr[0].n = !t[tid].map[i.ldp_stp.rn].x ? i.ldp_stp.rn : t[tid].map[i.ldp_stp.rn].rob;
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = i.ldp_stp.opc==2?8:4; /* 0:ldst32, 2:ldst64 */
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = 0; /* LSL 0 */
      rob->dr[1].t = 1; /* drt */
      rob->dr[1].n = AUXREGTOP;
      t[tid].map[AUXREGTOP].x = 1;
      t[tid].map[AUXREGTOP].rob = robid;
      rob->term = 0;
      return (1);
    case 1:
      rob->type  = i.ldp_stp.L?3:4; /* LD/ST */
      rob->opcd  = i.ldp_stp.opc==2?3:i.ldp_stp.opc==0?2:6; /* LDR/LDRW/LDRSW/STR/STRW */
      rob->sop   = 0; /* not used */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = i.ldp_stp.opc!=0; /* 0:ldst32, 1:ldst64 */
      rob->plus  = 1; /* plus */
      rob->pre   = pre_index || sig_offset;
      rob->wb    = post_index || pre_index;
      rob->updt  = 0; /* not used */
      rob->sr[0].t = !t[tid].map[i.ldp_stp.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ldp_stp.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[i.ldp_stp.rn].x; /* reg */
      rob->sr[0].n = !t[tid].map[i.ldp_stp.rn].x ? i.ldp_stp.rn : t[tid].map[i.ldp_stp.rn].rob;
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = offset;
      if (i.ldp_stp.L==0) { /* ST */
        rob->sr[3].t = i.ldp_stp.rt==31 ? 1 : /* ZERO */
                       !t[tid].map[i.ldp_stp.rt].x ? 2 :
                       (c[cid].rob[t[tid].map[i.ldp_stp.rt].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
        rob->sr[3].x = i.ldp_stp.rt==31 ? 0 : /* ZERO */
                       t[tid].map[i.ldp_stp.rt].x; /* reg */
        rob->sr[3].n = i.ldp_stp.rt==31 ? 0 : /* ZERO */
                       !t[tid].map[i.ldp_stp.rt].x ? i.ldp_stp.rt : t[tid].map[i.ldp_stp.rt].rob;
      }
      /* dest */
      if (i.ldp_stp.L && i.ldp_stp.rt!=31) { /* LD */
        rob->dr[1].t = 1;
        rob->dr[1].n = i.ldp_stp.rt;
        t[tid].map[i.ldp_stp.rt].x = 1;
        t[tid].map[i.ldp_stp.rt].rob = robid;
      }
      if (rob->wb) {
        rob->dr[2].t = 1; /* writeback-basereg */
        rob->dr[2].n = i.ldp_stp.rn;
        t[tid].map[i.ldp_stp.rn].x = 2;
        t[tid].map[i.ldp_stp.rn].rob = robid;
      }
      rob->term = 0;
      return (1);
    case 2:
      rob->type  = i.ldp_stp.L?3:4; /* LD/ST */
      rob->opcd  = i.ldp_stp.opc==2?3:i.ldp_stp.opc==0?2:6; /* LDR/LDRW/LDRSW/STR/STRW */
      rob->sop   = 0; /* not used */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = i.ldp_stp.opc!=0; /* 0:ldst32, 1:ldst64 */
      rob->plus  = 1; /* plus */
      rob->pre   = pre_index || sig_offset;
      rob->wb    = 0; /* not used */
      rob->updt  = 0; /* not used */
      rob->sr[0].t = !t[tid].map[AUXREGTOP].x ? 2 :
                     (c[cid].rob[t[tid].map[AUXREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x =  t[tid].map[AUXREGTOP].x; /* reg */
      rob->sr[0].n = !t[tid].map[AUXREGTOP].x ? AUXREGTOP : t[tid].map[AUXREGTOP].rob;
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = offset;
      if (i.ldp_stp.L==0) { /* ST */
        rob->sr[3].t = i.ldp_stp.rt2==31 ? 1 : /* ZERO */
                       !t[tid].map[i.ldp_stp.rt2].x ? 2 :
                       (c[cid].rob[t[tid].map[i.ldp_stp.rt2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
        rob->sr[3].x = i.ldp_stp.rt2==31 ? 0 : /* ZERO */
                       t[tid].map[i.ldp_stp.rt2].x; /* reg */
        rob->sr[3].n = i.ldp_stp.rt2==31 ? 0 : /* ZERO */
                       !t[tid].map[i.ldp_stp.rt2].x ? i.ldp_stp.rt2 : t[tid].map[i.ldp_stp.rt2].rob;
      }
      /* dest */
      if (i.ldp_stp.L && i.ldp_stp.rt2!=31) { /* LD */
        rob->dr[1].t = 1;
        rob->dr[1].n = i.ldp_stp.rt2;
        t[tid].map[i.ldp_stp.rt2].x = 1;
        t[tid].map[i.ldp_stp.rt2].rob = robid;
      }
      return (0);
    default:
      i_xxx(rob);
      return (0);
    }
  }
  else if (i.ldp_stp.op29_25==0x16) { /* C7.3.165 LDP(SIMD&FP), C7.3.284 STP(SIMD&FP) */
    int post_index = i.ldp_stp.op24_23==1;
    int pre_index  = i.ldp_stp.op24_23==3;
    int sig_offset = i.ldp_stp.op24_23==2;
    Ull offset     = (Sll)((Ull)i.ldp_stp.imm7<<57)>>(i.ldp_stp.opc==0?55:i.ldp_stp.opc==1?54:53);
    switch (mc) { /* multi-cycle */
    case 0: /* start */
      rob->type  = 0; /* ALU */
      rob->opcd  = 4; /* ADD */
      rob->sop   = 0; /* LSL 0 */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = 0; /* not used */
      rob->plus  = 0; /* not used */
      rob->pre   = 0; /* not used */
      rob->wb    = 0; /* not used */
      rob->updt  = 0; /* inhibit cc-update */
      rob->sr[0].t = !t[tid].map[i.ldp_stp.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ldp_stp.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[i.ldp_stp.rn].x; /* reg */
      rob->sr[0].n = !t[tid].map[i.ldp_stp.rn].x ? i.ldp_stp.rn : t[tid].map[i.ldp_stp.rn].rob;
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = i.ldp_stp.opc==0?4:i.ldp_stp.opc==1?8:16; /* 0:ldst32, 1:ldst64, 2:ldst128 */
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = 0; /* LSL 0 */
      rob->dr[1].t = 1; /* drt */
      rob->dr[1].n = AUXREGTOP;
      t[tid].map[AUXREGTOP].x = 1;
      t[tid].map[AUXREGTOP].rob = robid;
      rob->term = 0;
      return (1);
    case 1:
      rob->type  = i.ldp_stp.L?3:4; /* LD/ST */
      rob->opcd  = i.ldp_stp.opc==0?10:i.ldp_stp.opc==1?11:12; /* LDRS/LDRD/LDRQ */
      rob->sop   = 0; /* not used */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = i.ldp_stp.opc==2; /* 0:ldst32/64, 1:ldst128 */
      rob->plus  = 1; /* plus */
      rob->pre   = pre_index || sig_offset;
      rob->wb    = post_index || pre_index;
      rob->updt  = 0; /* not used */
      v0 = VECREGTOP+i.ldp_stp.rt;
      rob->sr[0].t = !t[tid].map[i.ldp_stp.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ldp_stp.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[i.ldp_stp.rn].x; /* reg */
      rob->sr[0].n = !t[tid].map[i.ldp_stp.rn].x ? i.ldp_stp.rn : t[tid].map[i.ldp_stp.rn].rob;
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = offset;
      if (i.ldp_stp.L==0) { /* ST */
        rob->sr[3].t = !t[tid].map[v0].x ? 2 :
                       (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
        rob->sr[3].x = t[tid].map[v0].x; /* reg */
        rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
      }
      /* dest */
      if (i.ldp_stp.L) { /* LD */
        rob->dr[1].t = 1;
        rob->dr[1].n = v0;
        t[tid].map[v0].x = 1;
        t[tid].map[v0].rob = robid;
      }
      if (rob->wb) {
        rob->dr[2].t = 1; /* writeback-basereg */
        rob->dr[2].n = i.ldp_stp.rn;
        t[tid].map[i.ldp_stp.rn].x = 2;
        t[tid].map[i.ldp_stp.rn].rob = robid;
      }
      rob->term = 0;
      return (1);
    case 2:
      rob->type  = i.ldp_stp.L?3:4; /* LD/ST */
      rob->opcd  = i.ldp_stp.opc==0?10:i.ldp_stp.opc==1?11:12; /* LDRS/LDRD/LDRQ */
      rob->sop   = 0; /* not used */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = i.ldp_stp.opc==2; /* 0:ldst32/64, 1:ldst128 */
      rob->plus  = 1; /* plus */
      rob->pre   = pre_index || sig_offset;
      rob->wb    = 0; /* not used */
      rob->updt  = 0; /* not used */
      v0 = VECREGTOP+i.ldp_stp.rt2;
      rob->sr[0].t = !t[tid].map[AUXREGTOP].x ? 2 :
                     (c[cid].rob[t[tid].map[AUXREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x =  t[tid].map[AUXREGTOP].x; /* reg */
      rob->sr[0].n = !t[tid].map[AUXREGTOP].x ? AUXREGTOP : t[tid].map[AUXREGTOP].rob;
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = offset;
      if (i.ldp_stp.L==0) { /* ST */
        rob->sr[3].t = !t[tid].map[v0].x ? 2 :
                       (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
        rob->sr[3].x = t[tid].map[v0].x; /* reg */
        rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
      }
      /* dest */
      if (i.ldp_stp.L) { /* LD */
        rob->dr[1].t = 1;
        rob->dr[1].n = v0;
        t[tid].map[v0].x = 1;
        t[tid].map[v0].rob = robid;
      }
      return (0);
    default:
      i_xxx(rob);
      return (0);
    }
  }
  else if (i.ldr_str_imm.op29_25==0x1c && ((i.ldr_str_imm.op24==0 && !(i.ldr_str_imm.imm12&0x800) && ((i.ldr_str_imm.imm12&3)==1 || (i.ldr_str_imm.imm12&3)==3))||(i.ldr_str_imm.op24==1))) { /* C6.6.83 LDR(immediate), C6.6.86 LDRB(immediate), C6.6.88 LDRH(immediate), C6.6.90 LDRSB(immediate), C6.6.92 LDRSH(immediate), C6.6.94 LDRSW(immediate), C6.6.178 STR(immediate), C6.6.180 STRB(immediate), C6.6.182 STR(immediate) */
    /* C6.6.86 ldrb(32):  size=00, opc=01 | C6.6.180 strb(32): size=00, opc=00 */
    /* C6.6.88 ldrh(32):  size=01, opc=01 | C6.6.182 strh(32): size=01, opc=00 */
    /* C6.6.83 ldr(32):   size=10, opc=01 | C6.6.178 str(32):  size=10, opc=00 */
    /* C6.6.83 ldr(64):   size=11, opc=01 | C6.6.178 str(64):  size=11, opc=00 */
    /* C6.6.90 ldrsb(64): size=00, opc=10 */
    /* C6.6.92 ldrsh(64): size=01, opc=10 */
    /* C6.6.94 ldrsw(64): size=10, opc=10 */
    /* C6.6.90 ldrsb(32): size=00, opc=11 */
    /* C6.6.92 ldrsh(32): size=01, opc=11 */
    int post_index = i.ldr_str_imm.op24==0 && (i.ldr_str_imm.imm12&3)==1;
    int pre_index  = i.ldr_str_imm.op24==0 && (i.ldr_str_imm.imm12&3)==3;
    int uns_offset = i.ldr_str_imm.op24==1;
    Ull offset     = (post_index || pre_index)?(Sll)((Ull)i.ldr_str_imm.imm12<<53)>>55:(Ull)i.ldr_str_imm.imm12<<i.ldr_str_imm.size;
    rob->type  = i.ldr_str_imm.opc?3:4; /* LD/ST */
    switch (i.ldr_str_imm.size) {
    case 0:
      switch (i.ldr_str_imm.opc) {
      case 0:
      case 1:
        rob->opcd = 0; /* LDRB/STRB(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
        rob->opcd = 4; /* LDRSB(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 3:
        rob->opcd = 4; /* LDRSB(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      }
      break;
    case 1:
      switch (i.ldr_str_imm.opc) {
      case 0:
      case 1:
        rob->opcd = 1; /* LDRH/STRH(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
        rob->opcd = 5; /* LDRSH(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 3:
        rob->opcd = 5; /* LDRSH(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      }
      break;
    case 2:
      switch (i.ldr_str_imm.opc) {
      case 0:
      case 1:
        rob->opcd = 2; /* LDR(32)/STR(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
        rob->opcd = 6; /* LDRSW(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 3:
        i_xxx(rob);
        return (0);
      }
      break;
    case 3:
      switch (i.ldr_str_imm.opc) {
      case 0:
      case 1:
        rob->opcd = 3; /* LDR(64)/STR(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 2:
      case 3:
        i_xxx(rob);
        return (0);
      }
    }
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->plus  = 1; /* plus */
    rob->pre   = pre_index || uns_offset;
    rob->wb    = post_index || pre_index;
    rob->updt  = 0; /* not used */
    rob->sr[0].t = !t[tid].map[i.ldr_str_imm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_str_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ldr_str_imm.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ldr_str_imm.rn].x ? i.ldr_str_imm.rn : t[tid].map[i.ldr_str_imm.rn].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = offset;
    if (i.ldr_str_imm.opc==0) { /* ST */
      rob->sr[3].t = i.ldr_str_imm.rt==31 ? 1 : /* ZERO */
                     !t[tid].map[i.ldr_str_imm.rt].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ldr_str_imm.rt].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[3].x = i.ldr_str_imm.rt==31 ? 0 : /* ZERO */
                     t[tid].map[i.ldr_str_imm.rt].x; /* reg */
      rob->sr[3].n = i.ldr_str_imm.rt==31 ? 0 : /* ZERO */
                     !t[tid].map[i.ldr_str_imm.rt].x ? i.ldr_str_imm.rt : t[tid].map[i.ldr_str_imm.rt].rob;
    }
    /* dest */
    if (i.ldr_str_imm.opc && i.ldr_str_imm.rt!=31) { /* LD */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.ldr_str_imm.rt;
      t[tid].map[i.ldr_str_imm.rt].x = 1;
      t[tid].map[i.ldr_str_imm.rt].rob = robid;
    }
    if (rob->wb) {
      rob->dr[2].t = 1; /* writeback-basereg */
      rob->dr[2].n = i.ldr_str_imm.rn;
      t[tid].map[i.ldr_str_imm.rn].x = 2;
      t[tid].map[i.ldr_str_imm.rn].rob = robid;
    }
    return (0);
  }
  else if (i.ldr_str_imm.op29_25==0x1e && ((i.ldr_str_imm.op24==0 && !(i.ldr_str_imm.imm12&0x800) && ((i.ldr_str_imm.imm12&3)==1 || (i.ldr_str_imm.imm12&3)==3))||(i.ldr_str_imm.op24==1))) { /* C7.3.166 LDR(immediate,SIMD&FP), C7.3.285 STR(immediate,SIMD&FP) */
    /* C7.3.166 ldrb(8):   size=00, opc=01 | C7.3.285 strb(8):   size=00, opc=00 */
    /* C7.3.166 ldrh(16):  size=01, opc=01 | C7.3.285 strh(16):  size=01, opc=00 */
    /* C7.3.166 ldrs(32):  size=10, opc=01 | C7.3.285 strs(32):  size=10, opc=00 */
    /* C7.3.166 ldrd(64):  size=11, opc=01 | C7.3.285 strd(64):  size=11, opc=00 */
    /* C7.3.166 ldrq(128): size=00, opc=11 | C7.3.285 strq(128): size=00, opc=10 */
    int post_index = i.ldr_str_imm.op24==0 && (i.ldr_str_imm.imm12&3)==1;
    int pre_index  = i.ldr_str_imm.op24==0 && (i.ldr_str_imm.imm12&3)==3;
    int uns_offset = i.ldr_str_imm.op24==1;
    Ull offset     = (post_index || pre_index)?(Sll)((Ull)i.ldr_str_imm.imm12<<53)>>55:(Ull)i.ldr_str_imm.imm12<<((i.ldr_str_imm.opc<<1&4)|i.ldr_str_imm.size);
    rob->type  = (i.ldr_str_imm.opc&1)?3:4; /* LD/ST */
    switch (i.ldr_str_imm.size) {
    case 0:
      switch (i.ldr_str_imm.opc) {
      case 0:
      case 1:
        rob->opcd = 8; /* LDRB/STRB(8) */
        rob->dbl  = 0; /* ldst8 */
        break;
      case 2:
      case 3:
        rob->opcd =12; /* LDRQ/STRQ(128) */
        rob->dbl  = 1; /* ldst128 */
        break;
      }
      break;
    case 1:
      switch (i.ldr_str_imm.opc) {
      case 0:
      case 1:
        rob->opcd = 9; /* LDRH/STRH(16) */
        rob->dbl  = 0; /* ldst16 */
        break;
      case 2:
      case 3:
        i_xxx(rob);
        return (0);
      }
      break;
    case 2:
      switch (i.ldr_str_imm.opc) {
      case 0:
      case 1:
        rob->opcd =10; /* LDRS(32)/STRS(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
      case 3:
        i_xxx(rob);
        return (0);
      }
      break;
    case 3:
      switch (i.ldr_str_imm.opc) {
      case 0:
      case 1:
        rob->opcd =11; /* LDRD(64)/STRD(64) */
        rob->dbl  = 0; /* ldst64 */
        break;
      case 2:
      case 3:
        i_xxx(rob);
        return (0);
      }
      break;
    }
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->plus  = 1; /* plus */
    rob->pre   = pre_index || uns_offset;
    rob->wb    = post_index || pre_index;
    rob->updt  = 0; /* not used */
    v0 = VECREGTOP+i.ldr_str_imm.rt;
    rob->sr[0].t = !t[tid].map[i.ldr_str_imm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_str_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ldr_str_imm.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ldr_str_imm.rn].x ? i.ldr_str_imm.rn : t[tid].map[i.ldr_str_imm.rn].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = offset;
    if ((i.ldr_str_imm.opc&1)==0) { /* ST */
      rob->sr[3].t = !t[tid].map[v0].x ? 2 :
                     (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[3].x = t[tid].map[v0].x; /* reg */
      rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
    }
    /* dest */
    if (i.ldr_str_imm.opc&1) { /* LD */
      rob->dr[1].t = 1;
      rob->dr[1].n = v0;
      t[tid].map[v0].x = 1;
      t[tid].map[v0].rob = robid;
    }
    if (rob->wb) {
      rob->dr[2].t = 1; /* writeback-basereg */
      rob->dr[2].n = i.ldr_str_imm.rn;
      t[tid].map[i.ldr_str_imm.rn].x = 2;
      t[tid].map[i.ldr_str_imm.rn].rob = robid;
    }
    return (0);
  }
  else if (i.ldr_str_unsc.op29_25==0x1c && i.ldr_str_unsc.op24==0 && i.ldr_str_unsc.op21==0 && i.ldr_str_unsc.op11_10==0) { /* C6.6.103 LDUR, C6.6.104 LDURB, C6.6.105 LDURH, C6.6.106 LDURSB, C6.6.107 LDURSH, C6.6.108 LDURSW, C6.6.187 STUR, C6.6.188 STURB, C6.6.189 STURH */
    /* C6.6.104 ldurb(32):  size=00, opc=01 | C6.6.188 sturb(32): size=00, opc=00 */
    /* C6.6.105 ldurh(32):  size=01, opc=01 | C6.6.189 sturh(32): size=01, opc=00 */
    /* C6.6.103 ldur(32):   size=10, opc=01 | C6.6.187 stur(32):  size=10, opc=00 */
    /* C6.6.103 ldur(64):   size=11, opc=01 | C6.6.187 stur(64):  size=11, opc=00 */
    /* C6.6.106 ldursb(64): size=00, opc=10 */
    /* C6.6.107 ldursh(64): size=01, opc=10 */
    /* C6.6.108 ldursw(64): size=10, opc=10 */
    /* C6.6.106 ldursb(32): size=00, opc=11 */
    /* C6.6.107 ldursh(32): size=01, opc=11 */
    Ull offset = (Sll)((Ull)i.ldr_str_unsc.imm9<<55)>>55;
    rob->type  = i.ldr_str_unsc.opc?3:4; /* LD/ST */
    switch (i.ldr_str_unsc.size) {
    case 0:
      switch (i.ldr_str_unsc.opc) {
      case 0:
      case 1:
        rob->opcd = 0; /* LDURB/STURB(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
        rob->opcd = 4; /* LDURSB(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 3:
        rob->opcd = 4; /* LDURSB(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      }
      break;
    case 1:
      switch (i.ldr_str_unsc.opc) {
      case 0:
      case 1:
        rob->opcd = 1; /* LDURH/STURH(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
        rob->opcd = 5; /* LDURSH(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 3:
        rob->opcd = 5; /* LDURSH(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      }
      break;
    case 2:
      switch (i.ldr_str_unsc.opc) {
      case 0:
      case 1:
        rob->opcd = 2; /* LDUR(32)/STUR(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
        rob->opcd = 6; /* LDURSW(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 3:
        i_xxx(rob);
        return (0);
      }
      break;
    case 3:
      switch (i.ldr_str_unsc.opc) {
      case 0:
      case 1:
        rob->opcd = 3; /* LDUR(64)/STUR(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 2:
      case 3:
        i_xxx(rob);
        return (0);
      }
    }
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->plus  = 1; /* plus */
    rob->pre   = 1; /* addr+offset */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = !t[tid].map[i.ldr_str_unsc.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_str_unsc.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ldr_str_unsc.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ldr_str_unsc.rn].x ? i.ldr_str_unsc.rn : t[tid].map[i.ldr_str_unsc.rn].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = offset;
    if (i.ldr_str_unsc.opc==0) { /* ST */
      rob->sr[3].t = i.ldr_str_unsc.rt==31 ? 1 : /* ZERO */
                     !t[tid].map[i.ldr_str_unsc.rt].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ldr_str_unsc.rt].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[3].x = i.ldr_str_unsc.rt==31 ? 0 : /* ZERO */
                     t[tid].map[i.ldr_str_unsc.rt].x; /* reg */
      rob->sr[3].n = i.ldr_str_unsc.rt==31 ? 0 : /* ZERO */
                     !t[tid].map[i.ldr_str_unsc.rt].x ? i.ldr_str_unsc.rt : t[tid].map[i.ldr_str_unsc.rt].rob;
    }
    /* dest */
    if (i.ldr_str_unsc.opc && i.ldr_str_unsc.rt!=31) { /* LD */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.ldr_str_unsc.rt;
      t[tid].map[i.ldr_str_unsc.rt].x = 1;
      t[tid].map[i.ldr_str_unsc.rt].rob = robid;
    }
    return (0);
  }
  else if (i.ldr_str_unsc.op29_25==0x1e && i.ldr_str_unsc.op24==0 && i.ldr_str_unsc.op21==0 && i.ldr_str_unsc.op11_10==0) { /* C7.3.169 LDUR(SIMD&FP), C7.3.287 STUR(SIMD&FP) */
    /* C7.3.169 ldur(8):  size=00, opc=01 | C7.3.287 stur(8):  size=00, opc=00 */
    /* C7.3.169 ldur(16): size=01, opc=01 | C7.3.287 stur(16): size=01, opc=00 */
    /* C7.3.169 ldur(32): size=10, opc=01 | C7.3.287 stur(32): size=10, opc=00 */
    /* C7.3.169 ldur(64): size=11, opc=01 | C7.3.287 stur(64): size=11, opc=00 */
    /* C7.3.169 ldur(128):size=00, opc=11 | C7.3.287 stur(128):size=00, opc=10 */
    Ull offset = (Sll)((Ull)i.ldr_str_unsc.imm9<<55)>>55;
    rob->type  = (i.ldr_str_unsc.opc&1)?3:4; /* LD/ST */
    switch (i.ldr_str_unsc.size) {
    case 0:
      switch (i.ldr_str_unsc.opc) {
      case 0:
      case 1:
        rob->opcd = 8; /* LDRB/STRB(8) */
        rob->dbl  = 0; /* ldst8 */
        break;
      case 2:
      case 3:
        rob->opcd =12; /* LDRQ/STRQ(128) */
        rob->dbl  = 1; /* ldst128 */
        break;
      }
      break;
    case 1:
      switch (i.ldr_str_unsc.opc) {
      case 0:
      case 1:
        rob->opcd = 9; /* LDRH/STRH(16) */
        rob->dbl  = 0; /* ldst16 */
        break;
      case 2:
      case 3:
        i_xxx(rob);
        return (0);
      }
      break;
    case 2:
      switch (i.ldr_str_unsc.opc) {
      case 0:
      case 1:
        rob->opcd =10; /* LDRS(32)/STRS(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
      case 3:
        i_xxx(rob);
        return (0);
      }
      break;
    case 3:
      switch (i.ldr_str_unsc.opc) {
      case 0:
      case 1:
        rob->opcd =11; /* LDRD(64)/STRD(64) */
        rob->dbl  = 0; /* ldst64 */
        break;
      case 2:
      case 3:
        i_xxx(rob);
        return (0);
      }
    }
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->plus  = 1; /* plus */
    rob->pre   = 1; /* addr+offset */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    v0 = VECREGTOP+i.ldr_str_unsc.rt;
    rob->sr[0].t = !t[tid].map[i.ldr_str_unsc.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_str_unsc.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ldr_str_unsc.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ldr_str_unsc.rn].x ? i.ldr_str_unsc.rn : t[tid].map[i.ldr_str_unsc.rn].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = offset;
    if ((i.ldr_str_unsc.opc&1)==0) { /* ST */
      rob->sr[3].t = !t[tid].map[v0].x ? 2 :
                     (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[3].x = t[tid].map[v0].x; /* reg */
      rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
    }
    /* dest */
    if (i.ldr_str_unsc.opc&1) { /* LD */
      rob->dr[1].t = 1;
      rob->dr[1].n = v0;
      t[tid].map[v0].x = 1;
      t[tid].map[v0].rob = robid;
    }
    return (0);
  }
  else if (i.ldr_str_reg.op29_25==0x1c && i.ldr_str_reg.op24==0 && i.ldr_str_reg.op21==1 && i.ldr_str_reg.op11_10==2) { /* C6.6.85 LDR(register), C6.6.87 LDRB(register), C6.6.89 LDRH(register), C6.6.91 LDRSB(register), C6.6.93 LDRSH(register), C6.6.96 LDRSW(register), C6.6.179 STR(register), C6.6.181 STRB(register), C6.6.183 STRH(register) */
    /* C6.6.87 ldrb(32):  size=00, opc=01 | C6.6.181 strb(32): size=00, opc=00 */
    /* C6.6.89 ldrh(32):  size=01, opc=01 | C6.6.183 strh(32): size=01, opc=00 */
    /* C6.6.85 ldr(32):   size=10, opc=01 | C6.6.179 str(32):  size=10, opc=00 */
    /* C6.6.85 ldr(64):   size=11, opc=01 | C6.6.179 str(64):  size=11, opc=00 */
    /* C6.6.91 ldrsb(64): size=00, opc=10 */
    /* C6.6.93 ldrsh(64): size=01, opc=10 */
    /* C6.6.96 ldrsw(64): size=10, opc=10 */
    /* C6.6.91 ldrsb(32): size=00, opc=11 */
    /* C6.6.93 ldrsh(32): size=01, opc=11 */
    /* option: 000:(uxtb), 001:(uxth), 010:uxtw, 011:uxtx, 100:(sxtb), 101:(sxth), 110:sxtw, 111:sxtx */
    /* shift:  S==1 ? size : 0 */
    rob->type  = i.ldr_str_reg.opc?3:4; /* LD/ST */
    switch (i.ldr_str_reg.size) {
    case 0:
      switch (i.ldr_str_reg.opc) {
      case 0:
      case 1:
        rob->opcd = 0; /* LDRB/STRB(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
        rob->opcd = 4; /* LDRSB(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 3:
        rob->opcd = 4; /* LDRSB(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      }
      break;
    case 1:
      switch (i.ldr_str_reg.opc) {
      case 0:
      case 1:
        rob->opcd = 1; /* LDRH/STRH(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
        rob->opcd = 5; /* LDRSH(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 3:
        rob->opcd = 5; /* LDRSH(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      }
      break;
    case 2:
      switch (i.ldr_str_reg.opc) {
      case 0:
      case 1:
        rob->opcd = 2; /* LDR(32)/STR(32) */
        rob->dbl  = 0; /* ldst32 */
        break;
      case 2:
        rob->opcd = 6; /* LDRSW(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 3:
        i_xxx(rob);
        return (0);
      }
      break;
    case 3:
      switch (i.ldr_str_reg.opc) {
      case 0:
      case 1:
        rob->opcd = 3; /* LDR(64)/STR(64) */
        rob->dbl  = 1; /* ldst64 */
        break;
      case 2:
      case 3:
        i_xxx(rob);
        return (0);
      }
    }
    rob->sop   = 8|i.ldr_str_reg.option; /* option: 000:(uxtb), 001:(uxth), 010:uxtw, 011:uxtx, 100:(sxtb), 101:(sxth), 110:sxtw, 111:sxtx */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->plus  = 1; /* plus */
    rob->pre   = 1; /* addr+offset */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = !t[tid].map[i.ldr_str_reg.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_str_reg.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ldr_str_reg.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ldr_str_reg.rn].x ? i.ldr_str_reg.rn : t[tid].map[i.ldr_str_reg.rn].rob;
    rob->sr[1].t = i.ldr_str_reg.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.ldr_str_reg.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_str_reg.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.ldr_str_reg.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.ldr_str_reg.rm].x; /* reg */
    rob->sr[1].n = i.ldr_str_reg.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.ldr_str_reg.rm].x ? i.ldr_str_reg.rm : t[tid].map[i.ldr_str_reg.rm].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = i.ldr_str_reg.S?i.ldr_str_reg.size:0; /* shift(0,2,3) */
    if (i.ldr_str_reg.opc==0) { /* ST */
      rob->sr[3].t = i.ldr_str_reg.rt==31 ? 1 : /* ZERO */
                     !t[tid].map[i.ldr_str_reg.rt].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ldr_str_reg.rt].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[3].x = i.ldr_str_reg.rt==31 ? 0 : /* ZERO */
                     t[tid].map[i.ldr_str_reg.rt].x; /* reg */
      rob->sr[3].n = i.ldr_str_reg.rt==31 ? 0 : /* ZERO */
                     !t[tid].map[i.ldr_str_reg.rt].x ? i.ldr_str_reg.rt : t[tid].map[i.ldr_str_reg.rt].rob;
    }
    /* dest */
    if (i.ldr_str_reg.opc && i.ldr_str_reg.rt!=31) { /* LD */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.ldr_str_reg.rt;
      t[tid].map[i.ldr_str_reg.rt].x = 1;
      t[tid].map[i.ldr_str_reg.rt].rob = robid;
    }
    return (0);
  }
  else if (i.ldr_str_reg.op29_25==0x1e && i.ldr_str_reg.op24==0 && i.ldr_str_reg.op21==1 && i.ldr_str_reg.op11_10==2) { /* C7.3.168 LDR(immediate,SIMD&FP), C7.3.286 STR(immediate,SIMD&FP) */
    /* C7.3.168 ldrb(8):   size=00, opc=01 | C7.3.286 strb(8):   size=00, opc=00 */
    /* C7.3.168 ldrh(16):  size=01, opc=01 | C7.3.286 strh(16):  size=01, opc=00 */
    /* C7.3.168 ldrs(32):  size=10, opc=01 | C7.3.286 strs(32):  size=10, opc=00 */
    /* C7.3.168 ldrd(64):  size=11, opc=01 | C7.3.286 strd(64):  size=11, opc=00 */
    /* C7.3.168 ldrq(128): size=00, opc=11 | C7.3.286 strq(128): size=00, opc=10 */
    /* option: 000:(uxtb), 001:(uxth), 010:uxtw, 011:uxtx, 100:(sxtb), 101:(sxth), 110:sxtw, 111:sxtx */
    /* shift:  S==1 ? size : 0 */
    rob->type  = (i.ldr_str_reg.opc&1)?3:4; /* LD/ST */
    switch (((i.ldr_str_reg.opc&2)<<1)|i.ldr_str_reg.size) {
    case 0:
      rob->opcd = 8; /* VLDRB(8) */
      break;
    case 1:
      rob->opcd = 9; /* VLDRH(16) */
      break;
    case 2:
      rob->opcd = 10; /* VLDRS(32) */
      break;
    case 3:
      rob->opcd = 11; /* VLDRD(64) */
      break;
    case 4:
      rob->opcd = 12; /* VLDRQ(128) */
      break;
    default:
      i_xxx(rob);
      return (0);
    }
    rob->sop   = 8|i.ldr_str_reg.option; /* option: 000:(uxtb), 001:(uxth), 010:uxtw, 011:uxtx, 100:(sxtb), 101:(sxth), 110:sxtw, 111:sxtx */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 1; /* ldst128 */
    rob->plus  = 1; /* plus */
    rob->pre   = 1; /* addr+offset */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    v0 = VECREGTOP+i.ldr_str_reg.rt;
    rob->sr[0].t = !t[tid].map[i.ldr_str_reg.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_str_reg.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ldr_str_reg.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ldr_str_reg.rn].x ? i.ldr_str_reg.rn : t[tid].map[i.ldr_str_reg.rn].rob;
    rob->sr[1].t = i.ldr_str_reg.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.ldr_str_reg.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_str_reg.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.ldr_str_reg.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.ldr_str_reg.rm].x; /* reg */
    rob->sr[1].n = i.ldr_str_reg.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.ldr_str_reg.rm].x ? i.ldr_str_reg.rm : t[tid].map[i.ldr_str_reg.rm].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = i.ldr_str_reg.S?((i.ldr_str_reg.opc&2)<<1)|i.ldr_str_reg.size:0; /* shift(0,2,3) */
    if ((i.ldr_str_reg.opc&1)==0) { /* ST */
      rob->sr[3].t = !t[tid].map[v0].x ? 2 :
                     (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[3].x = t[tid].map[v0].x; /* reg */
      rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
    }
    /* dest */
    if (i.ldr_str_reg.opc&1) { /* LD */
      rob->dr[1].t = 1;
      rob->dr[1].n = v0;
      t[tid].map[v0].x = 1;
      t[tid].map[v0].rob = robid;
    }
    return (0);
  }
  else if (i.ldr_str_literal.op29_24==0x18) { /* C6.6.84 LDR(literal), C6.6.95 LDRSW(literal) */
    rob->type  = 3; /* LD */
    rob->opcd  = i.ldr_str_literal.opc==1?3:i.ldr_str_literal.opc==0?2:6; /* LDR/LDRW/LDRSW */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.ldr_str_literal.opc!=0; /* 0:ld32, 1:ld64 */
    rob->plus  = 1; /* plus */
    rob->pre   = 1; /* addr+offset */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = 1; /* PC */
    rob->sr[0].x = 0; /* renamig N.A. */
    rob->sr[0].n = pc; /* PC */
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = (Sll)((Ull)i.ldr_str_literal.imm19<<45)>>43;
    /* dest */
    if (i.ldr_str_literal.rt!=31) { /* LD */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.ldr_str_literal.rt;
      t[tid].map[i.ldr_str_literal.rt].x = 1;
      t[tid].map[i.ldr_str_literal.rt].rob = robid;
    }
    return (0);
  }
  else if (i.ldr_str_literal.op29_24==0x1c) { /* C7.3.167 LDR(literal,simd&fp) */
    rob->type  = 3; /* LD */
    rob->opcd  = i.ldr_str_literal.opc==0?10:i.ldr_str_literal.opc==1?11:12; /* VLDRS/VLDRD/VLDRQ */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.ldr_str_literal.opc!=0; /* 0:ldst32/64, 1:ldst128 */
    rob->plus  = 1; /* plus */
    rob->pre   = 1; /* addr+offset */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    v0 = VECREGTOP+i.ldr_str_literal.rt;
    rob->sr[0].t = 1; /* PC */
    rob->sr[0].x = 0; /* renamig N.A. */
    rob->sr[0].n = pc; /* PC */
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = (Sll)((Ull)i.ldr_str_literal.imm19<<45)>>43;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.ld1_st1_mult.op31==0 && i.ld1_st1_mult.op29_25==0x06 && i.ld1_st1_mult.op24==0 && i.ld1_st1_mult.R==0) { /* C7.3.152 LD1(multiple structures), C7.3.155 LD2(multiple structures), C7.3.158 LD3(multiple structures), C7.3.161 LD4(multiple structures), C7.3.275 ST1(multiple structures), C7.3.277 ST2(multiple structures), C7.3.279 ST3(multiple structures), C7.3.281 ST4(multiple structures) */
    /* C7.3.152 ld1_nofs(1r  ,rpt=1,sel=1):op23=0,op=0111      |C7.3.275 st1_nofs(1r  ) */
    /* C7.3.152 ld1_post(1r+r,rpt=1,sel=1):op23=1,op=0111,rm<31|C7.3.275 st1_post(1r+r) */
    /* C7.3.152 ld1_post(1r+i,rpt=1,sel=1):op23=1,op=0111,rm=31|C7.3.275 st1_post(1r+i) */

    /* C7.3.152 ld1_nofs(2r  ,rpt=2,sel=1):op23=0,op=1010      |C7.3.275 st1_nofs(2r  ) */
    /* C7.3.152 ld1_post(2r+r,rpt=2,sel=1):op23=1,op=1010,rm<31|C7.3.275 st1_post(2r+r) */
    /* C7.3.152 ld1_post(2r+i,rpt=2,sel=1):op23=1,op=1010,rm=31|C7.3.275 st1_post(2r+i) */

    /* C7.3.152 ld1_nofs(3r  ,rpt=3,sel=1):op23=0,op=0110      |C7.3.275 st1_nofs(3r  ) */
    /* C7.3.152 ld1_post(3r+r,rpt=3,sel=1):op23=1,op=0110,rm<31|C7.3.275 st1_post(3r+r) */
    /* C7.3.152 ld1_post(3r+i,rpt=3,sel=1):op23=1,op=0110,rm=31|C7.3.275 st1_post(3r+i) */

    /* C7.3.152 ld1_nofs(4r  ,rpt=4,sel=1):op23=0,op=0010      |C7.3.275 st1_nofs(4r  ) */
    /* C7.3.152 ld1_post(4r+r,rpt=4,sel=1):op23=1,op=0010,rm<31|C7.3.275 st1_post(4r+r) */
    /* C7.3.152 ld1_post(4r+i,rpt=4,sel=1):op23=1,op=0010,rm=31|C7.3.275 st1_post(4r+i) */

    /* C7.3.155 ld2_nofs(2r  ,rpt=1,sel=2):op23=0,op=1000      |C7.3.277 st2_nofs(2r  ) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.155 ld2_post(2r+r,rpt=1,sel=2):op23=1,op=1000,rm<31|C7.3.277 st2_post(2r+r) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.155 ld2_post(2r+i,rpt=1,sel=2):op23=1,op=1000,rm=31|C7.3.277 st2_post(2r+i) *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.158 ld3_nofs(3r  ,rpt=1,sel=3):op23=0,op=0100      |C7.3.279 st3_nofs(3r  ) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.158 ld3_post(3r+r,rpt=1,sel=3):op23=1,op=0100,rm<31|C7.3.279 st3_post(3r+r) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.158 ld3_post(3r+i,rpt=1,sel=3):op23=1,op=0100,rm=31|C7.3.279 st3_post(3r+i) *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.161 ld4_nofs(4r  ,rpt=1,sel=4):op23=0,op=0000      |C7.3.281 st4_nofs(4r  ) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.161 ld4_post(4r+r,rpt=1,sel=4):op23=1,op=0000,rm<31|C7.3.281 st4_post(4r+r) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.161 ld4_post(4r+i,rpt=1,sel=4):op23=1,op=0000,rm=31|C7.3.281 st4_post(4r+i) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /*     T=8b : size=00,Q=0     */
    /*     T=16b: size=00,Q=1     */
    /*     T=4h : size=01,Q=0     */
    /*     T=8h : size=01,Q=1     */
    /*     T=2s : size=10,Q=0     */
    /*     T=4s : size=10,Q=1     */
    /*     T=1d : size=11,Q=0     */
    /*     T=2d : size=11,Q=1     */
    /*==============================================================================================*/
    /* integer datasize = if Q == '1' then 128 else 64;                                             */
    /* integer esize = 8 << UInt(size);                                    8,16,32,64               */
    /* integer elements = datasize DIV esize; 128b:16,8,4,2 64b:8,4,2,1   16, 8, 4, 2 / 8, 4, 2, 1  */
    /* offs = 0;                                                                                    */
    /*==============================================================================================*/
    /* ¥ì¥¸¥¹¥¿Æâ¤ÇÏ¢Â³ÎÎ°è o_ldst(128bit)¤ò4Ì¿ÎáÊ¬³ä,³Æ²ó1¥ì¥¸¥¹¥¿¤ËÄ¾ÀÜ³ÊÇ¼                       */
    /* for r = t,t+1,t+2,t+3 (11r:1 12r:2 13r:3 14r:4)                                              */
    /*  for e = 0 to elements-1 0-16,8,4,2,1                              16, 8, 4, 2 / 8, 4, 2, 1  */
    /*   LD: V[r].Elem[e, esize] = Mem[addr+offs, ebytes, AccT]; loc[e*esize] <- m[esize]           */
    /*   ST: Mem[addr+offs, ebytes, AccT] = V[r].Elem[e, esize]; m[esize] <- loc[e*esize]           */
    /*   offs = offs + ebytes;                                   m+=esize                           */
    /*==============================================================================================*/
    /* Ê£¿ô¥ì¥¸¥¹¥¿¤ò¥¤¥ó¥¿¥ê¡¼¥Ö»ÈÍÑ o_ldst(128bit)¤ò4Ì¿ÎáÊ¬³ä,AUX¤Ë³ÊÇ¼,AUX*4->UREG¤ò4Ì¿ÎáÄÉ²Ã    *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* for e = 0 to elements-1 0-16,8,4,2,1                               16, 8, 4, 2 / 8, 4, 2, 1  */
    /*  for s = t,t+1,t+2,t+3 (22r:2 33r:3 44r:4)                                                   */
    /*   LD: V[s].Elem[e, esize] = Mem[addr+offs, ebytes, AccT]; loc[e*esize] <- m[esize]           */
    /*   ST: Mem[addr+offs, ebytes, AccT] = V[s].Elem[e, esize]; m[esize] <- loc[e*esize]           */
    /*   offs = offs + ebytes;                                   m+=esize                           */
    /*==============================================================================================*/
    /* if wback then                                                                                */
    /*  if m != 31 then    offs = X[m];                                                             */
    /*  if n == 31  SP[] = address + offs;                                                          */
    /*  else        X[n] = address + offs;                                                          */
    /*==============================================================================================*/
    int num_ldst;
    int no_post_inc = i.ld1_st1_mult.op23==0;
    int post_imm = i.ld1_st1_mult.op23 && i.ld1_st1_mult.rm==31; /* auto_immediate_offset */
    int post_reg = i.ld1_st1_mult.op23 && i.ld1_st1_mult.rm!=31; /* auto_immediate_offset */
    switch (i.ld1_st1_mult.opcode) {
    case  7: num_ldst = 1; break;
    case 10: num_ldst = 2; break;
    case  6: num_ldst = 3; break;
    case  2: num_ldst = 4; break;
    default:   i_xxx(rob); return (0);
    }
    if (!post_reg || mc<num_ldst) {
      rob->type  = i.ld1_st1_mult.L?3:4; /* LD/ST */
      rob->opcd  = i.ld1_st1_mult.Q?12:11; /* 12:VLDRQ/VSTRQ(16), 11:VLDRD/VSTRD(8) */
      rob->sop   = 0; /* not used */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = i.ld1_st1_mult.Q; /* 0:ld64, 1:ld128 */
      rob->plus  = 1; /* plus */
      rob->pre   = !post_imm; /* addr+offset */
      rob->wb    = post_imm;
      rob->updt  = 0; /* not used */
      v0 = VECREGTOP+(i.ld1_st1_mult.rt + mc)%VECREG;
      rob->sr[0].t = !t[tid].map[i.ld1_st1_mult.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ld1_st1_mult.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[i.ld1_st1_mult.rn].x; /* reg */
      rob->sr[0].n = !t[tid].map[i.ld1_st1_mult.rn].x ? i.ld1_st1_mult.rn : t[tid].map[i.ld1_st1_mult.rn].rob;
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = (i.ld1_st1_mult.Q?16:8)*(post_imm?1:mc);
      if (i.ld1_st1_mult.L==0) { /* ST */
	rob->sr[3].t = !t[tid].map[v0].x ? 2 :                                              
                       (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
	rob->sr[3].x = t[tid].map[v0].x; /* reg */                                          
	rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;                         
      }
      /* dest */
      if (i.ld1_st1_mult.L) { /* LD */
        rob->dr[1].t = 1;
        rob->dr[1].n = v0;
        t[tid].map[v0].x = 1;
        t[tid].map[v0].rob = robid;
      }
      if (rob->wb) {
        rob->dr[2].t = 1; /* writeback-basereg */
        rob->dr[2].n = i.ld1_st1_mult.rn;
        t[tid].map[i.ld1_st1_mult.rn].x = 2;
        t[tid].map[i.ld1_st1_mult.rn].rob = robid;
      }
      if (mc+1 < num_ldst) { /* continue */
        rob->term = 0;
        return (1); /* continue */
      }
      else if (post_reg && mc < num_ldst) {
        rob->term = 0;
        return (1); /* continue */
      }
      else
        return (0); /* finish */
    }
    else { /* post_reg & update base */
      rob->type  = 0; /* ALU */
      rob->opcd  = 4; /* ADD */
      rob->sop   = 0; /* LSL */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = 1; /* 1:add64 */
      rob->plus  = 0; /* not used */
      rob->pre   = 0; /* not used */
      rob->wb    = 0; /* not used */
      rob->updt  = 0; /* not used */
      rob->sr[0].t = !t[tid].map[i.ld1_st1_mult.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ld1_st1_mult.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[i.ld1_st1_mult.rn].x; /* reg */
      rob->sr[0].n = !t[tid].map[i.ld1_st1_mult.rn].x ? i.ld1_st1_mult.rn : t[tid].map[i.ld1_st1_mult.rn].rob;
      rob->sr[1].t = !t[tid].map[i.ld1_st1_mult.rm].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ld1_st1_mult.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[1].x = t[tid].map[i.ld1_st1_mult.rm].x; /* reg */
      rob->sr[1].n = !t[tid].map[i.ld1_st1_mult.rm].x ? i.ld1_st1_mult.rm : t[tid].map[i.ld1_st1_mult.rm].rob;
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = 0; /* LSL 0 */
      /* dest */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.ld1_st1_mult.rn;
      t[tid].map[i.ld1_st1_mult.rn].x = 1;
      t[tid].map[i.ld1_st1_mult.rn].rob = robid;
      return (0); /* finish */
    }
  }
  else if (i.ld1_st1_sing.op31==0 && i.ld1_st1_sing.op29_25==0x06 && i.ld1_st1_sing.op24==1 && (i.ld1_st1_sing.opcode&6)!=6) { /* C7.3.153 LD1(single structures), C7.3.156 LD2(single structure), C7.3.159 LD3(single structure), C7.3.162 LD4(single structure), C7.3.276 ST1(single structure), C7.3.278 ST2(single structure), C7.3.280 ST3(single structure), C7.3.282 ST4(single structure) */
    /* C7.3.153 ld1_nofs(1r  ):op23=0,R=0,op=xx0      |C7.3.276 st1_nofs(1r  ) */
    /* C7.3.153 ld1_post(1r+r):op23=1,R=0,op=xx0,rm<31|C7.3.276 st1_post(1r+r) */
    /* C7.3.153 ld1_post(1r+i):op23=1,R=0,op=xx0,rm=31|C7.3.276 st1_post(1r+i) */
    /*     B: opc=000             -> scl=0 esz=1B selem=1 idx=Q:S:size<1:0>    */
    /*     H: opc=010     size=x0 -> scl=1 esz=2B selem=1 idx=Q:S:size<1>      */
    /*     S: opc=100     size=00 -> scl=2 esz=4B selem=1 idx=Q:S              */
    /*     D: opc=100 S=0 size=01 -> scl=3 esz=8B selem=1 idx=Q                */
    /*=========================================================================================*/
    /* 1¥ì¥¸¥¹¥¿¤Î»ØÄê°ÌÃÖ¤ËÄ¾ÀÜ³ÊÇ¼                                                           */
    /*  offs = 0;                                                                              */
    /*  LD: V[r].Elem[idx, esz] = Mem[addr+offs, ebytes, AccT]; loc[idx*esz] <- m[esz]         */
    /*  ST: Mem[addr+offs, ebytes, AccT] = V[r].Elem[idx, esz]; m[esz] <- loc[idx*esz]         */
    /*  offs = offs + ebytes;                                     m+=esz                       */
    /*=========================================================================================*/
    /* C7.3.156 ld2_nofs(2r  ):op23=0,R=1,op=xx0      |C7.3.278 st2_nofs(2r  ) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.156 ld2_post(2r+r):op23=1,R=1,op=xx0,rm<31|C7.3.278 st2_post(2r+r) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.156 ld2_post(2r+i):op23=1,R=1,op=xx0,rm=31|C7.3.278 st2_post(2r+i) *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.159 ld3_nofs(3r  ):op23=0,R=0,op=xx1      |C7.3.280 st3_nofs(3r  ) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.159 ld3_post(3r+r):op23=1,R=0,op=xx1,rm<31|C7.3.280 st3_post(3r+r) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.159 ld3_post(3r+i):op23=1,R=0,op=xx1,rm=31|C7.3.280 st3_post(3r+i) *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.162 ld4_nofs(4r  ):op23=0,R=1,op=xx1      |C7.3.282 st4_nofs(4r  ) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.162 ld4_post(4r+r):op23=1,R=1,op=xx1,rm<31|C7.3.282 st4_post(4r+r) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.162 ld4_post(4r+i):op23=1,R=1,op=xx1,rm=31|C7.3.282 st4_post(4r+i) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /*=========================================================================================*/
    /* if wback then                                                                           */
    /*  if m != 31 then    offs = X[m];                                                        */
    /*  if n == 31  SP[] = address + offs;                                                     */
    /*  else        X[n] = address + offs;                                                     */
    /*=========================================================================================*/
    int num_ldst;
    int esz, idx;
    int no_post_inc = i.ld1_st1_sing.op23==0;
    int post_imm = i.ld1_st1_sing.op23 && i.ld1_st1_sing.rm==31; /* auto_immediate_offset */
    int post_reg = i.ld1_st1_sing.op23 && i.ld1_st1_sing.rm!=31; /* auto_immediate_offset */
    switch (i.ld1_st1_sing.opcode) {
    case 0: { num_ldst=1; esz=1; idx=(i.ld1_st1_sing.Q<<3)|(i.ld1_st1_sing.S<<2)|i.ld1_st1_sing.size; break;}
    case 2: { num_ldst=1; esz=2; idx=(i.ld1_st1_sing.Q<<3)|(i.ld1_st1_sing.S<<2)|i.ld1_st1_sing.size; break;}
    case 4: if ((i.ld1_st1_sing.size&1)==0)
            { num_ldst=1; esz=4; idx=(i.ld1_st1_sing.Q<<3)|(i.ld1_st1_sing.S<<2); break;}
            else
	    { num_ldst=1; esz=8; idx=(i.ld1_st1_sing.Q<<3); break;}
    default: i_xxx(rob); return (0);
    }
    if (!post_reg || mc<num_ldst) {
      rob->type  = i.ld1_st1_sing.L?3:4; /* LD/ST */
      rob->opcd  = esz==1?8:esz==2?9:esz==4?10:11; /* 8:VLDRB(8), 9:VlDRH(16), 10:VLDRS(32), 11:VLDRD(64) */
                                                   /* 8:VSTRB(8), 9:VSTRH(16), 10:VSTRS(32), 11:VSTRD(64) */
      rob->sop   = 0; /* not used */
      rob->ptw   = 1; /* partial_reg_write */
      rob->size  = 0; /* not used */
      rob->idx   = idx; /* reg_index 15-0 byte-portion */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = i.ld1_st1_sing.Q; /* 0:ld64, 1:ld128 */
      rob->plus  = 1; /* plus */
      rob->pre   = !post_imm; /* addr+offset */
      rob->wb    = post_imm;
      rob->updt  = 0; /* not used */
      v0 = VECREGTOP+(i.ld1_st1_sing.rt + mc)%VECREG;
      rob->sr[0].t = !t[tid].map[i.ld1_st1_sing.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ld1_st1_sing.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[i.ld1_st1_sing.rn].x; /* reg */
      rob->sr[0].n = !t[tid].map[i.ld1_st1_sing.rn].x ? i.ld1_st1_sing.rn : t[tid].map[i.ld1_st1_sing.rn].rob;
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = esz*(post_imm?1:mc);
      rob->sr[3].t = !t[tid].map[v0].x ? 2 : /* for partial_LD and ST */
                     (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[3].x = t[tid].map[v0].x; /* reg */
      rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
      /* dest */
      if (i.ld1_st1_sing.L) { /* LD */
        rob->dr[1].t = 1;
        rob->dr[1].n = v0;
        t[tid].map[v0].x = 1;
        t[tid].map[v0].rob = robid;
      }
      if (rob->wb) {
        rob->dr[2].t = 1; /* writeback-basereg */
        rob->dr[2].n = i.ld1_st1_sing.rn;
        t[tid].map[i.ld1_st1_sing.rn].x = 2;
        t[tid].map[i.ld1_st1_sing.rn].rob = robid;
      }
      if (mc+1 < num_ldst) { /* continue */
        rob->term = 0;
        return (1); /* continue */
      }
      else if (post_reg && mc < num_ldst) {
        rob->term = 0;
        return (1); /* continue */
      }
      else
        return (0); /* finish */
    }
    else { /* post_reg & update base */
      rob->type  = 0; /* ALU */
      rob->opcd  = 4; /* ADD */
      rob->sop   = 0; /* LSL */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = 1; /* 1:add64 */
      rob->plus  = 0; /* not used */
      rob->pre   = 0; /* not used */
      rob->wb    = 0; /* not used */
      rob->updt  = 0; /* not used */
      rob->sr[0].t = !t[tid].map[i.ld1_st1_sing.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ld1_st1_sing.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[i.ld1_st1_sing.rn].x; /* reg */
      rob->sr[0].n = !t[tid].map[i.ld1_st1_sing.rn].x ? i.ld1_st1_sing.rn : t[tid].map[i.ld1_st1_sing.rn].rob;
      rob->sr[1].t = !t[tid].map[i.ld1_st1_sing.rm].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ld1_st1_sing.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[1].x = t[tid].map[i.ld1_st1_sing.rm].x; /* reg */
      rob->sr[1].n = !t[tid].map[i.ld1_st1_sing.rm].x ? i.ld1_st1_sing.rm : t[tid].map[i.ld1_st1_sing.rm].rob;
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = 0; /* LSL 0 */
      /* dest */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.ld1_st1_sing.rn;
      t[tid].map[i.ld1_st1_sing.rn].x = 1;
      t[tid].map[i.ld1_st1_sing.rn].rob = robid;
      return (0); /* finish */
    }
  }
  else if (i.ld1_st1_sing.op31==0 && i.ld1_st1_sing.op29_25==0x06 && i.ld1_st1_sing.op24==1 && i.ld1_st1_sing.L==1 && (i.ld1_st1_sing.opcode&6)==6) { /* C7.3.154 LD1R, C7.3.157 LD2R, C7.3.160 LD3R, C7.3.163 LD4R */
    /* C7.3.154 ld1_nofs(1r  ):op23=0,R=0,op=110       */
    /* C7.3.154 ld1_post(1r+r):op23=1,R=0,op=110,rm<31 */
    /* C7.3.154 ld1_post(1r+i):op23=1,R=0,op=110,rm=31 */
    /*    8B: opc=110 S=0 size=00 Q=0 -> scl=4 esz=16B selem=1 replicate */
    /*   16B: opc=110 S=0 size=00 Q=1 -> scl=4 esz=16B selem=1 replicate */
    /*    4H: opc=110 S=0 size=01 Q=0 -> scl=4 esz=16B selem=1 replicate */
    /*    8H: opc=110 S=0 size=01 Q=1 -> scl=4 esz=16B selem=1 replicate */
    /*    2S: opc=110 S=0 size=10 Q=0 -> scl=4 esz=16B selem=1 replicate */
    /*    4S: opc=110 S=0 size=10 Q=1 -> scl=4 esz=16B selem=1 replicate */
    /*    1D: opc=110 S=0 size=11 Q=0 -> scl=4 esz=16B selem=1 replicate */
    /*    2D: opc=110 S=0 size=11 Q=1 -> scl=4 esz=16B selem=1 replicate */
    /*=================================================================*/
    /*=================================================================*/
    /* C7.3.157 ld2_nofs(2r  ):op23=0,R=1,op=110       *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.157 ld2_post(2r+r):op23=1,R=1,op=110,rm<31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.157 ld2_post(2r+i):op23=1,R=1,op=110,rm=31 *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.160 ld3_nofs(3r  ):op23=0,R=0,op=111       *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.160 ld3_post(3r+r):op23=1,R=0,op=111,rm<31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.160 ld3_post(3r+i):op23=1,R=0,op=111,rm=31 *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.163 ld4_nofs(4r  ):op23=0,R=1,op=111       *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.163 ld4_post(4r+r):op23=1,R=1,op=111,rm<31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.163 ld4_post(4r+i):op23=1,R=1,op=111,rm=31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /*=================================================================*/
    /* if wback then                                                   */
    /*  if m != 31 then    offs = X[m];                                */
    /*  if n == 31  SP[] = address + offs;                             */
    /*  else        X[n] = address + offs;                             */
    /*=================================================================*/
    int num_ldst;
    int esz;
    int no_post_inc = i.ld1_st1_sing.op23==0;
    int post_imm = i.ld1_st1_sing.op23 && i.ld1_st1_sing.rm==31; /* auto_immediate_offset */
    int post_reg = i.ld1_st1_sing.op23 && i.ld1_st1_sing.rm!=31; /* auto_immediate_offset */
    switch (i.ld1_st1_sing.opcode) {
    case 6: { num_ldst=1; esz=1<<i.ld1_st1_sing.size; break;}
    default: i_xxx(rob); return (0);
    }
    if (!post_reg || mc<num_ldst) {
      rob->type  = 3; /* LD */
      rob->opcd  = esz==1?8:esz==2?9:esz==4?10:11; /* 8:VLDRB(8), 9:VlDRH(16), 10:VLDRS(32), 11:VLDRD(64) */
      rob->sop   = 0; /* not used */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 1; /* repeat */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = i.ld1_st1_sing.Q; /* 0:ld64, 1:ld128 */
      rob->plus  = 1; /* plus */
      rob->pre   = !post_imm; /* addr+offset */
      rob->wb    = post_imm;
      rob->updt  = 0; /* not used */
      v0 = VECREGTOP+(i.ld1_st1_sing.rt + mc)%VECREG;
      rob->sr[0].t = !t[tid].map[i.ld1_st1_sing.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ld1_st1_sing.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[i.ld1_st1_sing.rn].x; /* reg */
      rob->sr[0].n = !t[tid].map[i.ld1_st1_sing.rn].x ? i.ld1_st1_sing.rn : t[tid].map[i.ld1_st1_sing.rn].rob;
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = esz*(post_imm?1:mc);
      /* dest */
      if (i.ld1_st1_sing.L) { /* LD */
        rob->dr[1].t = 1;
        rob->dr[1].n = v0;
        t[tid].map[v0].x = 1;
        t[tid].map[v0].rob = robid;
      }
      if (rob->wb) {
        rob->dr[2].t = 1; /* writeback-basereg */
        rob->dr[2].n = i.ld1_st1_sing.rn;
        t[tid].map[i.ld1_st1_sing.rn].x = 2;
        t[tid].map[i.ld1_st1_sing.rn].rob = robid;
      }
      if (mc+1 < num_ldst) { /* continue */
        rob->term = 0;
        return (1); /* continue */
      }
      else if (post_reg && mc < num_ldst) {
        rob->term = 0;
        return (1); /* continue */
      }
      else
        return (0); /* finish */
    }
    else { /* post_reg & update base */
      rob->type  = 0; /* ALU */
      rob->opcd  = 4; /* ADD */
      rob->sop   = 0; /* LSL */
      rob->ptw   = 0; /* not used */
      rob->size  = 0; /* not used */
      rob->idx   = 0; /* not used */
      rob->rep   = 0; /* not used */
      rob->dir   = 0; /* not used */
      rob->iinv  = 0; /* not used */
      rob->oinv  = 0; /* not used */
      rob->dbl   = 1; /* 1:add64 */
      rob->plus  = 0; /* not used */
      rob->pre   = 0; /* not used */
      rob->wb    = 0; /* not used */
      rob->updt  = 0; /* not used */
      rob->sr[0].t = !t[tid].map[i.ld1_st1_sing.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ld1_st1_sing.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[i.ld1_st1_sing.rn].x; /* reg */
      rob->sr[0].n = !t[tid].map[i.ld1_st1_sing.rn].x ? i.ld1_st1_sing.rn : t[tid].map[i.ld1_st1_sing.rn].rob;
      rob->sr[1].t = !t[tid].map[i.ld1_st1_sing.rm].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ld1_st1_sing.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[1].x = t[tid].map[i.ld1_st1_sing.rm].x; /* reg */
      rob->sr[1].n = !t[tid].map[i.ld1_st1_sing.rm].x ? i.ld1_st1_sing.rm : t[tid].map[i.ld1_st1_sing.rm].rob;
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = 0; /* LSL 0 */
      /* dest */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.ld1_st1_sing.rn;
      t[tid].map[i.ld1_st1_sing.rn].x = 1;
      t[tid].map[i.ld1_st1_sing.rn].rob = robid;
      return (0); /* finish */
    }
    return (0); /* finish */
  }
  else if (i.mad.sf==1 && i.mad.op30_24==0x1b && i.mad.op22_21==1) { /* C6.6.163 SMADDL, C6.6.165 SMNEGL, C6.6.166 SMSUBL, C6.6.168 SMULL, C6.6.215 UMADDL, C6.6.216 UMNEGL, C6.6.217 UMSUBL, C6.6.219 UMULL */
    rob->type  = 1; /* MUL */
    rob->opcd  = i.mad.U?(i.mad.o0==0?0:1):(i.mad.o0==0?2:3); /* UMADDL/UMSUBL/SMADDL/SMSUBL */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.mad.sf; /* always 64bit */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.mad.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.mad.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.mad.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.mad.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.mad.rn].x; /* reg */
    rob->sr[0].n = i.mad.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.mad.rn].x ? i.mad.rn : t[tid].map[i.mad.rn].rob;
    rob->sr[1].t = i.mad.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.mad.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.mad.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.mad.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.mad.rm].x; /* reg */
    rob->sr[1].n = i.mad.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.mad.rm].x ? i.mad.rm : t[tid].map[i.mad.rm].rob;
    rob->sr[2].t = i.mad.ra==31 ? 1 : /* ZERO */
                   !t[tid].map[i.mad.ra].x ? 2 :
                   (c[cid].rob[t[tid].map[i.mad.ra].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = i.mad.ra==31 ? 0 : /* ZERO */
                   t[tid].map[i.mad.ra].x; /* reg */
    rob->sr[2].n = i.mad.ra==31 ? 0 : /* ZERO */
                   !t[tid].map[i.mad.ra].x ? i.mad.ra : t[tid].map[i.mad.ra].rob;
    /* dest */
    if (i.mad.rd!=31) { /* MUL */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.mad.rd;
      t[tid].map[i.mad.rd].x = 1;
      t[tid].map[i.mad.rd].rob = robid;
    }
    return (0);
  }
  else if (i.mad.op30_24==0x1b && i.mad.U==0 && i.mad.op22_21==0) { /* C6.6.119 MADD, C6.6.133 MUL, C6.6.120 MNEG, C6.6.132 MSUB */
    rob->type  = 1; /* MUL */
    rob->opcd  = i.mad.o0==0?4:5; /* MADD/MSUB */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.mad.sf; /* 0:mad32, 1:mad64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.mad.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.mad.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.mad.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.mad.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.mad.rn].x; /* reg */
    rob->sr[0].n = i.mad.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.mad.rn].x ? i.mad.rn : t[tid].map[i.mad.rn].rob;
    rob->sr[1].t = i.mad.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.mad.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.mad.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.mad.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.mad.rm].x; /* reg */
    rob->sr[1].n = i.mad.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.mad.rm].x ? i.mad.rm : t[tid].map[i.mad.rm].rob;
    rob->sr[2].t = i.mad.ra==31 ? 1 : /* ZERO */
                   !t[tid].map[i.mad.ra].x ? 2 :
                   (c[cid].rob[t[tid].map[i.mad.ra].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = i.mad.ra==31 ? 0 : /* ZERO */
                   t[tid].map[i.mad.ra].x; /* reg */
    rob->sr[2].n = i.mad.ra==31 ? 0 : /* ZERO */
                   !t[tid].map[i.mad.ra].x ? i.mad.ra : t[tid].map[i.mad.ra].rob;
    /* dest */
    if (i.mad.rd!=31) { /* MUL */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.mad.rd;
      t[tid].map[i.mad.rd].x = 1;
      t[tid].map[i.mad.rd].rob = robid;
    }
    return (0);
  }
  else if (i.mad.sf==1 && i.mad.op30_24==0x1b && i.mad.op22_21==2 && i.mad.o0==0 && i.mad.ra==31) { /* C6.6.167 SMULH, C6.6.218 UMULH */
    rob->type  = 1; /* MUL */
    rob->opcd  = i.mad.U==0?6:7; /* SMULH/UMULH */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 1; /* 0:mad32, 1:mad64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.mad.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.mad.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.mad.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.mad.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.mad.rn].x; /* reg */
    rob->sr[0].n = i.mad.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.mad.rn].x ? i.mad.rn : t[tid].map[i.mad.rn].rob;
    rob->sr[1].t = i.mad.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.mad.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.mad.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.mad.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.mad.rm].x; /* reg */
    rob->sr[1].n = i.mad.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.mad.rm].x ? i.mad.rm : t[tid].map[i.mad.rm].rob;
    /* dest */
    if (i.mad.rd!=31) { /* MUL */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.mad.rd;
      t[tid].map[i.mad.rd].x = 1;
      t[tid].map[i.mad.rd].rob = robid;
    }
    return (0);
  }
  else if (i.div.op30_21==0x0d6 && i.div.op15_11==0x01) { /* C6.6.160 SDIV, C6.6.214 UDIV */
    rob->type  = 1; /* MUL */
    rob->opcd  = i.div.o1==0?8:9; /* UDIV/SDIV */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.div.sf; /* 0:div32, 1:div64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = i.div.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.div.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.div.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.div.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.div.rn].x; /* reg */
    rob->sr[0].n = i.div.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.div.rn].x ? i.div.rn : t[tid].map[i.div.rn].rob;
    rob->sr[1].t = i.div.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.div.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.div.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = i.div.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.div.rm].x; /* reg */
    rob->sr[1].n = i.div.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.div.rm].x ? i.div.rm : t[tid].map[i.div.rm].rob;
    /* dest */
    if (i.div.rd!=31) { /* DIV */
      rob->dr[1].t = 1;
      rob->dr[1].n = i.div.rd;
      t[tid].map[i.div.rd].x = 1;
      t[tid].map[i.div.rd].rob = robid;
    }
    return (0);
  }
  else if (i.fmov_gen.op30_24==0x1e && i.fmov_gen.op21==1 && i.fmov_gen.op15_10==0) { /* C7.3.114 FMOV(general), C7.3.59 FCVTAS(scalar), C7.3.61 FCVTAU(scalar), C7.3.64 FCVTMS(scalar), C7.3.66 FCVTMU(scalar), C7.3.69 FCVTNS(scalar), C7.3.71 FCVTNU(scalar), C7.3.73 FCVTPS(scalar), C7.3.75 FCVTPU(scalar), C7.3.80 FCVTZS(scalar,integer), C7.3.84 FCVTZU(scalar,integer), C7.3.210 SCVTF(scalar,integer), C7.3.308 UCVTF(scalar,integer) */
    /* C7.3.114 fmov   s <-w: sf=0, type=0, rm=0, opc=111 |              C7.3.114 fmov   w<-s:  sf=0, type=0, rm=0, opc=110 */
    /* C7.3.114 fmov   d0<-x: sf=1, type=1, rm=0, opc=111 |              C7.3.114 fmov   x<-d0: sf=1, type=1, rm=0, opc=110 */
    /* C7.3.114 fmov   d1<-x: sf=1, type=2, rm=1, opc=111 |              C7.3.114 fmov   x<-d1: sf=1, type=2, rm=1, opc=110 */

    /*                                                      (int) rintf  C7.3.69  fcvtns w <-s: sf=0, type=0, rm=0, opc=000 */
    /*                                                      (Sll) rintf  C7.3.69  fcvtns x <-s: sf=1, type=0, rm=0, opc=000 */
    /*                                                      (int) rint   C7.3.69  fcvtns w <-d: sf=0, type=1, rm=0, opc=000 */
    /*                                                      (Sll) rint   C7.3.69  fcvtns x <-d: sf=1, type=1, rm=0, opc=000 */
    /*                                                      (int) ceilf  C7.3.73  fcvtps w <-s: sf=0, type=0, rm=1, opc=000 */
    /*                                                      (Sll) ceilf  C7.3.73  fcvtps x <-s: sf=1, type=0, rm=1, opc=000 */
    /*                                                      (int) ceil   C7.3.73  fcvtps w <-d: sf=0, type=1, rm=1, opc=000 */
    /*                                                      (Sll) ceil   C7.3.73  fcvtps x <-d: sf=1, type=1, rm=1, opc=000 */
    /*                                                      (int) floorf C7.3.64  fcvtms w <-s: sf=0, type=0, rm=2, opc=000 */
    /*                                                      (Sll) floorf C7.3.64  fcvtms x <-s: sf=1, type=0, rm=2, opc=000 */
    /*                                                      (int) floor  C7.3.64  fcvtms w <-d: sf=0, type=1, rm=2, opc=000 */
    /*                                                      (Sll) floor  C7.3.64  fcvtms x <-d: sf=1, type=1, rm=2, opc=000 */
    /*                                                      (int) truncf C7.3.80  fcvtzs w <-s: sf=0, type=0, rm=3, opc=000 */
    /*                                                      (Sll) truncf C7.3.80  fcvtzs x <-s: sf=1, type=0, rm=3, opc=000 */
    /*                                                      (int) trunc  C7.3.80  fcvtzs w <-d: sf=0, type=1, rm=3, opc=000 */
    /*                                                      (Sll) trunc  C7.3.80  fcvtzs x <-d: sf=1, type=1, rm=3, opc=000 */
    /* C7.3.210 scvtf  s <-w: sf=0, type=0, rm=0, opc=010 | (int) roundf C7.3.59  fcvtas w <-s: sf=0, type=0, rm=0, opc=100 */
    /* C7.3.210 scvtf  s <-x: sf=1, type=0, rm=0, opc=010 | (Sll) roundf C7.3.59  fcvtas x <-s: sf=1, type=0, rm=0, opc=100 */
    /* C7.3.210 scvtf  d <-w: sf=0, type=1, rm=0, opc=010 | (int) round  C7.3.59  fcvtas w <-d: sf=0, type=1, rm=0, opc=100 */
    /* C7.3.210 scvtf  d <-x: sf=1, type=1, rm=0, opc=010 | (Sll) round  C7.3.59  fcvtas x <-d: sf=1, type=1, rm=0, opc=100 */

    /*                                                      (Uint)rintf  C7.3.71  fcvtnu w <-s: sf=0, type=0, rm=0, opc=001 */
    /*                                                      (Ull) rintf  C7.3.71  fcvtnu x <-s: sf=1, type=0, rm=0, opc=001 */
    /*                                                      (Uint)rint   C7.3.71  fcvtnu w <-d: sf=0, type=1, rm=0, opc=001 */
    /*                                                      (Ull) rint   C7.3.71  fcvtnu x <-d: sf=1, type=1, rm=0, opc=001 */
    /*                                                      (Uint)ceilf  C7.3.75  fcvtpu w <-s: sf=0, type=0, rm=1, opc=001 */
    /*                                                      (Ull) ceilf  C7.3.75  fcvtpu x <-s: sf=1, type=0, rm=1, opc=001 */
    /*                                                      (Uint)ceil   C7.3.75  fcvtpu w <-d: sf=0, type=1, rm=1, opc=001 */
    /*                                                      (Ull) ceil   C7.3.75  fcvtpu x <-d: sf=1, type=1, rm=1, opc=001 */
    /*                                                      (Uint)floorf C7.3.66  fcvtmu w <-s: sf=0, type=0, rm=2, opc=001 */
    /*                                                      (Ull) floorf C7.3.66  fcvtmu x <-s: sf=1, type=0, rm=2, opc=001 */
    /*                                                      (Uint)floor  C7.3.66  fcvtmu w <-d: sf=0, type=1, rm=2, opc=001 */
    /*                                                      (Ull) floor  C7.3.66  fcvtmu x <-d: sf=1, type=1, rm=2, opc=001 */
    /*                                                      (Uint)truncf C7.3.84  fcvtzu w <-s: sf=0, type=0, rm=3, opc=001 */
    /*                                                      (Ull) truncf C7.3.84  fcvtzu x <-s: sf=1, type=0, rm=3, opc=001 */
    /*                                                      (Uint)trunc  C7.3.84  fcvtzu w <-d: sf=0, type=1, rm=3, opc=001 */
    /*                                                      (Ull) trunc  C7.3.84  fcvtzu x <-d: sf=1, type=1, rm=3, opc=001 */
    /* C7.3.308 ucvtf  s <-w: sf=0, type=0, rm=0, opc=011 | (Uint)roundf C7.3.61  fcvtau w <-s: sf=0, type=0, rm=0, opc=101 */
    /* C7.3.308 ucvtf  s <-x: sf=1, type=0, rm=0, opc=011 | (Ull) roundf C7.3.61  fcvtau x <-s: sf=1, type=0, rm=0, opc=101 */
    /* C7.3.308 ucvtf  d <-w: sf=0, type=1, rm=0, opc=011 | (Uint)round  C7.3.61  fcvtau w <-d: sf=0, type=1, rm=0, opc=101 */
    /* C7.3.308 ucvtf  d <-x: sf=1, type=1, rm=0, opc=011 | (Ull) round  C7.3.61  fcvtau x <-d: sf=1, type=1, rm=0, opc=101 */
    rob->type  = 2; /* VXX */
    rob->opcd  =  (i.fmov_gen.opc>=6 && i.fmov_gen.type< 2)?0:   /* FMOVL */
                  (i.fmov_gen.opc>=6 && i.fmov_gen.type==2)?0:   /* FMOVH */
                (!(i.fmov_gen.opc&1) && i.fmov_gen.type==0)?2:   /* CVTSS with sop|=0 */
                (!(i.fmov_gen.opc&1) && i.fmov_gen.type==1)?2:   /* CVTSD with sop|=8 */
                ( (i.fmov_gen.opc&1) && i.fmov_gen.type==0)?3:   /* CVTUS with sop|=0 */
                ( (i.fmov_gen.opc&1) && i.fmov_gen.type==1)?3:0; /* CVTUD with sop|=8 /error */
    rob->sop   = (i.fmov_gen.opc>=6)?(i.fmov_gen.type<2?0:1):    /* 0:FMOVL, 1:FMOVH  */
               ((!(i.fmov_gen.opc&1) && i.fmov_gen.type==1)      /* CVTSD with sop|=8 */
              ||( (i.fmov_gen.opc&1) && i.fmov_gen.type==1)?8:0) /* CVTUD with sop|=8 */
	        |((i.fmov_gen.opc<=1)?i.fmov_gen.mode:4);        /* 0:rint, 1:ceil, 2:floor, 3:trunc, 4:round */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = (i.fmov_gen.opc==2 || i.fmov_gen.opc==3 || i.fmov_gen.opc==7)?1:0; /* 0:RR<-VR, 1:VR<-RR */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fmov_gen.sf; /* 0:WR, 1:XR */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = !rob->dir? VECREGTOP+i.fmov_gen.rn : i.fmov_gen.rn; /* 0:RR<-VR, 1:VR<-RR */
    v0 = !rob->dir? i.fmov_gen.rd : VECREGTOP+i.fmov_gen.rd; /* 0:RR<-VR, 1:VR<-RR */
    rob->sr[0].t = (rob->dir && s1==31) ? 1 : /* ZERO */
                   !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = (rob->dir && s1==31) ? 0 : /* ZERO */
                   t[tid].map[s1].x; /* reg */
    rob->sr[0].n = (rob->dir && s1==31) ? 0 : /* ZERO */
                   !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    if (i.fmov_gen.opc==7 && i.fmov_gen.sf) { /* partial update needs d0 */
      rob->sr[1].t = !t[tid].map[v0].x ? 2 :
                     (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[1].x = t[tid].map[v0].x; /* reg */
      rob->sr[1].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
    }
    /* dest */
    if (rob->dir || v0!=31) { /* MOV */
      rob->dr[1].t = 1;
      rob->dr[1].n = v0;
      t[tid].map[v0].x = 1;
      t[tid].map[v0].rob = robid;
    }
    return (0);
  }
  else if (i.fmov_sca_imm.op31_24==0x1e && (i.fmov_sca_imm.type&2)==0 && i.fmov_sca_imm.op21==1 && i.fmov_sca_imm.op12_10==4 && i.fmov_sca_imm.rn==0 ) { /* C7.3.115 FMOV(scalar,immediate) */
    Ull i8  = i.fmov_sca_imm.imm8;
    Ull s   = i8>>7;
    Ull xe6 = (~i8>>6)&1;
    Ull e6  = (i8>>6)&1;
    Ull e54 = (i8>>4)&3;
    Ull f   = i8&15;
    rob->type  = 2; /* VXX */
    rob->opcd  = 0; /* FMOVL */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 1; /* 0:RR<-VR, 1:VR<-RR */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fmov_sca_imm.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    v0 = VECREGTOP+i.fmov_sca_imm.rd;
    rob->sr[0].t = 1; /* immediate */
    rob->sr[0].x = 0; /* renamig N.A. */
    if ((i.fmov_sca_imm.type&1)==0) { /* single s=1 e=8  f=23 */
      /* s.xe6.e6.e6.e6.e6.e6.e54.f.zero(19) */
      rob->sr[0].n = (s<<31)|(xe6<<30)|(e6<<29)|(e6<<28)|(e6<<27)|(e6<<26)|(e6<<25)|(e54<<23)|(f<<19);
    }
    else { /* double s=1 e=11 f=52 */
      /* s.xe6.e6.e6.e6.e6.e6.e6.e6.e6.e54.f.zero(48) */
      rob->sr[0].n = (s<<63)|(xe6<<62)|(e6<<61)|(e6<<60)|(e6<<59)|(e6<<58)|(e6<<57)|(e6<<56)|(e6<<55)|(e6<<54)|(e54<<52)|(f<<48);
    }
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = 0; /* ZERO */
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.movi.op31==0 && i.movi.op28_19==0x1e0 && i.movi.op11_10==1) { /* C7.3.12 BIC(vector,immediate), C7.3.112 FMOV(vector,immediate), C7.3.179 MOVI, C7.3.183 MVNI, C7.3.187 ORR(vector,immediate) */
    /* C7.3.179 movi32  Vd.T,#imm8,lsl #0 :      cmode=0000, op=0 */
    /* C7.3.183 mvni32  Vd.T,#imm8,lsl #0 :      cmode=0000, op=1 */
    /* C7.3.187 orr32   Vd.T,#imm8,lsl #0 :      cmode=0001, op=0 */
    /* C7.3.12  bic32   Vd.T,#imm8,lsl #0 :      cmode=0001, op=1 */
    /* C7.3.179 movi32  Vd.T,#imm8,lsl #8 :      cmode=0010, op=0 */
    /* C7.3.183 mvni32  Vd.T,#imm8,lsl #8 :      cmode=0010, op=1 */
    /* C7.3.187 orr32   Vd.T,#imm8,lsl #8 :      cmode=0011, op=0 */
    /* C7.3.12  bic32   Vd.T,#imm8,lsl #8 :      cmode=0011, op=1 */
    /* C7.3.179 movi32  Vd.T,#imm8,lsl #16:      cmode=0100, op=0 */
    /* C7.3.183 mvni32  Vd.T,#imm8,lsl #16:      cmode=0100, op=1 */
    /* C7.3.187 orr32   Vd.T,#imm8,lsl #16:      cmode=0101, op=0 */
    /* C7.3.12  bic32   Vd.T,#imm8,lsl #16:      cmode=0101, op=1 */
    /* C7.3.179 movi32  Vd.T,#imm8,lsl #24:      cmode=0110, op=0 */
    /* C7.3.183 mvni32  Vd.T,#imm8,lsl #24:      cmode=0110, op=1 */
    /* C7.3.187 orr32   Vd.T,#imm8,lsl #24:      cmode=0111, op=0 */
    /* C7.3.12  bic32   Vd.T,#imm8,lsl #24:      cmode=0111, op=1 */
    /*                     2s               Q=0                   */
    /*                     4s               Q=1                   */
    /* C7.3.179 movi16  Vd.T,#imm8,lsl #0 :      cmode=1000, op=0 */
    /* C7.3.183 mvni16  Vd.T,#imm8,lsl #0 :      cmode=1000, op=1 */
    /* C7.3.187 orr16   Vd.T,#imm8,lsl #0 :      cmode=1001  op=0 */
    /* C7.3.12  bic16   Vd.T,#imm8,lsl #0 :      cmode=1001  op=1 */
    /* C7.3.179 movi16  Vd.T,#imm8,lsl #8 :      cmode=1010, op=0 */
    /* C7.3.183 mvni16  Vd.T,#imm8,lsl #8 :      cmode=1010, op=1 */
    /* C7.3.187 orr16   Vd.T,#imm8,lsl #8 :      cmode=1011  op=0 */
    /* C7.3.12  bic16   Vd.T,#imm8,lsl #8 :      cmode=1011  op=1 */
    /*                     4h               Q=0                   */
    /*                     8h               Q=1                   */
    /* C7.3.179 movi32o Vd.T,#imm8,msl #8 :      cmode=1100, op=0 */
    /* C7.3.183 mvni32o Vd.T,#imm8,msl #8 :      cmode=1100, op=1 */
    /* C7.3.179 movi32o Vd.T,#imm8,msl #16:      cmode=1101, op=0 */
    /* C7.3.183 mvni32o Vd.T,#imm8,msl #16:      cmode=1101, op=1 */
    /*                     2s               Q=0                   */
    /*                     4s               Q=1                   */
    /* C7.3.179 movi8   Vd.T,#imm8,lsl #0 :      cmode=1110, op=0 */
    /*                     8b               Q=0                   */
    /*                     16b              Q=1                   */
    /* C7.3.112 fmov64  Dd,   #imm        : Q=0, cmode=1110, op=1 */
    /* C7.3.112 fmov64  Vd.2D,#imm        : Q=1, cmode=1110, op=1 */
    /* C7.3.112 fmov64                    :      cmode=1111, op=0 */
    /* C7.3.112 fmov64                    :      cmode=1111, op=1 */
    Ull imm8 = (i.movi.a<<7)|(i.movi.b<<6)|(i.movi.c<<5)|(i.movi.d<<4)|(i.movi.e<<3)|(i.movi.f<<2)|(i.movi.g<<1)|(i.movi.h);
    rob->type  = 2; /* VXX */
    rob->opcd  = 6; /* MOVI/MVNI/ORR/BIC */
    switch (i.movi.cmode) {
    case 0: case 2: case 4: case 6: case 8: case 10:
    case 12: case 13: case 14: case 15:
      rob->sop   = 0; /* MOVI/MVNI */
      break;
    case 1: case 3: case 5: case 7: case 9: case 11:
      if (i.movi.op==0) /* ORR */
	rob->sop = 1; /* ORR */
      else /* BIC */
	rob->sop = 2; /* BIC */
      break;
    }
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = (i.movi.cmode<=13&&i.movi.op)?1:0; /* invert imm */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.movi.Q; /* 0:single, 1:double */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    v0 = VECREGTOP+i.movi.rd;
    if (rob->opcd==7) {  /* ORR/BIC */
      rob->sr[0].t = !t[tid].map[v0].x ? 2 :
                     (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[0].x = t[tid].map[v0].x; /* reg */
      rob->sr[0].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
    }
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    switch (i.movi.cmode) {
    case 0: case 1:
      rob->sr[1].n = (imm8<<32)|(imm8);
      break;
    case 2: case 3:
      rob->sr[1].n = (imm8<<40)|(imm8<<8);
      break;
    case 4: case 5:
      rob->sr[1].n = (imm8<<48)|(imm8<<16);
      break;
    case 6: case 7:
      rob->sr[1].n = (imm8<<56)|(imm8<<24);
      break;
    case 8: case 9:
      rob->sr[1].n = (imm8<<48)|(imm8<<32)|(imm8<<16)|(imm8);
      break;
    case 10: case 11:
      rob->sr[1].n = (imm8<<56)|(imm8<<40)|(imm8<<24)|(imm8<<8);
      break;
    case 12:
      rob->sr[1].n = (imm8<<40)|0x000000ff00000000LL|(imm8<<8)|0x00000000000000ffLL;
      break;
    case 13:
      rob->sr[1].n = (imm8<<48)|0x0000ffff00000000LL|(imm8<<16)|0x000000000000ffffLL;
      break;
    case 14:
      if (i.movi.op==0)
        rob->sr[1].n = (imm8<<56)|(imm8<<48)|(imm8<<40)|(imm8<<32)|(imm8<<24)|(imm8<<16)|(imm8<<8)|(imm8);
      else {
        Ull a=i.movi.a, b=i.movi.b, c=i.movi.c, d=i.movi.d, e=i.movi.e, f=i.movi.f, g=i.movi.g, h=i.movi.h;
        rob->sr[1].n = (a<<63)|(a<<62)|(a<<61)|(a<<60)|(a<<59)|(a<<58)|(a<<57)|(a<<56)
                      |(b<<55)|(b<<54)|(b<<53)|(b<<52)|(b<<51)|(b<<50)|(b<<49)|(b<<48)
                      |(c<<47)|(c<<46)|(c<<45)|(c<<44)|(c<<43)|(c<<42)|(c<<41)|(c<<40)
                      |(d<<39)|(d<<38)|(d<<37)|(d<<36)|(d<<35)|(d<<34)|(d<<33)|(d<<32)
                      |(e<<31)|(e<<30)|(e<<29)|(e<<28)|(e<<27)|(e<<26)|(e<<25)|(e<<24)
                      |(f<<23)|(f<<22)|(f<<21)|(f<<20)|(f<<19)|(f<<18)|(f<<17)|(f<<16)
                      |(g<<15)|(g<<14)|(g<<13)|(g<<12)|(g<<11)|(g<<10)|(g<< 9)|(g<< 8)
                      |(h<< 7)|(h<< 6)|(h<< 5)|(h<< 4)|(h<< 3)|(h<< 2)|(h<< 1)|(h    );
      }
      break;
    case 15:
      if (i.movi.op==0) {
        Ull a=i.movi.a, b=i.movi.b, c=i.movi.c, d=i.movi.d, e=i.movi.e, f=i.movi.f, g=i.movi.g, h=i.movi.h;
        rob->sr[1].n = (a<<63)|((1-b)<<62)|(b<<61)|(b<<60)|(b<<59)|(b<<58)|(b<<57)|(c<<56)|(d<<55)|(e<<54)|(f<<53)|(g<<52)|(h<<51)
                      |(a<<31)|((1-b)<<30)|(b<<29)|(b<<28)|(b<<27)|(b<<26)|(b<<25)|(c<<24)|(d<<23)|(e<<22)|(f<<21)|(g<<20)|(h<<19);
      }
      else {
        Ull a=i.movi.a, b=i.movi.b, c=i.movi.c, d=i.movi.d, e=i.movi.e, f=i.movi.f, g=i.movi.g, h=i.movi.h;
        rob->sr[1].n = (a<<63)|((1-b)<<62)|(b<<61)|(b<<60)|(b<<59)|(b<<58)|(b<<57)|(b<<56)|(b<<55)|(b<<54)|(c<<53)|(d<<52)|(e<<51)|(f<<50)|(g<<49)|(h<<48);
      }
      break;
    }
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.movv.op31==0 && i.movv.op29_24==0x0e && i.movv.op21==1 && i.movv.op15_10==0x07) { /* C7.3.11 AND(vector), C7.3.13 BIC(vector,register), C7.3.177 MOV(vector), C7.3.186 ORN(vector), C7.3.188 ORR(vector,register) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 6; /* MOVI/MVNI/ORR/BIC */
    rob->sop   = i.movv.andor?1:2; /* OR/AND */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.movv.inv; /* invert s2 */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.movv.Q; /* 0:single, 1:double */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.movv.rn;
    s2 = VECREGTOP+i.movv.rm;
    v0 = VECREGTOP+i.movv.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.bitwise.op31==0 && i.bitwise.op29_24==0x2e && i.bitwise.op21==1 && i.bitwise.op15_10==0x07) { /* C7.3.14 BIF, C7.3.15 BIT, C7.3.16 BSL, C7.3.33 EOR */
    rob->type  = 2; /* VXX */
    rob->opcd  = 6; /* MOVI/MVNI/ORR/BIC/EOR/BSL/BIT/BIF */
    rob->sop   = 4|i.bitwise.opc2; /* EOR/BSL/BIT/BIF */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.bitwise.Q; /* 0:64, 1:128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.bitwise.rn;
    s2 = VECREGTOP+i.bitwise.rm;
    v0 = VECREGTOP+i.bitwise.rd;
    rob->sr[0].t = !t[tid].map[v0].x ? 2 :
                   (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[v0].x; /* reg */
    rob->sr[0].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
    rob->sr[1].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s1].x; /* reg */
    rob->sr[1].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[2].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = t[tid].map[s2].x; /* reg */
    rob->sr[2].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.shr_sca.op31_30==1 && i.shr_sca.op28_23==0x3e && i.shr_sca.immh && i.shr_sca.op15_10==0x01) { /* C7.3.271 SSHR(scalar), C7.3.340 USHR(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 4; /* SHIFT */
    rob->sop   = 0|i.shr_sca.U; /* 0:signed(SSHR), 1:signed(USHR) */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.shr_sca.rn;
    v0 = VECREGTOP+i.shr_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = (i.shr_sca.immh<<3)|i.shr_sca.immb;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.shr_sca.op31_30==1 && i.shr_sca.U==0 && i.shr_sca.op28_23==0x3e && i.shr_sca.immh && i.shr_sca.op15_10==0x15) { /* C7.3.222 SHL(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 4; /* SHIFT */
    rob->sop   = 4; /* SHL(scalar) */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.shr_sca.rn;
    v0 = VECREGTOP+i.shr_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = (i.shr_sca.immh<<3)|i.shr_sca.immb;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.sft_vec.op31==0 && i.sft_vec.op28_23==0x1e && i.sft_vec.immh && i.sft_vec.op15_10==0x01) { /* C7.3.271 SSHR(vector), C7.3.340 USHR(vector) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 4; /* SHIFT */
    rob->sop   = 2|i.sft_vec.U; /* 2:signed(SSHR), 3:signed(USHR) */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.sft_vec.Q; /* 0:single, 1:double */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.sft_vec.rn;
    v0 = VECREGTOP+i.sft_vec.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = (i.sft_vec.immh<<3)|i.sft_vec.immb;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.sft_vec.op31==0 && i.shr_sca.U==0 && i.sft_vec.op28_23==0x1e && i.sft_vec.immh && i.sft_vec.op15_10==0x15) { /* C7.3.222 SHL(vector) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 4; /* SHIFT */
    rob->sop   = 5; /* SHL(vector) */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.sft_vec.Q; /* 0:single, 1:double */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.sft_vec.rn;
    v0 = VECREGTOP+i.sft_vec.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = (i.sft_vec.immh<<3)|i.sft_vec.immb;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.sft_vec.op31==0 && i.sft_vec.op28_23==0x1e && i.shr_sca.immh && i.sft_vec.op15_10==0x29) { /* C7.3.270 SSHLL/SSHLL2, C7.3.339 USHLL/USHLL2 */
    rob->type  = 2; /* VXX */
    rob->opcd  = 4; /* SHIFT */
    rob->sop   = 6|i.sft_vec.U; /* 6:SSHLL/SSHLL2, 7:USHLL/USHLL2 */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.sft_vec.Q; /* 0:lower64, 1:upper64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.sft_vec.rn;
    v0 = VECREGTOP+i.sft_vec.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = (i.sft_vec.immh<<3)|i.sft_vec.immb;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.dup.op31==0 && i.dup.op29_21==0x070 && i.dup.op15_10==0x01) { /* C7.3.31 DUP(vector) */
    Uint size  = (i.dup.imm5&1)?1:(i.dup.imm5&2)?2:(i.dup.imm5&4)?4:8; /* bytes */
    Uint index = (i.dup.imm5&1)?(i.dup.imm5&~1)>>1:(i.dup.imm5&2)?(i.dup.imm5&~3)>>1:(i.dup.imm5&4)?(i.dup.imm5&~7)>>1:(i.dup.imm5&~15)>>1; /* byte-portion: 15,14..0, 14,12..0, 12,8..0, 8,0 */
    rob->type  = 2; /* VXX */
    rob->opcd  = 7; /* DUP */
    rob->sop   = 0; /* DUP */
    rob->ptw   = 0; /* not used */
    rob->size  = size; /* 1-8 */
    rob->idx   = index; /* 15-0 */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.dup.Q; /* 0:dup64, 1:dup128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.dup.rn;
    v0 = VECREGTOP+i.dup.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.dup.op31==0 && i.dup.op29_21==0x070 && i.dup.op15_10==0x03) { /* C7.3.32 DUP(general) */
    Uint size  = (i.dup.imm5&1)?1:(i.dup.imm5&2)?2:(i.dup.imm5&4)?4:8; /* bytes */
    rob->type  = 2; /* VXX */
    rob->opcd  = 7; /* DUP */
    rob->sop   = 0; /* DUP */
    rob->ptw   = 0; /* not used */
    rob->size  = size; /* 1-8 */
    rob->idx   = 0; /* 0 */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.dup.Q; /* 0:dup64, 1:dup128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    v0 = VECREGTOP+i.dup.rd;
    rob->sr[0].t = !t[tid].map[i.dup.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.dup.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.dup.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.dup.rn].x ? i.dup.rn : t[tid].map[i.dup.rn].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.umov.op31==0 && i.umov.Q==1 && i.umov.op29_21==0x070 && i.umov.op15_10==0x07) { /* C7.3.176 MOV(from general), C7.3.151 INS(general) */
    Uint size  = (i.umov.imm5&1)?1:(i.umov.imm5&2)?2:(i.umov.imm5&4)?4:8; /* bytes */
    Uint index = (i.umov.imm5&1)?(i.umov.imm5&~1)>>1:(i.umov.imm5&2)?(i.umov.imm5&~3)>>1:(i.umov.imm5&4)?(i.umov.imm5&~7)>>1:(i.umov.imm5&~15)>>1; /* byte-portion: 15,14..0, 14,12..0, 12,8..0, 8,0 */
    rob->type  = 2; /* VXX */
    rob->opcd  = 7; /* DUP */
    rob->sop   = 3; /* INS */
    rob->ptw   = 0; /* not used */
    rob->size  = size; /* 1-8 */
    rob->idx   = index; /* 15-0 */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    v0 = VECREGTOP+i.umov.rd;
    rob->sr[0].t = !t[tid].map[v0].x ? 2 :
                   (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[v0].x; /* reg */
    rob->sr[0].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
    rob->sr[1].t = !t[tid].map[i.umov.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.umov.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[i.umov.rn].x; /* reg */
    rob->sr[1].n = !t[tid].map[i.umov.rn].x ? i.umov.rn : t[tid].map[i.umov.rn].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.umov.op31==0 && i.umov.op29_21==0x070 && i.umov.op15_10==0x0f) { /* C7.3.178 MOV(to general), C7.3.321 UMOV */
    Uint size  = (i.umov.imm5&1)?1:(i.umov.imm5&2)?2:(i.umov.imm5&4)?4:8; /* bytes */
    Uint index = (i.umov.imm5&1)?(i.umov.imm5&~1)>>1:(i.umov.imm5&2)?(i.umov.imm5&~3)>>1:(i.umov.imm5&4)?(i.umov.imm5&~7)>>1:(i.umov.imm5&~15)>>1; /* byte-portion: 15,14..0, 14,12..0, 12,8..0, 8,0 */
    rob->type  = 2; /* VXX */
    rob->opcd  = 7; /* DUP */
    rob->sop   = 2; /* UMOV */
    rob->ptw   = 0; /* not used */
    rob->size  = size; /* 1-8 */
    rob->idx   = index; /* 15-0 */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.umov.Q; /* 0:umov64, 1:umov128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.umov.rn;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = i.umov.rd;
    t[tid].map[i.umov.rd].x = 1;
    t[tid].map[i.umov.rd].rob = robid;
    return (0);
  }
  else if (i.xtn.op31==0 && i.xtn.op29_24==0x0e && i.xtn.op21_10==0x84a) { /* C7.3.348 XTN/XTN2 */
    rob->type  = 2; /* VXX */
    rob->opcd  = 7; /* DUP */
    rob->sop   = 1; /* XTN/XTN2 */
    rob->ptw   = 0; /* not used */
    rob->size  = i.xtn.size;;
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.xtn.Q; /* 0:lower64, 1:upper64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.xtn.rn;
    v0 = VECREGTOP+i.xtn.rd;
    rob->sr[0].t = !t[tid].map[v0].x ? 2 :
                   (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[v0].x; /* reg */
    rob->sr[0].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
    rob->sr[1].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s1].x; /* reg */
    rob->sr[1].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.maxmin.op31==0 && i.maxmin.op28_24==0x0e && i.maxmin.op21==1 && i.maxmin.op15_12==6 && i.maxmin.op10==1) { /* C7.3.227 SMAX, C7.3.230 SMIN, C7.3.311 UMAX, C7.3.314 UMIN */
    rob->type  = 2; /* VXX */
    rob->opcd  = 7; /* DUP */
    rob->sop   = 4|(i.maxmin.op10<<1)|i.maxmin.U; /* 4:SMAX, 5:UMAX, 6:SMIN, 7:UMIN */
    rob->ptw   = 0; /* not used */
    rob->size  = i.maxmin.size;;
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.maxmin.Q; /* 0:64, 1:128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.maxmin.rn;
    s2 = VECREGTOP+i.maxmin.rm;
    v0 = VECREGTOP+i.maxmin.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.cmpr_sca.op31_30==1 && i.cmpr_sca.op28_24==0x1e && i.cmpr_sca.op21==1 && (i.cmpr_sca.op15_12==3||(i.cmpr_sca.op15_12==8&&i.cmpr_sca.eq)) && i.cmpr_sca.op10==1) { /* C7.3.19 CMEQ(scalar), C7.3.21 CMGE(scalar), C7.3.23 CMGT(scalar), C7.3.25 CMHI(scalar), C7.3.26 CMHS(scalar), C7.3.29 CMTST(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 5; /* CMP */
    rob->sop   = (i.cmpr_sca.op15_12==3 && i.cmpr_sca.U==0 && i.cmpr_sca.eq==0) ? 0 :     /* CMGT */
                 (i.cmpr_sca.op15_12==3 && i.cmpr_sca.U==1 && i.cmpr_sca.eq==0) ? 2 :     /* CMHI */
                 (i.cmpr_sca.op15_12==3 && i.cmpr_sca.U==0 && i.cmpr_sca.eq==1) ? 4 :     /* CMGE */
                 (i.cmpr_sca.op15_12==3 && i.cmpr_sca.U==1 && i.cmpr_sca.eq==1) ? 6 :     /* CMHS */
                 (i.cmpr_sca.op15_12==8 && i.cmpr_sca.U==0 && i.cmpr_sca.eq==1) ? 8 :     /* CMTST */
                 (i.cmpr_sca.op15_12==8 && i.cmpr_sca.U==1 && i.cmpr_sca.eq==1) ?10 : 12; /* CMEQ */
    rob->ptw   = 0; /* not used */
    rob->size  = i.cmpr_sca.size;
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* 0:register, 1:zero */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.cmpr_sca.rn;
    s2 = VECREGTOP+i.cmpr_sca.rm;
    v0 = VECREGTOP+i.cmpr_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.cmpr_vec.op31==0 && i.cmpr_vec.op28_24==0x0e && i.cmpr_vec.op21==1 && (i.cmpr_vec.op15_12==3||(i.cmpr_vec.op15_12==8&&i.cmpr_vec.eq)) && i.cmpr_vec.op10==1) { /* C7.3.19 CMEQ(vector), C7.3.21 CMGE(vector), C7.3.23 CMGT(vector), C7.3.25 CMHI(vector), C7.3.26 CMHS(vector), C7.3.29 CMTST(vector) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 5; /* CMP */
    rob->sop   = (i.cmpr_vec.op15_12==3 && i.cmpr_vec.U==0 && i.cmpr_vec.eq==0) ? 1 :     /* CMGT */
                 (i.cmpr_vec.op15_12==3 && i.cmpr_vec.U==1 && i.cmpr_vec.eq==0) ? 3 :     /* CMHI */
                 (i.cmpr_vec.op15_12==3 && i.cmpr_vec.U==0 && i.cmpr_vec.eq==1) ? 5 :     /* CMGE */
                 (i.cmpr_vec.op15_12==3 && i.cmpr_vec.U==1 && i.cmpr_vec.eq==1) ? 7 :     /* CMHS */
                 (i.cmpr_vec.op15_12==8 && i.cmpr_vec.U==0 && i.cmpr_vec.eq==1) ? 9 :     /* CMTST */
                 (i.cmpr_vec.op15_12==8 && i.cmpr_vec.U==1 && i.cmpr_vec.eq==1) ?11 : 13; /* CMEQ */
    rob->ptw   = 0; /* not used */
    rob->size  = i.cmpr_vec.size;
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* 0:register, 1:zero */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.cmpr_vec.Q; /* 0:64, 1:128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.cmpr_vec.rn;
    s2 = VECREGTOP+i.cmpr_vec.rm;
    v0 = VECREGTOP+i.cmpr_vec.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.cmpz_sca.op31_30==1 && i.cmpz_sca.op28_24==0x1e && (i.cmpz_sca.op21_13==0x104||(i.cmpz_sca.op21_13==0x105&&i.cmpz_sca.op==0)) && i.cmpz_sca.op11_10==2) { /* C7.3.20 CMEQZ(scalar), C7.3.22 CMGEZ(scalar), C7.3.24 CMGTZ(scalar), C7.3.27 CMLEZ(scalar), C7.3.28 CMLTZ(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 5; /* CMP */
    rob->sop   = (i.cmpz_sca.op21_13==0x104 && i.cmpz_sca.U==0 && i.cmpz_sca.op==0) ? 0 :     /* CMGTZ */
                 (i.cmpz_sca.op21_13==0x104 && i.cmpz_sca.U==1 && i.cmpz_sca.op==0) ? 2 :     /* CMGEZ */
                 (i.cmpz_sca.op21_13==0x104 && i.cmpz_sca.U==0 && i.cmpz_sca.op==1) ? 4 :     /* CMEQZ */
                 (i.cmpz_sca.op21_13==0x104 && i.cmpz_sca.U==1 && i.cmpz_sca.op==1) ? 6 :     /* CMLEZ */
                 (i.cmpz_sca.op21_13==0x105 && i.cmpz_sca.U==0 && i.cmpz_sca.op==0) ? 8 : 10; /* CMLTZ */
    rob->ptw   = 0; /* not used */
    rob->size  = i.cmpz_sca.size;
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 1; /* 0:register, 1:zero */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.cmpz_sca.rn;
    v0 = VECREGTOP+i.cmpz_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.cmpz_vec.op31==0 && i.cmpz_vec.op28_24==0x0e && (i.cmpz_vec.op21_13==0x104||(i.cmpz_vec.op21_13==0x105&&i.cmpz_vec.op==0)) && i.cmpz_vec.op11_10==2) { /* C7.3.20 CMEQZ(vector), C7.3.22 CMGEZ(vector), C7.3.24 CMGTZ(vector), C7.3.27 CMLEZ(vector), C7.3.28 CMLTZ(vector) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 5; /* CMP */
    rob->sop   = (i.cmpz_vec.op21_13==0x104 && i.cmpz_vec.U==0 && i.cmpz_vec.op==0) ? 1 :     /* CMGTZ */
                 (i.cmpz_vec.op21_13==0x104 && i.cmpz_vec.U==1 && i.cmpz_vec.op==0) ? 3 :     /* CMGEZ */
                 (i.cmpz_vec.op21_13==0x104 && i.cmpz_vec.U==0 && i.cmpz_vec.op==1) ? 5 :     /* CMEQZ */
                 (i.cmpz_vec.op21_13==0x104 && i.cmpz_vec.U==1 && i.cmpz_vec.op==1) ? 7 :     /* CMLEZ */
                 (i.cmpz_vec.op21_13==0x105 && i.cmpz_vec.U==0 && i.cmpz_vec.op==0) ? 9 : 11; /* CMLTZ */
    rob->ptw   = 0; /* not used */
    rob->size  = i.cmpz_vec.size;
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 1; /* 0:register, 1:zero */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.cmpz_vec.Q; /* 0:64, 1:128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.cmpz_vec.rn;
    v0 = VECREGTOP+i.cmpz_vec.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fadd.op31==0 && i.fadd.op28_24==0x0e && i.fadd.op21==1 && i.fadd.op15_10==0x35) { /* C7.3.40 FADD(vector), C7.3.148 FSUB(vector) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 8; /* FADD/FSUB */
    rob->sop   = (i.fadd.U<<1)|i.fadd.sz; /* 0:2S/4S, 1:2D, 2:pair2S/4S, 3:pair-2D */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.fadd.op==0?0:1; /* 0:FADD, 1:FSUB */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fadd.Q; /* 0:fadd64, 1:fadd128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fadd.rn;
    s2 = VECREGTOP+i.fadd.rm;
    v0 = VECREGTOP+i.fadd.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fmla.op31==0 && i.fmla.op29_24==0x0e && i.fmla.op21==1 && i.fmla.op15_10==0x33) { /* C7.3.109 FMLA(vector), C7.3.111 FMLS(vector) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 9; /* FMLA/FMLS */
    rob->sop   = i.fmla.sz; /* 0:2S/4S, 1:2D */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.fmla.op; /* 0:FMLA, 1:FMLS */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fmla.Q; /* 0:fmla64, 1:fmla128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fmla.rn;
    s2 = VECREGTOP+i.fmla.rm;
    s3 = VECREGTOP+i.fmla.rd;
    v0 = VECREGTOP+i.fmla.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    rob->sr[2].t = !t[tid].map[s3].x ? 2 :
                   (c[cid].rob[t[tid].map[s3].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = t[tid].map[s3].x; /* reg */
    rob->sr[2].n = !t[tid].map[s3].x ? s3 : t[tid].map[s3].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fmla.op31==0 && i.fmla.op29_24==0x2e && i.fmla.op==0 && i.fmla.op21==1 && i.fmla.op15_10==0x37) { /* C7.3.118 FMUL(vector) */
    rob->type  = 2; /* VXX */
    rob->opcd  =10; /* FMUL */
    rob->sop   = i.fmla.sz; /* 0:2S/4S, 1:2D */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fmla.Q; /* 0:fmla64, 1:fmla128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fmla.rn;
    s2 = VECREGTOP+i.fmla.rm;
    v0 = VECREGTOP+i.fmla.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.mla.op31==0 && i.mla.op28_24==0x0e && i.mla.op21==1 && i.mla.op15_10==0x25) { /* C7.3.171 MLA(vector), C7.3.173 MLS(vector) */
    rob->type  = 2; /* VXX */
    rob->opcd  =11; /* MLA/MLS */
    rob->sop   = i.mla.size; /* 0:8B/16B, 1:4H/8H, 2:2S/4S */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.mla.U; /* 0:MLA, 1:MLS */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.mla.Q; /* 0:mla64, 1:mla128 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.mla.rn;
    s2 = VECREGTOP+i.mla.rm;
    s3 = VECREGTOP+i.mla.rd;
    v0 = VECREGTOP+i.mla.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    rob->sr[2].t = !t[tid].map[s3].x ? 2 :
                   (c[cid].rob[t[tid].map[s3].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = t[tid].map[s3].x; /* reg */
    rob->sr[2].n = !t[tid].map[s3].x ? s3 : t[tid].map[s3].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fadd_sca.op31_24==0x1e && (i.fadd_sca.type&2)==0 && i.fadd_sca.op21==1 && i.fadd_sca.op15_13==1 && i.fadd_sca.op11_10==2) { /* C7.3.41 FADD(scalar), C7.3.149 FSUB(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  =12; /* FADD(scalar) */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.fadd_sca.op;
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fadd_sca.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fadd_sca.rn;
    s2 = VECREGTOP+i.fadd_sca.rm;
    v0 = VECREGTOP+i.fadd_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fmadd.op31_24==0x1f && (i.fmadd.type&2)==0) { /* C7.3.87 FMADD, C7.3.116 FMSUB, C7.3.124 FNMADD, C7.3.125 FNMSUB */
    rob->type  = 2; /* VXX */
    rob->opcd  =13; /* FMADD/FMSUB */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.fmadd.o1;             /* negate s3, o1o0=00->FMADD */
    rob->oinv  = i.fmadd.o0!=i.fmadd.o1; /* negate s1, o1o0=01->FMSUB */
    rob->dbl   = i.fmadd.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fmadd.rn;
    s2 = VECREGTOP+i.fmadd.rm;
    s3 = VECREGTOP+i.fmadd.ra;
    v0 = VECREGTOP+i.fmadd.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    rob->sr[2].t = !t[tid].map[s3].x ? 2 :
                   (c[cid].rob[t[tid].map[s3].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = t[tid].map[s3].x; /* reg */
    rob->sr[2].n = !t[tid].map[s3].x ? s3 : t[tid].map[s3].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fmul_sca.op31_24==0x1e && (i.fmul_sca.type&2)==0 && i.fmul_sca.op21==1 && i.fmul_sca.op14_10==0x02) { /* C7.3.119 FMUL(scalar), C7.3.126 FNMUL(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  =14; /* FMUL */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = i.fmul_sca.op; /* 0:normal 1:negate */
    rob->dbl   = i.fmul_sca.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fmul_sca.rn;
    s2 = VECREGTOP+i.fmul_sca.rm;
    v0 = VECREGTOP+i.fmul_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fdiv_sca.op31_24==0x1e && (i.fdiv_sca.type&2)==0 && i.fdiv_sca.op21==1 && i.fdiv_sca.op15_10==0x06) { /* C7.3.86 FDIV(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  =15; /* FDIV */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fdiv_sca.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fdiv_sca.rn;
    s2 = VECREGTOP+i.fdiv_sca.rm;
    v0 = VECREGTOP+i.fdiv_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fcmp.op31_24==0x1e && i.fcmp.op21==1 && i.fcmp.op15_10==0x08 && i.fcmp.op2_0==0) { /* C7.3.54 FCMP, C7.3.55 FCMPE */
    rob->type  = 2; /* VXX */
    rob->opcd  =12; /* FSUB */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 1; /* FSUB */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fcmp.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fcmp.rn;
    s2 = VECREGTOP+i.fcmp.rm;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    if ((i.fcmp.opc&1)==0) { /* reg */
      rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                     (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[1].x = t[tid].map[s2].x; /* reg */
      rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    }
    else if (i.fcmp.rm==0 && (i.fcmp.opc&1)) { /* immediate */
      rob->sr[1].t = 1; /* immediate */
      rob->sr[1].x = 0; /* renamig N.A. */
      rob->sr[1].n = 0; /* ZERO */
    }
    else {
      i_xxx(rob);
      return (0);
    }
    /* dest */
    rob->dr[3].t = 1; /* nzcv */
    rob->dr[3].n = CPSREGTOP;
    t[tid].map[CPSREGTOP].x = 3;
    t[tid].map[CPSREGTOP].rob = robid;
    return (0);
  }
  else if (i.fmov_reg.op31_24==0x1e && i.fmov_reg.op21_17==0x10 && i.fmov_reg.op14_10==0x10) { /* C7.3.113 FMOV(register) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 0; /* FMOVL */
    rob->sop   = 4|i.fmov_reg.opc; /* 4:mov, 5:abs, 6:neg, 7:sqrt, 8:undef */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fmov_reg.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fmov_reg.rn;
    v0 = VECREGTOP+i.fmov_reg.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fcvt_sca.op31_24==0x1e && i.fcvt_sca.op21_17==0x11 && i.fcvt_sca.op14_10==0x10) { /* C7.3.57 FCVT(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 1; /* FCVT */
    if      (i.fcvt_sca.type==3 && i.fcvt_sca.opc==0) rob->sop = 0; /* single<-half */
    else if (i.fcvt_sca.type==3 && i.fcvt_sca.opc==1) rob->sop = 1; /* double<-half */
    else if (i.fcvt_sca.type==0 && i.fcvt_sca.opc==3) rob->sop = 2; /* half  <-single */
    else if (i.fcvt_sca.type==0 && i.fcvt_sca.opc==1) rob->sop = 3; /* double<-single */
    else if (i.fcvt_sca.type==1 && i.fcvt_sca.opc==3) rob->sop = 4; /* half  <-double */
    else if (i.fcvt_sca.type==1 && i.fcvt_sca.opc==0) rob->sop = 5; /* single<-double */
    else                                              rob->sop = 8; /* undef */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fcvt_sca.rn;
    v0 = VECREGTOP+i.fcvt_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fcvt_sca.op31_24==0x1e && i.fcvt_sca.op21_17==0x12 && i.fcvt_sca.op14_10==0x10) { /* C7.3.135 FRINTM(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 1; /* FCVT */
    if      (i.fcvt_sca.type==0 && i.fcvt_sca.opc==2) rob->sop = 6; /* floor32 */
    else if (i.fcvt_sca.type==1 && i.fcvt_sca.opc==2) rob->sop = 7; /* floor64 */
    else                                              rob->sop = 8; /* undef */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* not used */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fcvt_sca.rn;
    v0 = VECREGTOP+i.fcvt_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.add_sca.op31_30==1 && i.add_sca.op28_24==0x1e && i.add_sca.op21==1 && i.add_sca.op15_10==0x21) { /* C7.3.2 ADD(scalar), C7.3.288 SUB(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  =11; /* MLA/MLS ... use ADD/SUB only */
    rob->sop   = 3; /* 0:8B/16B, 1:4H/8H, 2:2S/4S, 3:1D(scalar) dbl=0 */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.add_sca.U;
    rob->oinv  = 0; /* not used */
    rob->dbl   = 0; /* 0:64bit, 1:128bit */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    if (i.add_sca.size != 3) {
      i_xxx(rob);
      return (0);
    }
    s1 = VECREGTOP+i.add_sca.rn;
    s2 = VECREGTOP+i.add_sca.rm;
    v0 = VECREGTOP+i.add_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[2].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = t[tid].map[s2].x; /* reg */
    rob->sr[2].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.add_vec.op31==0 && i.add_vec.op28_24==0x0e && i.add_vec.op21==1 && i.add_vec.op15_10==0x21) { /* C7.3.2 ADD(vector), C7.3.288 SUB(vector) */
    rob->type  = 2; /* VXX */
    rob->opcd  =11; /* MLA/MLS ... use ADD/SUB only */
    rob->sop   = i.add_vec.size; /* 0:8B/16B, 1:4H/8H, 2:2S/4S, 3:2D(vector) dbl=1 */
    rob->ptw   = 0; /* not used */
    rob->size  = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.add_vec.U;
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.add_vec.Q; /* 0:64bit, 1:128bit */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    if (i.add_vec.size == 3 && i.add_vec.Q == 0) {
      i_xxx(rob);
      return (0);
    }
    s1 = VECREGTOP+i.add_vec.rn;
    s2 = VECREGTOP+i.add_vec.rm;
    v0 = VECREGTOP+i.add_vec.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[2].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = t[tid].map[s2].x; /* reg */
    rob->sr[2].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else {
    i_xxx(rob);
    return (0);
  }
  return (0); /* never reached */
}

i_xxx(rob) struct rob *rob;
{
  rob->stat = ROB_DECERR; /* decode error */
  return (0);
}
@


1.108
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/decode.c,v 1.107 2019/10/14 01:06:44 nakashim Exp nakashim $";
d146 1
d3897 32
a3928 1
    else                                              rob->sop = 6; /* undef */
@


1.107
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/decode.c,v 1.106 2019/02/07 13:36:59 nakashim Exp nakashim $";
d339 1
a339 1
    rob->iinv  = i.ccm.op==13; /* CCMP */
@


1.106
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/decode.c,v 1.105 2017/04/21 03:28:57 nakashim Exp nakashim $";
d83 1
d3223 29
@


1.105
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/csim/RCS/decode.c,v 1.104 2016/11/20 06:54:35 nakashim Exp nakashim $";
d88 2
a89 1
  /*  0        0  1  1  1  0        1                 1  0  0  1  0  1 mla(vector)                   */
d145 1
a145 1
  /*  0  1     1  1  1  1  0        1                 1  0  0  0  0  1 add(scalar)                   */
d3895 1
a3895 1
    rob->sop   = 3; /* 0:8B/16B, 1:4H/8H, 2:2S/4S, 3:1D */
d3903 1
a3903 1
    rob->dbl   = 1; /* 0:Sd, 1:Dd */
d3919 39
a3957 1
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
d3959 2
a3960 2
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
@


1.104
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.103 2016/11/18 16:04:34 nakashim Exp nakashim $";
d13 1
a13 1
#include "bsim.h"
d1061 1
a1061 1
    rob->type  = (i.svc.type==0)?6:7; /* SVC/PTHREAD(bsim special) */
@


1.103
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.102 2016/06/08 03:41:26 nakashim Exp nakashim $";
d131 1
d1745 97
@


1.102
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.101 2016/05/29 05:07:22 nakashim Exp nakashim $";
d72 2
d1080 66
@


1.101
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.100 2016/05/28 15:50:12 nakashim Exp nakashim $";
d2573 1
a2573 1
              (((!(i.fmov_gen.opc&1) && i.fmov_gen.type==1)      /* CVTSD with sop|=8 */
d2575 1
a2575 1
		 |(i.fmov_gen.opc<=1)?i.fmov_gen.mode:4);        /* 0:rint, 1:ceil, 2:floor, 3:trunc, 4:round */
@


1.100
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.99 2016/05/28 14:45:25 nakashim Exp nakashim $";
d92 1
d2826 38
@


1.99
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.98 2016/05/28 08:15:06 nakashim Exp nakashim $";
d3147 1
a3147 1
  else if (i.cmp_sca.op31_30==1 && i.cmp_sca.op28_24==0x1e && i.cmp_sca.op21==1 && (i.cmp_sca.op15_12==3||(i.cmp_sca.op15_12==8&&i.cmp_sca.eq)) && i.cmp_sca.op10==1) { /* C7.3.19 CMEQ(scalar), C7.3.21 CMGE(scalar), C7.3.23 CMGT(scalar), C7.3.25 CMHI(scalar), C7.3.26 CMHS(scalar), C7.3.29 CMTST(scalar) */
d3150 6
a3155 6
    rob->sop   = (i.cmp_sca.op15_12==3 && i.cmp_sca.U==0 && i.cmp_sca.eq==0) ? 0 :     /* CMGT */
                 (i.cmp_sca.op15_12==3 && i.cmp_sca.U==1 && i.cmp_sca.eq==0) ? 2 :     /* CMHI */
                 (i.cmp_sca.op15_12==3 && i.cmp_sca.U==0 && i.cmp_sca.eq==1) ? 4 :     /* CMGE */
                 (i.cmp_sca.op15_12==3 && i.cmp_sca.U==1 && i.cmp_sca.eq==1) ? 6 :     /* CMHS */
                 (i.cmp_sca.op15_12==8 && i.cmp_sca.U==0 && i.cmp_sca.eq==1) ? 8 :     /* CMTST */
                 (i.cmp_sca.op15_12==8 && i.cmp_sca.U==1 && i.cmp_sca.eq==1) ?10 : 12; /* CMEQ */
d3157 1
a3157 1
    rob->size  = i.cmp_sca.size;
d3168 3
a3170 3
    s1 = VECREGTOP+i.cmp_sca.rn;
    s2 = VECREGTOP+i.cmp_sca.rm;
    v0 = VECREGTOP+i.cmp_sca.rd;
d3186 1
a3186 1
  else if (i.cmp_vec.op31==0 && i.cmp_vec.op28_24==0x0e && i.cmp_vec.op21==1 && (i.cmp_vec.op15_12==3||(i.cmp_vec.op15_12==8&&i.cmp_vec.eq)) && i.cmp_vec.op10==1) { /* C7.3.19 CMEQ(vector), C7.3.21 CMGE(vector), C7.3.23 CMGT(vector), C7.3.25 CMHI(vector), C7.3.26 CMHS(vector), C7.3.29 CMTST(vector) */
d3189 6
a3194 6
    rob->sop   = (i.cmp_vec.op15_12==3 && i.cmp_vec.U==0 && i.cmp_vec.eq==0) ? 1 :     /* CMGT */
                 (i.cmp_vec.op15_12==3 && i.cmp_vec.U==1 && i.cmp_vec.eq==0) ? 3 :     /* CMHI */
                 (i.cmp_vec.op15_12==3 && i.cmp_vec.U==0 && i.cmp_vec.eq==1) ? 5 :     /* CMGE */
                 (i.cmp_vec.op15_12==3 && i.cmp_vec.U==1 && i.cmp_vec.eq==1) ? 7 :     /* CMHS */
                 (i.cmp_vec.op15_12==8 && i.cmp_vec.U==0 && i.cmp_vec.eq==1) ? 9 :     /* CMTST */
                 (i.cmp_vec.op15_12==8 && i.cmp_vec.U==1 && i.cmp_vec.eq==1) ?11 : 13; /* CMEQ */
d3196 1
a3196 1
    rob->size  = i.cmp_vec.size;
d3202 1
a3202 1
    rob->dbl   = i.cmp_vec.Q; /* 0:64, 1:128 */
d3207 3
a3209 3
    s1 = VECREGTOP+i.cmp_vec.rn;
    s2 = VECREGTOP+i.cmp_vec.rm;
    v0 = VECREGTOP+i.cmp_vec.rd;
d3225 66
@


1.98
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.97 2016/05/28 06:35:32 nakashim Exp nakashim $";
d89 3
d141 3
d3147 78
@


1.97
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.96 2016/05/28 02:32:12 nakashim Exp nakashim $";
d83 1
d2696 1
a2696 1
    rob->sop   = 0; /* MOVI/MVNI */
d2699 4
a2702 1
    rob->sop   = 1; /* ORR/BIC */
d2785 34
d3430 1
a3430 1
    rob->opcd  = 12; /* FSUB */
@


1.96
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.95 2016/05/28 01:01:36 nakashim Exp nakashim $";
d91 1
d139 1
d2781 1
a2781 1
  else if (i.shr_sca.op31_30==1 && i.shr_sca.op28_23==0x1e && i.shr_sca.op15_10==0x01) { /* C7.3.271 SSHR(scalar), C7.3.340 USHR(scalar) */
d2783 1
a2783 1
    rob->opcd  = 4; /* SHR */
d2813 1
a2813 1
  else if (i.shr_vec.op31==0 && i.shr_vec.op28_23==0x1e && i.shr_vec.op15_10==0x01) { /* C7.3.271 SSHR(vector), C7.3.340 USHR(vector) */
d2815 2
a2816 2
    rob->opcd  = 4; /* SHR */
    rob->sop   = 2|i.shr_vec.U; /* 2:signed(SSHR), 3:signed(USHR) */
d2824 97
a2920 1
    rob->dbl   = i.shr_vec.Q; /* 0:single, 1:double */
d2925 2
a2926 2
    s1 = VECREGTOP+i.shr_vec.rn;
    v0 = VECREGTOP+i.shr_vec.rd;
d2933 1
a2933 1
    rob->sr[1].n = (i.shr_vec.immh<<3)|i.shr_vec.immb;
d3036 1
a3036 1
  else if (i.xtn.op31==0 && i.xtn.op29_24==0x0e && i.xtn.op21_10==0x84a) { /* C7.3.348 XTN,XTN2 */
d3039 1
a3039 1
    rob->sop   = 1; /* XTN */
@


1.95
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.94 2016/05/27 14:54:56 nakashim Exp nakashim $";
d80 3
a82 3
  /*  0     0  0  1  1  1  0  0  0  0  dup_vec        0  0  0  0  0  1                               */
  /*  0  1  0  0  1  1  1  0  0  0  0  mov/ins        0  0  0  1  1  1                               */
  /*  0     0  0  1  1  1  0  0  0  0  mov/umov       0  0  1  1  1  1                               */
d84 5
a88 4
  /*  0        0  1  1  1  0        1  mla(vector)    1  0  0  1  0  1                               */
  /*  0        0  1  1  1  0        1  fadd(vector)   1  1  0  1  0  1                               */
  /*  0     0  0  1  1  1  0        1  fmla(vector)   1  1  0  0  1  1                               */
  /*  0     1  0  1  1  1  0  0     1  fmul(vector)   1  1  0  1  1  1                               */
d101 1
a101 1
  /*  1  1  0  1  0  1  0  0  0  0  0                                                  0  0  0  0  1 */
d2971 34
@


1.94
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.93 2016/05/27 08:04:22 nakashim Exp nakashim $";
d89 1
a89 1
  /*  0     1  0  1  1  1  1  0  -immh!=0--           0  0  0  0  0  1 ushr(vector)                  */
d135 2
a136 1
  /*  0  0  0  1  1  1  1  1           fmadd                                                         */
d2778 1
a2778 1
  else if (i.ushr.op31==0 && i.ushr.op29_23==0x5e && i.ushr.op15_10==0x01) { /* C7.3.340 USHR(vector) */
d2780 2
a2781 2
    rob->opcd  = 4; /* USHR */
    rob->sop   = 0; /* USHR */
d2789 33
a2821 1
    rob->dbl   = i.ushr.Q; /* 0:single, 1:double */
d2826 2
a2827 2
    s1 = VECREGTOP+i.ushr.rn;
    v0 = VECREGTOP+i.ushr.rd;
d2834 1
a2834 1
    rob->sr[1].n = (i.ushr.immh<<3)|i.ushr.immb;
@


1.93
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.92 2016/05/26 23:47:09 nakashim Exp nakashim $";
d81 3
a83 1
  /*  0     0  0  1  1  1  0  0  0  0  umov           0  0  1  1  1  1                               */
d2840 34
d2879 1
a2879 1
    rob->sop   = 1; /* UMOV */
d2904 33
@


1.92
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.91 2016/05/17 05:34:34 nakashim Exp nakashim $";
d33 1
d81 1
d87 1
d141 1
d173 1
d214 1
d265 1
d316 1
d377 1
d430 1
d468 1
d506 1
d554 1
d599 1
d647 1
d718 1
d813 1
d858 1
d906 1
d931 1
d959 1
d987 1
d1015 1
d1048 1
d1075 1
d1107 1
d1154 1
d1205 1
d1237 1
d1282 1
d1401 1
d1510 1
d1627 1
d1741 1
d1814 1
d1860 1
d1891 1
d1993 1
d2047 1
d2129 1
d2181 1
d2256 1
d2304 1
d2340 1
d2386 1
d2432 1
d2471 1
d2554 8
a2561 6
                (!(i.fmov_gen.opc&1) && i.fmov_gen.type==0)?2:   /* CVTSS */
                (!(i.fmov_gen.opc&1) && i.fmov_gen.type==1)?3:   /* CVTSD */
                ( (i.fmov_gen.opc&1) && i.fmov_gen.type==0)?4:   /* CVTUS */
                ( (i.fmov_gen.opc&1) && i.fmov_gen.type==1)?5:0; /* CVTUD/error */
    rob->sop   = (i.fmov_gen.opc>=6)?(i.fmov_gen.type<2?0:1):/* 0:fmovl, 1:fmovh */
                 (i.fmov_gen.opc<=1)?i.fmov_gen.mode:4;      /* 0:rint, 1:ceil, 2:floor, 3:trunc, 4:round */
d2563 1
d2609 1
d2696 1
d2775 32
d2812 1
a2812 1
    rob->sop   = size; /* 1-8 */
d2814 1
d2838 30
d2873 1
d2907 1
d2946 1
d2980 1
d3019 1
d3053 1
d3092 1
d3126 1
d3160 1
d3204 1
d3239 1
d3268 1
@


1.91
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.90 2016/05/11 14:58:55 nakashim Exp nakashim $";
d775 1
a775 1
      rob->sr[2].n = R; /* ROR */
@


1.90
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.89 2016/05/11 14:37:57 nakashim Exp nakashim $";
d1206 1
a1206 1
      rob->opcd  = i.ldp_stp.opc==0?3:i.ldp_stp.opc==1?2:6; /* LDRS/LDRD/LDRQ */
d1250 1
a1250 1
      rob->opcd  = i.ldp_stp.opc==0?3:i.ldp_stp.opc==1?2:6; /* LDRS/LDRD/LDRQ */
@


1.89
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.88 2016/05/11 12:12:13 nakashim Exp nakashim $";
d126 1
d3032 1
a3032 1
  else if (i.fcmp.op31_24==0x1e && i.fcmp.op21==1 && i.fcmp.op15_10==0x08 && i.fcmp.op2_0==0) { /* C7.3.54 FCMP */
d3053 1
a3053 1
    if (i.fcmp.opc==0) { /* reg */
d3059 1
a3059 1
    else if (i.fcmp.rm==0 && i.fcmp.opc==1) { /* immediate */
@


1.88
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.87 2016/05/08 11:02:17 nakashim Exp nakashim $";
d125 1
a2546 28
  else if (i.fmov_reg.op31_24==0x1e && i.fmov_reg.op21_17==0x10 && i.fmov_reg.op14_10==0x10) { /* C7.3.113 FMOV(register) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 0; /* FMOVL */
    rob->sop   = 4|i.fmov_reg.opc; /* 4:mov, 5:abs, 6:neg, 7:sqrt, 8:undef */
    rob->ptw   = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fmov_reg.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fmov_reg.rn;
    v0 = VECREGTOP+i.fmov_reg.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
d3031 71
@


1.87
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.86 2015/10/20 23:48:02 nakashim Exp nakashim $";
d125 1
d2546 28
@


1.86
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.85 2015/09/20 23:39:05 nakashim Exp nakashim $";
d1493 1
a1493 1
    if (i.ldr_str_imm.opc==0) { /* ST */
@


1.85
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.84 2015/09/20 11:00:53 nakashim Exp nakashim $";
d126 1
d2894 1
a2894 1
    rob->opcd  = 12; /* FADD(scalar) */
d2965 1
a2965 1
    rob->opcd  = 14; /* FMUL */
d2998 1
a2998 1
    rob->opcd  = 15; /* FDIV */
d3063 37
@


1.84
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.83 2015/09/20 09:20:06 nakashim Exp nakashim $";
d1017 1
a1017 1
    rob->type  = 6; /* SVC */
d1033 1
a1033 1
    rob->sr[1].n = i.svc.imm16;
@


1.83
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.82 2015/09/20 08:03:18 nakashim Exp nakashim $";
d125 1
d2502 1
a2502 1
                  (i.fmov_gen.opc>=6 && i.fmov_gen.type==2)?1:   /* FMOVH */
d2507 2
a2508 1
    rob->sop   = (i.fmov_gen.opc<=1)?i.fmov_gen.mode:4; /* 0:rint, 1:ceil, 2:floor, 3:trunc, 4:round */
d3028 34
@


1.82
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.81 2015/09/20 06:45:12 nakashim Exp nakashim $";
d81 1
d83 1
a83 1
  /*  0     0  0  1  1  1  0        1  fadd(vector)   1  1  0  1  0  1                               */
a2583 137
  else if (i.fadd_sca.op31_24==0x1e && (i.fadd_sca.type&2)==0 && i.fadd_sca.op21==1 && i.fadd_sca.op15_13==1 && i.fadd_sca.op11_10==2) { /* C7.3.41 FADD(scalar), C7.3.149 FSUB(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 12; /* FADD(scalar) */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.fadd_sca.op;
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fadd_sca.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fadd_sca.rn;
    s2 = VECREGTOP+i.fadd_sca.rm;
    v0 = VECREGTOP+i.fadd_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fmul_sca.op31_24==0x1e && (i.fmul_sca.type&2)==0 && i.fmul_sca.op21==1 && i.fmul_sca.op14_10==0x02) { /* C7.3.119 FMUL(scalar), C7.3.126 FNMUL(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 14; /* FMUL */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = i.fmul_sca.op; /* 0:normal 1:negate */
    rob->dbl   = i.fmul_sca.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fmul_sca.rn;
    s2 = VECREGTOP+i.fmul_sca.rm;
    v0 = VECREGTOP+i.fmul_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fdiv_sca.op31_24==0x1e && (i.fdiv_sca.type&2)==0 && i.fdiv_sca.op21==1 && i.fdiv_sca.op15_10==0x06) { /* C7.3.86 FDIV(scalar) */
    rob->type  = 2; /* VXX */
    rob->opcd  = 15; /* FDIV */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.fdiv_sca.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fdiv_sca.rn;
    s2 = VECREGTOP+i.fdiv_sca.rm;
    v0 = VECREGTOP+i.fdiv_sca.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
  else if (i.fmadd.op31_24==0x1f && (i.fmadd.type&2)==0) { /* C7.3.87 FMADD, C7.3.116 FMSUB, C7.3.124 FNMADD, C7.3.125 FNMSUB */
    rob->type  = 2; /* VXX */
    rob->opcd  =13; /* FMADD/FMSUB */
    rob->sop   = 0; /* not used */
    rob->ptw   = 0; /* not used */
    rob->idx   = 0; /* not used */
    rob->rep   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = i.fmadd.o1;             /* negate s3, o1o0=00->FMADD */
    rob->oinv  = i.fmadd.o0!=i.fmadd.o1; /* negate s1, o1o0=01->FMSUB */
    rob->dbl   = i.fmadd.type&1; /* 0:Sd, 1:Dd */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    s1 = VECREGTOP+i.fmadd.rn;
    s2 = VECREGTOP+i.fmadd.rm;
    s3 = VECREGTOP+i.fmadd.ra;
    v0 = VECREGTOP+i.fmadd.rd;
    rob->sr[0].t = !t[tid].map[s1].x ? 2 :
                   (c[cid].rob[t[tid].map[s1].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[s1].x; /* reg */
    rob->sr[0].n = !t[tid].map[s1].x ? s1 : t[tid].map[s1].rob;
    rob->sr[1].t = !t[tid].map[s2].x ? 2 :
                   (c[cid].rob[t[tid].map[s2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = t[tid].map[s2].x; /* reg */
    rob->sr[1].n = !t[tid].map[s2].x ? s2 : t[tid].map[s2].rob;
    rob->sr[2].t = !t[tid].map[s3].x ? 2 :
                   (c[cid].rob[t[tid].map[s3].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = t[tid].map[s3].x; /* reg */
    rob->sr[2].n = !t[tid].map[s3].x ? s3 : t[tid].map[s3].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = v0;
    t[tid].map[v0].x = 1;
    t[tid].map[v0].rob = robid;
    return (0);
  }
d2747 104
d2889 1
a2889 1
  else if (i.fmla.op31==0 && i.fmla.op29_24==0x0e && i.fmla.op21==1 && i.fmla.op15_10==0x33) { /* C7.3.109 FMLA(vector), C7.3.111 FMLS(vector) */
d2891 2
a2892 2
    rob->opcd  = 9; /* FMLA/FMLS */
    rob->sop   = i.fmla.sz; /* 0:2S/4S, 1:2D */
d2897 1
a2897 1
    rob->iinv  = i.fmla.op; /* 0:FMLA, 1:FMLS */
d2899 34
a2932 1
    rob->dbl   = i.fmla.Q; /* 0:fmla64, 1:fmla128 */
d2937 4
a2940 4
    s1 = VECREGTOP+i.fmla.rn;
    s2 = VECREGTOP+i.fmla.rm;
    s3 = VECREGTOP+i.fmla.rd;
    v0 = VECREGTOP+i.fmla.rd;
d2960 34
a2993 1
  else if (i.fadd.op31==0 && i.fadd.op28_24==0x0e && i.fadd.op21==1 && i.fadd.op15_10==0x35) { /* C7.3.40 FADD(vector), C7.3.148 FSUB(vector) */
d2995 2
a2996 2
    rob->opcd  = 8; /* FADD/FSUB */
    rob->sop   = (i.fadd.U<<1)|i.fadd.sz; /* 0:2S/4S, 1:2D, 2:pair2S/4S, 3:pair-2D */
d3001 1
a3001 1
    rob->iinv  = i.fadd.op==0?0:1; /* 0:FADD, 1:FSUB */
d3003 1
a3003 1
    rob->dbl   = i.fadd.Q; /* 0:fadd64, 1:fadd128 */
d3008 3
a3010 3
    s1 = VECREGTOP+i.fadd.rn;
    s2 = VECREGTOP+i.fadd.rm;
    v0 = VECREGTOP+i.fadd.rd;
@


1.81
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.80 2015/09/20 05:10:19 nakashim Exp nakashim $";
d79 1
d2853 30
d2885 1
a2885 1
    rob->opcd  = 7; /* MLA/MLS */
@


1.80
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.79 2015/09/20 04:39:20 nakashim Exp nakashim $";
d97 1
d1742 71
@


1.79
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.78 2015/09/20 03:48:25 nakashim Exp nakashim $";
d119 1
d2510 34
a2543 1
  else if (i.fmul_sca.op31_24==0x1e && (i.fmul_sca.type&2)==0 && i.fmul_sca.op21==1 && i.fmul_sca.op14_10==0x02) { /* C7.3.119 FMUL(scalar) */
d2691 1
a2691 1
    rob->opcd  =  6; /* MOVI/MVNI/ORR/BIC */
d2858 1
a2858 1
    rob->opcd  = 10; /* FADD/FSUB */
@


1.78
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.77 2015/09/20 02:29:28 nakashim Exp nakashim $";
d121 1
d2575 38
d2748 1
a2748 1
    rob->opcd  = 10; /* MLA/MLS */
d2786 1
a2786 1
    rob->opcd  = 8; /* FMLA/FMLS */
d2824 1
a2824 1
    rob->opcd  = 12; /* FADD/FSUB */
@


1.77
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.76 2015/09/19 17:13:30 nakashim Exp nakashim $";
d2618 1
d2622 1
a2622 1
      rob->opcd  =  6; /* MOVI/MVNI */
d2625 1
a2625 1
      rob->opcd  =  7; /* ORR/BIC */
a2627 1
    rob->sop   = 0; /* not used */
d2709 1
a2709 1
    rob->opcd  = i.mla.U==0?10:11; /* MLA/MLS */
d2715 1
a2715 1
    rob->iinv  = 0; /* not used */
d2747 1
a2747 1
    rob->opcd  = i.fmla.op==0?8:9; /* FMLA/FMLS */
d2753 1
a2753 1
    rob->iinv  = 0; /* not used */
d2785 1
a2785 1
    rob->opcd  = i.fadd.op==0?12:13; /* FADD/FSUB */
d2791 1
a2791 1
    rob->iinv  = 0; /* not used */
@


1.76
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.75 2015/09/19 14:03:58 nakashim Exp nakashim $";
d117 4
a120 1
  /*     0  0  1  1  1  1  0        1  fmov           0  0  0  0  0  0                               */
d2377 1
a2377 1
  else if (i.fmov.op30_24==0x1e && i.fmov.op21==1 && i.fmov.op15_10==0) { /* C7.3.114 FMOV(general), C7.3.59 FCVTAS(scalar), C7.3.61 FCVTAU(scalar), C7.3.64 FCVTMS(scalar), C7.3.66 FCVTMU(scalar), C7.3.69 FCVTNS(scalar), C7.3.71 FCVTNU(scalar), C7.3.73 FCVTPS(scalar), C7.3.75 FCVTPU(scalar), C7.3.80 FCVTZS(scalar,integer), C7.3.84 FCVTZU(scalar,integer), C7.3.210 SCVTF(scalar,integer), C7.3.308 UCVTF(scalar,integer) */
d2424 7
a2430 7
    rob->opcd  =  (i.fmov.opc>=6 && i.fmov.type< 2)?0:   /* FMOVL */
                  (i.fmov.opc>=6 && i.fmov.type==2)?1:   /* FMOVH */
                (!(i.fmov.opc&1) && i.fmov.type==0)?2:   /* CVTSS */
                (!(i.fmov.opc&1) && i.fmov.type==1)?3:   /* CVTSD */
                ( (i.fmov.opc&1) && i.fmov.type==0)?4:   /* CVTUS */
                ( (i.fmov.opc&1) && i.fmov.type==1)?5:0; /* CVTUD/error */
    rob->sop   = (i.fmov.opc<=1)?i.fmov.mode:4; /* 0:rint, 1:ceil, 2:floor, 3:trunc, 4:round */
d2434 1
a2434 1
    rob->dir   = (i.fmov.opc==2 || i.fmov.opc==3 || i.fmov.opc==7)?1:0; /* 0:RR<-VR, 1:VR<-RR */
d2437 1
a2437 1
    rob->dbl   = i.fmov.sf; /* 0:WR, 1:XR */
d2442 2
a2443 2
    s1 = !rob->dir? VECREGTOP+i.fmov.rn : i.fmov.rn; /* 0:RR<-VR, 1:VR<-RR */
    v0 = !rob->dir? i.fmov.rd : VECREGTOP+i.fmov.rd; /* 0:RR<-VR, 1:VR<-RR */
d2451 1
a2451 1
    if (i.fmov.opc==7 && i.fmov.sf) { /* partial update needs d0 */
d2466 108
@


1.75
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.74 2015/09/19 11:49:58 nakashim Exp nakashim $";
d79 3
a112 1
  /*     0  0  1  1  1  1  0        1  fmov           0  0  0  0  0  0                               */
d117 1
d2596 109
@


1.74
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.73 2015/09/19 09:34:18 nakashim Exp nakashim $";
d110 2
a114 1
  /*     0  0  1  1  1  1  0        1  fmov           0  0  0  0  0  0                               */
d1735 1
a1735 1
    rob->opcd  = i.ldr_str_literal.opc==1?3:i.ldp_stp.opc==0?2:6; /* LDR/LDRW/LDRSW */
d1763 29
@


1.73
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.72 2015/09/19 09:14:03 nakashim Exp $";
d34 1
d122 1
d153 1
d193 1
d243 1
d293 1
d353 1
d405 1
d442 1
d479 1
d526 1
d570 1
d617 1
d687 1
d781 1
d825 1
d872 1
d896 1
d923 1
d950 1
d977 1
d1009 1
d1035 1
d1066 1
d1112 1
d1162 1
d1193 1
d1237 1
d1355 1
d1463 1
d1579 1
d1692 1
d1738 1
d1840 1
d1893 1
d1974 1
d2025 1
d2053 120
a2172 32
  else if (i.ld1_st1_sing.op31==0 && i.ld1_st1_sing.op29_25==0x06 && i.ld1_st1_sing.op24==1 && (i.ld1_st1_sing.opcode&6)==6) { /* C7.3.154 LD1R, C7.3.157 LD2R, C7.3.160 LD3R, C7.3.163 LD4R */
    /* C7.3.154 ld1_nofs(1r  ):op23=0,R=0,op=xx0       */
    /* C7.3.154 ld1_post(1r+r):op23=1,R=0,op=xx0,rm<31 */
    /* C7.3.154 ld1_post(1r+i):op23=1,R=0,op=xx0,rm=31 */
    /*    8B: opc=110 S=0 size=00 Q=0 -> scale=4 esz=16 selem=1 replicate      */
    /*   16B: opc=110 S=0 size=00 Q=1 -> scale=4 esz=16 selem=1 replicate      */
    /*    4H: opc=110 S=0 size=01 Q=0 -> scale=4 esz=16 selem=1 replicate      */
    /*    8H: opc=110 S=0 size=01 Q=1 -> scale=4 esz=16 selem=1 replicate      */
    /*    2S: opc=110 S=0 size=10 Q=0 -> scale=4 esz=16 selem=1 replicate      */
    /*    4S: opc=110 S=0 size=10 Q=1 -> scale=4 esz=16 selem=1 replicate      */
    /*    1D: opc=110 S=0 size=11 Q=0 -> scale=4 esz=16 selem=1 replicate      */
    /*    2D: opc=110 S=0 size=11 Q=1 -> scale=4 esz=16 selem=1 replicate      */
    /*=========================================================================================*/
    /*=========================================================================================*/
    /* C7.3.157 ld2_nofs(2r  ):op23=0,R=1,op=xx0       *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.157 ld2_post(2r+r):op23=1,R=1,op=xx0,rm<31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.157 ld2_post(2r+i):op23=1,R=1,op=xx0,rm=31 *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.160 ld3_nofs(3r  ):op23=0,R=0,op=xx1       *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.160 ld3_post(3r+r):op23=1,R=0,op=xx1,rm<31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.160 ld3_post(3r+i):op23=1,R=0,op=xx1,rm=31 *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.163 ld4_nofs(4r  ):op23=0,R=1,op=xx1       *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.163 ld4_post(4r+r):op23=1,R=1,op=xx1,rm<31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.163 ld4_post(4r+i):op23=1,R=1,op=xx1,rm=31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /*=========================================================================================*/
    /* if wback then                                                                           */
    /*  if m != 31 then    offs = X[m];                                                        */
    /*  if n == 31  SP[] = address + offs;                                                     */
    /*  else        X[n] = address + offs;                                                     */
    /*=========================================================================================*/
    i_xxx(rob); 
d2181 1
d2226 1
d2271 1
d2309 1
d2397 1
d2486 1
@


1.72
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.71 2015/09/19 08:46:30 nakashim Exp nakashim $";
d9 1
a9 1
/* decode.c 2005/3/22 */
@


1.71
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.70 2015/09/19 08:16:27 nakashim Exp nakashim $";
d1823 6
a1828 6
#if 0
      rob->sr[3].t = !t[tid].map[v0].x ? 2 :                                              
                     (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[3].x = t[tid].map[v0].x; /* reg */                                          
      rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;                         
#endif
d1955 1
a1955 1
      rob->sr[3].t = !t[tid].map[v0].x ? 2 :
@


1.70
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.69 2015/09/19 07:37:48 nakashim Exp nakashim $";
d32 1
d119 1
d149 1
d188 1
d237 1
d286 1
d345 1
d396 1
d432 1
d468 1
d514 1
d557 1
d603 1
d672 1
d765 1
d808 1
d854 1
d877 1
d903 1
d929 1
d955 1
d986 1
d1011 1
d1041 1
d1086 1
d1135 1
d1165 1
d1208 1
d1325 1
d1432 1
d1547 1
d1659 1
d1704 1
d1805 1
d1823 6
a1828 4
      rob->sr[3].t = !t[tid].map[v0].x ? 2 :                                               /* reserved */
                     (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */ /* reserved */
      rob->sr[3].x = t[tid].map[v0].x; /* reg */                                           /* reserved */
      rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;                          /* reserved */
d1857 1
d1935 1
d1937 1
d1987 1
d2054 1
d2098 1
d2142 1
d2179 1
d2266 1
d2354 1
@


1.69
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.68 2015/09/19 04:25:46 nakashim Exp nakashim $";
d1977 3
a1979 3
    /* C7.3.154 ld1_nofs(1r  ):op23=0,R=0,op=xx0      |C7.3.277 st1_nofs(1r  ) */
    /* C7.3.154 ld1_post(1r+r):op23=1,R=0,op=xx0,rm<31|C7.3.277 st1_post(1r+r) */
    /* C7.3.154 ld1_post(1r+i):op23=1,R=0,op=xx0,rm=31|C7.3.277 st1_post(1r+i) */
d1990 11
a2000 11
    /* C7.3.157 ld2_nofs(2r  ):op23=0,R=1,op=xx0      |C7.3.278 st2_nofs(2r  ) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.157 ld2_post(2r+r):op23=1,R=1,op=xx0,rm<31|C7.3.278 st2_post(2r+r) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.157 ld2_post(2r+i):op23=1,R=1,op=xx0,rm=31|C7.3.278 st2_post(2r+i) *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.160 ld3_nofs(3r  ):op23=0,R=0,op=xx1      |C7.3.280 st3_nofs(3r  ) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.160 ld3_post(3r+r):op23=1,R=0,op=xx1,rm<31|C7.3.280 st3_post(3r+r) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.160 ld3_post(3r+i):op23=1,R=0,op=xx1,rm=31|C7.3.280 st3_post(3r+i) *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.163 ld4_nofs(4r  ):op23=0,R=1,op=xx1      |C7.3.282 st4_nofs(4r  ) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.163 ld4_post(4r+r):op23=1,R=1,op=xx1,rm<31|C7.3.282 st4_post(4r+r) *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.163 ld4_post(4r+i):op23=1,R=1,op=xx1,rm=31|C7.3.282 st4_post(4r+i) *//* ÅöÌÌÌ¤¼ÂÁõ */
@


1.68
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.67 2015/09/18 05:16:18 nakashim Exp nakashim $";
d32 1
d118 1
d147 1
d185 1
d233 1
d281 1
d339 1
d389 1
d424 1
d459 1
d504 1
d546 1
d591 1
d659 1
d751 1
d793 1
d838 1
d860 1
d885 1
d910 1
d935 1
d965 1
d989 1
d1018 1
d1062 1
d1110 1
d1139 1
d1181 1
d1297 1
d1403 1
d1517 1
d1628 1
d1672 1
d1743 1
a1743 1
    /*   offs = offs + ebytes;                                            m+=esize                  */
d1750 1
a1750 1
    /*   offs = offs + ebytes;                                            m+=esize                  */
d1772 1
d1795 4
a1798 4
	rob->dr[1].t = 1;
	rob->dr[1].n = v0;
	t[tid].map[v0].x = 1;
	t[tid].map[v0].rob = robid;
d1801 4
a1804 4
	rob->dr[2].t = 1; /* writeback-basereg */
	rob->dr[2].n = i.ld1_st1_mult.rn;
	t[tid].map[i.ld1_st1_mult.rn].x = 2;
	t[tid].map[i.ld1_st1_mult.rn].rob = robid;
d1807 2
a1808 2
	rob->term = 0;
	return (1); /* continue */
d1811 2
a1812 2
	rob->term = 0;
	return (1); /* continue */
d1815 1
a1815 1
	return (0); /* finish */
d1821 1
d1853 11
a1863 1

d1875 100
a1974 19
    /*==============================================================================================*/
    /* B: opc=000                 -> scale=0 esize=8   selem=1 index=Q:S:size<1:0> */
    /* H: opc=010     size=x0     -> scale=1 esize=16  selem=1 index=Q:S:size<1>   */
    /* S: opc=100     size=00     -> scale=2 esize=32  selem=1 index=Q:S           */
    /* D: opc=100 S=0 size=01     -> scale=3 esize=64  selem=1 index=Q             */
    /*==============================================================================================*/
    /* ¥ì¥¸¥¹¥¿Æâ¤ÇÏ¢Â³ÎÎ°è o_ldst(128bit)¤ò4Ì¿ÎáÊ¬³ä,³Æ²ó1¥ì¥¸¥¹¥¿¤ËÄ¾ÀÜ³ÊÇ¼                       */
    /* for r = t,t+1,t+2,t+3 (11r:1 12r:2 13r:3 14r:4)                                              */
    /*  for e = 0 to elements-1 0-16,8,4,2,1                              16, 8, 4, 2 / 8, 4, 2, 1  */
    /*   LD: V[r].Elem[e, esize] = Mem[addr+offs, ebytes, AccT]; loc[e*esize] <- m[esize]           */
    /*   ST: Mem[addr+offs, ebytes, AccT] = V[r].Elem[e, esize]; m[esize] <- loc[e*esize]           */
    /*   offs = offs + ebytes;                                            m+=esize                  */
    /*==============================================================================================*/
    /* if wback then                                                                                */
    /*  if m != 31 then    offs = X[m];                                                             */
    /*  if n == 31  SP[] = address + offs;                                                          */
    /*  else        X[n] = address + offs;                                                          */
    /*==============================================================================================*/
    return (0); /* finish */
d1980 10
a1989 1

d2001 7
a2007 22
    /*==============================================================================================*/
    /*    8B: opc=110 S=0 size=00 Q=0 -> scale=4 esize=128 selem=1 replicate           */
    /*   16B: opc=110 S=0 size=00 Q=1 -> scale=4 esize=128 selem=1 replicate           */
    /*    4H: opc=110 S=0 size=01 Q=0 -> scale=4 esize=128 selem=1 replicate           */
    /*    8H: opc=110 S=0 size=01 Q=1 -> scale=4 esize=128 selem=1 replicate           */
    /*    2S: opc=110 S=0 size=10 Q=0 -> scale=4 esize=128 selem=1 replicate           */
    /*    4S: opc=110 S=0 size=10 Q=1 -> scale=4 esize=128 selem=1 replicate           */
    /*    1D: opc=110 S=0 size=11 Q=0 -> scale=4 esize=128 selem=1 replicate           */
    /*    2D: opc=110 S=0 size=11 Q=1 -> scale=4 esize=128 selem=1 replicate           */
    /*==============================================================================================*/
    /* ¥ì¥¸¥¹¥¿Æâ¤ÇÏ¢Â³ÎÎ°è o_ldst(128bit)¤ò4Ì¿ÎáÊ¬³ä,³Æ²ó1¥ì¥¸¥¹¥¿¤ËÄ¾ÀÜ³ÊÇ¼                       */
    /* for r = t,t+1,t+2,t+3 (11r:1 12r:2 13r:3 14r:4)                                              */
    /*  for e = 0 to elements-1 0-16,8,4,2,1                              16, 8, 4, 2 / 8, 4, 2, 1  */
    /*   LD: V[r].Elem[e, esize] = Mem[addr+offs, ebytes, AccT]; loc[e*esize] <- m[esize]           */
    /*   ST: Mem[addr+offs, ebytes, AccT] = V[r].Elem[e, esize]; m[esize] <- loc[e*esize]           */
    /*   offs = offs + ebytes;                                            m+=esize                  */
    /*==============================================================================================*/
    /* if wback then                                                                                */
    /*  if m != 31 then    offs = X[m];                                                             */
    /*  if n == 31  SP[] = address + offs;                                                          */
    /*  else        X[n] = address + offs;                                                          */
    /*==============================================================================================*/
d2014 1
d2057 1
d2100 1
d2136 1
d2222 1
d2309 1
@


1.67
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.66 2015/09/18 04:05:38 nakashim Exp nakashim $";
d74 2
a75 1
  /*  0     0  0  1  1  0  1           ld1_st1_sing                                                  */
d1026 1
a1026 1
      if (post_index || pre_index) {
d1142 1
a1142 1
      if (post_index || pre_index) {
d1299 1
a1299 1
    if (post_index || pre_index) {
d1402 1
a1402 1
    if (post_index || pre_index) {
d1664 27
a1690 27
    /* C7.3.152 ld1_nofs(1r  ,rpt=1,sel=1):op23=0,op=0111      |C7.3.275 st1_nofs(1r  ):op23=0,op0111       */
    /* C7.3.152 ld1_post(1r+r,rpt=1,sel=1):op23=1,op=0111,rm<31|C7.3.275 st1_post(1r+r):op23=1,op0111,rm<31 */
    /* C7.3.152 ld1_post(1r+i,rpt=1,sel=1):op23=1,op=0111,rm=31|C7.3.275 st1_post(1r+i):op23=1,op0111,rm=31 */

    /* C7.3.152 ld1_nofs(2r  ,rpt=2,sel=1):op23=0,op=1010      |C7.3.275 st1_nofs(2r  ):op23=0,op1010       */
    /* C7.3.152 ld1_post(2r+r,rpt=2,sel=1):op23=1,op=1010,rm<31|C7.3.275 st1_post(2r+r):op23=1,op1010,rm<31 */
    /* C7.3.152 ld1_post(2r+i,rpt=2,sel=1):op23=1,op=1010,rm=31|C7.3.275 st1_post(2r+i):op23=1,op1010,rm=31 */

    /* C7.3.152 ld1_nofs(3r  ,rpt=3,sel=1):op23=0,op=0110      |C7.3.275 st1_nofs(3r  ):op23=0,op0110       */
    /* C7.3.152 ld1_post(3r+r,rpt=3,sel=1):op23=1,op=0110,rm<31|C7.3.275 st1_post(3r+r):op23=1,op0110,rm<31 */
    /* C7.3.152 ld1_post(3r+i,rpt=3,sel=1):op23=1,op=0110,rm=31|C7.3.275 st1_post(3r+i):op23=1,op0110,rm=31 */

    /* C7.3.152 ld1_nofs(4r  ,rpt=4,sel=1):op23=0,op=0010      |C7.3.275 st1_nofs(4r  ):op23=0,op0010       */
    /* C7.3.152 ld1_post(4r+r,rpt=4,sel=1):op23=1,op=0010,rm<31|C7.3.275 st1_post(4r+r):op23=1,op0010,rm<31 */
    /* C7.3.152 ld1_post(4r+i,rpt=4,sel=1):op23=1,op=0010,rm=31|C7.3.275 st1_post(4r+i):op23=1,op0010,rm=31 */

    /* C7.3.155 ld2_nofs(2r  ,rpt=1,sel=2):op23=0,op=1000      |C7.3.277 st2_nofs(2r  ):op23=0,op1000       *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.155 ld2_post(2r+r,rpt=1,sel=2):op23=1,op=1000,rm<31|C7.3.277 st2_post(2r+r):op23=1,op1000,rm<31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.155 ld2_post(2r+i,rpt=1,sel=2):op23=1,op=1000,rm=31|C7.3.277 st2_post(2r+i):op23=1,op1000,rm=31 *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.158 ld3_nofs(3r  ,rpt=1,sel=3):op23=0,op=0100      |C7.3.279 st3_nofs(3r  ):op23=0,op0100       *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.158 ld3_post(3r+r,rpt=1,sel=3):op23=1,op=0100,rm<31|C7.3.279 st3_post(3r+r):op23=1,op0100,rm<31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.158 ld3_post(3r+i,rpt=1,sel=3):op23=1,op=0100,rm=31|C7.3.279 st3_post(3r+i):op23=1,op0100,rm=31 *//* ÅöÌÌÌ¤¼ÂÁõ */

    /* C7.3.161 ld4_nofs(4r  ,rpt=1,sel=4):op23=0,op=0000      |C7.3.281 st4_nofs(4r  ):op23=0,op0000       *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.161 ld4_post(4r+r,rpt=1,sel=4):op23=1,op=0000,rm<31|C7.3.281 st4_post(4r+r):op23=1,op0000,rm<31 *//* ÅöÌÌÌ¤¼ÂÁõ */
    /* C7.3.161 ld4_post(4r+i,rpt=1,sel=4):op23=1,op=0000,rm=31|C7.3.281 st4_post(4r+i):op23=1,op0000,rm=31 *//* ÅöÌÌÌ¤¼ÂÁõ */
d1724 4
a1727 5
    int num_insn;
    int post_index = i.ld1_st1_mult.op23==1;
    int imm_offset = i.ld1_st1_mult.rm==31; /* immediate_offset */
    int offset     = i.ld1_st1_mult.Q?16:8;
    rob->type  = i.ld1_st1_mult.L?3:4; /* LD/ST */
d1729 4
a1732 4
    case  7: num_insn = 1; break;
    case 10: num_insn = 2; break;
    case  6: num_insn = 3; break;
    case  2: num_insn = 4; break;
d1735 72
a1806 28
    rob->opcd = i.ld1_st1_mult.Q?12:11; /* 12:VLDRQ/VSTRQ(16), 11:VLDRD/VSTRD(8) */
    rob->sop   = 0; /* not used */
    rob->dir   = 0; /* not used */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.ld1_st1_mult.Q; /* 0:ld64, 1:ld128 */
    rob->plus  = 1; /* plus */
    rob->pre   = !post_index; /* addr+offset */
    rob->wb    = post_index;
    rob->updt  = 0; /* not used */
    v0 = VECREGTOP+(i.ld1_st1_mult.rt + mc)%VECREG;
    rob->sr[0].t = !t[tid].map[i.ld1_st1_mult.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ld1_st1_mult.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ld1_st1_mult.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ld1_st1_mult.rn].x ? i.ld1_st1_mult.rn : t[tid].map[i.ld1_st1_mult.rn].rob;
    rob->sr[1].t = imm_offset ? 1 : /* immediate */
                   !t[tid].map[i.ld1_st1_mult.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ld1_st1_mult.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[1].x = imm_offset ? 0 : /* offset */
                   t[tid].map[i.ld1_st1_mult.rm].x; /* reg */
    rob->sr[1].n = imm_offset ? offset : /* offset */
                   !t[tid].map[i.ld1_st1_mult.rm].x ? i.ld1_st1_mult.rm : t[tid].map[i.ld1_st1_mult.rm].rob;
    rob->sr[3].t = !t[tid].map[v0].x ? 2 :                                               /* reserved */
                   (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */ /* reserved */
    rob->sr[3].x = t[tid].map[v0].x; /* reg */                                           /* reserved */
    rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;                          /* reserved */
    /* dest */
    if (i.ld1_st1_mult.L) { /* LD */
d1808 2
a1809 8
      rob->dr[1].n = v0;
      t[tid].map[v0].x = 1;
      t[tid].map[v0].rob = robid;
    }
    if (post_index) {
      rob->dr[2].t = 1; /* writeback-basereg */
      rob->dr[2].n = i.ld1_st1_mult.rn;
      t[tid].map[i.ld1_st1_mult.rn].x = 2;
d1811 1
d1813 76
a1888 6
    if (mc+1 < num_insn) { /* continue */
      rob->term = 0;
      return (1); /* continue */
    }
    else
      return (0); /* finish */
@


1.66
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.65 2015/09/16 14:04:52 nakashim Exp nakashim $";
d1768 8
a1775 1
    if (mc+1 < num_insn) /* continue */
d1777 1
@


1.65
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.64 2015/09/16 13:52:08 nakashim Exp nakashim $";
d9 1
a9 1
/* decode.c 2005/3/22 */ 
d73 2
d294 1
a294 1
		     (c[cid].rob[t[tid].map[i.ccm.rm_imm5].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
d348 2
a349 2
	i_xxx(rob);
	return (0);
d599 2
a600 2
	if ((imm>>len)&1)
	  break;
d603 2
a604 2
	i_xxx(rob);
	return (0);
d615 1
a615 1
	wmask = (wmask<<esize) | welem;
d617 1
a617 1
	wmask &= 0x00000000ffffffffLL;
d659 2
a660 2
	if ((imm>>len)&1)
	  break;
d663 2
a664 2
	i_xxx(rob);
	return (0);
d677 1
a677 1
	wmask = (wmask<<esize) | welem;
d679 1
a679 1
	wmask &= 0x00000000ffffffffLL;
d687 1
a687 1
	tmask = (tmask<<esize) | telem;
d689 1
a689 1
	tmask &= 0x00000000ffffffffLL;
d696 2
a697 2
	i_xxx(rob);
	return (0);
d975 1
a975 1
	             (c[cid].rob[t[tid].map[i.ldp_stp.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
d1010 7
a1016 7
	rob->sr[3].t = i.ldp_stp.rt==31 ? 1 : /* ZERO */
	               !t[tid].map[i.ldp_stp.rt].x ? 2 :
	               (c[cid].rob[t[tid].map[i.ldp_stp.rt].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
	rob->sr[3].x = i.ldp_stp.rt==31 ? 0 : /* ZERO */
	               t[tid].map[i.ldp_stp.rt].x; /* reg */
	rob->sr[3].n = i.ldp_stp.rt==31 ? 0 : /* ZERO */
	               !t[tid].map[i.ldp_stp.rt].x ? i.ldp_stp.rt : t[tid].map[i.ldp_stp.rt].rob;
d1020 4
a1023 4
	rob->dr[1].t = 1;
	rob->dr[1].n = i.ldp_stp.rt;
	t[tid].map[i.ldp_stp.rt].x = 1;
	t[tid].map[i.ldp_stp.rt].rob = robid;
d1046 1
a1046 1
	             (c[cid].rob[t[tid].map[AUXREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
d1053 1
a1053 1
	rob->sr[3].t = i.ldp_stp.rt2==31 ? 1 : /* ZERO */
d1055 5
a1059 5
	               (c[cid].rob[t[tid].map[i.ldp_stp.rt2].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
	rob->sr[3].x = i.ldp_stp.rt2==31 ? 0 : /* ZERO */
	               t[tid].map[i.ldp_stp.rt2].x; /* reg */
	rob->sr[3].n = i.ldp_stp.rt2==31 ? 0 : /* ZERO */
	               !t[tid].map[i.ldp_stp.rt2].x ? i.ldp_stp.rt2 : t[tid].map[i.ldp_stp.rt2].rob;
d1063 4
a1066 4
	rob->dr[1].t = 1;
	rob->dr[1].n = i.ldp_stp.rt2;
	t[tid].map[i.ldp_stp.rt2].x = 1;
	t[tid].map[i.ldp_stp.rt2].rob = robid;
d1093 1
a1093 1
	             (c[cid].rob[t[tid].map[i.ldp_stp.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
d1129 4
a1132 4
	rob->sr[3].t = !t[tid].map[v0].x ? 2 :
	               (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
	rob->sr[3].x = t[tid].map[v0].x; /* reg */
	rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
d1136 4
a1139 4
	rob->dr[1].t = 1;
	rob->dr[1].n = v0;
	t[tid].map[v0].x = 1;
	t[tid].map[v0].rob = robid;
d1163 1
a1163 1
	             (c[cid].rob[t[tid].map[AUXREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
d1170 4
a1173 4
	rob->sr[3].t = !t[tid].map[v0].x ? 2 :
	               (c[cid].rob[t[tid].map[v0].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
	rob->sr[3].x = t[tid].map[v0].x; /* reg */
	rob->sr[3].n = !t[tid].map[v0].x ? v0 : t[tid].map[v0].rob;
d1177 4
a1180 4
	rob->dr[1].t = 1;
	rob->dr[1].n = v0;
	t[tid].map[v0].x = 1;
	t[tid].map[v0].rob = robid;
d1208 3
a1210 3
	rob->opcd = 0; /* LDRB/STRB(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1212 3
a1214 3
	rob->opcd = 4; /* LDRSB(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1216 3
a1218 3
	rob->opcd = 4; /* LDRSB(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1225 3
a1227 3
	rob->opcd = 1; /* LDRH/STRH(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1229 3
a1231 3
	rob->opcd = 5; /* LDRSH(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1233 3
a1235 3
	rob->opcd = 5; /* LDRSH(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1242 3
a1244 3
	rob->opcd = 2; /* LDR(32)/STR(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1246 3
a1248 3
	rob->opcd = 6; /* LDRSW(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1250 2
a1251 2
	i_xxx(rob);
	return (0);
d1258 3
a1260 3
	rob->opcd = 3; /* LDR(64)/STR(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1263 2
a1264 2
	i_xxx(rob);
	return (0);
d1284 1
a1284 1
	             !t[tid].map[i.ldr_str_imm.rt].x ? 2 :
d1287 1
a1287 1
	             t[tid].map[i.ldr_str_imm.rt].x; /* reg */
d1322 3
a1324 3
	rob->opcd = 8; /* LDRB/STRB(8) */
	rob->dbl  = 0; /* ldst8 */
	break;
d1327 3
a1329 3
	rob->opcd =12; /* LDRQ/STRQ(128) */
	rob->dbl  = 1; /* ldst128 */
	break;
d1336 3
a1338 3
	rob->opcd = 9; /* LDRH/STRH(16) */
	rob->dbl  = 0; /* ldst16 */
	break;
d1341 2
a1342 2
	i_xxx(rob);
	return (0);
d1349 3
a1351 3
	rob->opcd =10; /* LDRS(32)/STRS(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1354 2
a1355 2
	i_xxx(rob);
	return (0);
d1362 3
a1364 3
	rob->opcd =11; /* LDRD(64)/STRD(64) */
	rob->dbl  = 0; /* ldst64 */
	break;
d1367 2
a1368 2
	i_xxx(rob);
	return (0);
d1426 3
a1428 3
	rob->opcd = 0; /* LDURB/STURB(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1430 3
a1432 3
	rob->opcd = 4; /* LDURSB(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1434 3
a1436 3
	rob->opcd = 4; /* LDURSB(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1443 3
a1445 3
	rob->opcd = 1; /* LDURH/STURH(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1447 3
a1449 3
	rob->opcd = 5; /* LDURSH(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1451 3
a1453 3
	rob->opcd = 5; /* LDURSH(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1460 3
a1462 3
	rob->opcd = 2; /* LDUR(32)/STUR(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1464 3
a1466 3
	rob->opcd = 6; /* LDURSW(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1468 2
a1469 2
	i_xxx(rob);
	return (0);
d1476 3
a1478 3
	rob->opcd = 3; /* LDUR(64)/STUR(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1481 2
a1482 2
	i_xxx(rob);
	return (0);
d1502 1
a1502 1
	             !t[tid].map[i.ldr_str_unsc.rt].x ? 2 :
d1505 1
a1505 1
	             t[tid].map[i.ldr_str_unsc.rt].x; /* reg */
d1536 3
a1538 3
	rob->opcd = 0; /* LDRB/STRB(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1540 3
a1542 3
	rob->opcd = 4; /* LDRSB(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1544 3
a1546 3
	rob->opcd = 4; /* LDRSB(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1553 3
a1555 3
	rob->opcd = 1; /* LDRH/STRH(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1557 3
a1559 3
	rob->opcd = 5; /* LDRSH(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1561 3
a1563 3
	rob->opcd = 5; /* LDRSH(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1570 3
a1572 3
	rob->opcd = 2; /* LDR(32)/STR(32) */
	rob->dbl  = 0; /* ldst32 */
	break;
d1574 3
a1576 3
	rob->opcd = 6; /* LDRSW(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1578 2
a1579 2
	i_xxx(rob);
	return (0);
d1586 3
a1588 3
	rob->opcd = 3; /* LDR(64)/STR(64) */
	rob->dbl  = 1; /* ldst64 */
	break;
d1591 2
a1592 2
	i_xxx(rob);
	return (0);
d1619 1
a1619 1
	             !t[tid].map[i.ldr_str_reg.rt].x ? 2 :
d1622 1
a1622 1
	             t[tid].map[i.ldr_str_reg.rt].x; /* reg */
d1662 111
d2111 1
a2111 1
	rob->sr[1].n = (imm8<<56)|(imm8<<48)|(imm8<<40)|(imm8<<32)|(imm8<<24)|(imm8<<16)|(imm8<<8)|(imm8);
d2113 9
a2121 9
	Ull a=i.movi.a, b=i.movi.b, c=i.movi.c, d=i.movi.d, e=i.movi.e, f=i.movi.f, g=i.movi.g, h=i.movi.h;
	rob->sr[1].n = (a<<63)|(a<<62)|(a<<61)|(a<<60)|(a<<59)|(a<<58)|(a<<57)|(a<<56)
	              |(b<<55)|(b<<54)|(b<<53)|(b<<52)|(b<<51)|(b<<50)|(b<<49)|(b<<48)
	              |(c<<47)|(c<<46)|(c<<45)|(c<<44)|(c<<43)|(c<<42)|(c<<41)|(c<<40)
	              |(d<<39)|(d<<38)|(d<<37)|(d<<36)|(d<<35)|(d<<34)|(d<<33)|(d<<32)
	              |(e<<31)|(e<<30)|(e<<29)|(e<<28)|(e<<27)|(e<<26)|(e<<25)|(e<<24)
	              |(f<<23)|(f<<22)|(f<<21)|(f<<20)|(f<<19)|(f<<18)|(f<<17)|(f<<16)
	              |(g<<15)|(g<<14)|(g<<13)|(g<<12)|(g<<11)|(g<<10)|(g<< 9)|(g<< 8)
	              |(h<< 7)|(h<< 6)|(h<< 5)|(h<< 4)|(h<< 3)|(h<< 2)|(h<< 1)|(h    );
d2126 3
a2128 3
	Ull a=i.movi.a, b=i.movi.b, c=i.movi.c, d=i.movi.d, e=i.movi.e, f=i.movi.f, g=i.movi.g, h=i.movi.h;
	rob->sr[1].n = (a<<63)|((1-b)<<62)|(b<<61)|(b<<60)|(b<<59)|(b<<58)|(b<<57)|(c<<56)|(d<<55)|(e<<54)|(f<<53)|(g<<52)|(h<<51)
	              |(a<<31)|((1-b)<<30)|(b<<29)|(b<<28)|(b<<27)|(b<<26)|(b<<25)|(c<<24)|(d<<23)|(e<<22)|(f<<21)|(g<<20)|(h<<19);
d2131 2
a2132 2
	Ull a=i.movi.a, b=i.movi.b, c=i.movi.c, d=i.movi.d, e=i.movi.e, f=i.movi.f, g=i.movi.g, h=i.movi.h;
	rob->sr[1].n = (a<<63)|((1-b)<<62)|(b<<61)|(b<<60)|(b<<59)|(b<<58)|(b<<57)|(b<<56)|(b<<55)|(b<<54)|(c<<53)|(d<<52)|(e<<51)|(f<<50)|(g<<49)|(h<<48);
@


1.64
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.63 2015/09/15 14:39:57 nakashim Exp nakashim $";
d1900 1
a1900 1
  else if (i.movi.op31==0 && i.movi.op28_19==0x1e0 && i.movi.op11_10==1) { /* C7.3.12 BIC, C7.3.179 MOVI, C7.3.183 MVNI, C7.3.187 ORR(vector,immediate) */
d1938 4
a1941 4
    /* C7.3.179 movi64s Dd,   #imm        : Q=0, cmode=1110, op=1 */
    /* C7.3.179 movi64s Vd.2D,#imm        : Q=1, cmode=1110, op=1 */
    /* C7.3.179 movi                      :      cmode=1111, op=0 */
    /* C7.3.179 movi                      :      cmode=1111, op=1 */
@


1.63
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.62 2015/09/15 12:54:59 nakashim Exp $";
d73 1
d1892 1
a1892 1
    if (rob->dir || s1!=31) { /* MOV */
d1900 130
@


1.62
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.61 2015/09/15 12:52:39 nakashim Exp nakashim $";
d9 1
a9 1
/* decode.c 2005/3/22 */
@


1.61
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.60 2015/09/13 14:29:07 nakashim Exp nakashim $";
d1745 1
a1745 1
    rob->opcd  = i.mad.U==0?8:9; /* SMULH/UMULH */
@


1.60
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.59 2015/09/13 10:03:52 nakashim Exp nakashim $";
d101 2
d1743 35
d1780 1
a1780 1
    rob->opcd  = i.div.o1==0?6:7; /* UDIV/SDIV */
@


1.59
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.58 2015/09/13 07:37:47 nakashim Exp nakashim $";
d92 1
a93 1
  /*        1  1  1  0  1  0  0  1  0  ccm                                             0             */
d95 2
d1741 35
@


1.58
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.57 2015/09/12 15:12:00 nakashim Exp nakashim $";
d1483 1
a1483 1
    rob->pre   = 0; /* not used */
@


1.57
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.56 2015/09/08 09:32:50 nakashim Exp nakashim $";
d87 1
d1402 109
@


1.56
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.55 2015/09/08 06:45:45 nakashim Exp nakashim $";
d1194 1
a1194 1
    rob->type  = (i.ldr_str_imm.opc!=0)?3:4; /* LD/ST */
d1284 1
a1284 1
    if ((i.ldr_str_imm.opc&1) && i.ldr_str_imm.rt!=31) { /* LD */
d1413 1
a1413 1
    rob->type  = (i.ldr_str_reg.opc!=0)?3:4; /* LD/ST */
d1510 1
a1510 1
    if ((i.ldr_str_reg.opc&1) && i.ldr_str_reg.rt!=31) { /* LD */
@


1.55
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.54 2015/09/08 06:17:30 nakashim Exp nakashim $";
d484 1
a484 1
    rob->sop   = 8+i.add_sub_extreg.option; /* 0:uxtb, 1:uxth, 2:uxtw, 3:uxtx, 4:sxtb, 5:sxth, 6:sxtw, 7:sxtx */
d1411 2
d1478 1
a1478 1
    rob->sop   = 0; /* not used */
d1483 1
a1483 1
    rob->pre   = 0; /* not used */
d1490 10
a1499 3
    rob->sr[1].t = 1; /* immediate */
    rob->sr[1].x = 0; /* renamig N.A. */
    rob->sr[1].n = offset;
a1515 6
    if (post_index || pre_index) {
      rob->dr[2].t = 1; /* writeback-basereg */
      rob->dr[2].n = i.ldr_str_reg.rn;
      t[tid].map[i.ldr_str_reg.rn].x = 2;
      t[tid].map[i.ldr_str_reg.rn].rob = robid;
    }
@


1.54
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.53 2015/09/06 10:18:56 nakashim Exp nakashim $";
d108 1
a108 1
    rob->dir   = 0;
d136 1
a136 1
    rob->dir   = 0;
d173 1
a173 1
    rob->dir   = 0;
d220 1
a220 1
    rob->dir   = 0;
d267 1
a267 1
    rob->dir   = 0;
d324 1
a324 1
    rob->dir   = 0;
d373 1
a373 1
    rob->dir   = 0;
d407 1
a407 1
    rob->dir   = 0;
d441 1
a441 1
    rob->dir   = 0;
d485 1
a485 1
    rob->dir   = 0;
d526 1
a526 1
    rob->dir   = 0;
d570 1
a570 1
    rob->dir   = 0;
d637 1
a637 1
    rob->dir   = 0;
d728 1
a728 1
    rob->dir   = 0;
d769 1
a769 1
    rob->dir   = 0;
d813 1
a813 1
    rob->dir   = 0;
d834 1
a834 1
    rob->dir   = 0;
d858 1
a858 1
    rob->dir   = 0;
d882 1
a882 1
    rob->dir   = 0;
d906 1
a906 1
    rob->dir   = 0;
d935 1
a935 1
    rob->dir   = 0;
d958 1
a958 1
      rob->dir   = 0;
d986 1
a986 1
      rob->dir   = 0;
d1029 1
a1029 1
      rob->dir   = 0;
d1076 1
a1076 1
      rob->dir   = 0;
d1104 1
a1104 1
      rob->dir   = 0;
d1145 1
a1145 1
      rob->dir   = 0;
d1260 1
a1260 1
    rob->dir   = 0;
d1365 1
a1365 1
    rob->dir   = 0;
d1477 1
a1477 1
    rob->dir   = 0;
d1519 1
a1519 1
    rob->dir   = 0;
d1546 1
a1546 1
    rob->dir   = 0;
d1588 1
a1588 1
    rob->dir   = 0;
@


1.53
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.52 2015/09/06 07:45:55 nakashim Exp nakashim $";
d86 4
a89 1
  /*        1  1  1  0  0              ldr_str_imm                                                   */
d98 3
a100 1
  /*        1  1  1  1  0              ldr_str_imm(simd&fp)                                          */
d103 1
a103 1
  if (i.adr.op28_24 == 0x10) { /* C6.6.9 ADR, C6.6.10 ADRP */
d132 1
a132 1
  else if (i.add_sub_imm.op28_24 == 0x11) { /* C6.6.4 ADD(immediate), C6.6.7 ADDS(immediate), C6.6.42 CMN(immediate), C6.6.45 CMP(immediate), C6.6.121 MOV(to/from SP), C6.6.195 SUB(immediate), C6.6.198 SUBS(immediate) */
d169 1
a169 1
  else if (i.adc_sbc.op28_21 == 0xd0 && i.adc_sbc.op15_10 == 0) { /* C6.6.1 ADC, C6.6.2 ADCS, C6.6.137 NGC, C6.6.138 NGCS, C6.6.155 SBC, C6.6.156 SBCS */
d216 1
a216 1
  else if (i.csel.op29_21 == 0x0d4 && i.csel.op11 == 0) { /* C6.6.36 CINC, C6.6.37 CINV, C6.6.47 CNEG, C6.6.50 CSEL, C6.6.51 CSET, C6.6.52 CSETM, C6.6.53 CSINC, C6.6.54 CSINV, C6.6.55 CSNEG */
d263 1
a263 1
  else if (i.ccm.op29_21 == 0x1d2 && i.ccm.op4 == 0) { /* C6.6.32 CCMN(immediate), C6.6.33 CCMN(register), C6.6.34 CCMP(immediate), C6.6.35 CCMP(register) */
d320 1
a320 1
  else if (i.mov.op28_23 == 0x25) { /* C6.6.122 MOV(inverted wide immediate), C6.6.123 MOV(wide immediate), C6.6.126 MOVK, C6.6.127 MOVN, C6.6.128 MOVZ */
d369 1
a369 1
  else if (i.rev.op30_12 == 0x5ac00) { /* C6.6.147 RBIT, C6.6.149 REV, C6.6.150 REV16, C6.6.151 REV32 */
d403 1
a403 1
  else if (i.cls.op30_11 == 0xb5802) { /* C6.6.39 CLS, C6.6.40 CLZ */
d437 1
a437 1
  else if (i.add_sub_shifted.op28_24 == 0x0b && i.add_sub_shifted.op21 == 0) { /* C6.6.5 ADD(shifted register), C6.6.8 ADDS(shifted register), C6.6.43 CMN(shifted register), C6.6.46 CMP(shifted register), C6.6.135 NEG(shifted register), C6.6.136 NEGS(shifted register), C6.6.196 SUB(shifted register), C6.6.199 SUBS(shifted register) */
d481 1
a481 1
  else if (i.add_sub_extreg.op28_24 == 0x0b && i.add_sub_extreg.op23_22 == 0 && i.add_sub_extreg.op21 == 1) { /* C6.6.3 ADD(extended register), C6.6.6 ADDS(extended register), C6.6.41 CMN(extended register), C6.6.44 CMP(extended register), C6.6.194 SUB(extended register), C6.6.197 SUBS(extended register) */
d522 1
a522 1
  else if (i.and_shifted.op28_24 == 0x0a) { /* C6.6.12 AND(shifted register), C6.6.14 ANDS(shifted register), C6.6.24 BIC(shifted register), C6.6.25 BICS(shifted register), C6.6.63 EON(shifted register), C6.6.65 EOR(shifted register), C6.6.125 MOV(register), C6.6.134 MVN(register), C6.6.140 ORN(shifted register), C6.6.142 ORR(shifted register), C6.6.210 TST(shifted register) */
d566 1
a566 1
  else if (i.and_imm.op28_23 == 0x24) { /* C6.6.11 AND(immediate), C6.6.13 ANDS(immediate), C6.6.64 EOR(immediate), C6.6.124 MOV(bitmask immediate), C6.6.141 ORR(immediate), C6.6.209 TST(immediate) */
d633 1
a633 1
  else if (i.sft_imm.op28_23 == 0x26) { /* C6.6.16 ASR(immediate), C6.6.21 BFI, C6.6.22 BFM, C6.6.23 BFXIL, C6.6.114 LSL(immediate), C6.6.117 LSR(immediate), C6.6.157 SBFIZ, C6.6.158 SBFM, C6.6.159 SBFX, C6.6.201 SXTB, C6.6.202 SXTH, C6.6.203 SXTW, C6.6.211 UBFIZ, C6.6.212 UBFM, C6.6.213 UBFX, C6.6.220 UXTB, C6.6.221 UXTH */
d724 1
a724 1
  else if (i.ror_imm.op30_23 == 0x27 && i.ror_imm.op21 == 0) { /* C6.6.67 EXTR(immediate), C6.6.152 ROR(immediate) */
d765 1
a765 1
  else if (i.sft_reg.op30_21 == 0x0d6 && i.sft_reg.op15_12 == 2) { /* C6.6.15 ASR, C6.6.17 ASRV, C6.6.113 LSL(register), C6.6.115 LSLV, C6.6.116 LSR(register), C6.6.118 LSRV */
d803 1
a803 1
  else if (i.b_cond.op31_24 == 0x54 && i.b_cond.op4 == 0) { /* C6.6.19 B.cond */
d828 1
a828 1
  else if (i.bl.op30_26 == 0x05) { /* C6.6.20 B, C6.6.26 BL */
d851 1
a851 1
  else if (i.cbz.op30_25 == 0x1a) { /* C6.6.30 CBNZ, C6.6.31 CBZ */
d875 1
a875 1
  else if (i.tbz.op30_25 == 0x1b) { /* C6.6.206 TBNZ, C6.6.207 TBZ */
d902 1
a902 1
  else if (i.blr.op31_23 == 0x1ac && i.blr.op20_10 == 0x7c0 && i.blr.op4_0 == 0) { /* C6.6.27 BLR, C6.6.28 BR, C6.6.148 RET */
d929 1
a929 1
  else if (i.svc.op31_21 == 0x6a0 && i.svc.op4_0 == 0x01) { /* C6.6.200 SVC */
d948 1
a948 1
  else if (i.ldp_stp.op29_25 == 0x14) { /* C6.6.81 LDP, C6.6.82 LDPSW, C6.6.177 STP */
d1066 1
a1066 1
  else if (i.ldp_stp.op29_25 == 0x16) { /* C7.3.165 LDP(SIMD&FP), C7.3.284 STP(SIMD&FP) */
d1180 2
a1181 2
  else if (i.ldr_str_imm.op29_25 == 0x1c) { /* C6.6.83 LDR(immediate), C6.6.86 LDRB(immediate), C6.6.88 LDRH(immediate), C6.6.90 LDRSB(immediate), C6.6.92 LDRSH(immediate), C6.6.94 LDRSW(immediate), C6.6.178 STR(immediate), C6.6.181 STRB(immediate), C6.6.182 STR(immediate) */
    /* C6.6.86 ldrb(32):  size=00, opc=01 | C6.6.181 strb(32): size=00, opc=00 */
d1298 1
a1298 1
  else if (i.ldr_str_imm.op29_25 == 0x1e) { /* C7.3.166 LDR(immediate,SIMD&FP), C7.3.285 STR(immediate,SIMD&FP) */
d1401 115
a1515 1
  else if (i.ldr_str_literal.op29_24 == 0x18) { /* C6.6.84 LDR(literal), C6.6.95 LDRSW(literal) */
d1542 1
a1542 1
  else if (i.mad.sf == 1 && i.mad.op30_24 == 0x1b && i.mad.op22_21 == 1) { /* C6.6.163 SMADDL, C6.6.165 SMNEGL, C6.6.166 SMSUBL, C6.6.168 SMULL, C6.6.215 UMADDL, C6.6.216 UMNEGL, C6.6.217 UMSUBL, C6.6.219 UMULL */
d1584 1
a1584 1
  else if (i.mad.op30_24 == 0x1b && i.mad.U == 0 && i.mad.op22_21 == 0) { /* C6.6.119 MADD, C6.6.133 MUL, C6.6.120 MNEG, C6.6.132 MSUB */
d1626 1
a1626 1
  else if (i.fmov.op30_24 == 0x1e && i.fmov.op21 == 1 && i.fmov.op15_10 == 0) { /* C7.3.114 FMOV(general), C7.3.59 FCVTAS(scalar), C7.3.61 FCVTAU(scalar), C7.3.64 FCVTMS(scalar), C7.3.66 FCVTMU(scalar), C7.3.69 FCVTNS(scalar), C7.3.71 FCVTNU(scalar), C7.3.73 FCVTPS(scalar), C7.3.75 FCVTPU(scalar), C7.3.80 FCVTZS(scalar,integer), C7.3.84 FCVTZU(scalar,integer), C7.3.210 SCVTF(scalar,integer), C7.3.308 UCVTF(scalar,integer) */
@


1.52
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.51 2015/09/06 05:41:35 nakashim Exp nakashim $";
d1189 1
a1189 1
    rob->type  = (i.ldr_str_imm.opc&1)?3:4; /* LD/ST */
@


1.51
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.50 2015/09/06 04:46:05 nakashim Exp nakashim $";
d479 1
a479 1
    rob->sop   = i.add_sub_extreg.shift; /* LSL/LSR/ASR/ROR */
d488 1
a488 2
    rob->sr[0].t = i.add_sub_extreg.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.add_sub_extreg.rn].x ? 2 :
d490 2
a491 4
    rob->sr[0].x = i.add_sub_extreg.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.add_sub_extreg.rn].x; /* reg */
    rob->sr[0].n = i.add_sub_extreg.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.add_sub_extreg.rn].x ? i.add_sub_extreg.rn : t[tid].map[i.add_sub_extreg.rn].rob;
d501 1
a501 1
    rob->sr[2].n = i.add_sub_extreg.imm6; /* LSL/LSR/ASR/ROR */
d503 1
a503 1
    if (i.add_sub_extreg.rd!=31) {
@


1.50
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.49 2015/09/05 14:54:19 nakashim Exp nakashim $";
d68 23
a90 6
  /*           1  0  0  0  0          adr                                                            */
  /*           1  0  0  0  1          add_sub_imm                                                    */
  /*           1  1  0  1  0  0  0  0 adc_sbc         0  0  0  0  0  0                               */
  /*        0  1  1  0  1  0  1  0  0 csel                        0                                  */
  /*        1  1  1  0  1  0  0  1  0 ccm                                              0             */
  /*           1  0  0  1  0  1       mov                                                            */
d93 4
a96 20
  /*           0  1  0  1  1        0 add_sub_shifted                                                */
  /*           0  1  0  1  0          and_shifted                                                    */
  /*           1  0  0  1  0  0       and_imm                                                        */
  /*           1  0  0  1  1  0       sft_imm                                                        */
  /*     0  0  1  0  0  1  1  1     0 ror_imm                                                        */
  /*     0  0  1  1  0  1  0  1  1  0 sft_reg         0  0  1  0                                     */
  /*  0  1  0  1  0  1  0  0          b_cond                                           0             */
  /*     0  0  1  0  1                bl                                                             */
  /*     0  1  1  0  1  0             cbz                                                            */
  /*     0  1  1  0  1  1             tbz                                                            */
  /*  1  1  0  1  0  1  1  0  0        1  1  1  1  1  0  0  0  0  0  0 blr             0  0  0  0  0 */
  /*  1  1  0  1  0  1  0  0  0  0  0                                                  0  0  0  0  1 */
  /*        1  0  1  0  0             ldp_stp                                                        */
  /*        1  0  1  1  0             ldp_stp(simd&fp)                                               */
  /*        1  1  1  0  0             ldr_str_imm                                                    */
  /*        1  1  1  1  0             ldr_str_imm(simd&fp)                                           */
  /*        0  1  1  0  0  0          ldr_str_literal                                                */
  /*  1  0  0  1  1  0  1  1     0  1 mad                                                            */
  /*     0  0  1  1  0  1  1  0  0  0 mad                                                            */
  /*     0  0  1  1  1  1  0        1 fmov            0  0  0  0  0  0                               */
d476 44
@


1.49
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.48 2015/09/03 23:55:02 nakashim Exp nakashim $";
d67 30
d431 1
a431 1
  else if (i.add_sub_shifted.op28_24 == 0x0b) { /* C6.6.5 ADD(shifted register), C6.6.8 ADDS(shifted register), C6.6.43 CMN(shifted register), C6.6.46 CMP(shifted register), C6.6.135 NEG(shifted register), C6.6.136 NEGS(shifted register), C6.6.196 SUB(shifted register), C6.6.199 SUBS(shifted register) */
d436 1
a436 1
    rob->iinv  = i.add_sub_shifted.N; /* invert */
@


1.48
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.47 2015/09/03 14:01:21 nakashim Exp nakashim $";
d32 1
d72 1
d100 1
d137 1
d184 1
d231 1
d288 1
d337 1
d371 1
d405 1
d449 1
d493 1
d556 1
a556 1
  else if (i.sft_imm.op28_23 == 0x26) { /* C6.6.16 ASR(immediate), C6.6.21 BFI, C6.6.22 BFM, C6.6.23 BFXIL, C6.6.114 LSL(immediate), C6.6.117 LSR(immediate), C6.6.157 SBFIZ, C6.6.158 SBFM, C6.6.159 SBFX, C6.6.201 SXTB, C6.6.202 SXTH, C6.6.203 SXTW, C6.6.211 UBFIZ, C6.6.212 UBFM, C6.6.213 UBFX,  C6.6.220 UXTB, C6.6.221 UXTH */
d560 1
d651 1
d692 1
d736 1
d757 1
d781 1
d805 1
d829 1
d858 1
d881 1
d909 1
d952 1
d999 1
d1027 1
d1068 1
d1183 1
d1288 1
d1328 1
d1355 1
d1393 1
a1393 1
  else if (i.mad.op30_24 == 0x1b && i.mad.U == 0 && i.mad.op22_21 == 0) { /* C6.6.119 MADD, C6.6.133 MUL, C6.6.120 MNEG, C6.6.132 MSUB,  */
d1397 1
d1435 86
@


1.47
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.46 2015/09/01 06:36:18 nakashim Exp nakashim $";
d21 1
a21 1
  Uint s1, s2, s3, d0, d1;
d965 111
d1266 1
d1275 4
a1278 4
      rob->sr[3].t = !t[tid].map[i.ldr_str_imm.rt].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ldr_str_imm.rt].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[3].x = t[tid].map[i.ldr_str_imm.rt].x; /* reg */
      rob->sr[3].n = !t[tid].map[i.ldr_str_imm.rt].x ? (VECREGTOP+i.ldr_str_imm.rt) : t[tid].map[i.ldr_str_imm.rt].rob;
d1283 3
a1285 3
      rob->dr[1].n = VECREGTOP+i.ldr_str_imm.rt;
      t[tid].map[i.ldr_str_imm.rt].x = 1;
      t[tid].map[i.ldr_str_imm.rt].rob = robid;
@


1.46
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.45 2015/09/01 06:13:33 nakashim Exp nakashim $";
d979 1
a979 1
    rob->type  = i.ldr_str_imm.opc!=0?3:4; /* LD/ST */
a1022 1
      case 3:
d1026 3
d1032 11
a1042 3
      rob->opcd = 3; /* LDR(64)/STR(64) */
      rob->dbl  = 1; /* ldst64 */
      break;
d1068 1
a1068 1
    if (i.ldr_str_imm.opc!=0 && i.ldr_str_imm.rt!=31) { /* LD */
d1082 101
@


1.45
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.44 2015/09/01 06:05:16 nakashim Exp nakashim $";
d47 4
a50 2
  rob->dr[1].mask = 0x00000000;
  rob->dr[1].val  = 0x00000000;
d53 4
a56 2
  rob->dr[2].mask = 0x00000000;
  rob->dr[2].val  = 0x00000000;
d59 4
a62 2
  rob->dr[3].mask = 0x00000000;
  rob->dr[3].val  = 0x00000000;
@


1.44
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.43 2015/09/01 05:35:03 nakashim Exp nakashim $";
d48 1
a48 1
  rob->dr[1].d    = 0x00000000;
d52 1
a52 1
  rob->dr[2].d    = 0x00000000;
d56 1
a56 1
  rob->dr[3].d    = 0x00000000;
@


1.43
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.42 2015/09/01 01:49:37 nakashim Exp nakashim $";
d48 1
a48 1
  rob->dr[1].v    = 0x00000000;
d52 1
a52 1
  rob->dr[2].v    = 0x00000000;
d56 1
a56 1
  rob->dr[3].v    = 0x00000000;
@


1.42
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.41 2015/08/31 13:41:16 nakashim Exp nakashim $";
d40 5
a44 8
  rob->sr[1].t  = 0;
  rob->sr[2].t  = 0; /* src2 */
  rob->sr[3].t  = 0;
  rob->sr[4].t  = 0; /* src3 */
  rob->sr[5].t  = 0;
  rob->sr[6].t  = 0; /* pass in-dst for conditional exec */
  rob->sr[7].t  = 0;
  rob->sr[8].t  = 0; /* pass in-cc for conditional exec */
d75 3
d80 1
a80 4
    rob->sr[2].n = offset;
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = 0; /* LSL 0 */
d103 3
d108 1
a108 4
    rob->sr[2].n = i.add_sub_imm.shift==0?(Ull)i.add_sub_imm.imm12:(Ull)(i.add_sub_imm.imm12<<12);
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = 0; /* LSL 0 */
d142 1
a142 1
    rob->sr[2].t = i.adc_sbc.rm==31 ? 1 : /* ZERO */
d145 1
a145 1
    rob->sr[2].x = i.adc_sbc.rm==31 ? 0 : /* ZERO */
d147 1
a147 1
    rob->sr[2].n = i.adc_sbc.rm==31 ? 0 : /* ZERO */
d149 6
a154 6
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = 0; /* LSL 0 */
    rob->sr[8].t = !t[tid].map[CPSREGTOP].x ? 2 : (c[cid].rob[t[tid].map[CPSREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* cpsr */
    rob->sr[8].x =  t[tid].map[CPSREGTOP].x; /* cpsr */
    rob->sr[8].n = !t[tid].map[CPSREGTOP].x ? CPSREGTOP : t[tid].map[CPSREGTOP].rob;
d188 1
a188 1
    rob->sr[2].t = i.csel.rm==31 ? 1 : /* ZERO */
d191 1
a191 1
    rob->sr[2].x = i.csel.rm==31 ? 0 : /* ZERO */
d193 1
a193 1
    rob->sr[2].n = i.csel.rm==31 ? 0 : /* ZERO */
d195 6
d203 4
a206 10
    rob->sr[4].n = 0; /* LSL 0 */
    rob->sr[6].t = 1; /* immediate */
    rob->sr[6].x = 0; /* renamig N.A. */
    rob->sr[6].n = i.csel.cond;
    rob->sr[7].t = 1; /* immediate */
    rob->sr[7].x = 0; /* renamig N.A. */
    rob->sr[7].n = i.csel.o2; /* o2(inc=1) */
    rob->sr[8].t = !t[tid].map[CPSREGTOP].x ? 2 : (c[cid].rob[t[tid].map[CPSREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* cpsr */
    rob->sr[8].x =  t[tid].map[CPSREGTOP].x; /* cpsr */
    rob->sr[8].n = !t[tid].map[CPSREGTOP].x ? CPSREGTOP : t[tid].map[CPSREGTOP].rob;
d236 1
a236 1
      rob->sr[2].t = i.ccm.rm_imm5==31 ? 1 : /* ZERO */
d239 1
a239 1
      rob->sr[2].x = i.ccm.rm_imm5==31 ? 0 : /* ZERO */
d241 1
a241 1
      rob->sr[2].n = i.ccm.rm_imm5==31 ? 0 : /* ZERO */
d245 3
a247 3
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = i.ccm.rm_imm5;
d253 6
d261 4
a264 10
    rob->sr[4].n = 0; /* LSL 0 */
    rob->sr[6].t = 1; /* immediate */
    rob->sr[6].x = 0; /* renamig N.A. */
    rob->sr[6].n = i.ccm.cond;
    rob->sr[7].t = 1; /* immediate */
    rob->sr[7].x = 0; /* renamig N.A. */
    rob->sr[7].n = i.ccm.nzcv;
    rob->sr[8].t = !t[tid].map[CPSREGTOP].x ? 2 : (c[cid].rob[t[tid].map[CPSREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* cpsr */
    rob->sr[8].x =  t[tid].map[CPSREGTOP].x; /* cpsr */
    rob->sr[8].n = !t[tid].map[CPSREGTOP].x ? CPSREGTOP : t[tid].map[CPSREGTOP].rob;
d301 3
d306 4
a309 7
      rob->sr[2].n = (Ull)i.mov.imm16<<pos; /* POS 0,16,32,48 -> wmask in alu.c */
      rob->sr[4].t = 1; /* immediate */
      rob->sr[4].x = 0; /* renamig N.A. */
      rob->sr[4].n = 0; /* LSL 0 */
      rob->sr[6].t = 1; /* immediate */
      rob->sr[6].x = 0; /* renamig N.A. */
      rob->sr[6].n = 0x000000000000FFFFLL<<pos; /* POS 0,16,32,48 -> wmask in alu.c */
d338 3
d343 1
a343 4
    rob->sr[2].n = i.rev.opc; /* 0:REV, 1:REV16, 2:REV32, 3:REV64 */
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = 0; /* LSL 0 */
d371 3
d376 1
a376 4
    rob->sr[2].n = i.cls.op; /* 0:CLZ, 1:CLS */
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = 0; /* LSL 0 */
d404 1
a404 1
    rob->sr[2].t = i.add_sub_shifted.rm==31 ? 1 : /* ZERO */
d407 1
a407 1
    rob->sr[2].x = i.add_sub_shifted.rm==31 ? 0 : /* ZERO */
d409 1
a409 1
    rob->sr[2].n = i.add_sub_shifted.rm==31 ? 0 : /* ZERO */
d411 3
a413 3
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = i.add_sub_shifted.imm6; /* LSL/LSR/ASR/ROR */
d447 1
a447 1
    rob->sr[2].t = i.and_shifted.rm==31 ? 1 : /* ZERO */
d450 1
a450 1
    rob->sr[2].x = i.and_shifted.rm==31 ? 0 : /* ZERO */
d452 1
a452 1
    rob->sr[2].n = i.and_shifted.rm==31 ? 0 : /* ZERO */
d454 3
a456 3
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = i.and_shifted.imm6; /* LSL/LSR/ASR/ROR */
d516 3
a518 3
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = wmask;
d520 3
a522 3
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = 0; /* LSL 0 */
d602 1
a602 1
      rob->sr[2].t = i.sft_imm.rn==31 ? 1 : /* ZERO */
d605 1
a605 1
      rob->sr[2].x = i.sft_imm.rn==31 ? 0 : /* ZERO */
d607 1
a607 1
      rob->sr[2].n = i.sft_imm.rn==31 ? 0 : /* ZERO */
d609 6
d617 1
a617 7
      rob->sr[4].n = R; /* ROR */
      rob->sr[6].t = 1; /* immediate */
      rob->sr[6].x = 0; /* renamig N.A. */
      rob->sr[6].n = wmask;
      rob->sr[7].t = 1; /* immediate */
      rob->sr[7].x = 0; /* renamig N.A. */
      rob->sr[7].n = tmask;
d646 1
a646 1
    rob->sr[2].t = i.ror_imm.rm==31 ? 1 : /* ZERO */
d649 1
a649 1
    rob->sr[2].x = i.ror_imm.rm==31 ? 0 : /* ZERO */
d651 1
a651 1
    rob->sr[2].n = i.ror_imm.rm==31 ? 0 : /* ZERO */
d653 6
a658 6
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = 0; /* LSL 0 */
    rob->sr[6].t = 1; /* immediate */
    rob->sr[6].x = 0; /* renamig N.A. */
    rob->sr[6].n = i.ror_imm.imms; /* ROR */
d682 1
a682 1
    rob->sr[2].t = i.sft_reg.rn==31 ? 1 : /* ZERO */
d685 1
a685 1
    rob->sr[2].x = i.sft_reg.rn==31 ? 0 : /* ZERO */
d687 1
a687 1
    rob->sr[2].n = i.sft_reg.rn==31 ? 0 : /* ZERO */
d689 1
a689 1
    rob->sr[4].t = i.sft_reg.rm==31 ? 1 : /* ZERO */
d692 1
a692 1
    rob->sr[4].x = i.sft_reg.rm==31 ? 0 : /* ZERO */
d694 1
a694 1
    rob->sr[4].n = i.sft_reg.rm==31 ? 0 : /* ZERO */
d723 3
a725 3
      rob->sr[8].t = !t[tid].map[CPSREGTOP].x ? 2 : (c[cid].rob[t[tid].map[CPSREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* cpsr */
      rob->sr[8].x =  t[tid].map[CPSREGTOP].x; /* cpsr */
      rob->sr[8].n = !t[tid].map[CPSREGTOP].x ? CPSREGTOP : t[tid].map[CPSREGTOP].rob;
d795 3
a797 3
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = (i.tbz.b5<<5)|i.tbz.b40;
d839 3
a841 3
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = i.svc.imm16;
d865 3
d870 1
a870 4
      rob->sr[2].n = i.ldp_stp.opc==2?8:4; /* 0:ldst32, 2:ldst64 */
      rob->sr[4].t = 1; /* immediate */
      rob->sr[4].x = 0; /* renamig N.A. */
      rob->sr[4].n = 0; /* LSL 0 */
d892 3
a894 3
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = offset;
d896 1
a896 1
	rob->sr[6].t = i.ldp_stp.rt==31 ? 1 : /* ZERO */
d899 1
a899 1
	rob->sr[6].x = i.ldp_stp.rt==31 ? 0 : /* ZERO */
d901 1
a901 1
	rob->sr[6].n = i.ldp_stp.rt==31 ? 0 : /* ZERO */
d934 3
a936 3
      rob->sr[2].t = 1; /* immediate */
      rob->sr[2].x = 0; /* renamig N.A. */
      rob->sr[2].n = offset;
d938 1
a938 1
	rob->sr[6].t = i.ldp_stp.rt2==31 ? 1 : /* ZERO */
d941 1
a941 1
	rob->sr[6].x = i.ldp_stp.rt2==31 ? 0 : /* ZERO */
d943 1
a943 1
	rob->sr[6].n = i.ldp_stp.rt2==31 ? 0 : /* ZERO */
d1039 3
a1041 3
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = offset;
d1043 1
a1043 1
      rob->sr[6].t = i.ldr_str_imm.rt==31 ? 1 : /* ZERO */
d1046 1
a1046 1
      rob->sr[6].x = i.ldr_str_imm.rt==31 ? 0 : /* ZERO */
d1048 1
a1048 1
      rob->sr[6].n = i.ldr_str_imm.rt==31 ? 0 : /* ZERO */
d1080 3
a1082 3
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = (Sll)((Ull)i.ldr_str_literal.imm19<<45)>>43;
d1110 1
a1110 1
    rob->sr[2].t = i.mad.rm==31 ? 1 : /* ZERO */
d1113 1
a1113 1
    rob->sr[2].x = i.mad.rm==31 ? 0 : /* ZERO */
d1115 1
a1115 1
    rob->sr[2].n = i.mad.rm==31 ? 0 : /* ZERO */
d1117 1
a1117 1
    rob->sr[4].t = i.mad.ra==31 ? 1 : /* ZERO */
d1120 1
a1120 1
    rob->sr[4].x = i.mad.ra==31 ? 0 : /* ZERO */
d1122 1
a1122 1
    rob->sr[4].n = i.mad.ra==31 ? 0 : /* ZERO */
d1151 1
a1151 1
    rob->sr[2].t = i.mad.rm==31 ? 1 : /* ZERO */
d1154 1
a1154 1
    rob->sr[2].x = i.mad.rm==31 ? 0 : /* ZERO */
d1156 1
a1156 1
    rob->sr[2].n = i.mad.rm==31 ? 0 : /* ZERO */
d1158 1
a1158 1
    rob->sr[4].t = i.mad.ra==31 ? 1 : /* ZERO */
d1161 1
a1161 1
    rob->sr[4].x = i.mad.ra==31 ? 0 : /* ZERO */
d1163 1
a1163 1
    rob->sr[4].n = i.mad.ra==31 ? 0 : /* ZERO */
@


1.41
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.40 2015/08/31 05:00:07 nakashim Exp nakashim $";
d59 1
a59 1
  rob->dr[2].v    = 0x00000000;
@


1.40
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.39 2015/08/31 04:16:21 nakashim Exp nakashim $";
d1095 82
@


1.39
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.38 2015/08/31 03:30:20 nakashim Exp nakashim $";
d886 1
a886 1
      rob->dbl   = i.ldp_stp.opc==2; /* 0:ldst32, 1:ldst64 */
d928 1
a928 1
      rob->dbl   = i.ldp_stp.opc==2; /* 0:ldst32, 1:ldst64 */
d1069 1
a1069 1
  else if (i.ldr_str_literal.op29_24 == 0x18) { /* C6.6.84 LDR(literal) */
d1071 1
a1071 1
    rob->opcd  = 3; /* LDR */
d1075 1
a1075 1
    rob->dbl   = i.ldr_str_literal.opc&1; /* 0:ld32, 1:ld64 */
@


1.38
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.37 2015/08/30 23:57:26 nakashim Exp nakashim $";
d847 1
a847 1
  else if (i.ldp_stp.op29_25 == 0x14) { /* C6.6.81 LDP, C6.6.177 STP */
d851 1
a851 1
    Ull offset     = (Sll)((Ull)i.ldp_stp.imm7<<57)>>(i.ldp_stp.opc==0?55:54);
d870 1
a870 1
      rob->sr[2].n = i.ldp_stp.opc==0?4:8; /* 0:ldst32, 2:ldst64 */
d882 1
a882 1
      rob->opcd  = 3; /* LDR/STR */
d924 1
a924 1
      rob->opcd  = 3; /* LDR/STR */
@


1.37
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.36 2015/08/30 13:24:30 nakashim Exp nakashim $";
a388 37
  else if (i.lsl.op30_21 == 0x0d6 && i.lsl.op15_12 == 2) { /* C6.6.15 ASR, C6.6.17 ASRV, C6.6.113 LSL(register), C6.6.115 LSLV, C6.6.116 LSR(register), C6.6.118 LSRV */
    rob->type  = 0; /* ALU */
    rob->opcd  = 3; /* ORR */
    rob->sop   = i.lsl.op2; /* LSL/LSR/ASR/ROR */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.lsl.sf; /* 0:lsl32, 1:lsl64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = 1; /* immediate */
    rob->sr[0].x = 0; /* renamig N.A. */
    rob->sr[0].n = 0; /* ORR 0 */
    rob->sr[2].t = i.lsl.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.lsl.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.lsl.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = i.lsl.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.lsl.rn].x; /* reg */
    rob->sr[2].n = i.lsl.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.lsl.rn].x ? i.lsl.rn : t[tid].map[i.lsl.rn].rob;
    rob->sr[4].t = i.lsl.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.lsl.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.lsl.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[4].x = i.lsl.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.lsl.rm].x; /* reg */
    rob->sr[4].n = i.lsl.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.lsl.rm].x ? i.lsl.rm : t[tid].map[i.lsl.rm].rob;
    /* dest */
    if (i.lsl.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.lsl.rd;
      t[tid].map[i.lsl.rd].x = 1;
      t[tid].map[i.lsl.rd].rob = robid;
    }
    return (0);
  }
d541 1
a541 1
  else if (i.ubfm_imm.op28_23 == 0x26) { /* C6.6.16 ASR(immediate), C6.6.21 BFI, C6.6.22 BFM, C6.6.23 BFXIL, C6.6.114 LSL(immediate), C6.6.117 LSR(immediate), C6.6.157 SBFIZ, C6.6.158 SBFM, C6.6.159 SBFX, C6.6.201 SXTB, C6.6.202 SXTH, C6.6.203 SXTW, C6.6.211 UBFIZ, C6.6.212 UBFM, C6.6.213 UBFX,  C6.6.220 UXTB, C6.6.221 UXTH */
d543 1
a543 1
    rob->opcd  = i.ubfm_imm.opc==0?8:9; /* 8:SBFM/9:BFM/UBFM */
d547 1
a547 1
    rob->dbl   = i.ubfm_imm.sf; /* 0:and32, 1:and64 */
d556 1
a556 1
      imm = (i.ubfm_imm.N<<6)|((~i.ubfm_imm.imms)&0x3f);
d567 2
a568 2
      S = (Uint)(i.ubfm_imm.imms & levels);
      R = (Uint)(i.ubfm_imm.immr & levels);
d577 1
a577 1
      if (!i.ubfm_imm.sf)
d587 1
a587 1
      if (!i.ubfm_imm.sf)
d590 1
a590 1
      switch (i.ubfm_imm.opc) {
d599 2
a600 2
                     !t[tid].map[i.ubfm_imm.rd].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ubfm_imm.rd].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
d602 1
a602 1
                     t[tid].map[i.ubfm_imm.rd].x; /* reg */
d604 8
a611 8
                     !t[tid].map[i.ubfm_imm.rd].x ? i.ubfm_imm.rd : t[tid].map[i.ubfm_imm.rd].rob;
      rob->sr[2].t = i.ubfm_imm.rn==31 ? 1 : /* ZERO */
                     !t[tid].map[i.ubfm_imm.rn].x ? 2 :
                     (c[cid].rob[t[tid].map[i.ubfm_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
      rob->sr[2].x = i.ubfm_imm.rn==31 ? 0 : /* ZERO */
                     t[tid].map[i.ubfm_imm.rn].x; /* reg */
      rob->sr[2].n = i.ubfm_imm.rn==31 ? 0 : /* ZERO */
                     !t[tid].map[i.ubfm_imm.rn].x ? i.ubfm_imm.rn : t[tid].map[i.ubfm_imm.rn].rob;
d623 78
a700 1
    if (i.ubfm_imm.rd!=31) {
d702 3
a704 3
      rob->dr[1].n = i.ubfm_imm.rd;
      t[tid].map[i.ubfm_imm.rd].x = 1;
      t[tid].map[i.ubfm_imm.rd].rob = robid;
d708 1
a708 1
  else if (i.b_cond.op31_24==0x54 && i.b_cond.op4==0) { /* C6.6.19 B.cond */
d754 1
a754 1
  else if (i.cbz.op30_25==0x1a) { /* C6.6.30 CBNZ, C6.6.31 CBZ */
d777 1
a777 1
  else if (i.tbz.op30_25==0x1b) { /* C6.6.206 TBNZ, C6.6.207 TBZ */
d803 1
a803 1
  else if (i.blr.op31_23==0x1ac && i.blr.op20_10==0x7c0 && i.blr.op4_0==0) { /* C6.6.27 BLR, C6.6.28 BR, C6.6.148 RET */
d829 1
a829 1
  else if (i.svc.op31_21==0x6a0 && i.svc.op4_0==0x01) { /* C6.6.200 SVC */
@


1.36
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.35 2015/08/30 13:15:31 nakashim Exp nakashim $";
d219 1
a219 1
  else if (i.ccm_imm.op29_21 == 0x1d2 && i.ccm_imm.op11_10 == 2 && i.ccm_imm.op4 == 0) { /* C6.6.32 CCMN(immediate), C6.6.34 CCMP(immediate) */
d223 1
a223 1
    rob->iinv  = i.ccm_imm.op==13; /* CCMP */
d225 1
a225 1
    rob->dbl   = i.ccm_imm.sf; /* 0:ccmp32, 1:ccmp64 */
d230 26
a255 10
    rob->sr[0].t = i.ccm_imm.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.ccm_imm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ccm_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.ccm_imm.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.ccm_imm.rn].x; /* reg */
    rob->sr[0].n = i.ccm_imm.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.ccm_imm.rn].x ? i.ccm_imm.rn : t[tid].map[i.ccm_imm.rn].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = i.ccm_imm.imm5;
d261 1
a261 1
    rob->sr[6].n = i.ccm_imm.cond;
d264 1
a264 1
    rob->sr[7].n = i.ccm_imm.nzcv;
@


1.35
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.34 2015/08/30 11:00:22 nakashim Exp nakashim $";
d173 1
a173 1
  else if (i.csinv.op29_21 == 0x0d4 && i.csinv.op11 == 0) { /* C6.6.36 CINC, C6.6.37 CINV, C6.6.47 CNEG, C6.6.51 CSET, C6.6.52 CSETM, C6.6.53 CSINC, C6.6.54 CSINV, C6.6.55 CSNEG */
d175 1
a175 1
    rob->opcd  =10; /* CSINV */
d178 2
a179 2
    rob->oinv  = i.csinv.op; /* 0:result, 1:~result */
    rob->dbl   = i.csinv.sf; /* 0:csinv32, 1:csinv64 */
d184 14
a197 14
    rob->sr[0].t = i.csinv.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.csinv.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.csinv.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.csinv.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.csinv.rn].x; /* reg */
    rob->sr[0].n = i.csinv.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.csinv.rn].x ? i.csinv.rn : t[tid].map[i.csinv.rn].rob;
    rob->sr[2].t = i.csinv.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.csinv.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.csinv.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = i.csinv.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.csinv.rm].x; /* reg */
    rob->sr[2].n = i.csinv.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.csinv.rm].x ? i.csinv.rm : t[tid].map[i.csinv.rm].rob;
d203 1
a203 1
    rob->sr[6].n = i.csinv.cond;
d206 1
a206 1
    rob->sr[7].n = i.csinv.o2; /* o2(inc=1) */
d211 1
a211 1
    if (i.csinv.rd!=31) {
d213 3
a215 3
      rob->dr[1].n = i.csinv.rd;
      t[tid].map[i.csinv.rd].x = 1;
      t[tid].map[i.csinv.rd].rob = robid;
@


1.34
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.33 2015/08/29 15:52:28 nakashim Exp nakashim $";
d127 1
a127 1
  else if (i.adc_sbc.op28_21 == 0xd0 && i.adc_sbc.imm6 == 0) { /* C6.6.1 ADC, C6.6.2 ADCS, C6.6.137 NGC, C6.6.138 NGCS, C6.6.155 SBC, C6.6.156 SBCS */
d173 1
a173 1
  else if (i.csinv.op29_21 == 0x0d4 && i.csinv.op11 == 0) { /* C6.6.37 CINV, C6.6.52 CSETM, C6.6.54 CSINV */
@


1.33
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.32 2015/08/29 14:21:22 nakashim Exp nakashim $";
d919 1
a919 1
    Ull offset     = (post_index || pre_index)?(Sll)((Ull)i.ldr_str_imm.imm12<<52)>>55:(Ull)i.ldr_str_imm.imm12<<i.ldr_str_imm.size;
@


1.32
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.31 2015/08/28 00:26:45 nakashim Exp nakashim $";
d843 2
a844 1
	rob->sr[6].t = !t[tid].map[i.ldp_stp.rt].x ? 2 :
d846 4
a849 2
	rob->sr[6].x =  t[tid].map[i.ldp_stp.rt].x; /* reg */
	rob->sr[6].n = !t[tid].map[i.ldp_stp.rt].x ? i.ldp_stp.rt : t[tid].map[i.ldp_stp.rt].rob;
d852 1
a852 1
      if (i.ldp_stp.L) { /* LD */
d885 2
a886 1
	rob->sr[6].t = !t[tid].map[i.ldp_stp.rt2].x ? 2 :
d888 4
a891 2
	rob->sr[6].x =  t[tid].map[i.ldp_stp.rt2].x; /* reg */
	rob->sr[6].n = !t[tid].map[i.ldp_stp.rt2].x ? i.ldp_stp.rt2 : t[tid].map[i.ldp_stp.rt2].rob;
d894 1
a894 1
      if (i.ldp_stp.L) { /* LD */
d990 2
a991 1
      rob->sr[6].t = !t[tid].map[i.ldr_str_imm.rt].x ? 2 :
d993 4
a996 2
      rob->sr[6].x =  t[tid].map[i.ldr_str_imm.rt].x; /* reg */
      rob->sr[6].n = !t[tid].map[i.ldr_str_imm.rt].x ? i.ldr_str_imm.rt : t[tid].map[i.ldr_str_imm.rt].rob;
d999 1
a999 1
    if (i.ldr_str_imm.opc!=0) { /* LD */
d1031 6
a1036 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.ldr_str_literal.rt;
    t[tid].map[i.ldr_str_literal.rt].x = 1;
    t[tid].map[i.ldr_str_literal.rt].rob = robid;
@


1.31
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.30 2015/08/28 00:03:46 nakashim Exp nakashim $";
d264 1
a264 1
    rob->oinv  = i.mov.opc==3; /* MOVK */
@


1.30
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.29 2015/08/27 06:47:08 nakashim Exp nakashim $";
d537 3
d598 2
d608 2
@


1.29
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.28 2015/08/26 08:33:20 nakashim Exp nakashim $";
d518 1
a518 1
      imm = (i.and_imm.N<<6)|(~i.and_imm.imms&0x3f);
d520 1
a520 1
	if (imm>>len&1)
d533 1
a533 1
      if (R>0) welem = (welem<<(64-R))|(s2>>R);
d535 1
a535 1
      for (len=1; len<64/esize; len++)
d574 1
a574 1
      imm = (i.ubfm_imm.N<<6)|(~i.ubfm_imm.imms&0x3f);
d576 1
a576 1
	if (imm>>len&1)
d591 1
a591 1
      if (R>0) welem = (welem<<(64-R))|(s2>>R);
d593 1
a593 1
      for (len=1; len<64/esize; len++)
d601 1
a601 1
      for (len=1; len<64/esize; len++)
@


1.28
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.27 2015/08/26 00:19:51 nakashim Exp nakashim $";
d714 26
d742 1
a742 1
    rob->opcd  = i.blr.op==1?4:5; /* CALL/JMP/RET */
d766 18
@


1.27
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.26 2015/08/25 13:36:46 nakashim Exp nakashim $";
d775 1
a775 1
      rob->opcd  = 4; /* LDR/STR */
d779 1
a779 1
      rob->dbl   = i.ldp_stp.opc==2; /* 0:ldst32, 2:ldst64 */
d814 1
a814 1
      rob->opcd  = 4; /* LDR/STR */
d818 1
a818 1
      rob->dbl   = i.ldp_stp.opc==2; /* 0:ldst32, 2:ldst64 */
d850 2
a853 3
    /* C6.6.86 ldrb(32):  size=00, opc=01 | C6.6.181 strb(32): size=00, opc=00 */
    /* C6.6.88 ldrh(32):  size=01, opc=01 | C6.6.182 strh(32): size=01, opc=00 */
    /* C6.6.90 ldrsb(32): size=00, opc=11 */
a854 1
    /* C6.6.92 ldrsh(32): size=01, opc=11 */
d857 2
d863 55
a917 2
    rob->type  = i.ldr_str_imm.opc==1?3:4; /* LD/ST */
    rob->opcd  = 4; /* LDR/STR */
a920 1
    rob->dbl   = i.ldr_str_imm.size&1; /* 2:ldst32, 3:ldst64 */
d939 1
a939 1
    if (i.ldr_str_imm.opc==1) { /* LD */
d955 1
a955 1
    rob->opcd  = 4; /* LDR */
@


1.26
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.25 2015/08/25 11:04:16 nakashim Exp nakashim $";
d17 1
a17 1
  /* return 0:normal end, 1:continue (ex. LDM/STM), 2:error */
d775 1
a775 1
      rob->opcd  = 1; /* LDP/STP */
d804 1
a804 1
      if (rob->wb) {
d814 1
a814 1
      rob->opcd  = 1; /* LDP/STP */
d849 16
a864 7
  else if (i.ldr_imm.op29_25 == 0x1c && i.ldr_imm.opc == 1) { /* C6.6.83 LDR(immediate) */
    int post_index = i.ldr_imm.op24==0 && (i.ldr_imm.imm12&3)==1;
    int pre_index  = i.ldr_imm.op24==0 && (i.ldr_imm.imm12&3)==3;
    int uns_offset = i.ldr_imm.op24==1;
    Ull offset     = (post_index || pre_index)?(Sll)((Ull)i.ldr_imm.imm12<<52)>>55:(Ull)i.ldr_imm.imm12<<i.ldr_imm.size;
    rob->type  = 3; /* LD */
    rob->opcd  = 0; /* LDR */
d868 1
a868 1
    rob->dbl   = i.ldr_imm.size&1; /* 2:ld32, 3:ld64 */
d873 4
a876 4
    rob->sr[0].t = !t[tid].map[i.ldr_imm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ldr_imm.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ldr_imm.rn].x ? i.ldr_imm.rn : t[tid].map[i.ldr_imm.rn].rob;
d880 6
d887 7
a893 5
    rob->dr[1].t = 1;
    rob->dr[1].n = i.ldr_imm.rt;
    t[tid].map[i.ldr_imm.rt].x = 1;
    t[tid].map[i.ldr_imm.rt].rob = robid;
    if (rob->wb) {
d895 3
a897 3
      rob->dr[2].n = i.ldr_imm.rn;
      t[tid].map[i.ldr_imm.rn].x = 2;
      t[tid].map[i.ldr_imm.rn].rob = robid;
d901 1
a901 1
  else if (i.ldr_literal.op29_24 == 0x18) { /* C6.6.84 LDR(literal) */
d903 1
a903 1
    rob->opcd  = 0; /* LDR */
d907 1
a907 1
    rob->dbl   = i.ldr_literal.opc&1; /* 0:ld32, 1:ld64 */
d917 1
a917 1
    rob->sr[2].n = (Sll)((Ull)i.ldr_literal.imm19<<45)>>43;
d920 3
a922 3
    rob->dr[1].n = i.ldr_literal.rt;
    t[tid].map[i.ldr_literal.rt].x = 1;
    t[tid].map[i.ldr_literal.rt].rob = robid;
@


1.25
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.24 2015/08/25 10:42:04 nakashim Exp nakashim $";
d714 26
@


1.24
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.23 2015/08/25 09:58:40 nakashim Exp nakashim $";
a694 1
    rob->cond  = i.cbz.op; /* 0:iszero, 1:isnotzero */
@


1.23
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.22 2015/08/25 08:06:35 nakashim Exp nakashim $";
d91 1
a91 1
  else if (i.add_sub_imm.op28_24 == 0x11) { /* C6.6.4 ADD(immediate), C6.6.7 ADDS(immediate), C6.6.121 MOV(to/from SP), C6.6.195 SUB(immediate), C6.6.198 SUBS(immediate) */
d496 1
a496 1
  else if (i.and_imm.op28_23 == 0x24) { /* C6.6.11 AND(immediate), C6.6.13 ANDS(immediate), C6.6.64 EOR(immediate), C6.6.124 MOV(bitmask immediate), C6.6.141 ORR(immediate) */
@


1.22
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.21 2015/08/25 07:13:32 nakashim Exp nakashim $";
d779 6
d796 1
a796 1
      rob->wb    = post_index || pre_index;
d851 6
@


1.21
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.20 2015/08/25 06:50:05 nakashim Exp nakashim $";
d113 6
a118 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.add_sub_imm.rd;
    t[tid].map[i.add_sub_imm.rd].x = 1;
    t[tid].map[i.add_sub_imm.rd].rob = robid;
d159 6
a164 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.adc_sbc.rd;
    t[tid].map[i.adc_sbc.rd].x = 1;
    t[tid].map[i.adc_sbc.rd].rob = robid;
d211 6
a216 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.csinv.rd;
    t[tid].map[i.csinv.rd].x = 1;
    t[tid].map[i.csinv.rd].rob = robid;
d299 6
a304 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.mov.rd;
    t[tid].map[i.mov.rd].x = 1;
    t[tid].map[i.mov.rd].rob = robid;
d332 6
a337 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.rev.rd;
    t[tid].map[i.rev.rd].x = 1;
    t[tid].map[i.rev.rd].rob = robid;
d365 6
a370 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.cls.rd;
    t[tid].map[i.cls.rd].x = 1;
    t[tid].map[i.cls.rd].rob = robid;
d402 6
a407 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.lsl.rd;
    t[tid].map[i.lsl.rd].x = 1;
    t[tid].map[i.lsl.rd].rob = robid;
d545 6
a550 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.and_imm.rd;
    t[tid].map[i.and_imm.rd].x = 1;
    t[tid].map[i.and_imm.rd].rob = robid;
d637 6
a642 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.ubfm_imm.rd;
    t[tid].map[i.ubfm_imm.rd].x = 1;
    t[tid].map[i.ubfm_imm.rd].rob = robid;
@


1.20
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.19 2015/08/25 04:23:36 nakashim Exp nakashim $";
d299 1
a299 1
  else if (i.rev.op30_12 == 0x5ac00) { /* C6.6.149 REV, C6.6.150 REV16, C6.6.151 REV32 */
@


1.19
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.18 2015/08/24 23:41:06 nakashim Exp nakashim $";
d171 1
a171 1
    rob->opcd  = 7; /* CSINV */
d215 1
a215 1
    rob->opcd  = 12; /* CCMN/CCMP */
d255 1
a255 1
    rob->opcd  = 11; /* MOVN, MOVZ, MOVK */
d301 1
a301 1
    rob->opcd  = 10; /* REV */
d330 31
@


1.18
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.17 2015/08/24 13:19:00 nakashim Exp nakashim $";
d215 1
a215 1
    rob->opcd  = i.ccm_imm.op==0?12:13; /* CCMN/CCMP */
d299 31
d514 1
a514 1
    rob->opcd  = (8|i.ubfm_imm.opc); /* 8:SBFM/9:BFM/10:UBFM */
@


1.17
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.16 2015/08/24 06:02:10 nakashim Exp nakashim $";
d63 63
a125 1
  if (i.adc_sbc.op28_21 == 0xd0 && i.adc_sbc.imm6 == 0) { /* C6.6.1 ADC, C6.6.2 ADCS, C6.6.137 NGC, C6.6.138 NGCS, C6.6.155 SBC, C6.6.156 SBCS */
a168 35
  else if (i.lsl.op30_21 == 0x0d6 && i.lsl.op15_12 == 2) { /* C6.6.15 ASR, C6.6.17 ASRV, C6.6.113 LSL(register), C6.6.115 LSLV, C6.6.116 LSR(register), C6.6.118 LSRV */
    rob->type  = 0; /* ALU */
    rob->opcd  = 3; /* ORR */
    rob->sop   = i.lsl.op2; /* LSL/LSR/ASR/ROR */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.lsl.sf; /* 0:lsl32, 1:lsl64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = 0; /* not used */
    rob->sr[0].t = 1; /* immediate */
    rob->sr[0].x = 0; /* renamig N.A. */
    rob->sr[0].n = 0; /* ORR 0 */
    rob->sr[2].t = i.lsl.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.lsl.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.lsl.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = i.lsl.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.lsl.rn].x; /* reg */
    rob->sr[2].n = i.lsl.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.lsl.rn].x ? i.lsl.rn : t[tid].map[i.lsl.rn].rob;
    rob->sr[4].t = i.lsl.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.lsl.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.lsl.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[4].x = i.lsl.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.lsl.rm].x; /* reg */
    rob->sr[4].n = i.lsl.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.lsl.rm].x ? i.lsl.rm : t[tid].map[i.lsl.rm].rob;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = i.lsl.rd;
    t[tid].map[i.lsl.rd].x = 1;
    t[tid].map[i.lsl.rd].rob = robid;
    return (0);
  }
a252 34
  else if (i.add_sub_imm.op28_24 == 0x11) { /* C6.6.4 ADD(immediate), C6.6.7 ADDS(immediate), C6.6.121 MOV(to/from SP), C6.6.195 SUB(immediate), C6.6.198 SUBS(immediate) */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.add_sub_imm.op==0?4:2; /* ADD/SUB */
    rob->sop   = 0; /* LSL */
    rob->iinv  = 0; /* not used */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.add_sub_imm.sf; /* 0:add32, 1:add64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = i.add_sub_imm.S;
    rob->sr[0].t = !t[tid].map[i.add_sub_imm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.add_sub_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.add_sub_imm.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.add_sub_imm.rn].x ? i.add_sub_imm.rn : t[tid].map[i.add_sub_imm.rn].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = i.add_sub_imm.shift==0?(Ull)i.add_sub_imm.imm12:(Ull)(i.add_sub_imm.imm12<<12);
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = 0; /* LSL 0 */
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = i.add_sub_imm.rd;
    t[tid].map[i.add_sub_imm.rd].x = 1;
    t[tid].map[i.add_sub_imm.rd].rob = robid;
    if (i.add_sub_imm.S) {
      rob->dr[3].t = 1; /* nzcv */
      rob->dr[3].n = CPSREGTOP;
      t[tid].map[CPSREGTOP].x = 3;
      t[tid].map[CPSREGTOP].rob = robid;
    }
    return (0);
  }
d299 1
a299 2
  else if (i.adr.op28_24 == 0x10) { /* C6.6.9 ADR, C6.6.10 ADRP */
    Ull offset = i.adr.op ? (Sll)(((Ull)i.adr.immhi<<45)|((Ull)i.adr.immlo<<43))>>31 : (Sll)(((Ull)i.adr.immhi<<45)|((Ull)i.adr.immlo<<43))>>43;
d301 2
a302 2
    rob->opcd  = 4; /* ADD */
    rob->sop   = 0; /* LSL */
d305 1
a305 1
    rob->dbl   = 1; /* always 64bit */
d310 1
a310 1
    rob->sr[0].t = 1; /* PC */
d312 90
a401 4
    rob->sr[0].n = i.adr.op ? pc&0xfffff000 : pc; /* PC */
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = offset;
d404 1
a404 1
    rob->sr[4].n = 0; /* LSL 0 */
d406 12
a417 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.adr.rd;
    t[tid].map[i.adr.rd].x = 1;
    t[tid].map[i.adr.rd].rob = robid;
a564 86
  else if (i.add_sub_shifted.op28_24 == 0x0b) { /* C6.6.5 ADD(shifted register), C6.6.8 ADDS(shifted register), C6.6.43 CMN(shifted register), C6.6.46 CMP(shifted register), C6.6.135 NEG(shifted register), C6.6.136 NEGS(shifted register), C6.6.196 SUB(shifted register), C6.6.199 SUBS(shifted register) */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.add_sub_shifted.op==0?4:2; /* ADD/SUB */
    rob->sop   = i.add_sub_shifted.shift; /* LSL/LSR/ASR/ROR */
    rob->iinv  = i.add_sub_shifted.N; /* invert */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.add_sub_shifted.sf; /* 0:add32, 1:add64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = i.add_sub_shifted.S; /* updtCC */
    rob->sr[0].t = i.add_sub_shifted.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.add_sub_shifted.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.add_sub_shifted.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.add_sub_shifted.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.add_sub_shifted.rn].x; /* reg */
    rob->sr[0].n = i.add_sub_shifted.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.add_sub_shifted.rn].x ? i.add_sub_shifted.rn : t[tid].map[i.add_sub_shifted.rn].rob;
    rob->sr[2].t = i.add_sub_shifted.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.add_sub_shifted.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.add_sub_shifted.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = i.add_sub_shifted.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.add_sub_shifted.rm].x; /* reg */
    rob->sr[2].n = i.add_sub_shifted.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.add_sub_shifted.rm].x ? i.add_sub_shifted.rm : t[tid].map[i.add_sub_shifted.rm].rob;
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = i.add_sub_shifted.imm6; /* LSL/LSR/ASR/ROR */
    /* dest */
    if (i.add_sub_shifted.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.add_sub_shifted.rd;
      t[tid].map[i.add_sub_shifted.rd].x = 1;
      t[tid].map[i.add_sub_shifted.rd].rob = robid;
    }
    if (i.add_sub_shifted.S) { /* updtCC */
      rob->dr[3].t = 1; /* nzcv */
      rob->dr[3].n = CPSREGTOP;
      t[tid].map[CPSREGTOP].x = 3;
      t[tid].map[CPSREGTOP].rob = robid;
    }
    return (0);
  }
  else if (i.and_shifted.op28_24 == 0x0a) { /* C6.6.12 AND(shifted register), C6.6.14 ANDS(shifted register), C6.6.24 BIC(shifted register), C6.6.25 BICS(shifted register), C6.6.63 EON(shifted register), C6.6.65 EOR(shifted register), C6.6.125 MOV(register), C6.6.134 MVN(register), C6.6.140 ORN(shifted register), C6.6.142 ORR(shifted register), C6.6.210 TST(shifted register) */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.and_shifted.opc==0?0:i.and_shifted.opc==1?3:i.and_shifted.opc==2?1:0; /* AND/ORR/EOR/ANDS */
    rob->sop   = i.and_shifted.shift; /* LSL/LSR/ASR/ROR */
    rob->iinv  = i.and_shifted.N; /* invert */
    rob->oinv  = 0; /* not used */
    rob->dbl   = i.and_shifted.sf; /* 0:and32, 1:and64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->updt  = i.and_shifted.opc==3; /* ANDS */
    rob->sr[0].t = i.and_shifted.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.and_shifted.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.and_shifted.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.and_shifted.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.and_shifted.rn].x; /* reg */
    rob->sr[0].n = i.and_shifted.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.and_shifted.rn].x ? i.and_shifted.rn : t[tid].map[i.and_shifted.rn].rob;
    rob->sr[2].t = i.and_shifted.rm==31 ? 1 : /* ZERO */
                   !t[tid].map[i.and_shifted.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.and_shifted.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = i.and_shifted.rm==31 ? 0 : /* ZERO */
                   t[tid].map[i.and_shifted.rm].x; /* reg */
    rob->sr[2].n = i.and_shifted.rm==31 ? 0 : /* ZERO */
                   !t[tid].map[i.and_shifted.rm].x ? i.and_shifted.rm : t[tid].map[i.and_shifted.rm].rob;
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = i.and_shifted.imm6; /* LSL/LSR/ASR/ROR */
    /* dest */
    if (i.and_shifted.rd!=31) {
      rob->dr[1].t = 1;
      rob->dr[1].n = i.and_shifted.rd;
      t[tid].map[i.and_shifted.rd].x = 1;
      t[tid].map[i.and_shifted.rd].rob = robid;
    }
    if (i.and_shifted.opc==3) { /* ANDS */
      rob->dr[3].t = 1; /* nzcv */
      rob->dr[3].n = CPSREGTOP;
      t[tid].map[CPSREGTOP].x = 3;
      t[tid].map[CPSREGTOP].rob = robid;
    }
    return (0);
  }
@


1.16
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.15 2015/08/24 05:01:30 nakashim Exp nakashim $";
d63 1
a63 1
  if (i.adc_sbc.op28_21 == 0xd0 && i.adc_sbc.imm6 == 0) { /* C6.6.1 ADC, C6.6.2 ADCS, C6.6.155 SBC, C6.6.156 SBCS */
d260 1
a260 1
  else if (i.mov.op28_23 == 0x25) { /* C6.6.122 MOV(inverted wide immediate), C6.6.123 MOV(wide immediate), C6.6.126 MOVK, C6.6.127 MOVN */
d395 1
a395 1
  else if (i.ubfm_imm.op28_23 == 0x26) { /* C6.6.16 ASR(immediate), C6.6.21 BFI, C6.6.22 BFM, C6.6.23 BFXIL, C6.6.114 LSL(immediate), C6.6.117 LSR(immediate), C6.6.157 SBFIZ, C6.6.158 SBFM, C6.6.159 SBFX, C6.6.201 SXTB, C6.6.202 SXTH, C6.6.203 SXTW, C.6.6.211 UBFIZ, C6.6.212 UBFM, C.6.6.213 UBFX,  C6.6.220 UXTB, C6.6.221 UXTH */
d611 1
a611 1
  else if (i.cbz.op30_25==0x1a) { /* C6.6.31 CBZ */
@


1.15
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.14 2015/08/23 14:16:57 nakashim Exp nakashim $";
d611 24
@


1.14
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.13 2015/08/23 09:04:56 nakashim Exp nakashim $";
d32 2
a33 1
  rob->inv    = 0; /* invert operand2 */
d67 2
a68 1
    rob->inv   = 0; /* not used */
d100 1
a100 1
      rob->dr[3].t = 1; /* nzvc */
d111 2
a112 1
    rob->inv   = 0; /* not used */
d146 2
a147 1
    rob->inv   = 0; /* not used */
d175 1
a175 1
    rob->sr[7].n = i.csinv.op<<1|i.csinv.o2; /* op(inv=1) | o2(inc=1) */
d186 40
d230 2
a231 1
    rob->inv   = 0; /* not used */
d253 1
a253 1
      rob->dr[3].t = 1; /* nzvc */
d262 1
a262 1
    rob->opcd  = 12|i.mov.opc; /* 12:MOVN, 14:MOVZ, 15:MOVK */
d264 2
a265 1
    rob->inv   = 0; /* not used */
d311 2
a312 1
    rob->inv   = 0; /* not used */
d338 2
a339 1
    rob->inv   = 0;
d388 1
a388 1
      rob->dr[3].t = 1; /* nzvc */
d399 2
a400 1
    rob->inv   = 0;
d483 2
a484 1
    rob->inv   = i.add_sub_shifted.N; /* invert */
d515 1
a515 1
      rob->dr[3].t = 1; /* nzvc */
d526 2
a527 1
    rob->inv   = i.and_shifted.N; /* invert */
d558 1
a558 1
      rob->dr[3].t = 1; /* nzvc */
d575 2
a576 1
    rob->inv   = 0; /* not used */
d595 2
a596 1
    rob->inv   = 0; /* not used */
d621 2
a622 1
      rob->inv   = 0; /* not used */
d648 2
a649 1
      rob->inv   = 0; /* not used */
d681 2
a682 1
      rob->inv   = 0; /* not used */
d722 2
a723 1
    rob->inv   = 0; /* not used */
d747 2
a748 1
    rob->inv   = 0; /* not used */
@


1.13
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.12 2015/08/23 09:04:07 nakashim Exp $";
d139 43
d518 1
a518 1
    else if ((i.b_cond.cond!=14||i.b_cond.cond==15) && i.b_cond.imm19&0x40000) /* conditional backward */
d520 1
a520 1
    rob->cond   = i.b_cond.cond;
d530 5
@


1.12
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.11 2015/08/23 05:57:44 nakashim Exp nakashim $";
d9 1
a9 1
/* decode.c 2005/3/22 */ 
@


1.11
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.10 2015/08/23 04:11:54 nakashim Exp nakashim $";
d105 34
@


1.10
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.9 2015/08/22 13:52:55 nakashim Exp nakashim $";
d138 45
@


1.9
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.8 2015/08/22 11:47:27 nakashim Exp nakashim $";
d167 1
a167 1
    rob->opcd  = i.and_imm.opc==0?0:i.and_imm.opc==1?12:i.and_imm.opc==2?1:0; /* AND/ORR/EOR/ANDS */
d225 83
d352 1
a352 1
    rob->opcd  = i.and_shifted.opc==0?0:i.and_shifted.opc==1?12:i.and_shifted.opc==2?1:0; /* AND/ORR/EOR/ANDS */
@


1.8
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.7 2015/08/22 04:49:17 nakashim Exp nakashim $";
d169 1
a169 1
    rob->inv   = i.and_imm.N; /* invert */
d225 43
a267 1
  else if (i.and_shifted.op28_24 == 0x0a) { /* C6.6.12 AND(shifted register), C6.6.14 ANDS(shifted register), C6.6.65 EOR(shifted register), C6.6.125 MOV(register), C6.6.142 ORR(shifted register) */
d295 6
a300 4
    rob->dr[1].t = 1;
    rob->dr[1].n = i.and_shifted.rd;
    t[tid].map[i.and_shifted.rd].x = 1;
    t[tid].map[i.and_shifted.rd].rob = robid;
@


1.7
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.6 2015/08/20 09:29:03 nakashim Exp nakashim $";
d62 1
a62 1
  if (i.add_imm.op28_24 == 0x11) { /* C6.6.4 ADD(immediate), C6.6.121 MOV(to/from SP) */
d64 1
a64 1
    rob->opcd  = i.add_imm.op==0?4:5; /* ADD/ADC */
d67 1
a67 1
    rob->dbl   = i.add_imm.sf; /* 0:add32, 1:add64 */
d71 48
a118 5
    rob->updt  = i.add_imm.S;
    rob->sr[0].t = !t[tid].map[i.add_imm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.add_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.add_imm.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.add_imm.rn].x ? i.add_imm.rn : t[tid].map[i.add_imm.rn].rob;
d121 1
a121 1
    rob->sr[2].n = i.add_imm.shift==0?(Ull)i.add_imm.imm12:(Ull)(i.add_imm.imm12<<12);
a124 5
    if (i.add_imm.op) { /* ADC */
      rob->sr[8].t = !t[tid].map[CPSREGTOP].x ? 2 : (c[cid].rob[t[tid].map[CPSREGTOP].rob].stat>=ROB_COMPLETE)? 2 : 3; /* cpsr */
      rob->sr[8].x =  t[tid].map[CPSREGTOP].x; /* cpsr */
      rob->sr[8].n = !t[tid].map[CPSREGTOP].x ? CPSREGTOP : t[tid].map[CPSREGTOP].rob;
    }
d127 4
a130 4
    rob->dr[1].n = i.add_imm.rd;
    t[tid].map[i.add_imm.rd].x = 1;
    t[tid].map[i.add_imm.rd].rob = robid;
    if (i.add_imm.S) {
d242 2
a243 1
    rob->sr[2].t = !t[tid].map[i.and_shifted.rm].x ? 2 :
d245 4
a248 2
    rob->sr[2].x = t[tid].map[i.and_shifted.rm].x; /* reg */
    rob->sr[2].n = !t[tid].map[i.and_shifted.rm].x ? i.and_shifted.rm : t[tid].map[i.and_shifted.rm].rob;
@


1.6
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.5 2015/08/17 12:34:08 nakashim Exp nakashim $";
a26 1
  rob->bpred  = 0; /* not taken */
d29 1
d127 61
a187 1
  else if (i.and_shifted.op28_24 == 0x0a) { /* C6.6.12 AND, C6.6.65 EOR(shifted register), C6.6.125 MOV(register), C6.6.142 ORR(shifted register) */
d189 1
a189 1
    rob->opcd  = i.and_shifted.opc==0?0:i.and_shifted.opc==1?12:i.and_shifted.opc==2?1:0; /* AND/ORR/EOR/ANDCC */
d196 1
a196 1
    rob->updt  = i.and_shifted.opc==3; /* ANDCC */
d210 1
a210 1
    rob->sr[4].n = i.and_shifted.rm; /* LSL/LSR/ASR/ROR */
d216 1
a216 1
    if (i.and_shifted.opc==3) { /* ANDCC */
d224 19
a242 1
  else if (i.bl.op30_26 == 0x05) { /* C6.6.26 BR/BL */
d246 1
a246 1
    rob->opcd  = i.bl.op; /* BR/BL */
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.4 2015/08/16 12:50:07 nakashim Exp nakashim $";
d65 1
a65 1
    rob->sop   = 0; /* SLL */
d81 1
a81 1
    rob->sr[4].n = 0; /* SLL 0 */
d104 1
a104 1
    rob->sop   = 0; /* SLL */
d119 1
a119 1
    rob->sr[4].n = 0; /* SLL 0 */
d185 99
a283 27
  else if (i.ldr_imm.op29_25 == 0x1c && i.ldr_imm.opc == 1) { /* C6.6.81 LDP, C6.6.177 STP */
    int post_index = i.ldr_imm.op24==0 && (i.ldr_imm.imm12&3)==1;
    int pre_index  = i.ldr_imm.op24==0 && (i.ldr_imm.imm12&3)==3;
    int uns_offset = i.ldr_imm.op24==1;
    Ull offset     = (post_index || pre_index)?(Sll)((Ull)i.ldr_imm.imm12<<52)>>55:(Ull)i.ldr_imm.imm12<<i.ldr_imm.size;
    rob->type  = 3; /* LD */
    rob->opcd  = 0; /* LDR */
    rob->sop   = 0; /* not used */
    rob->inv   = 0; /* not used */
    rob->dbl   = i.ldr_imm.size&1; /* 2:ld32, 3:ld64 */
    rob->plus  = 1; /* plus */
    rob->pre   = pre_index || uns_offset;
    rob->wb    = post_index || pre_index;
    rob->updt  = 0; /* not used */
    rob->sr[0].t = !t[tid].map[i.ldr_imm.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_imm.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ldr_imm.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ldr_imm.rn].x ? i.ldr_imm.rn : t[tid].map[i.ldr_imm.rn].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = offset;
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = i.ldr_imm.rt;
    t[tid].map[i.ldr_imm.rt].x = 1;
    t[tid].map[i.ldr_imm.rt].rob = robid;
    return (0);
@


1.4
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.3 2015/08/16 03:35:25 nakashim Exp nakashim $";
d17 1
a17 1
  /* return 0:normal end, 1:continue (LDM/STM), 2:error */
d32 7
a38 7
  rob->inv    = 0;
  rob->dbl    = 0;
  rob->plus   = 0;
  rob->pre    = 0;
  rob->wb     = 0;
  rob->updt   = 0;
  rob->sr[0].t  = 0;
d40 1
a40 1
  rob->sr[2].t  = 0;
d42 1
a42 1
  rob->sr[4].t  = 0;
d44 1
a44 1
  rob->sr[6].t  = 0;
d46 2
a47 2
  rob->sr[8].t  = 0;
  rob->dr[1].t    = 0;
d55 1
a55 1
  rob->dr[3].t    = 0;
d71 1
d110 1
d127 37
d175 1
d185 28
d226 1
d250 1
a263 36
  else if (i.and_shifted.op28_24 == 0x0a) { /* C6.6.125 MOV(register), C6.6.142 AND/ORR/EOR/ANDCC(shifted register) */
    rob->type  = 0; /* ALU */
    rob->opcd  = i.and_shifted.opc==0?0:i.and_shifted.opc==1?12:i.and_shifted.opc==2?1:0; /* AND/ORR/EOR/ANDCC */
    rob->sop   = i.and_shifted.shift; /* LSL/LSR/ASR/ROR */
    rob->inv   = i.and_shifted.N; /* invert */
    rob->dbl   = i.and_shifted.sf; /* 0:and32, 1:and64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->sr[0].t = i.and_shifted.rn==31 ? 1 : /* ZERO */
                   !t[tid].map[i.and_shifted.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.and_shifted.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = i.and_shifted.rn==31 ? 0 : /* ZERO */
                   t[tid].map[i.and_shifted.rn].x; /* reg */
    rob->sr[0].n = i.and_shifted.rn==31 ? 0 : /* ZERO */
                   !t[tid].map[i.and_shifted.rn].x ? i.and_shifted.rn : t[tid].map[i.and_shifted.rn].rob;
    rob->sr[2].t = !t[tid].map[i.and_shifted.rm].x ? 2 :
                   (c[cid].rob[t[tid].map[i.and_shifted.rm].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[2].x = t[tid].map[i.and_shifted.rm].x; /* reg */
    rob->sr[2].n = !t[tid].map[i.and_shifted.rm].x ? i.and_shifted.rm : t[tid].map[i.and_shifted.rm].rob;
    rob->sr[4].t = 1; /* immediate */
    rob->sr[4].x = 0; /* renamig N.A. */
    rob->sr[4].n = i.and_shifted.rm; /* LSL/LSR/ASR/ROR */
    /* dest */
    rob->dr[1].t = 1;
    rob->dr[1].n = i.and_shifted.rd;
    t[tid].map[i.and_shifted.rd].x = 1;
    t[tid].map[i.and_shifted.rd].rob = robid;
    if (i.and_shifted.opc==3) { /* ANDCC */
      rob->dr[3].t = 1; /* nzvc */
      rob->dr[3].n = CPSREGTOP;
      t[tid].map[CPSREGTOP].x = 3;
      t[tid].map[CPSREGTOP].rob = robid;
    }
    return (0);
  }
@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.2 2015/08/15 15:03:22 nakashim Exp nakashim $";
d32 1
d64 3
a66 2
    rob->opcd  = 0; /* ADD */
    rob->sop   = i.add_imm.op; /* ADD/ADC */
d78 3
d86 1
a86 1
    /* add */
d102 3
a104 2
    rob->opcd  = 0; /* ADD */
    rob->sop   = 0; /* not used */
d115 4
a118 1
    /* adr */
d131 1
d136 1
a136 1
    /* bl */
d153 1
d165 1
a165 1
    /* load */
d176 1
d187 1
a187 1
    /* load */
d194 36
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/bsim/RCS/decode.c,v 1.1 2015/07/21 05:44:37 nakashim Exp nakashim $";
d61 56
a116 1
  if (i.bl.op30_26 == 0x05) { /* C6.6.26 BR/BL */
a181 22
  else if (i.mov_sp.op == 0 && i.mov_sp.S == 0 && i.mov_sp.op28_24 == 0x11 && i.mov_sp.imm12 == 0) { /* C6.6.121 MOV(to/from SP) */
    rob->type  = 0; /* ALU */
    rob->opcd  = 0; /* ADD */
    rob->sop   = 0; /* not used */
    rob->dbl   = i.mov_sp.sf; /* 0:add32, 1:add64 */
    rob->plus  = 0; /* not used */
    rob->pre   = 0; /* not used */
    rob->wb    = 0; /* not used */
    rob->sr[0].t = !t[tid].map[i.mov_sp.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.mov_sp.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.mov_sp.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.mov_sp.rn].x ? i.mov_sp.rn : t[tid].map[i.mov_sp.rn].rob;
    rob->sr[2].t = 1; /* immediate */
    rob->sr[2].x = 0; /* renamig N.A. */
    rob->sr[2].n = (Sll)((Ull)i.mov_sp.imm12<<52)>>52;
    /* mov */
    rob->dr[1].t = 1;
    rob->dr[1].n = i.mov_sp.rd;
    t[tid].map[i.mov_sp.rd].x = 1;
    t[tid].map[i.mov_sp.rd].rob = robid;
    return (0);
  }
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm32/src/bsim/RCS/decode.c,v 1.16 2015/01/17 13:50:23 nakashim Exp nakashim $";
d61 46
a106 1
  if (i.ldr_literal.sop == 0x18) { /* C6.6.84 LDR(literal) */
d108 1
a108 1
    rob->opcd  = 0; /* LD_LITERAL */
d110 1
a110 1
    rob->dbl   = i.ldr_literal.opc; /* 0:ld32, 1:ld64 */
d119 1
a119 1
    rob->sr[2].n = (Sll)((Sll)i.ldr_literal.imm19<<45)>>43;
d121 1
a121 1
    rob->dr[1].t = 1; /* drt */
d123 1
a123 1
    t[tid].map[i.ldr_literal.rt].x = 1; /* dr7 */
d127 3
a129 3
  else if (i.ldr_imm_unsigned_offset.sop == 0x39) { /* C6.6.83 LDR(immediate) unsigned offset */
    rob->type  = 3; /* LD */
    rob->opcd  = 0; /* LD_LITERAL */
d131 3
a133 3
    rob->dbl   = i.ldr_imm_unsigned_offset.size&1; /* 2:ld32, 3:ld64 */
    rob->plus  = 1; /* plus */
    rob->pre   = 1; /* addr+offset */
d135 4
a138 4
    rob->sr[0].t = !t[tid].map[i.ldr_imm_unsigned_offset.rn].x ? 2 :
                   (c[cid].rob[t[tid].map[i.ldr_imm_unsigned_offset.rn].rob].stat>=ROB_COMPLETE)? 2 : 3; /* reg */
    rob->sr[0].x = t[tid].map[i.ldr_imm_unsigned_offset.rn].x; /* reg */
    rob->sr[0].n = !t[tid].map[i.ldr_imm_unsigned_offset.rn].x ? i.ldr_imm_unsigned_offset.rn : t[tid].map[i.ldr_imm_unsigned_offset.rn].rob;
d141 10
a150 6
    rob->sr[2].n = (Ull)i.ldr_imm_unsigned_offset.imm12;
    /* load */
    rob->dr[1].t = 1; /* drt */
    rob->dr[1].n = i.ldr_imm_unsigned_offset.rt;
    t[tid].map[i.ldr_imm_unsigned_offset.rt].x = 1; /* dr7 */
    t[tid].map[i.ldr_imm_unsigned_offset.rt].rob = robid;
a152 1
  /* ¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú¡ú */
@
